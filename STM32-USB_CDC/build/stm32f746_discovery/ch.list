
build/stm32f746_discovery/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

00200000 <_vectors>:
  200000:	20000400 	.word	0x20000400
  200004:	002002d9 	.word	0x002002d9
  200008:	002002db 	.word	0x002002db
  20000c:	002002da 	.word	0x002002da
  200010:	002002da 	.word	0x002002da
  200014:	002002da 	.word	0x002002da
  200018:	002002da 	.word	0x002002da
  20001c:	002002da 	.word	0x002002da
  200020:	002002da 	.word	0x002002da
  200024:	002002da 	.word	0x002002da
  200028:	002002da 	.word	0x002002da
  20002c:	00203be1 	.word	0x00203be1
  200030:	002002da 	.word	0x002002da
  200034:	002002da 	.word	0x002002da
  200038:	002002da 	.word	0x002002da
  20003c:	002002da 	.word	0x002002da
  200040:	002002da 	.word	0x002002da
  200044:	002002da 	.word	0x002002da
  200048:	002002da 	.word	0x002002da
  20004c:	002002da 	.word	0x002002da
  200050:	002002da 	.word	0x002002da
  200054:	002002da 	.word	0x002002da
  200058:	002002da 	.word	0x002002da
  20005c:	002002da 	.word	0x002002da
  200060:	002002da 	.word	0x002002da
  200064:	002002da 	.word	0x002002da
  200068:	002002da 	.word	0x002002da
  20006c:	002002da 	.word	0x002002da
  200070:	002002da 	.word	0x002002da
  200074:	002002da 	.word	0x002002da
  200078:	002002da 	.word	0x002002da
  20007c:	002002da 	.word	0x002002da
  200080:	002002da 	.word	0x002002da
  200084:	002002da 	.word	0x002002da
  200088:	002002da 	.word	0x002002da
  20008c:	002002da 	.word	0x002002da
  200090:	002002da 	.word	0x002002da
  200094:	002002da 	.word	0x002002da
  200098:	002002da 	.word	0x002002da
  20009c:	002002da 	.word	0x002002da
  2000a0:	002002da 	.word	0x002002da
  2000a4:	002002da 	.word	0x002002da
  2000a8:	002002da 	.word	0x002002da
  2000ac:	002002da 	.word	0x002002da
  2000b0:	0020b681 	.word	0x0020b681
  2000b4:	002002da 	.word	0x002002da
  2000b8:	002002da 	.word	0x002002da
  2000bc:	002002da 	.word	0x002002da
  2000c0:	002002da 	.word	0x002002da
  2000c4:	002002da 	.word	0x002002da
  2000c8:	002002da 	.word	0x002002da
  2000cc:	002002da 	.word	0x002002da
  2000d0:	002002da 	.word	0x002002da
  2000d4:	002002da 	.word	0x002002da
  2000d8:	002002da 	.word	0x002002da
  2000dc:	002002da 	.word	0x002002da
  2000e0:	002002da 	.word	0x002002da
  2000e4:	002002da 	.word	0x002002da
  2000e8:	002002da 	.word	0x002002da
  2000ec:	002002da 	.word	0x002002da
  2000f0:	002002da 	.word	0x002002da
  2000f4:	002002da 	.word	0x002002da
  2000f8:	002002da 	.word	0x002002da
  2000fc:	002002da 	.word	0x002002da
  200100:	002002da 	.word	0x002002da
  200104:	002002da 	.word	0x002002da
  200108:	002002da 	.word	0x002002da
  20010c:	002002da 	.word	0x002002da
  200110:	002002da 	.word	0x002002da
  200114:	002002da 	.word	0x002002da
  200118:	002002da 	.word	0x002002da
  20011c:	002002da 	.word	0x002002da
  200120:	002002da 	.word	0x002002da
  200124:	002002da 	.word	0x002002da
  200128:	002002da 	.word	0x002002da
  20012c:	002002da 	.word	0x002002da
  200130:	002002da 	.word	0x002002da
  200134:	002002da 	.word	0x002002da
  200138:	002002da 	.word	0x002002da
  20013c:	002002da 	.word	0x002002da
  200140:	002002da 	.word	0x002002da
  200144:	002002da 	.word	0x002002da
  200148:	002002da 	.word	0x002002da
  20014c:	0020b7b1 	.word	0x0020b7b1
  200150:	002002da 	.word	0x002002da
  200154:	002002da 	.word	0x002002da
  200158:	002002da 	.word	0x002002da
  20015c:	002002da 	.word	0x002002da
  200160:	002002da 	.word	0x002002da
  200164:	002002da 	.word	0x002002da
  200168:	002002da 	.word	0x002002da
  20016c:	002002da 	.word	0x002002da
  200170:	002002da 	.word	0x002002da
  200174:	0020b781 	.word	0x0020b781
  200178:	002002da 	.word	0x002002da
  20017c:	002002da 	.word	0x002002da
  200180:	002002da 	.word	0x002002da
  200184:	002002da 	.word	0x002002da
  200188:	002002da 	.word	0x002002da
  20018c:	002002da 	.word	0x002002da
  200190:	002002da 	.word	0x002002da
  200194:	002002da 	.word	0x002002da
  200198:	002002da 	.word	0x002002da
  20019c:	002002da 	.word	0x002002da
  2001a0:	002002da 	.word	0x002002da
  2001a4:	002002da 	.word	0x002002da
  2001a8:	002002da 	.word	0x002002da
  2001ac:	002002da 	.word	0x002002da
  2001b0:	002002da 	.word	0x002002da
  2001b4:	002002da 	.word	0x002002da
  2001b8:	002002da 	.word	0x002002da
  2001bc:	002002da 	.word	0x002002da
  2001c0:	002002da 	.word	0x002002da
  2001c4:	002002da 	.word	0x002002da
  2001c8:	002002da 	.word	0x002002da
  2001cc:	002002da 	.word	0x002002da
  2001d0:	002002da 	.word	0x002002da
  2001d4:	002002da 	.word	0x002002da
  2001d8:	002002da 	.word	0x002002da
  2001dc:	002002da 	.word	0x002002da
  2001e0:	002002da 	.word	0x002002da
  2001e4:	002002da 	.word	0x002002da
  2001e8:	002002da 	.word	0x002002da
  2001ec:	002002da 	.word	0x002002da
  2001f0:	002002da 	.word	0x002002da
  2001f4:	002002da 	.word	0x002002da
  2001f8:	002002da 	.word	0x002002da
  2001fc:	002002da 	.word	0x002002da

Disassembly of section .text:

00200200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
  200200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
  200202:	4827      	ldr	r0, [pc, #156]	; (2002a0 <endfiniloop+0x4>)
                msr     MSP, r0
  200204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
  200208:	4826      	ldr	r0, [pc, #152]	; (2002a4 <endfiniloop+0x8>)
                msr     PSP, r0
  20020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
  20020e:	4826      	ldr	r0, [pc, #152]	; (2002a8 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
  200210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
  200214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
  200218:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
  20021a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
  20021c:	f380 8814 	msr	CONTROL, r0
                isb
  200220:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
  200224:	f00b fb24 	bl	20b870 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
  200228:	f00b f892 	bl	20b350 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
  20022c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
  200230:	491e      	ldr	r1, [pc, #120]	; (2002ac <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
  200232:	4a1b      	ldr	r2, [pc, #108]	; (2002a0 <endfiniloop+0x4>)

00200234 <msloop>:
msloop:
                cmp     r1, r2
  200234:	4291      	cmp	r1, r2
                itt     lo
  200236:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  200238:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
  20023c:	e7fa      	bcc.n	200234 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
  20023e:	491c      	ldr	r1, [pc, #112]	; (2002b0 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
  200240:	4a18      	ldr	r2, [pc, #96]	; (2002a4 <endfiniloop+0x8>)

00200242 <psloop>:
psloop:
                cmp     r1, r2
  200242:	4291      	cmp	r1, r2
                itt     lo
  200244:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  200246:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
  20024a:	e7fa      	bcc.n	200242 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
  20024c:	4919      	ldr	r1, [pc, #100]	; (2002b4 <endfiniloop+0x18>)
                ldr     r2, =_data_start
  20024e:	4a1a      	ldr	r2, [pc, #104]	; (2002b8 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
  200250:	4b1a      	ldr	r3, [pc, #104]	; (2002bc <endfiniloop+0x20>)

00200252 <dloop>:
dloop:
                cmp     r2, r3
  200252:	429a      	cmp	r2, r3
                ittt    lo
  200254:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
  200256:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
  20025a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
  20025e:	e7f8      	bcc.n	200252 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
  200260:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
  200262:	4917      	ldr	r1, [pc, #92]	; (2002c0 <endfiniloop+0x24>)
                ldr     r2, =_bss_end
  200264:	4a17      	ldr	r2, [pc, #92]	; (2002c4 <endfiniloop+0x28>)

00200266 <bloop>:
bloop:
                cmp     r1, r2
  200266:	4291      	cmp	r1, r2
                itt     lo
  200268:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  20026a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
  20026e:	e7fa      	bcc.n	200266 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
  200270:	f00b fab6 	bl	20b7e0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
  200274:	f00b faf4 	bl	20b860 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
  200278:	4c13      	ldr	r4, [pc, #76]	; (2002c8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
  20027a:	4d14      	ldr	r5, [pc, #80]	; (2002cc <endfiniloop+0x30>)

0020027c <initloop>:
initloop:
                cmp     r4, r5
  20027c:	42ac      	cmp	r4, r5
                bge     endinitloop
  20027e:	da03      	bge.n	200288 <endinitloop>
                ldr     r1, [r4], #4
  200280:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  200284:	4788      	blx	r1
                b       initloop
  200286:	e7f9      	b.n	20027c <initloop>

00200288 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
  200288:	f008 fe2a 	bl	208ee0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
  20028c:	4c10      	ldr	r4, [pc, #64]	; (2002d0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
  20028e:	4d11      	ldr	r5, [pc, #68]	; (2002d4 <endfiniloop+0x38>)

00200290 <finiloop>:
finiloop:
                cmp     r4, r5
  200290:	42ac      	cmp	r4, r5
                bge     endfiniloop
  200292:	da03      	bge.n	20029c <endfiniloop>
                ldr     r1, [r4], #4
  200294:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  200298:	4788      	blx	r1
                b       finiloop
  20029a:	e7f9      	b.n	200290 <finiloop>

0020029c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
  20029c:	f00b bad8 	b.w	20b850 <__default_exit>
                ldr     r0, =__main_stack_end__
  2002a0:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
  2002a4:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
  2002a8:	00200000 	.word	0x00200000
                ldr     r1, =__main_stack_base__
  2002ac:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
  2002b0:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
  2002b4:	0800e954 	.word	0x0800e954
                ldr     r2, =_data_start
  2002b8:	20010000 	.word	0x20010000
                ldr     r3, =_data_end
  2002bc:	20010498 	.word	0x20010498
                ldr     r1, =_bss_start
  2002c0:	20000800 	.word	0x20000800
                ldr     r2, =_bss_end
  2002c4:	20002110 	.word	0x20002110
                ldr     r4, =__init_array_start
  2002c8:	00200200 	.word	0x00200200
                ldr     r5, =__init_array_end
  2002cc:	00200200 	.word	0x00200200
                ldr     r4, =__fini_array_start
  2002d0:	00200200 	.word	0x00200200
                ldr     r5, =__fini_array_end
  2002d4:	00200200 	.word	0x00200200

002002d8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
  2002d8:	e792      	b.n	200200 <_crt0_entry>

002002da <NMI_Handler>:
Vector3F0:
Vector3F4:
Vector3F8:
Vector3FC:
#endif
        bl          _unhandled_exception
  2002da:	f000 f800 	bl	2002de <_unhandled_exception>

002002de <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
  2002de:	e7fe      	b.n	2002de <_unhandled_exception>

002002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
  2002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
  2002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
  2002e8:	f8d0 d00c 	ldr.w	sp, [r0, #12]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
  2002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

002002f0 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
  2002f0:	f003 fcde 	bl	203cb0 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
  2002f4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
  2002f6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
  2002fa:	4628      	mov	r0, r5
                blx     r4
  2002fc:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
  2002fe:	2000      	movs	r0, #0
                bl      chThdExit
  200300:	f008 f986 	bl	208610 <chThdExit>

00200304 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
  200304:	f003 fd24 	bl	203d50 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
  200308:	f003 fc7a 	bl	203c00 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
  20030c:	f003 fcd0 	bl	203cb0 <_dbg_check_unlock>

00200310 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
  200310:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
  200312:	e7fe      	b.n	200312 <_port_exit_from_isr+0x2>

00200314 <memcpy>:
  200314:	4684      	mov	ip, r0
  200316:	ea41 0300 	orr.w	r3, r1, r0
  20031a:	f013 0303 	ands.w	r3, r3, #3
  20031e:	d16d      	bne.n	2003fc <memcpy+0xe8>
  200320:	3a40      	subs	r2, #64	; 0x40
  200322:	d341      	bcc.n	2003a8 <memcpy+0x94>
  200324:	f851 3b04 	ldr.w	r3, [r1], #4
  200328:	f840 3b04 	str.w	r3, [r0], #4
  20032c:	f851 3b04 	ldr.w	r3, [r1], #4
  200330:	f840 3b04 	str.w	r3, [r0], #4
  200334:	f851 3b04 	ldr.w	r3, [r1], #4
  200338:	f840 3b04 	str.w	r3, [r0], #4
  20033c:	f851 3b04 	ldr.w	r3, [r1], #4
  200340:	f840 3b04 	str.w	r3, [r0], #4
  200344:	f851 3b04 	ldr.w	r3, [r1], #4
  200348:	f840 3b04 	str.w	r3, [r0], #4
  20034c:	f851 3b04 	ldr.w	r3, [r1], #4
  200350:	f840 3b04 	str.w	r3, [r0], #4
  200354:	f851 3b04 	ldr.w	r3, [r1], #4
  200358:	f840 3b04 	str.w	r3, [r0], #4
  20035c:	f851 3b04 	ldr.w	r3, [r1], #4
  200360:	f840 3b04 	str.w	r3, [r0], #4
  200364:	f851 3b04 	ldr.w	r3, [r1], #4
  200368:	f840 3b04 	str.w	r3, [r0], #4
  20036c:	f851 3b04 	ldr.w	r3, [r1], #4
  200370:	f840 3b04 	str.w	r3, [r0], #4
  200374:	f851 3b04 	ldr.w	r3, [r1], #4
  200378:	f840 3b04 	str.w	r3, [r0], #4
  20037c:	f851 3b04 	ldr.w	r3, [r1], #4
  200380:	f840 3b04 	str.w	r3, [r0], #4
  200384:	f851 3b04 	ldr.w	r3, [r1], #4
  200388:	f840 3b04 	str.w	r3, [r0], #4
  20038c:	f851 3b04 	ldr.w	r3, [r1], #4
  200390:	f840 3b04 	str.w	r3, [r0], #4
  200394:	f851 3b04 	ldr.w	r3, [r1], #4
  200398:	f840 3b04 	str.w	r3, [r0], #4
  20039c:	f851 3b04 	ldr.w	r3, [r1], #4
  2003a0:	f840 3b04 	str.w	r3, [r0], #4
  2003a4:	3a40      	subs	r2, #64	; 0x40
  2003a6:	d2bd      	bcs.n	200324 <memcpy+0x10>
  2003a8:	3230      	adds	r2, #48	; 0x30
  2003aa:	d311      	bcc.n	2003d0 <memcpy+0xbc>
  2003ac:	f851 3b04 	ldr.w	r3, [r1], #4
  2003b0:	f840 3b04 	str.w	r3, [r0], #4
  2003b4:	f851 3b04 	ldr.w	r3, [r1], #4
  2003b8:	f840 3b04 	str.w	r3, [r0], #4
  2003bc:	f851 3b04 	ldr.w	r3, [r1], #4
  2003c0:	f840 3b04 	str.w	r3, [r0], #4
  2003c4:	f851 3b04 	ldr.w	r3, [r1], #4
  2003c8:	f840 3b04 	str.w	r3, [r0], #4
  2003cc:	3a10      	subs	r2, #16
  2003ce:	d2ed      	bcs.n	2003ac <memcpy+0x98>
  2003d0:	320c      	adds	r2, #12
  2003d2:	d305      	bcc.n	2003e0 <memcpy+0xcc>
  2003d4:	f851 3b04 	ldr.w	r3, [r1], #4
  2003d8:	f840 3b04 	str.w	r3, [r0], #4
  2003dc:	3a04      	subs	r2, #4
  2003de:	d2f9      	bcs.n	2003d4 <memcpy+0xc0>
  2003e0:	3204      	adds	r2, #4
  2003e2:	d008      	beq.n	2003f6 <memcpy+0xe2>
  2003e4:	07d2      	lsls	r2, r2, #31
  2003e6:	bf1c      	itt	ne
  2003e8:	f811 3b01 	ldrbne.w	r3, [r1], #1
  2003ec:	f800 3b01 	strbne.w	r3, [r0], #1
  2003f0:	d301      	bcc.n	2003f6 <memcpy+0xe2>
  2003f2:	880b      	ldrh	r3, [r1, #0]
  2003f4:	8003      	strh	r3, [r0, #0]
  2003f6:	4660      	mov	r0, ip
  2003f8:	4770      	bx	lr
  2003fa:	bf00      	nop
  2003fc:	2a08      	cmp	r2, #8
  2003fe:	d313      	bcc.n	200428 <memcpy+0x114>
  200400:	078b      	lsls	r3, r1, #30
  200402:	d08d      	beq.n	200320 <memcpy+0xc>
  200404:	f010 0303 	ands.w	r3, r0, #3
  200408:	d08a      	beq.n	200320 <memcpy+0xc>
  20040a:	f1c3 0304 	rsb	r3, r3, #4
  20040e:	1ad2      	subs	r2, r2, r3
  200410:	07db      	lsls	r3, r3, #31
  200412:	bf1c      	itt	ne
  200414:	f811 3b01 	ldrbne.w	r3, [r1], #1
  200418:	f800 3b01 	strbne.w	r3, [r0], #1
  20041c:	d380      	bcc.n	200320 <memcpy+0xc>
  20041e:	f831 3b02 	ldrh.w	r3, [r1], #2
  200422:	f820 3b02 	strh.w	r3, [r0], #2
  200426:	e77b      	b.n	200320 <memcpy+0xc>
  200428:	3a04      	subs	r2, #4
  20042a:	d3d9      	bcc.n	2003e0 <memcpy+0xcc>
  20042c:	3a01      	subs	r2, #1
  20042e:	f811 3b01 	ldrb.w	r3, [r1], #1
  200432:	f800 3b01 	strb.w	r3, [r0], #1
  200436:	d2f9      	bcs.n	20042c <memcpy+0x118>
  200438:	780b      	ldrb	r3, [r1, #0]
  20043a:	7003      	strb	r3, [r0, #0]
  20043c:	784b      	ldrb	r3, [r1, #1]
  20043e:	7043      	strb	r3, [r0, #1]
  200440:	788b      	ldrb	r3, [r1, #2]
  200442:	7083      	strb	r3, [r0, #2]
  200444:	4660      	mov	r0, ip
  200446:	4770      	bx	lr
	...
  200460:	eba2 0003 	sub.w	r0, r2, r3
  200464:	4770      	bx	lr
  200466:	bf00      	nop

00200468 <strcmp>:
  200468:	7802      	ldrb	r2, [r0, #0]
  20046a:	780b      	ldrb	r3, [r1, #0]
  20046c:	2a01      	cmp	r2, #1
  20046e:	bf28      	it	cs
  200470:	429a      	cmpcs	r2, r3
  200472:	d1f5      	bne.n	200460 <memcpy+0x14c>
  200474:	e96d 4504 	strd	r4, r5, [sp, #-16]!
  200478:	ea40 0401 	orr.w	r4, r0, r1
  20047c:	e9cd 6702 	strd	r6, r7, [sp, #8]
  200480:	f06f 0c00 	mvn.w	ip, #0
  200484:	ea4f 7244 	mov.w	r2, r4, lsl #29
  200488:	b312      	cbz	r2, 2004d0 <strcmp+0x68>
  20048a:	ea80 0401 	eor.w	r4, r0, r1
  20048e:	f014 0f07 	tst.w	r4, #7
  200492:	d16a      	bne.n	20056a <strcmp+0x102>
  200494:	f000 0407 	and.w	r4, r0, #7
  200498:	f020 0007 	bic.w	r0, r0, #7
  20049c:	f004 0503 	and.w	r5, r4, #3
  2004a0:	f021 0107 	bic.w	r1, r1, #7
  2004a4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
  2004a8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
  2004ac:	f014 0f04 	tst.w	r4, #4
  2004b0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
  2004b4:	fa0c f405 	lsl.w	r4, ip, r5
  2004b8:	ea62 0204 	orn	r2, r2, r4
  2004bc:	ea66 0604 	orn	r6, r6, r4
  2004c0:	d00a      	beq.n	2004d8 <strcmp+0x70>
  2004c2:	ea63 0304 	orn	r3, r3, r4
  2004c6:	4662      	mov	r2, ip
  2004c8:	ea67 0704 	orn	r7, r7, r4
  2004cc:	4666      	mov	r6, ip
  2004ce:	e003      	b.n	2004d8 <strcmp+0x70>
  2004d0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
  2004d4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
  2004d8:	fa82 f54c 	uadd8	r5, r2, ip
  2004dc:	ea82 0406 	eor.w	r4, r2, r6
  2004e0:	faa4 f48c 	sel	r4, r4, ip
  2004e4:	bb6c      	cbnz	r4, 200542 <strcmp+0xda>
  2004e6:	fa83 f54c 	uadd8	r5, r3, ip
  2004ea:	ea83 0507 	eor.w	r5, r3, r7
  2004ee:	faa5 f58c 	sel	r5, r5, ip
  2004f2:	b995      	cbnz	r5, 20051a <strcmp+0xb2>
  2004f4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
  2004f8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
  2004fc:	fa82 f54c 	uadd8	r5, r2, ip
  200500:	ea82 0406 	eor.w	r4, r2, r6
  200504:	faa4 f48c 	sel	r4, r4, ip
  200508:	fa83 f54c 	uadd8	r5, r3, ip
  20050c:	ea83 0507 	eor.w	r5, r3, r7
  200510:	faa5 f58c 	sel	r5, r5, ip
  200514:	4325      	orrs	r5, r4
  200516:	d0db      	beq.n	2004d0 <strcmp+0x68>
  200518:	b99c      	cbnz	r4, 200542 <strcmp+0xda>
  20051a:	ba2d      	rev	r5, r5
  20051c:	fab5 f485 	clz	r4, r5
  200520:	f024 0407 	bic.w	r4, r4, #7
  200524:	fa27 f104 	lsr.w	r1, r7, r4
  200528:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  20052c:	fa23 f304 	lsr.w	r3, r3, r4
  200530:	f003 00ff 	and.w	r0, r3, #255	; 0xff
  200534:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  200538:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  20053c:	eba0 0001 	sub.w	r0, r0, r1
  200540:	4770      	bx	lr
  200542:	ba24      	rev	r4, r4
  200544:	fab4 f484 	clz	r4, r4
  200548:	f024 0407 	bic.w	r4, r4, #7
  20054c:	fa26 f104 	lsr.w	r1, r6, r4
  200550:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  200554:	fa22 f204 	lsr.w	r2, r2, r4
  200558:	f002 00ff 	and.w	r0, r2, #255	; 0xff
  20055c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  200560:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  200564:	eba0 0001 	sub.w	r0, r0, r1
  200568:	4770      	bx	lr
  20056a:	f014 0f03 	tst.w	r4, #3
  20056e:	d13c      	bne.n	2005ea <strcmp+0x182>
  200570:	f010 0403 	ands.w	r4, r0, #3
  200574:	d128      	bne.n	2005c8 <strcmp+0x160>
  200576:	f850 2b08 	ldr.w	r2, [r0], #8
  20057a:	f851 3b08 	ldr.w	r3, [r1], #8
  20057e:	fa82 f54c 	uadd8	r5, r2, ip
  200582:	ea82 0503 	eor.w	r5, r2, r3
  200586:	faa5 f58c 	sel	r5, r5, ip
  20058a:	b95d      	cbnz	r5, 2005a4 <strcmp+0x13c>
  20058c:	f850 2c04 	ldr.w	r2, [r0, #-4]
  200590:	f851 3c04 	ldr.w	r3, [r1, #-4]
  200594:	fa82 f54c 	uadd8	r5, r2, ip
  200598:	ea82 0503 	eor.w	r5, r2, r3
  20059c:	faa5 f58c 	sel	r5, r5, ip
  2005a0:	2d00      	cmp	r5, #0
  2005a2:	d0e8      	beq.n	200576 <strcmp+0x10e>
  2005a4:	ba2d      	rev	r5, r5
  2005a6:	fab5 f485 	clz	r4, r5
  2005aa:	f024 0407 	bic.w	r4, r4, #7
  2005ae:	fa23 f104 	lsr.w	r1, r3, r4
  2005b2:	fa22 f204 	lsr.w	r2, r2, r4
  2005b6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
  2005ba:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  2005be:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  2005c2:	eba0 0001 	sub.w	r0, r0, r1
  2005c6:	4770      	bx	lr
  2005c8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
  2005cc:	f020 0003 	bic.w	r0, r0, #3
  2005d0:	f850 2b08 	ldr.w	r2, [r0], #8
  2005d4:	f021 0103 	bic.w	r1, r1, #3
  2005d8:	f851 3b08 	ldr.w	r3, [r1], #8
  2005dc:	fa0c f404 	lsl.w	r4, ip, r4
  2005e0:	ea62 0204 	orn	r2, r2, r4
  2005e4:	ea63 0304 	orn	r3, r3, r4
  2005e8:	e7c9      	b.n	20057e <strcmp+0x116>
  2005ea:	f010 0403 	ands.w	r4, r0, #3
  2005ee:	d01a      	beq.n	200626 <strcmp+0x1be>
  2005f0:	eba1 0104 	sub.w	r1, r1, r4
  2005f4:	f020 0003 	bic.w	r0, r0, #3
  2005f8:	07e4      	lsls	r4, r4, #31
  2005fa:	f850 2b04 	ldr.w	r2, [r0], #4
  2005fe:	d006      	beq.n	20060e <strcmp+0x1a6>
  200600:	d20f      	bcs.n	200622 <strcmp+0x1ba>
  200602:	788b      	ldrb	r3, [r1, #2]
  200604:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
  200608:	1ae4      	subs	r4, r4, r3
  20060a:	d106      	bne.n	20061a <strcmp+0x1b2>
  20060c:	b12b      	cbz	r3, 20061a <strcmp+0x1b2>
  20060e:	78cb      	ldrb	r3, [r1, #3]
  200610:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
  200614:	1ae4      	subs	r4, r4, r3
  200616:	d100      	bne.n	20061a <strcmp+0x1b2>
  200618:	b91b      	cbnz	r3, 200622 <strcmp+0x1ba>
  20061a:	4620      	mov	r0, r4
  20061c:	f85d 4b10 	ldr.w	r4, [sp], #16
  200620:	4770      	bx	lr
  200622:	f101 0104 	add.w	r1, r1, #4
  200626:	f850 2b04 	ldr.w	r2, [r0], #4
  20062a:	07cc      	lsls	r4, r1, #31
  20062c:	f021 0103 	bic.w	r1, r1, #3
  200630:	f851 3b04 	ldr.w	r3, [r1], #4
  200634:	d848      	bhi.n	2006c8 <strcmp+0x260>
  200636:	d224      	bcs.n	200682 <strcmp+0x21a>
  200638:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
  20063c:	fa82 f54c 	uadd8	r5, r2, ip
  200640:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
  200644:	faa5 f58c 	sel	r5, r5, ip
  200648:	d10a      	bne.n	200660 <strcmp+0x1f8>
  20064a:	b965      	cbnz	r5, 200666 <strcmp+0x1fe>
  20064c:	f851 3b04 	ldr.w	r3, [r1], #4
  200650:	ea84 0402 	eor.w	r4, r4, r2
  200654:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
  200658:	d10e      	bne.n	200678 <strcmp+0x210>
  20065a:	f850 2b04 	ldr.w	r2, [r0], #4
  20065e:	e7eb      	b.n	200638 <strcmp+0x1d0>
  200660:	ea4f 2313 	mov.w	r3, r3, lsr #8
  200664:	e055      	b.n	200712 <strcmp+0x2aa>
  200666:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
  20066a:	d14d      	bne.n	200708 <strcmp+0x2a0>
  20066c:	7808      	ldrb	r0, [r1, #0]
  20066e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  200672:	f1c0 0000 	rsb	r0, r0, #0
  200676:	4770      	bx	lr
  200678:	ea4f 6212 	mov.w	r2, r2, lsr #24
  20067c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
  200680:	e047      	b.n	200712 <strcmp+0x2aa>
  200682:	ea02 441c 	and.w	r4, r2, ip, lsr #16
  200686:	fa82 f54c 	uadd8	r5, r2, ip
  20068a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
  20068e:	faa5 f58c 	sel	r5, r5, ip
  200692:	d10a      	bne.n	2006aa <strcmp+0x242>
  200694:	b965      	cbnz	r5, 2006b0 <strcmp+0x248>
  200696:	f851 3b04 	ldr.w	r3, [r1], #4
  20069a:	ea84 0402 	eor.w	r4, r4, r2
  20069e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
  2006a2:	d10c      	bne.n	2006be <strcmp+0x256>
  2006a4:	f850 2b04 	ldr.w	r2, [r0], #4
  2006a8:	e7eb      	b.n	200682 <strcmp+0x21a>
  2006aa:	ea4f 4313 	mov.w	r3, r3, lsr #16
  2006ae:	e030      	b.n	200712 <strcmp+0x2aa>
  2006b0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
  2006b4:	d128      	bne.n	200708 <strcmp+0x2a0>
  2006b6:	880b      	ldrh	r3, [r1, #0]
  2006b8:	ea4f 4212 	mov.w	r2, r2, lsr #16
  2006bc:	e029      	b.n	200712 <strcmp+0x2aa>
  2006be:	ea4f 4212 	mov.w	r2, r2, lsr #16
  2006c2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
  2006c6:	e024      	b.n	200712 <strcmp+0x2aa>
  2006c8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
  2006cc:	fa82 f54c 	uadd8	r5, r2, ip
  2006d0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
  2006d4:	faa5 f58c 	sel	r5, r5, ip
  2006d8:	d10a      	bne.n	2006f0 <strcmp+0x288>
  2006da:	b965      	cbnz	r5, 2006f6 <strcmp+0x28e>
  2006dc:	f851 3b04 	ldr.w	r3, [r1], #4
  2006e0:	ea84 0402 	eor.w	r4, r4, r2
  2006e4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
  2006e8:	d109      	bne.n	2006fe <strcmp+0x296>
  2006ea:	f850 2b04 	ldr.w	r2, [r0], #4
  2006ee:	e7eb      	b.n	2006c8 <strcmp+0x260>
  2006f0:	ea4f 6313 	mov.w	r3, r3, lsr #24
  2006f4:	e00d      	b.n	200712 <strcmp+0x2aa>
  2006f6:	f015 0fff 	tst.w	r5, #255	; 0xff
  2006fa:	d105      	bne.n	200708 <strcmp+0x2a0>
  2006fc:	680b      	ldr	r3, [r1, #0]
  2006fe:	ea4f 2212 	mov.w	r2, r2, lsr #8
  200702:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  200706:	e004      	b.n	200712 <strcmp+0x2aa>
  200708:	f04f 0000 	mov.w	r0, #0
  20070c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  200710:	4770      	bx	lr
  200712:	ba12      	rev	r2, r2
  200714:	ba1b      	rev	r3, r3
  200716:	fa82 f44c 	uadd8	r4, r2, ip
  20071a:	ea82 0403 	eor.w	r4, r2, r3
  20071e:	faa4 f58c 	sel	r5, r4, ip
  200722:	fab5 f485 	clz	r4, r5
  200726:	fa02 f204 	lsl.w	r2, r2, r4
  20072a:	fa03 f304 	lsl.w	r3, r3, r4
  20072e:	ea4f 6012 	mov.w	r0, r2, lsr #24
  200732:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  200736:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
  20073a:	4770      	bx	lr
  20073c:	0000      	movs	r0, r0
	...

00200740 <chTMStartMeasurementX.constprop.63>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
  200740:	4b01      	ldr	r3, [pc, #4]	; (200748 <chTMStartMeasurementX.constprop.63+0x8>)
  200742:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
  200744:	6083      	str	r3, [r0, #8]
}
  200746:	4770      	bx	lr
  200748:	e0001000 	.word	0xe0001000
  20074c:	00000000 	.word	0x00000000

00200750 <_test_assert_time_window.constprop.2>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
  200750:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((time - start) < (end - start));
  200754:	1a09      	subs	r1, r1, r0
  200756:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  200758:	1a1b      	subs	r3, r3, r0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
  20075a:	428b      	cmp	r3, r1
  20075c:	d30b      	bcc.n	200776 <_test_assert_time_window.constprop.2+0x26>
  test_local_fail      = true;
  20075e:	2301      	movs	r3, #1
  test_failure_message = msg;
  200760:	4a06      	ldr	r2, [pc, #24]	; (20077c <_test_assert_time_window.constprop.2+0x2c>)
  200762:	4907      	ldr	r1, [pc, #28]	; (200780 <_test_assert_time_window.constprop.2+0x30>)
    return _test_fail(msg);
  200764:	4618      	mov	r0, r3
  clear_tokens();

  return false;
}

bool _test_assert_time_window(systime_t start,
  200766:	b430      	push	{r4, r5}
  test_local_fail      = true;
  200768:	4d06      	ldr	r5, [pc, #24]	; (200784 <_test_assert_time_window.constprop.2+0x34>)
  test_global_fail     = true;
  20076a:	4c07      	ldr	r4, [pc, #28]	; (200788 <_test_assert_time_window.constprop.2+0x38>)
  test_local_fail      = true;
  20076c:	702b      	strb	r3, [r5, #0]
  test_global_fail     = true;
  20076e:	7023      	strb	r3, [r4, #0]
  test_failure_message = msg;
  200770:	6011      	str	r1, [r2, #0]
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
  200772:	bc30      	pop	{r4, r5}
  200774:	4770      	bx	lr
  return false;
  200776:	2000      	movs	r0, #0
}
  200778:	4770      	bx	lr
  20077a:	bf00      	nop
  20077c:	20001ec4 	.word	0x20001ec4
  200780:	0800c1d8 	.word	0x0800c1d8
  200784:	20001f68 	.word	0x20001f68
  200788:	20001ec8 	.word	0x20001ec8
  20078c:	00000000 	.word	0x00000000

00200790 <null_provider>:

  (void)size;
  (void)align;

  return NULL;
}
  200790:	2000      	movs	r0, #0
  200792:	4770      	bx	lr
	...

002007a0 <tmo>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
  2007a0:	4770      	bx	lr
  2007a2:	bf00      	nop
	...

002007b0 <rt_test_004_001_setup>:
 *   the state of the reference are tested.
 * .
 */

static void rt_test_004_001_setup(void) {
  tr1 = NULL;
  2007b0:	4b01      	ldr	r3, [pc, #4]	; (2007b8 <rt_test_004_001_setup+0x8>)
  2007b2:	2200      	movs	r2, #0
  2007b4:	601a      	str	r2, [r3, #0]
}
  2007b6:	4770      	bx	lr
  2007b8:	20001f98 	.word	0x20001f98
  2007bc:	00000000 	.word	0x00000000

002007c0 <_test_assert>:
  if (!condition)
  2007c0:	b950      	cbnz	r0, 2007d8 <_test_assert+0x18>
  test_local_fail      = true;
  2007c2:	2301      	movs	r3, #1
  test_failure_message = msg;
  2007c4:	4a05      	ldr	r2, [pc, #20]	; (2007dc <_test_assert+0x1c>)
bool _test_assert(bool condition, const char *msg) {
  2007c6:	b430      	push	{r4, r5}
  test_local_fail      = true;
  2007c8:	4d05      	ldr	r5, [pc, #20]	; (2007e0 <_test_assert+0x20>)
    return _test_fail(msg);
  2007ca:	4618      	mov	r0, r3
  test_global_fail     = true;
  2007cc:	4c05      	ldr	r4, [pc, #20]	; (2007e4 <_test_assert+0x24>)
  test_local_fail      = true;
  2007ce:	702b      	strb	r3, [r5, #0]
  test_global_fail     = true;
  2007d0:	7023      	strb	r3, [r4, #0]
  test_failure_message = msg;
  2007d2:	6011      	str	r1, [r2, #0]
}
  2007d4:	bc30      	pop	{r4, r5}
  2007d6:	4770      	bx	lr
  return false;
  2007d8:	2000      	movs	r0, #0
}
  2007da:	4770      	bx	lr
  2007dc:	20001ec4 	.word	0x20001ec4
  2007e0:	20001f68 	.word	0x20001f68
  2007e4:	20001ec8 	.word	0x20001ec8
	...

002007f0 <rt_test_002_004_execute>:

static void rt_test_002_004_execute(void) {

  /* [2.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
  2007f0:	4a05      	ldr	r2, [pc, #20]	; (200808 <rt_test_002_004_execute+0x18>)
  2007f2:	2101      	movs	r1, #1
  2007f4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  2007f8:	6011      	str	r1, [r2, #0]
  2007fa:	4619      	mov	r1, r3
  2007fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  2007fe:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
  200800:	429a      	cmp	r2, r3
  200802:	d0fc      	beq.n	2007fe <rt_test_002_004_execute+0xe>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
  200804:	4770      	bx	lr
  200806:	bf00      	nop
  200808:	20001f6c 	.word	0x20001f6c
  20080c:	00000000 	.word	0x00000000

00200810 <test_printn.part.0>:

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
  200810:	b318      	cbz	r0, 20085a <test_printn.part.0+0x4a>
void test_printn(uint32_t n) {
  200812:	b570      	push	{r4, r5, r6, lr}
  200814:	b084      	sub	sp, #16
      *p++ = (n % 10) + '0', n /= 10;
  200816:	4e11      	ldr	r6, [pc, #68]	; (20085c <test_printn.part.0+0x4c>)
    p = buf;
  200818:	466d      	mov	r5, sp
  20081a:	462c      	mov	r4, r5
  20081c:	e000      	b.n	200820 <test_printn.part.0+0x10>
    while (n)
  20081e:	4614      	mov	r4, r2
      *p++ = (n % 10) + '0', n /= 10;
  200820:	fba6 2300 	umull	r2, r3, r6, r0
  200824:	4622      	mov	r2, r4
  200826:	08db      	lsrs	r3, r3, #3
  200828:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  20082c:	eba0 0141 	sub.w	r1, r0, r1, lsl #1
    while (n)
  200830:	4618      	mov	r0, r3
      *p++ = (n % 10) + '0', n /= 10;
  200832:	3130      	adds	r1, #48	; 0x30
  200834:	b2c9      	uxtb	r1, r1
  200836:	f802 1b01 	strb.w	r1, [r2], #1
    while (n)
  20083a:	2b00      	cmp	r3, #0
  20083c:	d1ef      	bne.n	20081e <test_printn.part.0+0xe>
    while (p > buf)
  20083e:	42aa      	cmp	r2, r5
  200840:	d909      	bls.n	200856 <test_printn.part.0+0x46>
  200842:	4e07      	ldr	r6, [pc, #28]	; (200860 <test_printn.part.0+0x50>)
  200844:	e001      	b.n	20084a <test_printn.part.0+0x3a>
  200846:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      streamPut(test_chp, *--p);
  20084a:	6830      	ldr	r0, [r6, #0]
  20084c:	6803      	ldr	r3, [r0, #0]
  20084e:	68db      	ldr	r3, [r3, #12]
  200850:	4798      	blx	r3
    while (p > buf)
  200852:	42a5      	cmp	r5, r4
  200854:	d1f7      	bne.n	200846 <test_printn.part.0+0x36>
  }
}
  200856:	b004      	add	sp, #16
  200858:	bd70      	pop	{r4, r5, r6, pc}
  20085a:	4770      	bx	lr
  20085c:	cccccccd 	.word	0xcccccccd
  200860:	20001ec0 	.word	0x20001ec0
	...

00200870 <test_printn>:
  if (!n)
  200870:	b928      	cbnz	r0, 20087e <test_printn+0xe>
    streamPut(test_chp, '0');
  200872:	4b04      	ldr	r3, [pc, #16]	; (200884 <test_printn+0x14>)
  200874:	2130      	movs	r1, #48	; 0x30
  200876:	6818      	ldr	r0, [r3, #0]
  200878:	6803      	ldr	r3, [r0, #0]
  20087a:	68db      	ldr	r3, [r3, #12]
  20087c:	4718      	bx	r3
  20087e:	f7ff bfc7 	b.w	200810 <test_printn.part.0>
  200882:	bf00      	nop
  200884:	20001ec0 	.word	0x20001ec0
	...

00200890 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
  200890:	b570      	push	{r4, r5, r6, lr}
  while (*msgp)
  200892:	7801      	ldrb	r1, [r0, #0]
  200894:	b189      	cbz	r1, 2008ba <test_println+0x2a>
  200896:	4604      	mov	r4, r0
  200898:	4d09      	ldr	r5, [pc, #36]	; (2008c0 <test_println+0x30>)
    streamPut(test_chp, *msgp++);
  20089a:	6828      	ldr	r0, [r5, #0]
  20089c:	6803      	ldr	r3, [r0, #0]
  20089e:	68db      	ldr	r3, [r3, #12]
  2008a0:	4798      	blx	r3
  while (*msgp)
  2008a2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
  2008a6:	2900      	cmp	r1, #0
  2008a8:	d1f7      	bne.n	20089a <test_println+0xa>

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
  2008aa:	6828      	ldr	r0, [r5, #0]
  2008ac:	2202      	movs	r2, #2
  2008ae:	4905      	ldr	r1, [pc, #20]	; (2008c4 <test_println+0x34>)
  2008b0:	6803      	ldr	r3, [r0, #0]
}
  2008b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
  2008b6:	685b      	ldr	r3, [r3, #4]
  2008b8:	4718      	bx	r3
  2008ba:	4d01      	ldr	r5, [pc, #4]	; (2008c0 <test_println+0x30>)
  2008bc:	e7f5      	b.n	2008aa <test_println+0x1a>
  2008be:	bf00      	nop
  2008c0:	20001ec0 	.word	0x20001ec0
  2008c4:	0800c4dc 	.word	0x0800c4dc
	...

002008d0 <test_print>:
  while (*msgp)
  2008d0:	7801      	ldrb	r1, [r0, #0]
  2008d2:	b159      	cbz	r1, 2008ec <test_print+0x1c>
void test_print(const char *msgp) {
  2008d4:	b538      	push	{r3, r4, r5, lr}
  2008d6:	4604      	mov	r4, r0
  2008d8:	4d05      	ldr	r5, [pc, #20]	; (2008f0 <test_print+0x20>)
    streamPut(test_chp, *msgp++);
  2008da:	6828      	ldr	r0, [r5, #0]
  2008dc:	6803      	ldr	r3, [r0, #0]
  2008de:	68db      	ldr	r3, [r3, #12]
  2008e0:	4798      	blx	r3
  while (*msgp)
  2008e2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
  2008e6:	2900      	cmp	r1, #0
  2008e8:	d1f7      	bne.n	2008da <test_print+0xa>
}
  2008ea:	bd38      	pop	{r3, r4, r5, pc}
  2008ec:	4770      	bx	lr
  2008ee:	bf00      	nop
  2008f0:	20001ec0 	.word	0x20001ec0
	...

00200900 <_test_assert_sequence>:
bool _test_assert_sequence(char *expected, const char *msg) {
  200900:	b4f0      	push	{r4, r5, r6, r7}
  while (cp < test_tokp) {
  200902:	4e0e      	ldr	r6, [pc, #56]	; (20093c <_test_assert_sequence+0x3c>)
  200904:	1e42      	subs	r2, r0, #1
  char *cp = test_tokens_buffer;
  200906:	4f0e      	ldr	r7, [pc, #56]	; (200940 <_test_assert_sequence+0x40>)
  while (cp < test_tokp) {
  200908:	6835      	ldr	r5, [r6, #0]
  char *cp = test_tokens_buffer;
  20090a:	463b      	mov	r3, r7
  20090c:	e003      	b.n	200916 <_test_assert_sequence+0x16>
    if (*cp++ != *expected++)
  20090e:	f813 4b01 	ldrb.w	r4, [r3], #1
  200912:	4284      	cmp	r4, r0
  200914:	d107      	bne.n	200926 <_test_assert_sequence+0x26>
  while (cp < test_tokp) {
  200916:	429d      	cmp	r5, r3
  200918:	f812 0f01 	ldrb.w	r0, [r2, #1]!
  20091c:	d8f7      	bhi.n	20090e <_test_assert_sequence+0xe>
  if (*expected)
  20091e:	b910      	cbnz	r0, 200926 <_test_assert_sequence+0x26>
  test_tokp = test_tokens_buffer;
  200920:	6037      	str	r7, [r6, #0]
}
  200922:	bcf0      	pop	{r4, r5, r6, r7}
  200924:	4770      	bx	lr
  test_local_fail      = true;
  200926:	2301      	movs	r3, #1
  200928:	4d06      	ldr	r5, [pc, #24]	; (200944 <_test_assert_sequence+0x44>)
  test_global_fail     = true;
  20092a:	4c07      	ldr	r4, [pc, #28]	; (200948 <_test_assert_sequence+0x48>)
  test_failure_message = msg;
  20092c:	4a07      	ldr	r2, [pc, #28]	; (20094c <_test_assert_sequence+0x4c>)
     return _test_fail(msg);
  20092e:	4618      	mov	r0, r3
  test_local_fail      = true;
  200930:	702b      	strb	r3, [r5, #0]
  test_global_fail     = true;
  200932:	7023      	strb	r3, [r4, #0]
  test_failure_message = msg;
  200934:	6011      	str	r1, [r2, #0]
}
  200936:	bcf0      	pop	{r4, r5, r6, r7}
  200938:	4770      	bx	lr
  20093a:	bf00      	nop
  20093c:	20001f80 	.word	0x20001f80
  200940:	20001f70 	.word	0x20001f70
  200944:	20001f68 	.word	0x20001f68
  200948:	20001ec8 	.word	0x20001ec8
  20094c:	20001ec4 	.word	0x20001ec4

00200950 <print_line>:
static void print_line(void) {
  200950:	b570      	push	{r4, r5, r6, lr}
  200952:	244c      	movs	r4, #76	; 0x4c
  200954:	4d07      	ldr	r5, [pc, #28]	; (200974 <print_line+0x24>)
    streamPut(test_chp, '-');
  200956:	6828      	ldr	r0, [r5, #0]
  200958:	212d      	movs	r1, #45	; 0x2d
  20095a:	6803      	ldr	r3, [r0, #0]
  20095c:	68db      	ldr	r3, [r3, #12]
  20095e:	4798      	blx	r3
  for (i = 0; i < 76; i++)
  200960:	3c01      	subs	r4, #1
  200962:	d1f8      	bne.n	200956 <print_line+0x6>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
  200964:	6828      	ldr	r0, [r5, #0]
  200966:	2202      	movs	r2, #2
  200968:	4903      	ldr	r1, [pc, #12]	; (200978 <print_line+0x28>)
  20096a:	6803      	ldr	r3, [r0, #0]
}
  20096c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
  200970:	685b      	ldr	r3, [r3, #4]
  200972:	4718      	bx	r3
  200974:	20001ec0 	.word	0x20001ec0
  200978:	0800c4dc 	.word	0x0800c4dc
  20097c:	00000000 	.word	0x00000000

00200980 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
  200980:	2902      	cmp	r1, #2
  200982:	d006      	beq.n	200992 <get_descriptor+0x12>
  200984:	2903      	cmp	r1, #3
  200986:	d006      	beq.n	200996 <get_descriptor+0x16>
  200988:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
  20098a:	4807      	ldr	r0, [pc, #28]	; (2009a8 <get_descriptor+0x28>)
  20098c:	bf18      	it	ne
  20098e:	2000      	movne	r0, #0
  200990:	4770      	bx	lr
    return &vcom_configuration_descriptor;
  200992:	4806      	ldr	r0, [pc, #24]	; (2009ac <get_descriptor+0x2c>)
  200994:	4770      	bx	lr
    if (dindex < 4)
  200996:	2a03      	cmp	r2, #3
  200998:	d803      	bhi.n	2009a2 <get_descriptor+0x22>
      return &vcom_strings[dindex];
  20099a:	4805      	ldr	r0, [pc, #20]	; (2009b0 <get_descriptor+0x30>)
  20099c:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
  2009a0:	4770      	bx	lr
  return NULL;
  2009a2:	2000      	movs	r0, #0
}
  2009a4:	4770      	bx	lr
  2009a6:	bf00      	nop
  2009a8:	0800e880 	.word	0x0800e880
  2009ac:	0800e834 	.word	0x0800e834
  2009b0:	0800e908 	.word	0x0800e908
	...

002009c0 <_port_irq_epilogue>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  2009c0:	b672      	cpsid	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2009c2:	2320      	movs	r3, #32
  2009c4:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2009c8:	b662      	cpsie	i
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  2009ca:	4b0f      	ldr	r3, [pc, #60]	; (200a08 <_port_irq_epilogue+0x48>)
  2009cc:	685b      	ldr	r3, [r3, #4]
  2009ce:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  2009d2:	d102      	bne.n	2009da <_port_irq_epilogue+0x1a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2009d4:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
  2009d8:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2009da:	f3ef 8309 	mrs	r3, PSP
    ctxp->xpsr = (regarm_t)0x01000000;
  2009de:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp--;
  2009e2:	f1a3 0220 	sub.w	r2, r3, #32
    ctxp->xpsr = (regarm_t)0x01000000;
  2009e6:	f843 1c04 	str.w	r1, [r3, #-4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2009ea:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
  2009ee:	4a07      	ldr	r2, [pc, #28]	; (200a0c <_port_irq_epilogue+0x4c>)
  2009f0:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
  2009f2:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  2009f4:	6889      	ldr	r1, [r1, #8]
  2009f6:	6892      	ldr	r2, [r2, #8]
  2009f8:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
  2009fa:	bf8c      	ite	hi
  2009fc:	4a04      	ldrhi	r2, [pc, #16]	; (200a10 <_port_irq_epilogue+0x50>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
  2009fe:	4a05      	ldrls	r2, [pc, #20]	; (200a14 <_port_irq_epilogue+0x54>)
  200a00:	f843 2c08 	str.w	r2, [r3, #-8]
  200a04:	4770      	bx	lr
  200a06:	bf00      	nop
  200a08:	e000ed00 	.word	0xe000ed00
  200a0c:	20000dc8 	.word	0x20000dc8
  200a10:	00200305 	.word	0x00200305
  200a14:	00200310 	.word	0x00200310
	...

00200a20 <chTMStopMeasurementX>:
  200a20:	4b10      	ldr	r3, [pc, #64]	; (200a64 <chTMStopMeasurementX+0x44>)
  tmp->last = (now - tmp->last) - offset;
  200a22:	6882      	ldr	r2, [r0, #8]
  200a24:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  200a26:	4910      	ldr	r1, [pc, #64]	; (200a68 <chTMStopMeasurementX+0x48>)
  tmp->last = (now - tmp->last) - offset;
  200a28:	1a9b      	subs	r3, r3, r2
  if (tmp->last > tmp->worst) {
  200a2a:	6842      	ldr	r2, [r0, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
  200a2c:	e92d 0830 	stmdb	sp!, {r4, r5, fp}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  200a30:	f8d1 4884 	ldr.w	r4, [r1, #2180]	; 0x884
  tmp->n++;
  200a34:	68c1      	ldr	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  200a36:	1b1b      	subs	r3, r3, r4
  tmp->n++;
  200a38:	3101      	adds	r1, #1
  tmp->last = (now - tmp->last) - offset;
  200a3a:	6083      	str	r3, [r0, #8]
  tmp->n++;
  200a3c:	60c1      	str	r1, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
  200a3e:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  200a42:	eb14 0b03 	adds.w	fp, r4, r3
  200a46:	f145 0c00 	adc.w	ip, r5, #0
  if (tmp->last > tmp->worst) {
  200a4a:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
  200a4c:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
  200a4e:	bf88      	it	hi
  200a50:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
  200a52:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
  200a54:	e9c0 bc04 	strd	fp, ip, [r0, #16]
    tmp->best = tmp->last;
  200a58:	bf38      	it	cc
  200a5a:	6003      	strcc	r3, [r0, #0]
}
  200a5c:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
  200a60:	4770      	bx	lr
  200a62:	bf00      	nop
  200a64:	e0001000 	.word	0xe0001000
  200a68:	20000dc8 	.word	0x20000dc8
  200a6c:	00000000 	.word	0x00000000

00200a70 <trace_next>:
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
  200a70:	4a0b      	ldr	r2, [pc, #44]	; (200aa0 <trace_next+0x30>)
  200a72:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
static NOINLINE void trace_next(void) {
  200a76:	b430      	push	{r4, r5}
  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
  200a78:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
  200a7a:	f502 6004 	add.w	r0, r2, #2112	; 0x840
  200a7e:	6a4d      	ldr	r5, [r1, #36]	; 0x24
  200a80:	4c08      	ldr	r4, [pc, #32]	; (200aa4 <trace_next+0x34>)
  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
  200a82:	605d      	str	r5, [r3, #4]
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
  200a84:	6819      	ldr	r1, [r3, #0]
  200a86:	6864      	ldr	r4, [r4, #4]
  200a88:	f364 211f 	bfi	r1, r4, #8, #24
  200a8c:	f843 1b10 	str.w	r1, [r3], #16
  if (++ch.dbg.trace_buffer.ptr >=
  200a90:	4283      	cmp	r3, r0
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
  200a92:	bf28      	it	cs
  200a94:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
  }
}
  200a98:	bc30      	pop	{r4, r5}
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
  200a9a:	63d3      	str	r3, [r2, #60]	; 0x3c
}
  200a9c:	4770      	bx	lr
  200a9e:	bf00      	nop
  200aa0:	20000dc8 	.word	0x20000dc8
  200aa4:	e0001000 	.word	0xe0001000
	...

00200ab0 <_trace_switch.constprop.79>:
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
  200ab0:	4b0b      	ldr	r3, [pc, #44]	; (200ae0 <_trace_switch.constprop.79+0x30>)
  200ab2:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
  200ab4:	07d2      	lsls	r2, r2, #31
  200ab6:	d500      	bpl.n	200aba <_trace_switch.constprop.79+0xa>
  200ab8:	4770      	bx	lr
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
  200aba:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
void _trace_switch(thread_t *ntp, thread_t *otp) {
  200abc:	b430      	push	{r4, r5}
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
  200abe:	780a      	ldrb	r2, [r1, #0]
  200ac0:	2501      	movs	r5, #1
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
  200ac2:	6a44      	ldr	r4, [r0, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
  200ac4:	f365 0202 	bfi	r2, r5, #0, #3
  200ac8:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
  200aca:	f890 0020 	ldrb.w	r0, [r0, #32]
  200ace:	f360 02c7 	bfi	r2, r0, #3, #5
  200ad2:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
  200ad4:	699b      	ldr	r3, [r3, #24]
  200ad6:	e9c1 3402 	strd	r3, r4, [r1, #8]
    trace_next();
  }
}
  200ada:	bc30      	pop	{r4, r5}
    trace_next();
  200adc:	f7ff bfc8 	b.w	200a70 <trace_next>
  200ae0:	20000dc8 	.word	0x20000dc8
	...

00200af0 <_trace_isr_leave>:
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
  200af0:	4a0a      	ldr	r2, [pc, #40]	; (200b1c <_trace_isr_leave+0x2c>)
  200af2:	8f13      	ldrh	r3, [r2, #56]	; 0x38
void _trace_isr_leave(const char *isr) {
  200af4:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
  200af6:	f013 0402 	ands.w	r4, r3, #2
  200afa:	d000      	beq.n	200afe <_trace_isr_leave+0xe>
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
    port_unlock_from_isr();
  }
}
  200afc:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
  200afe:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200b00:	2320      	movs	r3, #32
  200b02:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  200b06:	b662      	cpsie	i
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
  200b08:	2103      	movs	r1, #3
  200b0a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
  200b0c:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
  200b0e:	7019      	strb	r1, [r3, #0]
    trace_next();
  200b10:	f7ff ffae 	bl	200a70 <trace_next>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200b14:	f384 8811 	msr	BASEPRI, r4
}
  200b18:	bd10      	pop	{r4, pc}
  200b1a:	bf00      	nop
  200b1c:	20000dc8 	.word	0x20000dc8

00200b20 <_trace_isr_enter>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
  200b20:	4a0a      	ldr	r2, [pc, #40]	; (200b4c <_trace_isr_enter+0x2c>)
  200b22:	8f13      	ldrh	r3, [r2, #56]	; 0x38
void _trace_isr_enter(const char *isr) {
  200b24:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
  200b26:	f013 0402 	ands.w	r4, r3, #2
  200b2a:	d000      	beq.n	200b2e <_trace_isr_enter+0xe>
}
  200b2c:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
  200b2e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200b30:	2320      	movs	r3, #32
  200b32:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  200b36:	b662      	cpsie	i
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
  200b38:	2102      	movs	r1, #2
  200b3a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
  200b3c:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
  200b3e:	7019      	strb	r1, [r3, #0]
    trace_next();
  200b40:	f7ff ff96 	bl	200a70 <trace_next>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200b44:	f384 8811 	msr	BASEPRI, r4
}
  200b48:	bd10      	pop	{r4, pc}
  200b4a:	bf00      	nop
  200b4c:	20000dc8 	.word	0x20000dc8

00200b50 <chSysPolledDelayX>:
  200b50:	4a03      	ldr	r2, [pc, #12]	; (200b60 <chSysPolledDelayX+0x10>)
  200b52:	6851      	ldr	r1, [r2, #4]
  200b54:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
  200b56:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
  200b58:	4298      	cmp	r0, r3
  200b5a:	d8fb      	bhi.n	200b54 <chSysPolledDelayX+0x4>
  }
}
  200b5c:	4770      	bx	lr
  200b5e:	bf00      	nop
  200b60:	e0001000 	.word	0xe0001000
	...

00200b70 <chSysHalt>:
void chSysHalt(const char *reason) {
  200b70:	b508      	push	{r3, lr}
  200b72:	4605      	mov	r5, r0
  __ASM volatile ("cpsid i" : : : "memory");
  200b74:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
  200b76:	4c06      	ldr	r4, [pc, #24]	; (200b90 <chSysHalt+0x20>)
  200b78:	8f23      	ldrh	r3, [r4, #56]	; 0x38
  200b7a:	075b      	lsls	r3, r3, #29
  200b7c:	d501      	bpl.n	200b82 <chSysHalt+0x12>
  ch.dbg.panic_msg = reason;
  200b7e:	62e5      	str	r5, [r4, #44]	; 0x2c
  200b80:	e7fe      	b.n	200b80 <chSysHalt+0x10>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
  200b82:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  200b84:	2204      	movs	r2, #4
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
  200b86:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
  200b88:	701a      	strb	r2, [r3, #0]
    trace_next();
  200b8a:	f7ff ff71 	bl	200a70 <trace_next>
  200b8e:	e7f6      	b.n	200b7e <chSysHalt+0xe>
  200b90:	20000dc8 	.word	0x20000dc8
	...

00200ba0 <rt_test_009_001_setup>:
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
  200ba0:	4b0b      	ldr	r3, [pc, #44]	; (200bd0 <rt_test_009_001_setup+0x30>)
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
  200ba2:	2000      	movs	r0, #0
  200ba4:	4a0b      	ldr	r2, [pc, #44]	; (200bd4 <rt_test_009_001_setup+0x34>)
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
  200ba6:	1dd9      	adds	r1, r3, #7
  200ba8:	f021 0107 	bic.w	r1, r1, #7
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  200bac:	1acb      	subs	r3, r1, r3
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
  200bae:	f5c3 63cc 	rsb	r3, r3, #1632	; 0x660
 *   freeing memory.
 * - [9.1.7] Getting heap info again for verification.
 * .
 */

static void rt_test_009_001_setup(void) {
  200bb2:	b410      	push	{r4}
  200bb4:	08db      	lsrs	r3, r3, #3
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
  200bb6:	f102 040c 	add.w	r4, r2, #12
  H_PAGES(&heapp->header) = 0;
  200bba:	6090      	str	r0, [r2, #8]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
  200bbc:	6150      	str	r0, [r2, #20]
  H_NEXT(&heapp->header) = hp;
  200bbe:	6051      	str	r1, [r2, #4]
  heapp->provider = NULL;
  200bc0:	6010      	str	r0, [r2, #0]
  H_NEXT(hp) = NULL;
  200bc2:	6008      	str	r0, [r1, #0]
  tqp->prev = (thread_t *)tqp;
  200bc4:	e9c2 4403 	strd	r4, r4, [r2, #12]
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
  200bc8:	604b      	str	r3, [r1, #4]
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}
  200bca:	bc10      	pop	{r4}
  200bcc:	4770      	bx	lr
  200bce:	bf00      	nop
  200bd0:	20001858 	.word	0x20001858
  200bd4:	200017dc 	.word	0x200017dc
	...

00200be0 <oslib_test_003_001_setup>:
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
  200be0:	4b0b      	ldr	r3, [pc, #44]	; (200c10 <oslib_test_003_001_setup+0x30>)
  heapp->provider = NULL;
  200be2:	2000      	movs	r0, #0
  200be4:	4a0b      	ldr	r2, [pc, #44]	; (200c14 <oslib_test_003_001_setup+0x34>)
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
  200be6:	1dd9      	adds	r1, r3, #7
  200be8:	f021 0107 	bic.w	r1, r1, #7
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  200bec:	1acb      	subs	r3, r1, r3
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
  200bee:	f1c3 0378 	rsb	r3, r3, #120	; 0x78
 * - [3.1.10] Testing final conditions. The heap geometry must be the
 *   same than the one registered at beginning.
 * .
 */

static void oslib_test_003_001_setup(void) {
  200bf2:	b410      	push	{r4}
  200bf4:	08db      	lsrs	r3, r3, #3
  tqp->next = (thread_t *)tqp;
  200bf6:	f102 040c 	add.w	r4, r2, #12
  H_PAGES(&heapp->header) = 0;
  200bfa:	6090      	str	r0, [r2, #8]
  200bfc:	6150      	str	r0, [r2, #20]
  H_NEXT(&heapp->header) = hp;
  200bfe:	6051      	str	r1, [r2, #4]
  heapp->provider = NULL;
  200c00:	6010      	str	r0, [r2, #0]
  H_NEXT(hp) = NULL;
  200c02:	6008      	str	r0, [r1, #0]
  tqp->prev = (thread_t *)tqp;
  200c04:	e9c2 4403 	strd	r4, r4, [r2, #12]
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
  200c08:	604b      	str	r3, [r1, #4]
  chHeapObjectInit(&test_heap, test_heap_buffer, sizeof(test_heap_buffer));
}
  200c0a:	bc10      	pop	{r4}
  200c0c:	4770      	bx	lr
  200c0e:	bf00      	nop
  200c10:	20001ee8 	.word	0x20001ee8
  200c14:	20001ecc 	.word	0x20001ecc
	...

00200c20 <oslib_test_002_001_setup>:
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  200c20:	4b03      	ldr	r3, [pc, #12]	; (200c30 <oslib_test_002_001_setup+0x10>)
  200c22:	2100      	movs	r1, #0
  mp->object_size = size;
  200c24:	2204      	movs	r2, #4
  mp->next = NULL;
  200c26:	6019      	str	r1, [r3, #0]
  mp->align = align;
  mp->provider = provider;
  200c28:	60d9      	str	r1, [r3, #12]
  mp->align = align;
  200c2a:	e9c3 2201 	strd	r2, r2, [r3, #4]
 * .
 */

static void oslib_test_002_001_setup(void) {
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
}
  200c2e:	4770      	bx	lr
  200c30:	20010480 	.word	0x20010480
	...

00200c40 <oslib_test_001_003_setup>:
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));

  mbp->buffer = buf;
  200c40:	4b0a      	ldr	r3, [pc, #40]	; (200c6c <oslib_test_001_003_setup+0x2c>)
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
  mbp->cnt    = (size_t)0;
  200c42:	2100      	movs	r1, #0
  mbp->buffer = buf;
  200c44:	4a0a      	ldr	r2, [pc, #40]	; (200c70 <oslib_test_001_003_setup+0x30>)
  tqp->next = (thread_t *)tqp;
  200c46:	f103 0020 	add.w	r0, r3, #32
 *   active state.
 * - [1.3.4] Testing chMBFetchTimeout() and chMBFetchI() timeout.
 * .
 */

static void oslib_test_001_003_setup(void) {
  200c4a:	b430      	push	{r4, r5}
  200c4c:	f103 0418 	add.w	r4, r3, #24
  mbp->top    = &buf[n];
  200c50:	f102 0510 	add.w	r5, r2, #16
  mbp->buffer = buf;
  200c54:	601a      	str	r2, [r3, #0]
  mbp->top    = &buf[n];
  200c56:	605d      	str	r5, [r3, #4]
  mbp->cnt    = (size_t)0;
  200c58:	6119      	str	r1, [r3, #16]
  mbp->reset  = false;
  200c5a:	7519      	strb	r1, [r3, #20]
  tqp->prev = (thread_t *)tqp;
  200c5c:	e9c3 4406 	strd	r4, r4, [r3, #24]
  mbp->wrptr  = buf;
  200c60:	e9c3 2202 	strd	r2, r2, [r3, #8]
  200c64:	e9c3 0008 	strd	r0, r0, [r3, #32]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
  200c68:	bc30      	pop	{r4, r5}
  200c6a:	4770      	bx	lr
  200c6c:	20010458 	.word	0x20010458
  200c70:	200017f8 	.word	0x200017f8
	...

00200c80 <oslib_test_001_002_setup>:
  200c80:	f7ff bfde 	b.w	200c40 <oslib_test_001_003_setup>
	...

00200c90 <oslib_test_001_001_setup>:
  200c90:	f7ff bfd6 	b.w	200c40 <oslib_test_001_003_setup>
	...

00200ca0 <rt_test_009_002_setup>:
  mp->next = NULL;
  200ca0:	4b04      	ldr	r3, [pc, #16]	; (200cb4 <rt_test_009_002_setup+0x14>)
  200ca2:	2200      	movs	r2, #0
  mp->object_size = size;
  200ca4:	f44f 70a4 	mov.w	r0, #328	; 0x148
  mp->align = align;
  200ca8:	2104      	movs	r1, #4
  mp->next = NULL;
  200caa:	601a      	str	r2, [r3, #0]
  mp->provider = provider;
  200cac:	60da      	str	r2, [r3, #12]
  mp->align = align;
  200cae:	e9c3 0101 	strd	r0, r1, [r3, #4]
 * .
 */

static void rt_test_009_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
  200cb2:	4770      	bx	lr
  200cb4:	20001808 	.word	0x20001808
	...

00200cc0 <chSemObjectInit>:
  200cc0:	e9c0 0000 	strd	r0, r0, [r0]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
  200cc4:	6081      	str	r1, [r0, #8]
}
  200cc6:	4770      	bx	lr
	...

00200cd0 <oslib_test_002_003_setup>:
 * - [2.3.1] Trying to allocate with 100mS timeout, must fail because
 *   the pool is empty.
 * .
 */

static void oslib_test_002_003_setup(void) {
  200cd0:	b410      	push	{r4}
  mp->next = NULL;
  200cd2:	4b06      	ldr	r3, [pc, #24]	; (200cec <oslib_test_002_003_setup+0x1c>)
  200cd4:	2200      	movs	r2, #0
  mp->object_size = size;
  200cd6:	2404      	movs	r4, #4
void chGuardedPoolObjectInitAligned(guarded_memory_pool_t *gmp,
                                    size_t size,
                                    unsigned align) {

  chPoolObjectInitAligned(&gmp->pool, size, align, NULL);
  chSemObjectInit(&gmp->sem, (cnt_t)0);
  200cd8:	4618      	mov	r0, r3
  200cda:	4611      	mov	r1, r2
  mp->next = NULL;
  200cdc:	60da      	str	r2, [r3, #12]
  mp->provider = provider;
  200cde:	619a      	str	r2, [r3, #24]
  mp->align = align;
  200ce0:	e9c3 4404 	strd	r4, r4, [r3, #16]
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}
  200ce4:	bc10      	pop	{r4}
  chSemObjectInit(&gmp->sem, (cnt_t)0);
  200ce6:	f7ff bfeb 	b.w	200cc0 <chSemObjectInit>
  200cea:	bf00      	nop
  200cec:	20010414 	.word	0x20010414

00200cf0 <oslib_test_002_002_setup>:
  200cf0:	f7ff bfee 	b.w	200cd0 <oslib_test_002_003_setup>
	...

00200d00 <rt_test_010_010_setup>:
 * - [10.10.2] The score is printed.
 * .
 */

static void rt_test_010_010_setup(void) {
  chSemObjectInit(&sem1, 1);
  200d00:	2101      	movs	r1, #1
  200d02:	4801      	ldr	r0, [pc, #4]	; (200d08 <rt_test_010_010_setup+0x8>)
  200d04:	f7ff bfdc 	b.w	200cc0 <chSemObjectInit>
  200d08:	20001844 	.word	0x20001844
  200d0c:	00000000 	.word	0x00000000

00200d10 <rt_test_010_007_setup>:
  chSemObjectInit(&sem1, 0);
  200d10:	2100      	movs	r1, #0
  200d12:	4801      	ldr	r0, [pc, #4]	; (200d18 <rt_test_010_007_setup+0x8>)
  200d14:	f7ff bfd4 	b.w	200cc0 <chSemObjectInit>
  200d18:	20001844 	.word	0x20001844
  200d1c:	00000000 	.word	0x00000000

00200d20 <rt_test_005_005_setup>:
 *   counter value must be one on exit.
 * .
 */

static void rt_test_005_005_setup(void) {
  chSemObjectInit(&sem1, 0);
  200d20:	2100      	movs	r1, #0
  200d22:	4801      	ldr	r0, [pc, #4]	; (200d28 <rt_test_005_005_setup+0x8>)
  200d24:	f7ff bfcc 	b.w	200cc0 <chSemObjectInit>
  200d28:	20001838 	.word	0x20001838
  200d2c:	00000000 	.word	0x00000000

00200d30 <rt_test_005_004_setup>:
  200d30:	f7ff bff6 	b.w	200d20 <rt_test_005_005_setup>
	...

00200d40 <rt_test_005_003_setup>:
  200d40:	f7ff bfee 	b.w	200d20 <rt_test_005_005_setup>
	...

00200d50 <rt_test_005_002_setup>:
  200d50:	f7ff bfe6 	b.w	200d20 <rt_test_005_005_setup>
	...

00200d60 <rt_test_005_001_setup>:
  chSemObjectInit(&sem1, 1);
  200d60:	2101      	movs	r1, #1
  200d62:	4801      	ldr	r0, [pc, #4]	; (200d68 <rt_test_005_001_setup+0x8>)
  200d64:	f7ff bfac 	b.w	200cc0 <chSemObjectInit>
  200d68:	20001838 	.word	0x20001838
  200d6c:	00000000 	.word	0x00000000

00200d70 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
  200d70:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
  200d72:	4b05      	ldr	r3, [pc, #20]	; (200d88 <chDbgCheckClassS+0x18>)
  200d74:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  200d76:	b91a      	cbnz	r2, 200d80 <chDbgCheckClassS+0x10>
  200d78:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  200d7a:	2b00      	cmp	r3, #0
  200d7c:	dd00      	ble.n	200d80 <chDbgCheckClassS+0x10>
    chSysHalt("SV#11");
  }
}
  200d7e:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
  200d80:	4802      	ldr	r0, [pc, #8]	; (200d8c <chDbgCheckClassS+0x1c>)
  200d82:	f7ff fef5 	bl	200b70 <chSysHalt>
  200d86:	bf00      	nop
  200d88:	20000dc8 	.word	0x20000dc8
  200d8c:	0800c1f8 	.word	0x0800c1f8

00200d90 <chDbgCheckClassI>:
void chDbgCheckClassI(void) {
  200d90:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
  200d92:	4b05      	ldr	r3, [pc, #20]	; (200da8 <chDbgCheckClassI+0x18>)
  200d94:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  200d96:	2a00      	cmp	r2, #0
  200d98:	db03      	blt.n	200da2 <chDbgCheckClassI+0x12>
  200d9a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  200d9c:	2b00      	cmp	r3, #0
  200d9e:	dd00      	ble.n	200da2 <chDbgCheckClassI+0x12>
}
  200da0:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
  200da2:	4802      	ldr	r0, [pc, #8]	; (200dac <chDbgCheckClassI+0x1c>)
  200da4:	f7ff fee4 	bl	200b70 <chSysHalt>
  200da8:	20000dc8 	.word	0x20000dc8
  200dac:	0800c1f0 	.word	0x0800c1f0

00200db0 <chPoolFreeI>:
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  200db0:	b538      	push	{r3, r4, r5, lr}
  200db2:	4604      	mov	r4, r0
  200db4:	460d      	mov	r5, r1
  chDbgCheckClassI();
  200db6:	f7ff ffeb 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
  200dba:	b144      	cbz	r4, 200dce <chPoolFreeI+0x1e>
  200dbc:	b13d      	cbz	r5, 200dce <chPoolFreeI+0x1e>
  chDbgAssert(((size_t)objp & MEM_ALIGN_MASK(mp->align)) == 0U,
  200dbe:	68a3      	ldr	r3, [r4, #8]
  200dc0:	3b01      	subs	r3, #1
  200dc2:	421d      	tst	r5, r3
  200dc4:	d103      	bne.n	200dce <chPoolFreeI+0x1e>
  php->next = mp->next;
  200dc6:	6823      	ldr	r3, [r4, #0]
  200dc8:	602b      	str	r3, [r5, #0]
  mp->next = php;
  200dca:	6025      	str	r5, [r4, #0]
}
  200dcc:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheck((mp != NULL) && (objp != NULL));
  200dce:	4801      	ldr	r0, [pc, #4]	; (200dd4 <chPoolFreeI+0x24>)
  200dd0:	f7ff fece 	bl	200b70 <chSysHalt>
  200dd4:	0800be30 	.word	0x0800be30
	...

00200de0 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
  200de0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  200de2:	460e      	mov	r6, r1
  200de4:	4604      	mov	r4, r0
  200de6:	4615      	mov	r5, r2
  uint8_t *p, *next;

  chDbgCheckClassI();
  200de8:	f7ff ffd2 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
  200dec:	b1a6      	cbz	r6, 200e18 <chCoreAllocAlignedWithOffsetI+0x38>
  200dee:	1e73      	subs	r3, r6, #1
  200df0:	4233      	tst	r3, r6
  200df2:	d111      	bne.n	200e18 <chCoreAllocAlignedWithOffsetI+0x38>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  200df4:	4a0b      	ldr	r2, [pc, #44]	; (200e24 <chCoreAllocAlignedWithOffsetI+0x44>)
  size = MEM_ALIGN_NEXT(size, align);
  200df6:	1e63      	subs	r3, r4, #1
  200df8:	4271      	negs	r1, r6
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  200dfa:	6817      	ldr	r7, [r2, #0]
  size = MEM_ALIGN_NEXT(size, align);
  200dfc:	4433      	add	r3, r6
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
  200dfe:	6854      	ldr	r4, [r2, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  200e00:	1978      	adds	r0, r7, r5
  size = MEM_ALIGN_NEXT(size, align);
  200e02:	400b      	ands	r3, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  200e04:	4430      	add	r0, r6
  200e06:	3801      	subs	r0, #1
  200e08:	4008      	ands	r0, r1
  next = p + size;
  200e0a:	4403      	add	r3, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
  200e0c:	429c      	cmp	r4, r3
  200e0e:	d306      	bcc.n	200e1e <chCoreAllocAlignedWithOffsetI+0x3e>
  200e10:	429f      	cmp	r7, r3
  200e12:	d804      	bhi.n	200e1e <chCoreAllocAlignedWithOffsetI+0x3e>
    return NULL;
  }

  ch_memcore.nextmem = next;
  200e14:	6013      	str	r3, [r2, #0]

  return p;
}
  200e16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
  200e18:	4803      	ldr	r0, [pc, #12]	; (200e28 <chCoreAllocAlignedWithOffsetI+0x48>)
  200e1a:	f7ff fea9 	bl	200b70 <chSysHalt>
    return NULL;
  200e1e:	2000      	movs	r0, #0
}
  200e20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  200e22:	bf00      	nop
  200e24:	20001770 	.word	0x20001770
  200e28:	0800bdbc 	.word	0x0800bdbc
  200e2c:	00000000 	.word	0x00000000

00200e30 <chCoreAllocAlignedI>:
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
  200e30:	2200      	movs	r2, #0
  200e32:	f7ff bfd5 	b.w	200de0 <chCoreAllocAlignedWithOffsetI>
  200e36:	bf00      	nop
	...

00200e40 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  200e40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  200e44:	4604      	mov	r4, r0
  thread_t *tp;

  chDbgCheckClassI();
  200e46:	f7ff ffa3 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
  200e4a:	6861      	ldr	r1, [r4, #4]
  200e4c:	0748      	lsls	r0, r1, #29
  200e4e:	d107      	bne.n	200e60 <chThdCreateSuspendedI+0x20>
  200e50:	68a3      	ldr	r3, [r4, #8]
  200e52:	075a      	lsls	r2, r3, #29
  200e54:	d104      	bne.n	200e60 <chThdCreateSuspendedI+0x20>
  200e56:	4299      	cmp	r1, r3
  200e58:	bf34      	ite	cc
  200e5a:	2500      	movcc	r5, #0
  200e5c:	2501      	movcs	r5, #1
  200e5e:	b115      	cbz	r5, 200e66 <chThdCreateSuspendedI+0x26>
  200e60:	4820      	ldr	r0, [pc, #128]	; (200ee4 <chThdCreateSuspendedI+0xa4>)
  200e62:	f7ff fe85 	bl	200b70 <chSysHalt>
  200e66:	1a5a      	subs	r2, r3, r1
  200e68:	2ac7      	cmp	r2, #199	; 0xc7
  200e6a:	d9f9      	bls.n	200e60 <chThdCreateSuspendedI+0x20>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
  200e6c:	68e0      	ldr	r0, [r4, #12]
  200e6e:	28ff      	cmp	r0, #255	; 0xff
  200e70:	d8f6      	bhi.n	200e60 <chThdCreateSuspendedI+0x20>
  200e72:	6926      	ldr	r6, [r4, #16]
  200e74:	2e00      	cmp	r6, #0
  200e76:	d0f3      	beq.n	200e60 <chThdCreateSuspendedI+0x20>
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
  200e78:	f843 1c2c 	str.w	r1, [r3, #-44]
  tp->state     = CH_STATE_WTSTART;
  200e7c:	f04f 0802 	mov.w	r8, #2
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  200e80:	6961      	ldr	r1, [r4, #20]
  tp->refs      = (trefs_t)1;
  200e82:	f04f 0c01 	mov.w	ip, #1
  REG_INSERT(tp);
  200e86:	4a18      	ldr	r2, [pc, #96]	; (200ee8 <chThdCreateSuspendedI+0xa8>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  200e88:	f1a3 076c 	sub.w	r7, r3, #108	; 0x6c
  200e8c:	f843 1c68 	str.w	r1, [r3, #-104]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
  200e90:	6821      	ldr	r1, [r4, #0]
  queue_init(&tp->msgqueue);
  200e92:	f1a3 041c 	sub.w	r4, r3, #28
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  200e96:	f843 6c6c 	str.w	r6, [r3, #-108]
  list_init(&tp->waiting);
  200e9a:	f1a3 0620 	sub.w	r6, r3, #32
  return _thread_init(tp, tdp->name, tdp->prio);
  200e9e:	f843 1c30 	str.w	r1, [r3, #-48]
  tp = (thread_t *)((uint8_t *)tdp->wend -
  200ea2:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
  tp->state     = CH_STATE_WTSTART;
  200ea6:	f803 8c28 	strb.w	r8, [r3, #-40]
  tp->flags     = CH_FLAG_MODE_STATIC;
  200eaa:	f803 5c27 	strb.w	r5, [r3, #-39]
  tp->refs      = (trefs_t)1;
  200eae:	f803 cc26 	strb.w	ip, [r3, #-38]
  REG_INSERT(tp);
  200eb2:	f843 2c38 	str.w	r2, [r3, #-56]
  tp->prio      = prio;
  200eb6:	f843 0c40 	str.w	r0, [r3, #-64]
  tp->epending  = (eventmask_t)0;
  200eba:	f843 5c14 	str.w	r5, [r3, #-20]
  tp->mtxlist   = NULL;
  200ebe:	e943 5004 	strd	r5, r0, [r3, #-16]
  REG_INSERT(tp);
  200ec2:	6955      	ldr	r5, [r2, #20]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  200ec4:	4809      	ldr	r0, [pc, #36]	; (200eec <chThdCreateSuspendedI+0xac>)
  200ec6:	f843 7c3c 	str.w	r7, [r3, #-60]
  200eca:	f843 0c4c 	str.w	r0, [r3, #-76]
}
  200ece:	4608      	mov	r0, r1
  REG_INSERT(tp);
  200ed0:	f843 5c34 	str.w	r5, [r3, #-52]
  200ed4:	6129      	str	r1, [r5, #16]
  200ed6:	6151      	str	r1, [r2, #20]
  200ed8:	f843 4c18 	str.w	r4, [r3, #-24]
  tqp->next = (thread_t *)tqp;
  200edc:	e943 6408 	strd	r6, r4, [r3, #-32]
}
  200ee0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  200ee4:	0800bddc 	.word	0x0800bddc
  200ee8:	20000dc8 	.word	0x20000dc8
  200eec:	002002f1 	.word	0x002002f1

00200ef0 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
  200ef0:	b510      	push	{r4, lr}
  200ef2:	4604      	mov	r4, r0
  chDbgCheckClassI();
  200ef4:	f7ff ff4c 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
  200ef8:	b1bc      	cbz	r4, 200f2a <chSchReadyI+0x3a>
  chDbgAssert((tp->state != CH_STATE_READY) &&
  200efa:	f894 2020 	ldrb.w	r2, [r4, #32]
  200efe:	b1a2      	cbz	r2, 200f2a <chSchReadyI+0x3a>
  200f00:	f1a2 020f 	sub.w	r2, r2, #15
  200f04:	fab2 f282 	clz	r2, r2
  200f08:	0952      	lsrs	r2, r2, #5
  200f0a:	b972      	cbnz	r2, 200f2a <chSchReadyI+0x3a>
  } while (cp->prio >= tp->prio);
  200f0c:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
  200f0e:	4b08      	ldr	r3, [pc, #32]	; (200f30 <chSchReadyI+0x40>)
  tp->state = CH_STATE_READY;
  200f10:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
  200f14:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  200f16:	689a      	ldr	r2, [r3, #8]
  200f18:	428a      	cmp	r2, r1
  200f1a:	d2fb      	bcs.n	200f14 <chSchReadyI+0x24>
  tp->queue.prev             = cp->queue.prev;
  200f1c:	685a      	ldr	r2, [r3, #4]
}
  200f1e:	4620      	mov	r0, r4
  tp->queue.prev             = cp->queue.prev;
  200f20:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
  200f24:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  200f26:	605c      	str	r4, [r3, #4]
}
  200f28:	bd10      	pop	{r4, pc}
  chDbgCheck(tp != NULL);
  200f2a:	4802      	ldr	r0, [pc, #8]	; (200f34 <chSchReadyI+0x44>)
  200f2c:	f7ff fe20 	bl	200b70 <chSysHalt>
  200f30:	20000dc8 	.word	0x20000dc8
  200f34:	0800bd68 	.word	0x0800bd68
	...

00200f40 <chThdDequeueNextI.constprop.80>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  200f40:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
  200f42:	6803      	ldr	r3, [r0, #0]

  if (queue_notempty(tqp)) {
  200f44:	4298      	cmp	r0, r3
  200f46:	d009      	beq.n	200f5c <chThdDequeueNextI.constprop.80+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
  200f48:	681a      	ldr	r2, [r3, #0]
  200f4a:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  200f4c:	6050      	str	r0, [r2, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
  200f4e:	f893 2020 	ldrb.w	r2, [r3, #32]
  200f52:	2a04      	cmp	r2, #4
  200f54:	d003      	beq.n	200f5e <chThdDequeueNextI.constprop.80+0x1e>
  200f56:	4805      	ldr	r0, [pc, #20]	; (200f6c <chThdDequeueNextI.constprop.80+0x2c>)
  200f58:	f7ff fe0a 	bl	200b70 <chSysHalt>
    chThdDoDequeueNextI(tqp, msg);
  }
}
  200f5c:	bd08      	pop	{r3, pc}

  tp->u.rdymsg = msg;
  200f5e:	2200      	movs	r2, #0
  (void) chSchReadyI(tp);
  200f60:	4618      	mov	r0, r3
  tp->u.rdymsg = msg;
  200f62:	625a      	str	r2, [r3, #36]	; 0x24
  200f64:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  (void) chSchReadyI(tp);
  200f68:	f7ff bfc2 	b.w	200ef0 <chSchReadyI>
  200f6c:	0800bd00 	.word	0x0800bd00

00200f70 <chMBFetchI.constprop.20>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
  200f70:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
  200f72:	4c10      	ldr	r4, [pc, #64]	; (200fb4 <chMBFetchI.constprop.20+0x44>)
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
  200f74:	4605      	mov	r5, r0
  chDbgCheckClassI();
  200f76:	f7ff ff0b 	bl	200d90 <chDbgCheckClassI>
  if (mbp->reset) {
  200f7a:	7d23      	ldrb	r3, [r4, #20]
  200f7c:	b9a3      	cbnz	r3, 200fa8 <chMBFetchI.constprop.20+0x38>
 *
 * @iclass
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();
  200f7e:	f7ff ff07 	bl	200d90 <chDbgCheckClassI>

  return mbp->cnt;
  200f82:	6923      	ldr	r3, [r4, #16]
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (size_t)0) {
  200f84:	b19b      	cbz	r3, 200fae <chMBFetchI.constprop.20+0x3e>
    *msgp = *mbp->rdptr++;
  200f86:	68e1      	ldr	r1, [r4, #12]
    if (mbp->rdptr >= mbp->top) {
  200f88:	6860      	ldr	r0, [r4, #4]
    *msgp = *mbp->rdptr++;
  200f8a:	1d0a      	adds	r2, r1, #4
  200f8c:	6809      	ldr	r1, [r1, #0]
    if (mbp->rdptr >= mbp->top) {
  200f8e:	4282      	cmp	r2, r0
    *msgp = *mbp->rdptr++;
  200f90:	60e2      	str	r2, [r4, #12]
  200f92:	6029      	str	r1, [r5, #0]
    if (mbp->rdptr >= mbp->top) {
  200f94:	d301      	bcc.n	200f9a <chMBFetchI.constprop.20+0x2a>
      mbp->rdptr = mbp->buffer;
  200f96:	6822      	ldr	r2, [r4, #0]
  200f98:	60e2      	str	r2, [r4, #12]
    }
    mbp->cnt--;
  200f9a:	3b01      	subs	r3, #1

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
  200f9c:	4806      	ldr	r0, [pc, #24]	; (200fb8 <chMBFetchI.constprop.20+0x48>)
    mbp->cnt--;
  200f9e:	6123      	str	r3, [r4, #16]
    chThdDequeueNextI(&mbp->qw, MSG_OK);
  200fa0:	f7ff ffce 	bl	200f40 <chThdDequeueNextI.constprop.80>

    return MSG_OK;
  200fa4:	2000      	movs	r0, #0
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
}
  200fa6:	bd38      	pop	{r3, r4, r5, pc}
    return MSG_RESET;
  200fa8:	f06f 0001 	mvn.w	r0, #1
}
  200fac:	bd38      	pop	{r3, r4, r5, pc}
  return MSG_TIMEOUT;
  200fae:	f04f 30ff 	mov.w	r0, #4294967295
}
  200fb2:	bd38      	pop	{r3, r4, r5, pc}
  200fb4:	20010458 	.word	0x20010458
  200fb8:	20010470 	.word	0x20010470
  200fbc:	00000000 	.word	0x00000000

00200fc0 <chThdDequeueAllI.constprop.82>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
  200fc0:	b538      	push	{r3, r4, r5, lr}
  return (bool)(tqp->next != (const thread_t *)tqp);
  200fc2:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
  200fc4:	4298      	cmp	r0, r3
  200fc6:	d00a      	beq.n	200fde <chThdDequeueAllI.constprop.82+0x1e>
  tqp->next             = tp->queue.next;
  200fc8:	681a      	ldr	r2, [r3, #0]
  200fca:	4604      	mov	r4, r0
  200fcc:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  200fce:	6050      	str	r0, [r2, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
  200fd0:	f893 2020 	ldrb.w	r2, [r3, #32]
  200fd4:	2a04      	cmp	r2, #4
  200fd6:	d003      	beq.n	200fe0 <chThdDequeueAllI.constprop.82+0x20>
  200fd8:	480b      	ldr	r0, [pc, #44]	; (201008 <chThdDequeueAllI.constprop.82+0x48>)
  200fda:	f7ff fdc9 	bl	200b70 <chSysHalt>
    chThdDoDequeueNextI(tqp, msg);
  }
}
  200fde:	bd38      	pop	{r3, r4, r5, pc}
  tp->u.rdymsg = msg;
  200fe0:	f06f 0501 	mvn.w	r5, #1
  200fe4:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
  200fe6:	4618      	mov	r0, r3
  200fe8:	f7ff ff82 	bl	200ef0 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
  200fec:	6823      	ldr	r3, [r4, #0]
  while (queue_notempty(tqp)) {
  200fee:	429c      	cmp	r4, r3
  200ff0:	d0f5      	beq.n	200fde <chThdDequeueAllI.constprop.82+0x1e>
  tqp->next             = tp->queue.next;
  200ff2:	681a      	ldr	r2, [r3, #0]
  200ff4:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  200ff6:	6054      	str	r4, [r2, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
  200ff8:	f893 2020 	ldrb.w	r2, [r3, #32]
  200ffc:	2a04      	cmp	r2, #4
  200ffe:	d0f1      	beq.n	200fe4 <chThdDequeueAllI.constprop.82+0x24>
  201000:	4801      	ldr	r0, [pc, #4]	; (201008 <chThdDequeueAllI.constprop.82+0x48>)
  201002:	f7ff fdb5 	bl	200b70 <chSysHalt>
  201006:	bf00      	nop
  201008:	0800bd00 	.word	0x0800bd00
  20100c:	00000000 	.word	0x00000000

00201010 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
  201010:	b538      	push	{r3, r4, r5, lr}
  201012:	4604      	mov	r4, r0
  201014:	460d      	mov	r5, r1

  chDbgCheckClassI();
  201016:	f7ff febb 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
  20101a:	b1bc      	cbz	r4, 20104c <chEvtSignalI+0x3c>

  tp->epending |= events;
  20101c:	6b61      	ldr	r1, [r4, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
  20101e:	f894 3020 	ldrb.w	r3, [r4, #32]
  tp->epending |= events;
  201022:	4329      	orrs	r1, r5
  if (((tp->state == CH_STATE_WTOREVT) &&
  201024:	2b0a      	cmp	r3, #10
  tp->epending |= events;
  201026:	6361      	str	r1, [r4, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
  201028:	d00c      	beq.n	201044 <chEvtSignalI+0x34>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  20102a:	2b0b      	cmp	r3, #11
  20102c:	d000      	beq.n	201030 <chEvtSignalI+0x20>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
  20102e:	bd38      	pop	{r3, r4, r5, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
  201030:	6a63      	ldr	r3, [r4, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
  201032:	438b      	bics	r3, r1
  201034:	d1fb      	bne.n	20102e <chEvtSignalI+0x1e>
    tp->u.rdymsg = MSG_OK;
  201036:	2300      	movs	r3, #0
    (void) chSchReadyI(tp);
  201038:	4620      	mov	r0, r4
    tp->u.rdymsg = MSG_OK;
  20103a:	6263      	str	r3, [r4, #36]	; 0x24
}
  20103c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void) chSchReadyI(tp);
  201040:	f7ff bf56 	b.w	200ef0 <chSchReadyI>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  201044:	6a63      	ldr	r3, [r4, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
  201046:	4219      	tst	r1, r3
  201048:	d1f5      	bne.n	201036 <chEvtSignalI+0x26>
  20104a:	e7f0      	b.n	20102e <chEvtSignalI+0x1e>
  chDbgCheck(tp != NULL);
  20104c:	4801      	ldr	r0, [pc, #4]	; (201054 <chEvtSignalI+0x44>)
  20104e:	f7ff fd8f 	bl	200b70 <chSysHalt>
  201052:	bf00      	nop
  201054:	0800bf10 	.word	0x0800bf10
	...

00201060 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  201060:	b570      	push	{r4, r5, r6, lr}
  201062:	4606      	mov	r6, r0
  201064:	460d      	mov	r5, r1
  chDbgCheckClassI();
  201066:	f7ff fe93 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
  20106a:	b18e      	cbz	r6, 201090 <chEvtBroadcastFlagsI+0x30>
  elp = esp->next;
  20106c:	6834      	ldr	r4, [r6, #0]
  while (elp != (event_listener_t *)esp) {
  20106e:	42a6      	cmp	r6, r4
  201070:	d00d      	beq.n	20108e <chEvtBroadcastFlagsI+0x2e>
    elp->flags |= flags;
  201072:	68e3      	ldr	r3, [r4, #12]
  201074:	432b      	orrs	r3, r5
  201076:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
  201078:	b115      	cbz	r5, 201080 <chEvtBroadcastFlagsI+0x20>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
  20107a:	6922      	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
  20107c:	4213      	tst	r3, r2
  20107e:	d003      	beq.n	201088 <chEvtBroadcastFlagsI+0x28>
      chEvtSignalI(elp->listener, elp->events);
  201080:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
  201084:	f7ff ffc4 	bl	201010 <chEvtSignalI>
    elp = elp->next;
  201088:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
  20108a:	42a6      	cmp	r6, r4
  20108c:	d1f1      	bne.n	201072 <chEvtBroadcastFlagsI+0x12>
}
  20108e:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(esp != NULL);
  201090:	4801      	ldr	r0, [pc, #4]	; (201098 <chEvtBroadcastFlagsI+0x38>)
  201092:	f7ff fd6d 	bl	200b70 <chSysHalt>
  201096:	bf00      	nop
  201098:	0800be48 	.word	0x0800be48
  20109c:	00000000 	.word	0x00000000

002010a0 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  2010a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  thread_t *ctp = currp;
  2010a4:	4b1d      	ldr	r3, [pc, #116]	; (20111c <chMtxUnlockS+0x7c>)
void chMtxUnlockS(mutex_t *mp) {
  2010a6:	4605      	mov	r5, r0
  thread_t *ctp = currp;
  2010a8:	f8d3 8018 	ldr.w	r8, [r3, #24]
  mutex_t *lmp;

  chDbgCheckClassS();
  2010ac:	f7ff fe60 	bl	200d70 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
  2010b0:	b12d      	cbz	r5, 2010be <chMtxUnlockS+0x1e>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
  2010b2:	f8d8 6038 	ldr.w	r6, [r8, #56]	; 0x38
  2010b6:	b116      	cbz	r6, 2010be <chMtxUnlockS+0x1e>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
  2010b8:	68b3      	ldr	r3, [r6, #8]
  2010ba:	4543      	cmp	r3, r8
  2010bc:	d002      	beq.n	2010c4 <chMtxUnlockS+0x24>
  chDbgCheck(mp != NULL);
  2010be:	4818      	ldr	r0, [pc, #96]	; (201120 <chMtxUnlockS+0x80>)
  2010c0:	f7ff fd56 	bl	200b70 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
  2010c4:	42ae      	cmp	r6, r5
  2010c6:	d1fa      	bne.n	2010be <chMtxUnlockS+0x1e>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
  2010c8:	68ec      	ldr	r4, [r5, #12]
  2010ca:	f8c8 4038 	str.w	r4, [r8, #56]	; 0x38
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
  2010ce:	f7ff fe4f 	bl	200d70 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
  2010d2:	682f      	ldr	r7, [r5, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
  2010d4:	42bd      	cmp	r5, r7
  2010d6:	d01c      	beq.n	201112 <chMtxUnlockS+0x72>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
  2010d8:	f8d8 603c 	ldr.w	r6, [r8, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
  2010dc:	b15c      	cbz	r4, 2010f6 <chMtxUnlockS+0x56>
  2010de:	f7ff fe47 	bl	200d70 <chDbgCheckClassS>
  2010e2:	6823      	ldr	r3, [r4, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
  2010e4:	429c      	cmp	r4, r3
  2010e6:	d003      	beq.n	2010f0 <chMtxUnlockS+0x50>
  2010e8:	689b      	ldr	r3, [r3, #8]
  2010ea:	429e      	cmp	r6, r3
  2010ec:	bf38      	it	cc
  2010ee:	461e      	movcc	r6, r3
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
  2010f0:	68e4      	ldr	r4, [r4, #12]
      while (lmp != NULL) {
  2010f2:	2c00      	cmp	r4, #0
  2010f4:	d1f3      	bne.n	2010de <chMtxUnlockS+0x3e>
  tqp->next             = tp->queue.next;
  2010f6:	683b      	ldr	r3, [r7, #0]
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
  2010f8:	4638      	mov	r0, r7
      mp->next = tp->mtxlist;
  2010fa:	6bba      	ldr	r2, [r7, #56]	; 0x38
      ctp->prio = newprio;
  2010fc:	f8c8 6008 	str.w	r6, [r8, #8]
  201100:	602b      	str	r3, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  201102:	605d      	str	r5, [r3, #4]
      mp->next = tp->mtxlist;
  201104:	e9c5 7202 	strd	r7, r2, [r5, #8]
      tp->mtxlist = mp;
  201108:	63bd      	str	r5, [r7, #56]	; 0x38
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
  20110a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      (void) chSchReadyI(tp);
  20110e:	f7ff beef 	b.w	200ef0 <chSchReadyI>
      mp->owner = NULL;
  201112:	2300      	movs	r3, #0
  201114:	60b3      	str	r3, [r6, #8]
}
  201116:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  20111a:	bf00      	nop
  20111c:	20000dc8 	.word	0x20000dc8
  201120:	0800becc 	.word	0x0800becc
	...

00201130 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
  201130:	b510      	push	{r4, lr}
  201132:	4604      	mov	r4, r0

  chDbgCheckClassI();
  201134:	f7ff fe2c 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
  201138:	b12c      	cbz	r4, 201146 <chSemSignalI+0x16>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  20113a:	68a3      	ldr	r3, [r4, #8]
  20113c:	6822      	ldr	r2, [r4, #0]
  20113e:	2b00      	cmp	r3, #0
  201140:	db04      	blt.n	20114c <chSemSignalI+0x1c>
  201142:	42a2      	cmp	r2, r4
  201144:	d004      	beq.n	201150 <chSemSignalI+0x20>
  chDbgCheck(sp != NULL);
  201146:	480a      	ldr	r0, [pc, #40]	; (201170 <chSemSignalI+0x40>)
  201148:	f7ff fd12 	bl	200b70 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  20114c:	42a2      	cmp	r2, r4
  20114e:	d0fa      	beq.n	201146 <chSemSignalI+0x16>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
  201150:	3301      	adds	r3, #1
  201152:	2b00      	cmp	r3, #0
  201154:	60a3      	str	r3, [r4, #8]
  201156:	dd00      	ble.n	20115a <chSemSignalI+0x2a>
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
  201158:	bd10      	pop	{r4, pc}
  tqp->next             = tp->queue.next;
  20115a:	6813      	ldr	r3, [r2, #0]
    tp->u.rdymsg = MSG_OK;
  20115c:	2100      	movs	r1, #0
    (void) chSchReadyI(tp);
  20115e:	4610      	mov	r0, r2
  201160:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  201162:	605c      	str	r4, [r3, #4]
    tp->u.rdymsg = MSG_OK;
  201164:	6251      	str	r1, [r2, #36]	; 0x24
}
  201166:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    (void) chSchReadyI(tp);
  20116a:	f7ff bec1 	b.w	200ef0 <chSchReadyI>
  20116e:	bf00      	nop
  201170:	0800beac 	.word	0x0800beac
	...

00201180 <chSysIntegrityCheckI>:
bool chSysIntegrityCheckI(unsigned testmask) {
  201180:	b510      	push	{r4, lr}
  201182:	4604      	mov	r4, r0
  chDbgCheckClassI();
  201184:	f7ff fe04 	bl	200d90 <chDbgCheckClassI>
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
  201188:	07e2      	lsls	r2, r4, #31
  20118a:	d510      	bpl.n	2011ae <chSysIntegrityCheckI+0x2e>
    tp = ch.rlist.queue.next;
  20118c:	4b24      	ldr	r3, [pc, #144]	; (201220 <chSysIntegrityCheckI+0xa0>)
  20118e:	e9d3 1000 	ldrd	r1, r0, [r3]
    while (tp != (thread_t *)&ch.rlist.queue) {
  201192:	4299      	cmp	r1, r3
  201194:	d039      	beq.n	20120a <chSysIntegrityCheckI+0x8a>
    n = (cnt_t)0;
  201196:	2200      	movs	r2, #0
      tp = tp->queue.next;
  201198:	6809      	ldr	r1, [r1, #0]
      n++;
  20119a:	3201      	adds	r2, #1
    while (tp != (thread_t *)&ch.rlist.queue) {
  20119c:	4299      	cmp	r1, r3
  20119e:	d1fb      	bne.n	201198 <chSysIntegrityCheckI+0x18>
    while (tp != (thread_t *)&ch.rlist.queue) {
  2011a0:	4288      	cmp	r0, r1
  2011a2:	d030      	beq.n	201206 <chSysIntegrityCheckI+0x86>
      tp = tp->queue.prev;
  2011a4:	6840      	ldr	r0, [r0, #4]
      n--;
  2011a6:	3a01      	subs	r2, #1
    while (tp != (thread_t *)&ch.rlist.queue) {
  2011a8:	4298      	cmp	r0, r3
  2011aa:	d1fb      	bne.n	2011a4 <chSysIntegrityCheckI+0x24>
    if (n != (cnt_t)0) {
  2011ac:	bb5a      	cbnz	r2, 201206 <chSysIntegrityCheckI+0x86>
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
  2011ae:	07a3      	lsls	r3, r4, #30
  2011b0:	d512      	bpl.n	2011d8 <chSysIntegrityCheckI+0x58>
    vtp = ch.vtlist.next;
  2011b2:	4b1b      	ldr	r3, [pc, #108]	; (201220 <chSysIntegrityCheckI+0xa0>)
  2011b4:	69da      	ldr	r2, [r3, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
  2011b6:	f103 001c 	add.w	r0, r3, #28
  2011ba:	6a19      	ldr	r1, [r3, #32]
  2011bc:	4282      	cmp	r2, r0
  2011be:	d028      	beq.n	201212 <chSysIntegrityCheckI+0x92>
    n = (cnt_t)0;
  2011c0:	2300      	movs	r3, #0
      vtp = vtp->next;
  2011c2:	6812      	ldr	r2, [r2, #0]
      n++;
  2011c4:	3301      	adds	r3, #1
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
  2011c6:	4282      	cmp	r2, r0
  2011c8:	d1fb      	bne.n	2011c2 <chSysIntegrityCheckI+0x42>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
  2011ca:	4291      	cmp	r1, r2
  2011cc:	d01b      	beq.n	201206 <chSysIntegrityCheckI+0x86>
      vtp = vtp->prev;
  2011ce:	6849      	ldr	r1, [r1, #4]
      n--;
  2011d0:	3b01      	subs	r3, #1
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
  2011d2:	4281      	cmp	r1, r0
  2011d4:	d1fb      	bne.n	2011ce <chSysIntegrityCheckI+0x4e>
    if (n != (cnt_t)0) {
  2011d6:	b9b3      	cbnz	r3, 201206 <chSysIntegrityCheckI+0x86>
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
  2011d8:	f014 0004 	ands.w	r0, r4, #4
  2011dc:	d012      	beq.n	201204 <chSysIntegrityCheckI+0x84>
    tp = ch.rlist.newer;
  2011de:	4b10      	ldr	r3, [pc, #64]	; (201220 <chSysIntegrityCheckI+0xa0>)
    n = (cnt_t)0;
  2011e0:	2000      	movs	r0, #0
  2011e2:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
    while (tp != (thread_t *)&ch.rlist) {
  2011e6:	429a      	cmp	r2, r3
  2011e8:	d017      	beq.n	20121a <chSysIntegrityCheckI+0x9a>
      tp = tp->newer;
  2011ea:	6912      	ldr	r2, [r2, #16]
      n++;
  2011ec:	3001      	adds	r0, #1
    while (tp != (thread_t *)&ch.rlist) {
  2011ee:	429a      	cmp	r2, r3
  2011f0:	d1fb      	bne.n	2011ea <chSysIntegrityCheckI+0x6a>
    while (tp != (thread_t *)&ch.rlist) {
  2011f2:	4291      	cmp	r1, r2
  2011f4:	d007      	beq.n	201206 <chSysIntegrityCheckI+0x86>
      tp = tp->older;
  2011f6:	6949      	ldr	r1, [r1, #20]
      n--;
  2011f8:	3801      	subs	r0, #1
    while (tp != (thread_t *)&ch.rlist) {
  2011fa:	4299      	cmp	r1, r3
  2011fc:	d1fb      	bne.n	2011f6 <chSysIntegrityCheckI+0x76>
    if (n != (cnt_t)0) {
  2011fe:	3000      	adds	r0, #0
  201200:	bf18      	it	ne
  201202:	2001      	movne	r0, #1
}
  201204:	bd10      	pop	{r4, pc}
      return true;
  201206:	2001      	movs	r0, #1
}
  201208:	bd10      	pop	{r4, pc}
    while (tp != (thread_t *)&ch.rlist.queue) {
  20120a:	4298      	cmp	r0, r3
  20120c:	d0cf      	beq.n	2011ae <chSysIntegrityCheckI+0x2e>
    n = (cnt_t)0;
  20120e:	2200      	movs	r2, #0
  201210:	e7c8      	b.n	2011a4 <chSysIntegrityCheckI+0x24>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
  201212:	4281      	cmp	r1, r0
  201214:	d0e0      	beq.n	2011d8 <chSysIntegrityCheckI+0x58>
    n = (cnt_t)0;
  201216:	2300      	movs	r3, #0
  201218:	e7d9      	b.n	2011ce <chSysIntegrityCheckI+0x4e>
    while (tp != (thread_t *)&ch.rlist) {
  20121a:	4291      	cmp	r1, r2
  20121c:	d1eb      	bne.n	2011f6 <chSysIntegrityCheckI+0x76>
}
  20121e:	bd10      	pop	{r4, pc}
  201220:	20000dc8 	.word	0x20000dc8
	...

00201230 <_dbg_check_leave_isr>:
void _dbg_check_leave_isr(void) {
  201230:	b508      	push	{r3, lr}
  201232:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201234:	2320      	movs	r3, #32
  201236:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20123a:	b662      	cpsie	i
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
  20123c:	4a06      	ldr	r2, [pc, #24]	; (201258 <_dbg_check_leave_isr+0x28>)
  20123e:	6b13      	ldr	r3, [r2, #48]	; 0x30
  201240:	2b00      	cmp	r3, #0
  201242:	dd01      	ble.n	201248 <_dbg_check_leave_isr+0x18>
  201244:	6b51      	ldr	r1, [r2, #52]	; 0x34
  201246:	b111      	cbz	r1, 20124e <_dbg_check_leave_isr+0x1e>
    chSysHalt("SV#9");
  201248:	4804      	ldr	r0, [pc, #16]	; (20125c <_dbg_check_leave_isr+0x2c>)
  20124a:	f7ff fc91 	bl	200b70 <chSysHalt>
  ch.dbg.isr_cnt--;
  20124e:	3b01      	subs	r3, #1
  201250:	6313      	str	r3, [r2, #48]	; 0x30
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201252:	f381 8811 	msr	BASEPRI, r1
}
  201256:	bd08      	pop	{r3, pc}
  201258:	20000dc8 	.word	0x20000dc8
  20125c:	0800c1a8 	.word	0x0800c1a8

00201260 <_dbg_check_enter_isr>:
void _dbg_check_enter_isr(void) {
  201260:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  201262:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201264:	2320      	movs	r3, #32
  201266:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20126a:	b662      	cpsie	i
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
  20126c:	4a06      	ldr	r2, [pc, #24]	; (201288 <_dbg_check_enter_isr+0x28>)
  20126e:	6b13      	ldr	r3, [r2, #48]	; 0x30
  201270:	2b00      	cmp	r3, #0
  201272:	db01      	blt.n	201278 <_dbg_check_enter_isr+0x18>
  201274:	6b51      	ldr	r1, [r2, #52]	; 0x34
  201276:	b111      	cbz	r1, 20127e <_dbg_check_enter_isr+0x1e>
    chSysHalt("SV#8");
  201278:	4804      	ldr	r0, [pc, #16]	; (20128c <_dbg_check_enter_isr+0x2c>)
  20127a:	f7ff fc79 	bl	200b70 <chSysHalt>
  ch.dbg.isr_cnt++;
  20127e:	3301      	adds	r3, #1
  201280:	6313      	str	r3, [r2, #48]	; 0x30
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201282:	f381 8811 	msr	BASEPRI, r1
}
  201286:	bd08      	pop	{r3, pc}
  201288:	20000dc8 	.word	0x20000dc8
  20128c:	0800c1a0 	.word	0x0800c1a0

00201290 <_dbg_check_unlock_from_isr>:
void _dbg_check_unlock_from_isr(void) {
  201290:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
  201292:	4b06      	ldr	r3, [pc, #24]	; (2012ac <_dbg_check_unlock_from_isr+0x1c>)
  201294:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  201296:	2a00      	cmp	r2, #0
  201298:	dd05      	ble.n	2012a6 <_dbg_check_unlock_from_isr+0x16>
  20129a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  20129c:	2a00      	cmp	r2, #0
  20129e:	dd02      	ble.n	2012a6 <_dbg_check_unlock_from_isr+0x16>
  _dbg_leave_lock();
  2012a0:	2200      	movs	r2, #0
  2012a2:	635a      	str	r2, [r3, #52]	; 0x34
}
  2012a4:	bd08      	pop	{r3, pc}
    chSysHalt("SV#7");
  2012a6:	4802      	ldr	r0, [pc, #8]	; (2012b0 <_dbg_check_unlock_from_isr+0x20>)
  2012a8:	f7ff fc62 	bl	200b70 <chSysHalt>
  2012ac:	20000dc8 	.word	0x20000dc8
  2012b0:	0800c1d0 	.word	0x0800c1d0
	...

002012c0 <_dbg_check_lock_from_isr>:
void _dbg_check_lock_from_isr(void) {
  2012c0:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
  2012c2:	4b06      	ldr	r3, [pc, #24]	; (2012dc <_dbg_check_lock_from_isr+0x1c>)
  2012c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  2012c6:	2a00      	cmp	r2, #0
  2012c8:	dd01      	ble.n	2012ce <_dbg_check_lock_from_isr+0xe>
  2012ca:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  2012cc:	b112      	cbz	r2, 2012d4 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
  2012ce:	4804      	ldr	r0, [pc, #16]	; (2012e0 <_dbg_check_lock_from_isr+0x20>)
  2012d0:	f7ff fc4e 	bl	200b70 <chSysHalt>
  _dbg_enter_lock();
  2012d4:	2201      	movs	r2, #1
  2012d6:	635a      	str	r2, [r3, #52]	; 0x34
}
  2012d8:	bd08      	pop	{r3, pc}
  2012da:	bf00      	nop
  2012dc:	20000dc8 	.word	0x20000dc8
  2012e0:	0800c1b8 	.word	0x0800c1b8
	...

002012f0 <wakeup>:
static void wakeup(void *p) {
  2012f0:	b538      	push	{r3, r4, r5, lr}
  2012f2:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  2012f4:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2012f6:	2320      	movs	r3, #32
  2012f8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2012fc:	b662      	cpsie	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
  2012fe:	f7ff ffdf 	bl	2012c0 <_dbg_check_lock_from_isr>
  switch (tp->state) {
  201302:	f894 3020 	ldrb.w	r3, [r4, #32]
  201306:	2b07      	cmp	r3, #7
  201308:	d810      	bhi.n	20132c <wakeup+0x3c>
  20130a:	e8df f003 	tbb	[pc, r3]
  20130e:	0f15      	.short	0x0f15
  201310:	040a1b0f 	.word	0x040a1b0f
  201314:	0a0f      	.short	0x0a0f
    chSemFastSignalI(tp->u.wtsemp);
  201316:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
  201318:	f7ff fd3a 	bl	200d90 <chDbgCheckClassI>

  sp->cnt++;
  20131c:	68ab      	ldr	r3, [r5, #8]
  20131e:	3301      	adds	r3, #1
  201320:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
  201322:	e9d4 2300 	ldrd	r2, r3, [r4]
  201326:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  201328:	6822      	ldr	r2, [r4, #0]
  20132a:	6053      	str	r3, [r2, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
  20132c:	f04f 33ff 	mov.w	r3, #4294967295
  (void) chSchReadyI(tp);
  201330:	4620      	mov	r0, r4
  tp->u.rdymsg = MSG_TIMEOUT;
  201332:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
  201334:	f7ff fddc 	bl	200ef0 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
  201338:	f7ff ffaa 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20133c:	2300      	movs	r3, #0
  20133e:	f383 8811 	msr	BASEPRI, r3
}
  201342:	bd38      	pop	{r3, r4, r5, pc}
    *tp->u.wttrp = NULL;
  201344:	6a63      	ldr	r3, [r4, #36]	; 0x24
  201346:	2200      	movs	r2, #0
  (void) chSchReadyI(tp);
  201348:	4620      	mov	r0, r4
    *tp->u.wttrp = NULL;
  20134a:	601a      	str	r2, [r3, #0]
  tp->u.rdymsg = MSG_TIMEOUT;
  20134c:	f04f 33ff 	mov.w	r3, #4294967295
  201350:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
  201352:	f7ff fdcd 	bl	200ef0 <chSchReadyI>
  201356:	e7ef      	b.n	201338 <wakeup+0x48>
	...

00201360 <_dbg_check_enable>:
void _dbg_check_enable(void) {
  201360:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
  201362:	4b04      	ldr	r3, [pc, #16]	; (201374 <_dbg_check_enable+0x14>)
  201364:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  201366:	b90a      	cbnz	r2, 20136c <_dbg_check_enable+0xc>
  201368:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  20136a:	b113      	cbz	r3, 201372 <_dbg_check_enable+0x12>
    chSysHalt("SV#3");
  20136c:	4802      	ldr	r0, [pc, #8]	; (201378 <_dbg_check_enable+0x18>)
  20136e:	f7ff fbff 	bl	200b70 <chSysHalt>
}
  201372:	bd08      	pop	{r3, pc}
  201374:	20000dc8 	.word	0x20000dc8
  201378:	0800c198 	.word	0x0800c198
  20137c:	00000000 	.word	0x00000000

00201380 <_dbg_check_suspend>:
void _dbg_check_suspend(void) {
  201380:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
  201382:	4b04      	ldr	r3, [pc, #16]	; (201394 <_dbg_check_suspend+0x14>)
  201384:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  201386:	b90a      	cbnz	r2, 20138c <_dbg_check_suspend+0xc>
  201388:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  20138a:	b113      	cbz	r3, 201392 <_dbg_check_suspend+0x12>
    chSysHalt("SV#2");
  20138c:	4802      	ldr	r0, [pc, #8]	; (201398 <_dbg_check_suspend+0x18>)
  20138e:	f7ff fbef 	bl	200b70 <chSysHalt>
}
  201392:	bd08      	pop	{r3, pc}
  201394:	20000dc8 	.word	0x20000dc8
  201398:	0800c1c0 	.word	0x0800c1c0
  20139c:	00000000 	.word	0x00000000

002013a0 <rt_test_002_003_execute>:
static void rt_test_002_003_execute(void) {
  2013a0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
  2013a2:	2201      	movs	r2, #1
  2013a4:	4b0d      	ldr	r3, [pc, #52]	; (2013dc <rt_test_002_003_execute+0x3c>)
  2013a6:	2420      	movs	r4, #32
  2013a8:	601a      	str	r2, [r3, #0]
  2013aa:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
  2013ae:	b662      	cpsie	i
  _dbg_check_suspend();
  2013b0:	f7ff ffe6 	bl	201380 <_dbg_check_suspend>
  __ASM volatile ("cpsid i" : : : "memory");
  2013b4:	b672      	cpsid	i
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
  2013b6:	4b0a      	ldr	r3, [pc, #40]	; (2013e0 <rt_test_002_003_execute+0x40>)
  2013b8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  2013ba:	b90a      	cbnz	r2, 2013c0 <rt_test_002_003_execute+0x20>
  2013bc:	6b5d      	ldr	r5, [r3, #52]	; 0x34
  2013be:	b115      	cbz	r5, 2013c6 <rt_test_002_003_execute+0x26>
    chSysHalt("SV#1");
  2013c0:	4808      	ldr	r0, [pc, #32]	; (2013e4 <rt_test_002_003_execute+0x44>)
  2013c2:	f7ff fbd5 	bl	200b70 <chSysHalt>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2013c6:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
  2013ca:	b662      	cpsie	i
  2013cc:	f7ff ffd8 	bl	201380 <_dbg_check_suspend>
  _dbg_check_enable();
  2013d0:	f7ff ffc6 	bl	201360 <_dbg_check_enable>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2013d4:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  2013d8:	b662      	cpsie	i
}
  2013da:	bd38      	pop	{r3, r4, r5, pc}
  2013dc:	20001f6c 	.word	0x20001f6c
  2013e0:	20000dc8 	.word	0x20000dc8
  2013e4:	0800d4dc 	.word	0x0800d4dc
	...

002013f0 <_idle_thread>:
static void _idle_thread(void *p) {
  2013f0:	e7fe      	b.n	2013f0 <_idle_thread>
  2013f2:	bf00      	nop
	...

00201400 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
  201400:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  201404:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
  201408:	68d8      	ldr	r0, [r3, #12]
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  20140a:	b4f0      	push	{r4, r5, r6, r7}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
  20140c:	6944      	ldr	r4, [r0, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  20140e:	6823      	ldr	r3, [r4, #0]
  201410:	60e3      	str	r3, [r4, #12]
  if (isp->txsize == 0) {
  201412:	b9eb      	cbnz	r3, 201450 <usb_lld_start_in+0x50>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  201414:	eb02 1341 	add.w	r3, r2, r1, lsl #5
  201418:	f44f 2400 	mov.w	r4, #524288	; 0x80000
  20141c:	f8c3 4910 	str.w	r4, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  201420:	6803      	ldr	r3, [r0, #0]
  201422:	f003 0303 	and.w	r3, r3, #3
  201426:	2b01      	cmp	r3, #1
  201428:	d027      	beq.n	20147a <usb_lld_start_in+0x7a>
  20142a:	b208      	sxth	r0, r1
  20142c:	eb02 1040 	add.w	r0, r2, r0, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  201430:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  201432:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  201436:	fa03 f101 	lsl.w	r1, r3, r1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  20143a:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
  20143e:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  201442:	f8d2 3834 	ldr.w	r3, [r2, #2100]	; 0x834
  201446:	4319      	orrs	r1, r3
}
  201448:	bcf0      	pop	{r4, r5, r6, r7}
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  20144a:	f8c2 1834 	str.w	r1, [r2, #2100]	; 0x834
}
  20144e:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
  201450:	b909      	cbnz	r1, 201456 <usb_lld_start_in+0x56>
  201452:	2b40      	cmp	r3, #64	; 0x40
  201454:	d822      	bhi.n	20149c <usb_lld_start_in+0x9c>
  201456:	f043 5600 	orr.w	r6, r3, #536870912	; 0x20000000
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
  20145a:	8a07      	ldrh	r7, [r0, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
  20145c:	eb02 1541 	add.w	r5, r2, r1, lsl #5
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
  201460:	1e7c      	subs	r4, r7, #1
  201462:	4423      	add	r3, r4
  201464:	fbb3 f3f7 	udiv	r3, r3, r7
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
  201468:	ea46 43c3 	orr.w	r3, r6, r3, lsl #19
  20146c:	f8c5 3910 	str.w	r3, [r5, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  201470:	6803      	ldr	r3, [r0, #0]
  201472:	f003 0303 	and.w	r3, r3, #3
  201476:	2b01      	cmp	r3, #1
  201478:	d1d7      	bne.n	20142a <usb_lld_start_in+0x2a>
  20147a:	b208      	sxth	r0, r1
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
  20147c:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
  201480:	eb02 1440 	add.w	r4, r2, r0, lsl #5
  201484:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
  201488:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
  20148c:	bf14      	ite	ne
  20148e:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  201492:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
  201496:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
  20149a:	e7c7      	b.n	20142c <usb_lld_start_in+0x2c>
      isp->txsize = EP0_MAX_INSIZE;
  20149c:	2340      	movs	r3, #64	; 0x40
  20149e:	4e01      	ldr	r6, [pc, #4]	; (2014a4 <usb_lld_start_in+0xa4>)
  2014a0:	6023      	str	r3, [r4, #0]
  2014a2:	e7da      	b.n	20145a <usb_lld_start_in+0x5a>
  2014a4:	20000040 	.word	0x20000040
	...

002014b0 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
  2014b0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  2014b4:	b470      	push	{r4, r5, r6}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
  2014b6:	68dc      	ldr	r4, [r3, #12]
  2014b8:	69a3      	ldr	r3, [r4, #24]
  osp->totsize = osp->rxsize;
  2014ba:	681e      	ldr	r6, [r3, #0]
  2014bc:	60de      	str	r6, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
  2014be:	b909      	cbnz	r1, 2014c4 <usb_lld_start_out+0x14>
  2014c0:	2e40      	cmp	r6, #64	; 0x40
  2014c2:	d824      	bhi.n	20150e <usb_lld_start_out+0x5e>
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  2014c4:	8a63      	ldrh	r3, [r4, #18]
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  2014c6:	6824      	ldr	r4, [r4, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  2014c8:	1e5a      	subs	r2, r3, #1
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  2014ca:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  2014ce:	f004 0403 	and.w	r4, r4, #3
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  2014d2:	4432      	add	r2, r6
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  2014d4:	eb00 1541 	add.w	r5, r0, r1, lsl #5
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  2014d8:	2c01      	cmp	r4, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  2014da:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
  2014de:	fb02 f303 	mul.w	r3, r2, r3
  2014e2:	f103 0303 	add.w	r3, r3, #3
  2014e6:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  2014ea:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
  2014ee:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
  2014f2:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  2014f6:	d00e      	beq.n	201516 <usb_lld_start_out+0x66>
  2014f8:	b209      	sxth	r1, r1
  2014fa:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
  2014fe:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
  201502:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
}
  201506:	bc70      	pop	{r4, r5, r6}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
  201508:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
  20150c:	4770      	bx	lr
      osp->rxsize = EP0_MAX_OUTSIZE;
  20150e:	2240      	movs	r2, #64	; 0x40
  201510:	4616      	mov	r6, r2
  201512:	601a      	str	r2, [r3, #0]
  201514:	e7d6      	b.n	2014c4 <usb_lld_start_out+0x14>
  201516:	b209      	sxth	r1, r1
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
  201518:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
  20151c:	eb00 1241 	add.w	r2, r0, r1, lsl #5
  201520:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
  201524:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  201528:	bf14      	ite	ne
  20152a:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  20152e:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
  201532:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  201536:	e7e0      	b.n	2014fa <usb_lld_start_out+0x4a>
	...

00201540 <otg_epout_handler>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
  201540:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
  201544:	f8d0 7090 	ldr.w	r7, [r0, #144]	; 0x90
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
  201548:	4606      	mov	r6, r0
  20154a:	460d      	mov	r5, r1
  uint32_t epint = otgp->oe[ep].DOEPINT;
  20154c:	eb07 1341 	add.w	r3, r7, r1, lsl #5
  201550:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
  201554:	0722      	lsls	r2, r4, #28
  otgp->oe[ep].DOEPINT = epint;
  201556:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
  20155a:	d508      	bpl.n	20156e <otg_epout_handler+0x2e>
  20155c:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
  201560:	071b      	lsls	r3, r3, #28
  201562:	d504      	bpl.n	20156e <otg_epout_handler+0x2e>
    _usb_isr_invoke_setup_cb(usbp, ep);
  201564:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  201568:	68db      	ldr	r3, [r3, #12]
  20156a:	685b      	ldr	r3, [r3, #4]
  20156c:	4798      	blx	r3
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
  20156e:	07e2      	lsls	r2, r4, #31
  201570:	d533      	bpl.n	2015da <otg_epout_handler+0x9a>
  201572:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
  201576:	07db      	lsls	r3, r3, #31
  201578:	d52f      	bpl.n	2015da <otg_epout_handler+0x9a>
    osp = usbp->epc[ep]->out_state;
  20157a:	eb06 0385 	add.w	r3, r6, r5, lsl #2
  20157e:	68d9      	ldr	r1, [r3, #12]
    if (ep == 0) {
  201580:	b95d      	cbnz	r5, 20159a <otg_epout_handler+0x5a>
    osp = usbp->epc[ep]->out_state;
  201582:	698a      	ldr	r2, [r1, #24]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
  201584:	8a48      	ldrh	r0, [r1, #18]
  201586:	6854      	ldr	r4, [r2, #4]
  201588:	fbb4 f3f0 	udiv	r3, r4, r0
  20158c:	fb00 4313 	mls	r3, r0, r3, r4
  201590:	b91b      	cbnz	r3, 20159a <otg_epout_handler+0x5a>
          (osp->rxsize < osp->totsize)) {
  201592:	6810      	ldr	r0, [r2, #0]
  201594:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
  201596:	4298      	cmp	r0, r3
  201598:	d30d      	bcc.n	2015b6 <otg_epout_handler+0x76>
    _usb_isr_invoke_out_cb(usbp, ep);
  20159a:	2201      	movs	r2, #1
  20159c:	8973      	ldrh	r3, [r6, #10]
  20159e:	68cc      	ldr	r4, [r1, #12]
  2015a0:	40aa      	lsls	r2, r5
  2015a2:	ea23 0302 	bic.w	r3, r3, r2
  2015a6:	8173      	strh	r3, [r6, #10]
  2015a8:	b1bc      	cbz	r4, 2015da <otg_epout_handler+0x9a>
  2015aa:	4629      	mov	r1, r5
  2015ac:	4630      	mov	r0, r6
  2015ae:	4623      	mov	r3, r4
}
  2015b0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
  2015b4:	4718      	bx	r3
        osp->rxsize = osp->totsize - osp->rxsize;
  2015b6:	1a1b      	subs	r3, r3, r0
  2015b8:	e9c2 3500 	strd	r3, r5, [r2]
  __ASM volatile ("cpsid i" : : : "memory");
  2015bc:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2015be:	2320      	movs	r3, #32
  2015c0:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2015c4:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  2015c6:	f7ff fe7b 	bl	2012c0 <_dbg_check_lock_from_isr>
        usb_lld_start_out(usbp, ep);
  2015ca:	4629      	mov	r1, r5
  2015cc:	4630      	mov	r0, r6
  2015ce:	f7ff ff6f 	bl	2014b0 <usb_lld_start_out>
  _dbg_check_unlock_from_isr();
  2015d2:	f7ff fe5d 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2015d6:	f385 8811 	msr	BASEPRI, r5
}
  2015da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  2015de:	bf00      	nop

002015e0 <otg_txfifo_handler>:
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2015e0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  2015e4:	68db      	ldr	r3, [r3, #12]
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
  2015e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2015ea:	695f      	ldr	r7, [r3, #20]
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
  2015ec:	468e      	mov	lr, r1
  2015ee:	f8d0 8090 	ldr.w	r8, [r0, #144]	; 0x90
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2015f2:	e9d7 2400 	ldrd	r2, r4, [r7]
  2015f6:	42a2      	cmp	r2, r4
  2015f8:	d92e      	bls.n	201658 <otg_txfifo_handler+0x78>
  2015fa:	1c4d      	adds	r5, r1, #1
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  2015fc:	eb08 1c4e 	add.w	ip, r8, lr, lsl #5
    if (n > usbp->epc[ep]->in_maxsize)
  201600:	8a19      	ldrh	r1, [r3, #16]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
  201602:	eb08 3505 	add.w	r5, r8, r5, lsl #12
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
  201606:	1b14      	subs	r4, r2, r4
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  201608:	f8dc 3918 	ldr.w	r3, [ip, #2328]	; 0x918
    if (n > usbp->epc[ep]->in_maxsize)
  20160c:	42a1      	cmp	r1, r4
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  20160e:	b29b      	uxth	r3, r3
    if (n > usbp->epc[ep]->in_maxsize)
  201610:	d207      	bcs.n	201622 <otg_txfifo_handler+0x42>
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  201612:	ebb1 0f83 	cmp.w	r1, r3, lsl #2
  201616:	d82c      	bhi.n	201672 <otg_txfifo_handler+0x92>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
  201618:	68be      	ldr	r6, [r7, #8]
  osalDbgAssert(n > 0, "is zero");
  20161a:	bb41      	cbnz	r1, 20166e <otg_txfifo_handler+0x8e>
  20161c:	4816      	ldr	r0, [pc, #88]	; (201678 <otg_txfifo_handler+0x98>)
  20161e:	f7ff faa7 	bl	200b70 <chSysHalt>
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  201622:	ebb4 0f83 	cmp.w	r4, r3, lsl #2
  201626:	d824      	bhi.n	201672 <otg_txfifo_handler+0x92>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
  201628:	68be      	ldr	r6, [r7, #8]
    *fifop = *((uint32_t *)buf);
  20162a:	6833      	ldr	r3, [r6, #0]
    if (n <= 4) {
  20162c:	2c04      	cmp	r4, #4
    *fifop = *((uint32_t *)buf);
  20162e:	602b      	str	r3, [r5, #0]
    if (n <= 4) {
  201630:	d90a      	bls.n	201648 <otg_txfifo_handler+0x68>
  201632:	1f60      	subs	r0, r4, #5
  201634:	4633      	mov	r3, r6
  201636:	f020 0003 	bic.w	r0, r0, #3
  20163a:	3004      	adds	r0, #4
  20163c:	4430      	add	r0, r6
    *fifop = *((uint32_t *)buf);
  20163e:	f853 2f04 	ldr.w	r2, [r3, #4]!
    if (n <= 4) {
  201642:	4298      	cmp	r0, r3
    *fifop = *((uint32_t *)buf);
  201644:	602a      	str	r2, [r5, #0]
    if (n <= 4) {
  201646:	d1fa      	bne.n	20163e <otg_txfifo_handler+0x5e>
    usbp->epc[ep]->in_state->txcnt += n;
  201648:	687b      	ldr	r3, [r7, #4]
    usbp->epc[ep]->in_state->txbuf += n;
  20164a:	4426      	add	r6, r4
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  20164c:	683a      	ldr	r2, [r7, #0]
    usbp->epc[ep]->in_state->txcnt += n;
  20164e:	441c      	add	r4, r3
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  201650:	42a2      	cmp	r2, r4
    usbp->epc[ep]->in_state->txcnt += n;
  201652:	e9c7 4601 	strd	r4, r6, [r7, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  201656:	d8d6      	bhi.n	201606 <otg_txfifo_handler+0x26>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
  201658:	2001      	movs	r0, #1
  20165a:	f8d8 3834 	ldr.w	r3, [r8, #2100]	; 0x834
  20165e:	fa00 fe0e 	lsl.w	lr, r0, lr
  201662:	ea23 030e 	bic.w	r3, r3, lr
  201666:	f8c8 3834 	str.w	r3, [r8, #2100]	; 0x834
}
  20166a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
  20166e:	460c      	mov	r4, r1
  201670:	e7db      	b.n	20162a <otg_txfifo_handler+0x4a>
      return false;
  201672:	2000      	movs	r0, #0
}
  201674:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  201678:	0800c0a0 	.word	0x0800c0a0
  20167c:	00000000 	.word	0x00000000

00201680 <otg_epin_handler>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
  201680:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
  201684:	f8d0 6090 	ldr.w	r6, [r0, #144]	; 0x90
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
  201688:	4607      	mov	r7, r0
  20168a:	460d      	mov	r5, r1
  uint32_t epint = otgp->ie[ep].DIEPINT;
  20168c:	eb06 1341 	add.w	r3, r6, r1, lsl #5
  201690:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908
  otgp->ie[ep].DIEPINT = epint;
  201694:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
  201698:	07e3      	lsls	r3, r4, #31
  20169a:	d503      	bpl.n	2016a4 <otg_epin_handler+0x24>
  20169c:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
  2016a0:	07da      	lsls	r2, r3, #31
  2016a2:	d409      	bmi.n	2016b8 <otg_epin_handler+0x38>
  if ((epint & DIEPINT_TXFE) &&
  2016a4:	0623      	lsls	r3, r4, #24
  2016a6:	d505      	bpl.n	2016b4 <otg_epin_handler+0x34>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
  2016a8:	2301      	movs	r3, #1
  2016aa:	f8d6 2834 	ldr.w	r2, [r6, #2100]	; 0x834
  2016ae:	40ab      	lsls	r3, r5
  if ((epint & DIEPINT_TXFE) &&
  2016b0:	4213      	tst	r3, r2
  2016b2:	d119      	bne.n	2016e8 <otg_epin_handler+0x68>
}
  2016b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
  2016b8:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  2016bc:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  2016c0:	f8dc 3014 	ldr.w	r3, [ip, #20]
    if (isp->txsize < isp->totsize) {
  2016c4:	f8d3 e000 	ldr.w	lr, [r3]
  2016c8:	68da      	ldr	r2, [r3, #12]
  2016ca:	4596      	cmp	lr, r2
  2016cc:	d312      	bcc.n	2016f4 <otg_epin_handler+0x74>
      _usb_isr_invoke_in_cb(usbp, ep);
  2016ce:	2201      	movs	r2, #1
  2016d0:	8903      	ldrh	r3, [r0, #8]
  2016d2:	f8dc 8008 	ldr.w	r8, [ip, #8]
  2016d6:	408a      	lsls	r2, r1
  2016d8:	ea23 0302 	bic.w	r3, r3, r2
  2016dc:	8103      	strh	r3, [r0, #8]
  2016de:	f1b8 0f00 	cmp.w	r8, #0
  2016e2:	d0df      	beq.n	2016a4 <otg_epin_handler+0x24>
  2016e4:	47c0      	blx	r8
  2016e6:	e7dd      	b.n	2016a4 <otg_epin_handler+0x24>
    otg_txfifo_handler(usbp, ep);
  2016e8:	4629      	mov	r1, r5
  2016ea:	4638      	mov	r0, r7
}
  2016ec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    otg_txfifo_handler(usbp, ep);
  2016f0:	f7ff bf76 	b.w	2015e0 <otg_txfifo_handler>
      isp->txsize = isp->totsize - isp->txsize;
  2016f4:	eba2 020e 	sub.w	r2, r2, lr
      isp->txcnt  = 0;
  2016f8:	f04f 0800 	mov.w	r8, #0
  2016fc:	e9c3 2800 	strd	r2, r8, [r3]
  __ASM volatile ("cpsid i" : : : "memory");
  201700:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201702:	2320      	movs	r3, #32
  201704:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  201708:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  20170a:	f7ff fdd9 	bl	2012c0 <_dbg_check_lock_from_isr>
      usb_lld_start_in(usbp, ep);
  20170e:	4629      	mov	r1, r5
  201710:	4638      	mov	r0, r7
  201712:	f7ff fe75 	bl	201400 <usb_lld_start_in>
  _dbg_check_unlock_from_isr();
  201716:	f7ff fdbb 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20171a:	f388 8811 	msr	BASEPRI, r8
  20171e:	e7c1      	b.n	2016a4 <otg_epin_handler+0x24>

00201720 <usb_lld_serve_interrupt>:
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  201720:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  stm32_otg_t *otgp = usbp->otg;
  201724:	f8d0 6090 	ldr.w	r6, [r0, #144]	; 0x90
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  201728:	4604      	mov	r4, r0
  sts  = otgp->GINTSTS;
  20172a:	6975      	ldr	r5, [r6, #20]
  sts &= otgp->GINTMSK;
  20172c:	69b3      	ldr	r3, [r6, #24]
  20172e:	401d      	ands	r5, r3
  if (sts & GINTSTS_USBRST) {
  201730:	f415 5980 	ands.w	r9, r5, #4096	; 0x1000
  otgp->GINTSTS = sts;
  201734:	6175      	str	r5, [r6, #20]
  if (sts & GINTSTS_USBRST) {
  201736:	f040 811f 	bne.w	201978 <usb_lld_serve_interrupt+0x258>
  if (sts & GINTSTS_WKUPINT) {
  20173a:	2d00      	cmp	r5, #0
  20173c:	db5d      	blt.n	2017fa <usb_lld_serve_interrupt+0xda>
  if (sts & GINTSTS_USBSUSP) {
  20173e:	052a      	lsls	r2, r5, #20
  201740:	f100 80de 	bmi.w	201900 <usb_lld_serve_interrupt+0x1e0>
  if (sts & GINTSTS_ENUMDNE) {
  201744:	04ab      	lsls	r3, r5, #18
  201746:	d50c      	bpl.n	201762 <usb_lld_serve_interrupt+0x42>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
  201748:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
  20174c:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
  201750:	68f3      	ldr	r3, [r6, #12]
  201752:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
  201756:	bf0c      	ite	eq
  201758:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
  20175c:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
  201760:	60f3      	str	r3, [r6, #12]
  if (sts & GINTSTS_SOF) {
  201762:	072f      	lsls	r7, r5, #28
  201764:	d504      	bpl.n	201770 <usb_lld_serve_interrupt+0x50>
    _usb_isr_invoke_sof_cb(usbp);
  201766:	6863      	ldr	r3, [r4, #4]
  201768:	68db      	ldr	r3, [r3, #12]
  20176a:	b10b      	cbz	r3, 201770 <usb_lld_serve_interrupt+0x50>
  20176c:	4620      	mov	r0, r4
  20176e:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
  201770:	02e8      	lsls	r0, r5, #11
  201772:	d47f      	bmi.n	201874 <usb_lld_serve_interrupt+0x154>
  if (sts & GINTSTS_IISOOXFR) {
  201774:	02aa      	lsls	r2, r5, #10
  201776:	f100 80d4 	bmi.w	201922 <usb_lld_serve_interrupt+0x202>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
  20177a:	06eb      	lsls	r3, r5, #27
  20177c:	d455      	bmi.n	20182a <usb_lld_serve_interrupt+0x10a>
  if (sts & GINTSTS_OEPINT) {
  20177e:	0328      	lsls	r0, r5, #12
  src = otgp->DAINT;
  201780:	f8d6 6818 	ldr.w	r6, [r6, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
  201784:	d51a      	bpl.n	2017bc <usb_lld_serve_interrupt+0x9c>
    if (src & (1 << 16))
  201786:	03f1      	lsls	r1, r6, #15
  201788:	f100 81dd 	bmi.w	201b46 <usb_lld_serve_interrupt+0x426>
    if (src & (1 << 17))
  20178c:	03b2      	lsls	r2, r6, #14
  20178e:	f100 81e1 	bmi.w	201b54 <usb_lld_serve_interrupt+0x434>
    if (src & (1 << 18))
  201792:	0373      	lsls	r3, r6, #13
  201794:	f100 81e5 	bmi.w	201b62 <usb_lld_serve_interrupt+0x442>
    if (src & (1 << 19))
  201798:	0337      	lsls	r7, r6, #12
  20179a:	f100 81e9 	bmi.w	201b70 <usb_lld_serve_interrupt+0x450>
    if (src & (1 << 20))
  20179e:	02f0      	lsls	r0, r6, #11
  2017a0:	f100 81ed 	bmi.w	201b7e <usb_lld_serve_interrupt+0x45e>
    if (src & (1 << 21))
  2017a4:	02b1      	lsls	r1, r6, #10
  2017a6:	f100 81f1 	bmi.w	201b8c <usb_lld_serve_interrupt+0x46c>
    if (src & (1 << 22))
  2017aa:	0272      	lsls	r2, r6, #9
  2017ac:	f100 81f5 	bmi.w	201b9a <usb_lld_serve_interrupt+0x47a>
    if (src & (1 << 23))
  2017b0:	0233      	lsls	r3, r6, #8
  2017b2:	f100 81c3 	bmi.w	201b3c <usb_lld_serve_interrupt+0x41c>
    if (src & (1 << 24))
  2017b6:	01f7      	lsls	r7, r6, #7
  2017b8:	f100 8162 	bmi.w	201a80 <usb_lld_serve_interrupt+0x360>
  if (sts & GINTSTS_IEPINT) {
  2017bc:	0368      	lsls	r0, r5, #13
  2017be:	d51a      	bpl.n	2017f6 <usb_lld_serve_interrupt+0xd6>
    if (src & (1 << 0))
  2017c0:	07f1      	lsls	r1, r6, #31
  2017c2:	f100 81b6 	bmi.w	201b32 <usb_lld_serve_interrupt+0x412>
    if (src & (1 << 1))
  2017c6:	07b2      	lsls	r2, r6, #30
  2017c8:	f100 81ae 	bmi.w	201b28 <usb_lld_serve_interrupt+0x408>
    if (src & (1 << 2))
  2017cc:	0773      	lsls	r3, r6, #29
  2017ce:	f100 81a6 	bmi.w	201b1e <usb_lld_serve_interrupt+0x3fe>
    if (src & (1 << 3))
  2017d2:	0737      	lsls	r7, r6, #28
  2017d4:	f100 819e 	bmi.w	201b14 <usb_lld_serve_interrupt+0x3f4>
    if (src & (1 << 4))
  2017d8:	06f5      	lsls	r5, r6, #27
  2017da:	f100 8196 	bmi.w	201b0a <usb_lld_serve_interrupt+0x3ea>
    if (src & (1 << 5))
  2017de:	06b0      	lsls	r0, r6, #26
  2017e0:	f100 818e 	bmi.w	201b00 <usb_lld_serve_interrupt+0x3e0>
    if (src & (1 << 6))
  2017e4:	0671      	lsls	r1, r6, #25
  2017e6:	f100 8186 	bmi.w	201af6 <usb_lld_serve_interrupt+0x3d6>
    if (src & (1 << 7))
  2017ea:	0632      	lsls	r2, r6, #24
  2017ec:	f100 817e 	bmi.w	201aec <usb_lld_serve_interrupt+0x3cc>
    if (src & (1 << 8))
  2017f0:	05f3      	lsls	r3, r6, #23
  2017f2:	f100 8138 	bmi.w	201a66 <usb_lld_serve_interrupt+0x346>
}
  2017f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
  2017fa:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
  2017fe:	0799      	lsls	r1, r3, #30
  201800:	f040 8137 	bne.w	201a72 <usb_lld_serve_interrupt+0x352>
    otgp->DCTL &= ~DCTL_RWUSIG;
  201804:	f8d6 3804 	ldr.w	r3, [r6, #2052]	; 0x804

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
  201808:	6862      	ldr	r2, [r4, #4]
  20180a:	f023 0301 	bic.w	r3, r3, #1
  20180e:	f8c6 3804 	str.w	r3, [r6, #2052]	; 0x804
  usbp->state = usbp->saved_state;
  201812:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
  201816:	7023      	strb	r3, [r4, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
  201818:	6813      	ldr	r3, [r2, #0]
  20181a:	2b00      	cmp	r3, #0
  20181c:	d08f      	beq.n	20173e <usb_lld_serve_interrupt+0x1e>
  20181e:	2105      	movs	r1, #5
  201820:	4620      	mov	r0, r4
  201822:	4798      	blx	r3
  if (sts & GINTSTS_USBSUSP) {
  201824:	052a      	lsls	r2, r5, #20
  201826:	d58d      	bpl.n	201744 <usb_lld_serve_interrupt+0x24>
  201828:	e06a      	b.n	201900 <usb_lld_serve_interrupt+0x1e0>
  sts = usbp->otg->GRXSTSP;
  20182a:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
  20182e:	6a02      	ldr	r2, [r0, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  201830:	f402 13f0 	and.w	r3, r2, #1966080	; 0x1e0000
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
  201834:	f3c2 110a 	ubfx	r1, r2, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
  201838:	f002 020f 	and.w	r2, r2, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  20183c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
  201840:	f000 8129 	beq.w	201a96 <usb_lld_serve_interrupt+0x376>
  201844:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
  201848:	d199      	bne.n	20177e <usb_lld_serve_interrupt+0x5e>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
  20184a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  20184e:	68d3      	ldr	r3, [r2, #12]
  201850:	6a1f      	ldr	r7, [r3, #32]
  while (i < n) {
  201852:	2900      	cmp	r1, #0
  201854:	d093      	beq.n	20177e <usb_lld_serve_interrupt+0x5e>
  uint32_t w = 0;
  201856:	2200      	movs	r2, #0
      w = *fifop;
  201858:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
  size_t i = 0;
  20185c:	4613      	mov	r3, r2
    if ((i & 3) == 0){
  20185e:	f013 0f03 	tst.w	r3, #3
  201862:	d100      	bne.n	201866 <usb_lld_serve_interrupt+0x146>
      w = *fifop;
  201864:	6802      	ldr	r2, [r0, #0]
    if (i < max) {
  201866:	2b07      	cmp	r3, #7
  201868:	f240 819c 	bls.w	201ba4 <usb_lld_serve_interrupt+0x484>
    i++;
  20186c:	3301      	adds	r3, #1
  while (i < n) {
  20186e:	4299      	cmp	r1, r3
  201870:	d1f5      	bne.n	20185e <usb_lld_serve_interrupt+0x13e>
  201872:	e784      	b.n	20177e <usb_lld_serve_interrupt+0x5e>
  stm32_otg_t *otgp = usbp->otg;
  201874:	f8d4 a090 	ldr.w	sl, [r4, #144]	; 0x90
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  201878:	2700      	movs	r7, #0
      _usb_isr_invoke_in_cb(usbp, ep);
  20187a:	f04f 0801 	mov.w	r8, #1
  20187e:	e008      	b.n	201892 <usb_lld_serve_interrupt+0x172>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  201880:	3701      	adds	r7, #1
  201882:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
  201886:	b2ff      	uxtb	r7, r7
  201888:	689b      	ldr	r3, [r3, #8]
  20188a:	429f      	cmp	r7, r3
  20188c:	46b9      	mov	r9, r7
  20188e:	f63f af71 	bhi.w	201774 <usb_lld_serve_interrupt+0x54>
  201892:	eb0a 1247 	add.w	r2, sl, r7, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
  201896:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
  20189a:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
  20189e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
  2018a2:	d1ed      	bne.n	201880 <usb_lld_serve_interrupt+0x160>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
  2018a4:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
  2018a8:	2b00      	cmp	r3, #0
  2018aa:	dae9      	bge.n	201880 <usb_lld_serve_interrupt+0x160>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
  2018ac:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
  2018b0:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
  2018b4:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
  2018b8:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
  2018bc:	2b00      	cmp	r3, #0
  2018be:	dbfb      	blt.n	2018b8 <usb_lld_serve_interrupt+0x198>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  2018c0:	ea4f 1989 	mov.w	r9, r9, lsl #6
  2018c4:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
  2018c8:	f049 0320 	orr.w	r3, r9, #32
  2018cc:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  2018ce:	6913      	ldr	r3, [r2, #16]
  2018d0:	0699      	lsls	r1, r3, #26
  2018d2:	d4fc      	bmi.n	2018ce <usb_lld_serve_interrupt+0x1ae>
 * @xclass
 */
#if (PORT_SUPPORTS_RT == TRUE) || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
  2018d4:	2012      	movs	r0, #18
  2018d6:	f7ff f93b 	bl	200b50 <chSysPolledDelayX>
      _usb_isr_invoke_in_cb(usbp, ep);
  2018da:	8922      	ldrh	r2, [r4, #8]
  2018dc:	eb04 0187 	add.w	r1, r4, r7, lsl #2
  2018e0:	fa08 f307 	lsl.w	r3, r8, r7
  2018e4:	68c9      	ldr	r1, [r1, #12]
  2018e6:	ea22 0303 	bic.w	r3, r2, r3
  2018ea:	688a      	ldr	r2, [r1, #8]
  2018ec:	8123      	strh	r3, [r4, #8]
  2018ee:	b112      	cbz	r2, 2018f6 <usb_lld_serve_interrupt+0x1d6>
  2018f0:	4639      	mov	r1, r7
  2018f2:	4620      	mov	r0, r4
  2018f4:	4790      	blx	r2
    otg_txfifo_handler(usbp, ep);
  2018f6:	4639      	mov	r1, r7
  2018f8:	4620      	mov	r0, r4
  2018fa:	f7ff fe71 	bl	2015e0 <otg_txfifo_handler>
  2018fe:	e7bf      	b.n	201880 <usb_lld_serve_interrupt+0x160>
  usbp->saved_state = usbp->state;
  201900:	7821      	ldrb	r1, [r4, #0]
  usbp->state       = USB_SUSPENDED;
  201902:	2205      	movs	r2, #5
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
  201904:	6863      	ldr	r3, [r4, #4]
  usbp->saved_state = usbp->state;
  201906:	f884 108c 	strb.w	r1, [r4, #140]	; 0x8c
  usbp->state       = USB_SUSPENDED;
  20190a:	7022      	strb	r2, [r4, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
  20190c:	681b      	ldr	r3, [r3, #0]
  20190e:	2b00      	cmp	r3, #0
  201910:	f43f af18 	beq.w	201744 <usb_lld_serve_interrupt+0x24>
  201914:	2104      	movs	r1, #4
  201916:	4620      	mov	r0, r4
  201918:	4798      	blx	r3
  if (sts & GINTSTS_ENUMDNE) {
  20191a:	04ab      	lsls	r3, r5, #18
  20191c:	f57f af21 	bpl.w	201762 <usb_lld_serve_interrupt+0x42>
  201920:	e712      	b.n	201748 <usb_lld_serve_interrupt+0x28>
  stm32_otg_t *otgp = usbp->otg;
  201922:	f8d4 8090 	ldr.w	r8, [r4, #144]	; 0x90
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  201926:	2700      	movs	r7, #0
      _usb_isr_invoke_out_cb(usbp, ep);
  201928:	f04f 0901 	mov.w	r9, #1
  20192c:	e007      	b.n	20193e <usb_lld_serve_interrupt+0x21e>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  20192e:	3701      	adds	r7, #1
  201930:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
  201934:	b2ff      	uxtb	r7, r7
  201936:	689b      	ldr	r3, [r3, #8]
  201938:	429f      	cmp	r7, r3
  20193a:	f63f af1e 	bhi.w	20177a <usb_lld_serve_interrupt+0x5a>
  20193e:	eb08 1247 	add.w	r2, r8, r7, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
  201942:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  201946:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
  20194a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
  20194e:	d1ee      	bne.n	20192e <usb_lld_serve_interrupt+0x20e>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
  201950:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
  201954:	2b00      	cmp	r3, #0
  201956:	daea      	bge.n	20192e <usb_lld_serve_interrupt+0x20e>
      _usb_isr_invoke_out_cb(usbp, ep);
  201958:	eb04 0187 	add.w	r1, r4, r7, lsl #2
  20195c:	8962      	ldrh	r2, [r4, #10]
  20195e:	fa09 f307 	lsl.w	r3, r9, r7
  201962:	68c9      	ldr	r1, [r1, #12]
  201964:	ea22 0303 	bic.w	r3, r2, r3
  201968:	68ca      	ldr	r2, [r1, #12]
  20196a:	8163      	strh	r3, [r4, #10]
  20196c:	2a00      	cmp	r2, #0
  20196e:	d0de      	beq.n	20192e <usb_lld_serve_interrupt+0x20e>
  201970:	4639      	mov	r1, r7
  201972:	4620      	mov	r0, r4
  201974:	4790      	blx	r2
  201976:	e7da      	b.n	20192e <usb_lld_serve_interrupt+0x20e>
  usbp->status        = 0;
  201978:	2000      	movs	r0, #0
  usbp->state         = USB_READY;
  20197a:	2502      	movs	r5, #2
  usbp->transmitting  = 0;
  20197c:	4623      	mov	r3, r4
  20197e:	f104 012c 	add.w	r1, r4, #44	; 0x2c
    usbp->epc[i] = NULL;
  201982:	4602      	mov	r2, r0
  usbp->status        = 0;
  201984:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
  usbp->state         = USB_READY;
  201988:	7025      	strb	r5, [r4, #0]
  usbp->transmitting  = 0;
  20198a:	f843 0f08 	str.w	r0, [r3, #8]!
    usbp->epc[i] = NULL;
  20198e:	f843 2f04 	str.w	r2, [r3, #4]!
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
  201992:	4299      	cmp	r1, r3
  201994:	d1fb      	bne.n	20198e <usb_lld_serve_interrupt+0x26e>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  201996:	2320      	movs	r3, #32
  usbp->ep0state = USB_EP0_STP_WAITING;
  201998:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
  20199c:	6133      	str	r3, [r6, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  20199e:	6935      	ldr	r5, [r6, #16]
  2019a0:	f015 0520 	ands.w	r5, r5, #32
  2019a4:	d1fb      	bne.n	20199e <usb_lld_serve_interrupt+0x27e>
  2019a6:	2012      	movs	r0, #18
  2019a8:	f7ff f8d2 	bl	200b50 <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2019ac:	f8d4 7094 	ldr.w	r7, [r4, #148]	; 0x94
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  2019b0:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
  2019b4:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  2019b8:	68b8      	ldr	r0, [r7, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  2019ba:	f04f 32ff 	mov.w	r2, #4294967295
  otgp->DIEPEMPMSK = 0;
  2019be:	f8c6 5834 	str.w	r5, [r6, #2100]	; 0x834
  2019c2:	3001      	adds	r0, #1
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  2019c4:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
  2019c8:	eb06 1345 	add.w	r3, r6, r5, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2019cc:	3501      	adds	r5, #1
  2019ce:	4285      	cmp	r5, r0
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
  2019d0:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
  2019d4:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  2019d8:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  2019dc:	f8c3 2b08 	str.w	r2, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2019e0:	d1f2      	bne.n	2019c8 <usb_lld_serve_interrupt+0x2a8>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  2019e2:	6839      	ldr	r1, [r7, #0]
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
  2019e4:	2210      	movs	r2, #16
  2019e6:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  2019ea:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  2019ee:	6839      	ldr	r1, [r7, #0]
  2019f0:	6271      	str	r1, [r6, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
  2019f2:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
  2019f4:	691d      	ldr	r5, [r3, #16]
  2019f6:	f015 0510 	ands.w	r5, r5, #16
  2019fa:	d1fb      	bne.n	2019f4 <usb_lld_serve_interrupt+0x2d4>
  2019fc:	2012      	movs	r0, #18
  usbp->epc[0] = &ep0config;
  2019fe:	4f6b      	ldr	r7, [pc, #428]	; (201bac <usb_lld_serve_interrupt+0x48c>)
  201a00:	f7ff f8a6 	bl	200b50 <chSysPolledDelayX>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
  201a04:	f8d6 2800 	ldr.w	r2, [r6, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  201a08:	4b69      	ldr	r3, [pc, #420]	; (201bb0 <usb_lld_serve_interrupt+0x490>)
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  201a0a:	2109      	movs	r1, #9
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
  201a0c:	f422 62fe 	bic.w	r2, r2, #2032	; 0x7f0
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
  201a10:	f04f 40c0 	mov.w	r0, #1610612736	; 0x60000000
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
  201a14:	f8c6 2800 	str.w	r2, [r6, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  201a18:	69b2      	ldr	r2, [r6, #24]
  201a1a:	4313      	orrs	r3, r2
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
  201a1c:	4a65      	ldr	r2, [pc, #404]	; (201bb4 <usb_lld_serve_interrupt+0x494>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  201a1e:	61b3      	str	r3, [r6, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  201a20:	f8c6 1810 	str.w	r1, [r6, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
  201a24:	f8c6 1814 	str.w	r1, [r6, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
  201a28:	60e7      	str	r7, [r4, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
  201a2a:	f8c6 0b10 	str.w	r0, [r6, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
  201a2e:	f8c6 2b00 	str.w	r2, [r6, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
  201a32:	f8c6 5910 	str.w	r5, [r6, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
  201a36:	f8c6 2900 	str.w	r2, [r6, #2304]	; 0x900
  201a3a:	e9d4 1325 	ldrd	r1, r3, [r4, #148]	; 0x94
  usbp->pmnext += size;
  201a3e:	f103 0210 	add.w	r2, r3, #16
  201a42:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
  201a46:	6849      	ldr	r1, [r1, #4]
  201a48:	428a      	cmp	r2, r1
  201a4a:	d821      	bhi.n	201a90 <usb_lld_serve_interrupt+0x370>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
  201a4c:	6862      	ldr	r2, [r4, #4]
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
  201a4e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  201a52:	6812      	ldr	r2, [r2, #0]
  201a54:	62b3      	str	r3, [r6, #40]	; 0x28
  201a56:	2a00      	cmp	r2, #0
  201a58:	f43f aecd 	beq.w	2017f6 <usb_lld_serve_interrupt+0xd6>
  201a5c:	4629      	mov	r1, r5
  201a5e:	4620      	mov	r0, r4
}
  201a60:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  201a64:	4710      	bx	r2
      otg_epin_handler(usbp, 8);
  201a66:	4620      	mov	r0, r4
  201a68:	2108      	movs	r1, #8
}
  201a6a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      otg_epin_handler(usbp, 8);
  201a6e:	f7ff be07 	b.w	201680 <otg_epin_handler>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
  201a72:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
  201a76:	f023 0303 	bic.w	r3, r3, #3
  201a7a:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00
  201a7e:	e6c1      	b.n	201804 <usb_lld_serve_interrupt+0xe4>
      otg_epout_handler(usbp, 8);
  201a80:	4620      	mov	r0, r4
  201a82:	2108      	movs	r1, #8
  201a84:	f7ff fd5c 	bl	201540 <otg_epout_handler>
  if (sts & GINTSTS_IEPINT) {
  201a88:	0368      	lsls	r0, r5, #13
  201a8a:	f57f aeb4 	bpl.w	2017f6 <usb_lld_serve_interrupt+0xd6>
  201a8e:	e697      	b.n	2017c0 <usb_lld_serve_interrupt+0xa0>
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
  201a90:	4849      	ldr	r0, [pc, #292]	; (201bb8 <usb_lld_serve_interrupt+0x498>)
  201a92:	f7ff f86d 	bl	200b70 <chSysHalt>
  201a96:	eb04 0882 	add.w	r8, r4, r2, lsl #2
                            usbp->epc[ep]->out_state->rxbuf,
  201a9a:	f8d8 300c 	ldr.w	r3, [r8, #12]
  201a9e:	f8d3 c018 	ldr.w	ip, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
  201aa2:	e9dc 3701 	ldrd	r3, r7, [ip, #4]
  201aa6:	f8dc 2000 	ldr.w	r2, [ip]
  201aaa:	eba2 0e03 	sub.w	lr, r2, r3
  while (i < n) {
  201aae:	b1c1      	cbz	r1, 201ae2 <usb_lld_serve_interrupt+0x3c2>
  uint32_t w = 0;
  201ab0:	f04f 0c00 	mov.w	ip, #0
      w = *fifop;
  201ab4:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
  size_t i = 0;
  201ab8:	4663      	mov	r3, ip
    if ((i & 3) == 0){
  201aba:	079a      	lsls	r2, r3, #30
  201abc:	d101      	bne.n	201ac2 <usb_lld_serve_interrupt+0x3a2>
      w = *fifop;
  201abe:	f8d0 c000 	ldr.w	ip, [r0]
    if (i < max) {
  201ac2:	459e      	cmp	lr, r3
  201ac4:	d904      	bls.n	201ad0 <usb_lld_serve_interrupt+0x3b0>
      *buf++ = (uint8_t)w;
  201ac6:	f887 c000 	strb.w	ip, [r7]
      w >>= 8;
  201aca:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
      *buf++ = (uint8_t)w;
  201ace:	3701      	adds	r7, #1
    i++;
  201ad0:	3301      	adds	r3, #1
  while (i < n) {
  201ad2:	4299      	cmp	r1, r3
  201ad4:	d1f1      	bne.n	201aba <usb_lld_serve_interrupt+0x39a>
  201ad6:	f8d8 300c 	ldr.w	r3, [r8, #12]
  201ada:	f8d3 c018 	ldr.w	ip, [r3, #24]
  201ade:	e9dc 3701 	ldrd	r3, r7, [ip, #4]
    usbp->epc[ep]->out_state->rxbuf += cnt;
  201ae2:	440f      	add	r7, r1
    usbp->epc[ep]->out_state->rxcnt += cnt;
  201ae4:	440b      	add	r3, r1
  201ae6:	e9cc 3701 	strd	r3, r7, [ip, #4]
  201aea:	e648      	b.n	20177e <usb_lld_serve_interrupt+0x5e>
      otg_epin_handler(usbp, 7);
  201aec:	2107      	movs	r1, #7
  201aee:	4620      	mov	r0, r4
  201af0:	f7ff fdc6 	bl	201680 <otg_epin_handler>
  201af4:	e67c      	b.n	2017f0 <usb_lld_serve_interrupt+0xd0>
      otg_epin_handler(usbp, 6);
  201af6:	2106      	movs	r1, #6
  201af8:	4620      	mov	r0, r4
  201afa:	f7ff fdc1 	bl	201680 <otg_epin_handler>
  201afe:	e674      	b.n	2017ea <usb_lld_serve_interrupt+0xca>
      otg_epin_handler(usbp, 5);
  201b00:	2105      	movs	r1, #5
  201b02:	4620      	mov	r0, r4
  201b04:	f7ff fdbc 	bl	201680 <otg_epin_handler>
  201b08:	e66c      	b.n	2017e4 <usb_lld_serve_interrupt+0xc4>
      otg_epin_handler(usbp, 4);
  201b0a:	2104      	movs	r1, #4
  201b0c:	4620      	mov	r0, r4
  201b0e:	f7ff fdb7 	bl	201680 <otg_epin_handler>
  201b12:	e664      	b.n	2017de <usb_lld_serve_interrupt+0xbe>
      otg_epin_handler(usbp, 3);
  201b14:	2103      	movs	r1, #3
  201b16:	4620      	mov	r0, r4
  201b18:	f7ff fdb2 	bl	201680 <otg_epin_handler>
  201b1c:	e65c      	b.n	2017d8 <usb_lld_serve_interrupt+0xb8>
      otg_epin_handler(usbp, 2);
  201b1e:	2102      	movs	r1, #2
  201b20:	4620      	mov	r0, r4
  201b22:	f7ff fdad 	bl	201680 <otg_epin_handler>
  201b26:	e654      	b.n	2017d2 <usb_lld_serve_interrupt+0xb2>
      otg_epin_handler(usbp, 1);
  201b28:	2101      	movs	r1, #1
  201b2a:	4620      	mov	r0, r4
  201b2c:	f7ff fda8 	bl	201680 <otg_epin_handler>
  201b30:	e64c      	b.n	2017cc <usb_lld_serve_interrupt+0xac>
      otg_epin_handler(usbp, 0);
  201b32:	2100      	movs	r1, #0
  201b34:	4620      	mov	r0, r4
  201b36:	f7ff fda3 	bl	201680 <otg_epin_handler>
  201b3a:	e644      	b.n	2017c6 <usb_lld_serve_interrupt+0xa6>
      otg_epout_handler(usbp, 7);
  201b3c:	2107      	movs	r1, #7
  201b3e:	4620      	mov	r0, r4
  201b40:	f7ff fcfe 	bl	201540 <otg_epout_handler>
  201b44:	e637      	b.n	2017b6 <usb_lld_serve_interrupt+0x96>
      otg_epout_handler(usbp, 0);
  201b46:	2100      	movs	r1, #0
  201b48:	4620      	mov	r0, r4
  201b4a:	f7ff fcf9 	bl	201540 <otg_epout_handler>
    if (src & (1 << 17))
  201b4e:	03b2      	lsls	r2, r6, #14
  201b50:	f57f ae1f 	bpl.w	201792 <usb_lld_serve_interrupt+0x72>
      otg_epout_handler(usbp, 1);
  201b54:	2101      	movs	r1, #1
  201b56:	4620      	mov	r0, r4
  201b58:	f7ff fcf2 	bl	201540 <otg_epout_handler>
    if (src & (1 << 18))
  201b5c:	0373      	lsls	r3, r6, #13
  201b5e:	f57f ae1b 	bpl.w	201798 <usb_lld_serve_interrupt+0x78>
      otg_epout_handler(usbp, 2);
  201b62:	2102      	movs	r1, #2
  201b64:	4620      	mov	r0, r4
  201b66:	f7ff fceb 	bl	201540 <otg_epout_handler>
    if (src & (1 << 19))
  201b6a:	0337      	lsls	r7, r6, #12
  201b6c:	f57f ae17 	bpl.w	20179e <usb_lld_serve_interrupt+0x7e>
      otg_epout_handler(usbp, 3);
  201b70:	4620      	mov	r0, r4
  201b72:	2103      	movs	r1, #3
  201b74:	f7ff fce4 	bl	201540 <otg_epout_handler>
    if (src & (1 << 20))
  201b78:	02f0      	lsls	r0, r6, #11
  201b7a:	f57f ae13 	bpl.w	2017a4 <usb_lld_serve_interrupt+0x84>
      otg_epout_handler(usbp, 4);
  201b7e:	2104      	movs	r1, #4
  201b80:	4620      	mov	r0, r4
  201b82:	f7ff fcdd 	bl	201540 <otg_epout_handler>
    if (src & (1 << 21))
  201b86:	02b1      	lsls	r1, r6, #10
  201b88:	f57f ae0f 	bpl.w	2017aa <usb_lld_serve_interrupt+0x8a>
      otg_epout_handler(usbp, 5);
  201b8c:	2105      	movs	r1, #5
  201b8e:	4620      	mov	r0, r4
  201b90:	f7ff fcd6 	bl	201540 <otg_epout_handler>
    if (src & (1 << 22))
  201b94:	0272      	lsls	r2, r6, #9
  201b96:	f57f ae0b 	bpl.w	2017b0 <usb_lld_serve_interrupt+0x90>
      otg_epout_handler(usbp, 6);
  201b9a:	2106      	movs	r1, #6
  201b9c:	4620      	mov	r0, r4
  201b9e:	f7ff fccf 	bl	201540 <otg_epout_handler>
  201ba2:	e605      	b.n	2017b0 <usb_lld_serve_interrupt+0x90>
      *buf++ = (uint8_t)w;
  201ba4:	703a      	strb	r2, [r7, #0]
      w >>= 8;
  201ba6:	0a12      	lsrs	r2, r2, #8
      *buf++ = (uint8_t)w;
  201ba8:	3701      	adds	r7, #1
  201baa:	e65f      	b.n	20186c <usb_lld_serve_interrupt+0x14c>
  201bac:	0800c4f0 	.word	0x0800c4f0
  201bb0:	000c0010 	.word	0x000c0010
  201bb4:	10008040 	.word	0x10008040
  201bb8:	0800c074 	.word	0x0800c074
  201bbc:	00000000 	.word	0x00000000

00201bc0 <usbStartTransmitI>:
                       const uint8_t *buf, size_t n) {
  201bc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  201bc4:	4604      	mov	r4, r0
  201bc6:	460e      	mov	r6, r1
  201bc8:	4617      	mov	r7, r2
  201bca:	4698      	mov	r8, r3
  osalDbgCheckClassI();
  201bcc:	f7ff f8e0 	bl	200d90 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  201bd0:	b1bc      	cbz	r4, 201c02 <usbStartTransmitI+0x42>
  201bd2:	2e08      	cmp	r6, #8
  201bd4:	d815      	bhi.n	201c02 <usbStartTransmitI+0x42>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
  201bd6:	2001      	movs	r0, #1
  201bd8:	8925      	ldrh	r5, [r4, #8]
  201bda:	40b0      	lsls	r0, r6
  201bdc:	b280      	uxth	r0, r0
  201bde:	ea15 0300 	ands.w	r3, r5, r0
  201be2:	d10e      	bne.n	201c02 <usbStartTransmitI+0x42>
  isp = usbp->epc[ep]->in_state;
  201be4:	eb04 0286 	add.w	r2, r4, r6, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  201be8:	4305      	orrs	r5, r0
  usb_lld_start_in(usbp, ep);
  201bea:	4620      	mov	r0, r4
  201bec:	4631      	mov	r1, r6
  isp = usbp->epc[ep]->in_state;
  201bee:	68d2      	ldr	r2, [r2, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  201bf0:	8125      	strh	r5, [r4, #8]
  isp = usbp->epc[ep]->in_state;
  201bf2:	6954      	ldr	r4, [r2, #20]
  isp->txbuf  = buf;
  201bf4:	60a7      	str	r7, [r4, #8]
  isp->txcnt  = 0;
  201bf6:	e9c4 8300 	strd	r8, r3, [r4]
}
  201bfa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  usb_lld_start_in(usbp, ep);
  201bfe:	f7ff bbff 	b.w	201400 <usb_lld_start_in>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  201c02:	4801      	ldr	r0, [pc, #4]	; (201c08 <usbStartTransmitI+0x48>)
  201c04:	f7fe ffb4 	bl	200b70 <chSysHalt>
  201c08:	0800c130 	.word	0x0800c130
  201c0c:	00000000 	.word	0x00000000

00201c10 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
  201c10:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
  201c12:	f890 1070 	ldrb.w	r1, [r0, #112]	; 0x70
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
  201c16:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
  201c18:	2914      	cmp	r1, #20
  201c1a:	d032      	beq.n	201c82 <_usb_ep0out+0x72>
  201c1c:	2915      	cmp	r1, #21
  201c1e:	d01a      	beq.n	201c56 <_usb_ep0out+0x46>
  201c20:	2906      	cmp	r1, #6
  201c22:	d002      	beq.n	201c2a <_usb_ep0out+0x1a>
  case USB_EP0_STP_WAITING:
  case USB_EP0_IN_TX:
  case USB_EP0_IN_WAITING_TX0:
  case USB_EP0_IN_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
  201c24:	481d      	ldr	r0, [pc, #116]	; (201c9c <_usb_ep0out+0x8c>)
  201c26:	f7fe ffa3 	bl	200b70 <chSysHalt>
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  201c2a:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  201c2e:	6845      	ldr	r5, [r0, #4]
  201c30:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  201c34:	682d      	ldr	r5, [r5, #0]
  201c36:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  201c3a:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  201c3e:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  201c42:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  201c46:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  201c4a:	b105      	cbz	r5, 201c4e <_usb_ep0out+0x3e>
  201c4c:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
  201c4e:	2306      	movs	r3, #6
  201c50:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
  201c54:	bd38      	pop	{r3, r4, r5, pc}
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
  201c56:	230b      	movs	r3, #11
  201c58:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
  __ASM volatile ("cpsid i" : : : "memory");
  201c5c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201c5e:	2320      	movs	r3, #32
  201c60:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  201c64:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  201c66:	f7ff fb2b 	bl	2012c0 <_dbg_check_lock_from_isr>
    usbStartTransmitI(usbp, 0, NULL, 0);
  201c6a:	2300      	movs	r3, #0
  201c6c:	4620      	mov	r0, r4
  201c6e:	461a      	mov	r2, r3
  201c70:	4619      	mov	r1, r3
  201c72:	f7ff ffa5 	bl	201bc0 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
  201c76:	f7ff fb0b 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201c7a:	2300      	movs	r3, #0
  201c7c:	f383 8811 	msr	BASEPRI, r3
}
  201c80:	bd38      	pop	{r3, r4, r5, pc}
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
  201c82:	68c3      	ldr	r3, [r0, #12]
  201c84:	699b      	ldr	r3, [r3, #24]
  201c86:	685b      	ldr	r3, [r3, #4]
  201c88:	2b00      	cmp	r3, #0
  201c8a:	d1e3      	bne.n	201c54 <_usb_ep0out+0x44>
    if (usbp->ep0endcb != NULL) {
  201c8c:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
  201c8e:	b103      	cbz	r3, 201c92 <_usb_ep0out+0x82>
      usbp->ep0endcb(usbp);
  201c90:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
  201c92:	2300      	movs	r3, #0
  201c94:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
  201c98:	bd38      	pop	{r3, r4, r5, pc}
  201c9a:	bf00      	nop
  201c9c:	0800c18c 	.word	0x0800c18c

00201ca0 <usbStartReceiveI>:
                      uint8_t *buf, size_t n) {
  201ca0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  201ca4:	4604      	mov	r4, r0
  201ca6:	460e      	mov	r6, r1
  201ca8:	4617      	mov	r7, r2
  201caa:	4698      	mov	r8, r3
  osalDbgCheckClassI();
  201cac:	f7ff f870 	bl	200d90 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  201cb0:	b1bc      	cbz	r4, 201ce2 <usbStartReceiveI+0x42>
  201cb2:	2e08      	cmp	r6, #8
  201cb4:	d815      	bhi.n	201ce2 <usbStartReceiveI+0x42>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
  201cb6:	2001      	movs	r0, #1
  201cb8:	8965      	ldrh	r5, [r4, #10]
  201cba:	40b0      	lsls	r0, r6
  201cbc:	b280      	uxth	r0, r0
  201cbe:	ea15 0300 	ands.w	r3, r5, r0
  201cc2:	d10e      	bne.n	201ce2 <usbStartReceiveI+0x42>
  osp = usbp->epc[ep]->out_state;
  201cc4:	eb04 0286 	add.w	r2, r4, r6, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  201cc8:	4305      	orrs	r5, r0
  usb_lld_start_out(usbp, ep);
  201cca:	4620      	mov	r0, r4
  201ccc:	4631      	mov	r1, r6
  osp = usbp->epc[ep]->out_state;
  201cce:	68d2      	ldr	r2, [r2, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  201cd0:	8165      	strh	r5, [r4, #10]
  osp = usbp->epc[ep]->out_state;
  201cd2:	6994      	ldr	r4, [r2, #24]
  osp->rxbuf  = buf;
  201cd4:	60a7      	str	r7, [r4, #8]
  osp->rxcnt  = 0;
  201cd6:	e9c4 8300 	strd	r8, r3, [r4]
}
  201cda:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  usb_lld_start_out(usbp, ep);
  201cde:	f7ff bbe7 	b.w	2014b0 <usb_lld_start_out>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  201ce2:	4801      	ldr	r0, [pc, #4]	; (201ce8 <usbStartReceiveI+0x48>)
  201ce4:	f7fe ff44 	bl	200b70 <chSysHalt>
  201ce8:	0800c100 	.word	0x0800c100
  201cec:	00000000 	.word	0x00000000

00201cf0 <_usb_ep0in>:
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  201cf0:	b538      	push	{r3, r4, r5, lr}
  switch (usbp->ep0state) {
  201cf2:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  201cf6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
  201cf8:	3b06      	subs	r3, #6
  201cfa:	2b05      	cmp	r3, #5
  201cfc:	d804      	bhi.n	201d08 <_usb_ep0in+0x18>
  201cfe:	e8df f003 	tbb	[pc, r3]
  201d02:	032c      	.short	0x032c
  201d04:	43160603 	.word	0x43160603
    osalDbgAssert(false, "EP0 state machine error");
  201d08:	482d      	ldr	r0, [pc, #180]	; (201dc0 <_usb_ep0in+0xd0>)
  201d0a:	f7fe ff31 	bl	200b70 <chSysHalt>
  hw |= (uint16_t)*p << 8U;
  201d0e:	f890 1087 	ldrb.w	r1, [r0, #135]	; 0x87
  201d12:	f890 3086 	ldrb.w	r3, [r0, #134]	; 0x86
    if ((usbp->ep0n < max) &&
  201d16:	6f82      	ldr	r2, [r0, #120]	; 0x78
    max = (size_t)get_hword(&usbp->setup[6]);
  201d18:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    if ((usbp->ep0n < max) &&
  201d1c:	429a      	cmp	r2, r3
  201d1e:	d206      	bcs.n	201d2e <_usb_ep0in+0x3e>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
  201d20:	68c3      	ldr	r3, [r0, #12]
  201d22:	8a1b      	ldrh	r3, [r3, #16]
  201d24:	fbb2 f5f3 	udiv	r5, r2, r3
  201d28:	fb03 2515 	mls	r5, r3, r5, r2
    if ((usbp->ep0n < max) &&
  201d2c:	b39d      	cbz	r5, 201d96 <_usb_ep0in+0xa6>
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
  201d2e:	2314      	movs	r3, #20
  201d30:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
  __ASM volatile ("cpsid i" : : : "memory");
  201d34:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201d36:	2320      	movs	r3, #32
  201d38:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  201d3c:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  201d3e:	f7ff fabf 	bl	2012c0 <_dbg_check_lock_from_isr>
    usbStartReceiveI(usbp, 0, NULL, 0);
  201d42:	2300      	movs	r3, #0
  201d44:	4620      	mov	r0, r4
  201d46:	461a      	mov	r2, r3
  201d48:	4619      	mov	r1, r3
  201d4a:	f7ff ffa9 	bl	201ca0 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
  201d4e:	f7ff fa9f 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201d52:	2300      	movs	r3, #0
  201d54:	f383 8811 	msr	BASEPRI, r3
}
  201d58:	bd38      	pop	{r3, r4, r5, pc}
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  201d5a:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  201d5e:	6841      	ldr	r1, [r0, #4]
  201d60:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  201d64:	680d      	ldr	r5, [r1, #0]
  201d66:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  201d6a:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  201d6e:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  201d72:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  201d76:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  201d7a:	b10d      	cbz	r5, 201d80 <_usb_ep0in+0x90>
  201d7c:	2106      	movs	r1, #6
  201d7e:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
  201d80:	2306      	movs	r3, #6
  201d82:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
  201d86:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
  201d88:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
  201d8a:	b103      	cbz	r3, 201d8e <_usb_ep0in+0x9e>
      usbp->ep0endcb(usbp);
  201d8c:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
  201d8e:	2300      	movs	r3, #0
  201d90:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
  201d94:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
  201d96:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201d98:	2320      	movs	r3, #32
  201d9a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  201d9e:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  201da0:	f7ff fa8e 	bl	2012c0 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
  201da4:	462b      	mov	r3, r5
  201da6:	462a      	mov	r2, r5
  201da8:	4629      	mov	r1, r5
  201daa:	4620      	mov	r0, r4
  201dac:	f7ff ff08 	bl	201bc0 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
  201db0:	f7ff fa6e 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201db4:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
  201db8:	230a      	movs	r3, #10
  201dba:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
  201dbe:	bd38      	pop	{r3, r4, r5, pc}
  201dc0:	0800c180 	.word	0x0800c180
	...

00201dd0 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
  201dd0:	4770      	bx	lr
  201dd2:	bf00      	nop
	...

00201de0 <sduRequestsHook>:
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
  201de0:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
  201de4:	f003 0360 	and.w	r3, r3, #96	; 0x60
  201de8:	2b20      	cmp	r3, #32
  201dea:	d001      	beq.n	201df0 <sduRequestsHook+0x10>
      return false;
  201dec:	2000      	movs	r0, #0
}
  201dee:	4770      	bx	lr
    switch (usbp->setup[1]) {
  201df0:	f890 3081 	ldrb.w	r3, [r0, #129]	; 0x81
  201df4:	4602      	mov	r2, r0
  201df6:	2b20      	cmp	r3, #32
  201df8:	d3f8      	bcc.n	201dec <sduRequestsHook+0xc>
  201dfa:	2b21      	cmp	r3, #33	; 0x21
  201dfc:	d809      	bhi.n	201e12 <sduRequestsHook+0x32>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
  201dfe:	2107      	movs	r1, #7
  201e00:	2300      	movs	r3, #0
      return true;
  201e02:	2001      	movs	r0, #1
bool sduRequestsHook(USBDriver *usbp) {
  201e04:	b410      	push	{r4}
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
  201e06:	4c07      	ldr	r4, [pc, #28]	; (201e24 <sduRequestsHook+0x44>)
  201e08:	67d3      	str	r3, [r2, #124]	; 0x7c
  201e0a:	e9c2 411d 	strd	r4, r1, [r2, #116]	; 0x74
}
  201e0e:	bc10      	pop	{r4}
  201e10:	4770      	bx	lr
    switch (usbp->setup[1]) {
  201e12:	2b22      	cmp	r3, #34	; 0x22
  201e14:	d1ea      	bne.n	201dec <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, NULL, 0, NULL);
  201e16:	2300      	movs	r3, #0
      return true;
  201e18:	2001      	movs	r0, #1
      usbSetupTransfer(usbp, NULL, 0, NULL);
  201e1a:	e9c2 331d 	strd	r3, r3, [r2, #116]	; 0x74
  201e1e:	67d3      	str	r3, [r2, #124]	; 0x7c
  201e20:	4770      	bx	lr
  201e22:	bf00      	nop
  201e24:	20010430 	.word	0x20010430
	...

00201e30 <_ctl>:
static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
  201e30:	b508      	push	{r3, lr}
  osalDbgCheck(sdup != NULL);
  201e32:	b118      	cbz	r0, 201e3c <_ctl+0xc>
  switch (operation) {
  201e34:	b111      	cbz	r1, 201e3c <_ctl+0xc>
  201e36:	2901      	cmp	r1, #1
  201e38:	d103      	bne.n	201e42 <_ctl+0x12>
    osalDbgCheck(arg == NULL);
  201e3a:	b112      	cbz	r2, 201e42 <_ctl+0x12>
    osalDbgAssert(false, "invalid CTL operation");
  201e3c:	4802      	ldr	r0, [pc, #8]	; (201e48 <_ctl+0x18>)
  201e3e:	f7fe fe97 	bl	200b70 <chSysHalt>
}
  201e42:	2000      	movs	r0, #0
  201e44:	bd08      	pop	{r3, pc}
  201e46:	bf00      	nop
  201e48:	0800c00c 	.word	0x0800c00c
  201e4c:	00000000 	.word	0x00000000

00201e50 <sdu_start_receive>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
  201e50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  201e52:	f8d0 648c 	ldr.w	r6, [r0, #1164]	; 0x48c
  201e56:	6837      	ldr	r7, [r6, #0]
  201e58:	783b      	ldrb	r3, [r7, #0]
  201e5a:	2b04      	cmp	r3, #4
  201e5c:	d001      	beq.n	201e62 <sdu_start_receive+0x12>
    return true;
  201e5e:	2001      	movs	r0, #1
}
  201e60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  201e62:	7a03      	ldrb	r3, [r0, #8]
  201e64:	2b02      	cmp	r3, #2
  201e66:	d1fa      	bne.n	201e5e <sdu_start_receive+0xe>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  201e68:	7933      	ldrb	r3, [r6, #4]
  201e6a:	2501      	movs	r5, #1
  201e6c:	897a      	ldrh	r2, [r7, #10]
  201e6e:	fa05 f303 	lsl.w	r3, r5, r3
  201e72:	4213      	tst	r3, r2
  201e74:	d1f3      	bne.n	201e5e <sdu_start_receive+0xe>
  201e76:	4604      	mov	r4, r0
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();
  201e78:	f7fe ff8a 	bl	200d90 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
  201e7c:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
  201e80:	429a      	cmp	r2, r3
  201e82:	d009      	beq.n	201e98 <sdu_start_receive+0x48>
  if (buf == NULL) {
  201e84:	3204      	adds	r2, #4
  201e86:	d0ea      	beq.n	201e5e <sdu_start_receive+0xe>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
  201e88:	4638      	mov	r0, r7
  201e8a:	7971      	ldrb	r1, [r6, #5]
  201e8c:	f44f 7380 	mov.w	r3, #256	; 0x100
  201e90:	f7ff ff06 	bl	201ca0 <usbStartReceiveI>
  return false;
  201e94:	2000      	movs	r0, #0
}
  201e96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  201e98:	69a3      	ldr	r3, [r4, #24]
  201e9a:	2b00      	cmp	r3, #0
  201e9c:	d1df      	bne.n	201e5e <sdu_start_receive+0xe>
  201e9e:	e7f1      	b.n	201e84 <sdu_start_receive+0x34>

00201ea0 <ibnotify>:
  (void) sdu_start_receive(sdup);
  201ea0:	6b40      	ldr	r0, [r0, #52]	; 0x34
  201ea2:	f7ff bfd5 	b.w	201e50 <sdu_start_receive>
  201ea6:	bf00      	nop
	...

00201eb0 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
  201eb0:	3113      	adds	r1, #19
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  201eb2:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
  201eb4:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
  201eb8:	b1c4      	cbz	r4, 201eec <sduDataReceived+0x3c>
  __ASM volatile ("cpsid i" : : : "memory");
  201eba:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201ebc:	2320      	movs	r3, #32
  201ebe:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  201ec2:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  201ec4:	f7ff f9fc 	bl	2012c0 <_dbg_check_lock_from_isr>
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
  201ec8:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
  201ecc:	6813      	ldr	r3, [r2, #0]
  201ece:	7952      	ldrb	r2, [r2, #5]
  201ed0:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  201ed4:	68db      	ldr	r3, [r3, #12]
  201ed6:	699b      	ldr	r3, [r3, #24]
  201ed8:	685d      	ldr	r5, [r3, #4]
  if (size > (size_t)0) {
  201eda:	b945      	cbnz	r5, 201eee <sduDataReceived+0x3e>
  (void) sdu_start_receive(sdup);
  201edc:	4620      	mov	r0, r4
  201ede:	f7ff ffb7 	bl	201e50 <sdu_start_receive>
  _dbg_check_unlock_from_isr();
  201ee2:	f7ff f9d5 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  201ee6:	2300      	movs	r3, #0
  201ee8:	f383 8811 	msr	BASEPRI, r3
}
  201eec:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
  201eee:	2104      	movs	r1, #4
  201ef0:	1860      	adds	r0, r4, r1
  201ef2:	f7ff f8b5 	bl	201060 <chEvtBroadcastFlagsI>
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();
  201ef6:	f7fe ff4b 	bl	200d90 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  201efa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  201efc:	3b04      	subs	r3, #4
  201efe:	429d      	cmp	r5, r3
  201f00:	d817      	bhi.n	201f32 <sduDataReceived+0x82>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
  201f02:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
  201f06:	4293      	cmp	r3, r2
  201f08:	d010      	beq.n	201f2c <sduDataReceived+0x7c>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
  201f0a:	601d      	str	r5, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
  201f0c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  ibqp->bcounter++;
  201f0e:	69a2      	ldr	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
  201f10:	4403      	add	r3, r0
  if (ibqp->bwrptr >= ibqp->btop) {
  201f12:	6a61      	ldr	r1, [r4, #36]	; 0x24
  ibqp->bcounter++;
  201f14:	3201      	adds	r2, #1
  if (ibqp->bwrptr >= ibqp->btop) {
  201f16:	428b      	cmp	r3, r1
  ibqp->bwrptr += ibqp->bsize;
  201f18:	61e3      	str	r3, [r4, #28]
  ibqp->bcounter++;
  201f1a:	61a2      	str	r2, [r4, #24]
  if (ibqp->bwrptr >= ibqp->btop) {
  201f1c:	d301      	bcc.n	201f22 <sduDataReceived+0x72>
    ibqp->bwrptr = ibqp->buffers;
  201f1e:	6b23      	ldr	r3, [r4, #48]	; 0x30
  201f20:	61e3      	str	r3, [r4, #28]
  chThdDequeueNextI(tqp, msg);
  201f22:	f104 000c 	add.w	r0, r4, #12
  201f26:	f7ff f80b 	bl	200f40 <chThdDequeueNextI.constprop.80>
  201f2a:	e7d7      	b.n	201edc <sduDataReceived+0x2c>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
  201f2c:	69a2      	ldr	r2, [r4, #24]
  201f2e:	2a00      	cmp	r2, #0
  201f30:	d0eb      	beq.n	201f0a <sduDataReceived+0x5a>
  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  201f32:	4801      	ldr	r0, [pc, #4]	; (201f38 <sduDataReceived+0x88>)
  201f34:	f7fe fe1c 	bl	200b70 <chSysHalt>
  201f38:	0800c02c 	.word	0x0800c02c
  201f3c:	00000000 	.word	0x00000000

00201f40 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
  201f40:	b570      	push	{r4, r5, r6, lr}
  201f42:	460d      	mov	r5, r1
  201f44:	4604      	mov	r4, r0

  osalDbgCheckClassS();
  201f46:	f7fe ff13 	bl	200d70 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  201f4a:	b1d5      	cbz	r5, 201f82 <obqPostFullBufferS+0x42>
  201f4c:	69e3      	ldr	r3, [r4, #28]
  201f4e:	3b04      	subs	r3, #4
  201f50:	42ab      	cmp	r3, r5
  201f52:	d316      	bcc.n	201f82 <obqPostFullBufferS+0x42>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
  201f54:	68e3      	ldr	r3, [r4, #12]
  201f56:	b1a3      	cbz	r3, 201f82 <obqPostFullBufferS+0x42>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
  201f58:	6923      	ldr	r3, [r4, #16]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
  201f5a:	69a1      	ldr	r1, [r4, #24]
  *((size_t *)obqp->bwrptr) = size;
  201f5c:	601d      	str	r5, [r3, #0]
  obqp->bwrptr += obqp->bsize;
  201f5e:	69e0      	ldr	r0, [r4, #28]
  obqp->bcounter--;
  201f60:	68e2      	ldr	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
  201f62:	4403      	add	r3, r0
  obqp->bcounter--;
  201f64:	3a01      	subs	r2, #1
  if (obqp->bwrptr >= obqp->btop) {
  201f66:	428b      	cmp	r3, r1
  obqp->bwrptr += obqp->bsize;
  201f68:	6123      	str	r3, [r4, #16]
  obqp->bcounter--;
  201f6a:	60e2      	str	r2, [r4, #12]
  if (obqp->bwrptr >= obqp->btop) {
  201f6c:	d301      	bcc.n	201f72 <obqPostFullBufferS+0x32>
    obqp->bwrptr = obqp->buffers;
  201f6e:	6a63      	ldr	r3, [r4, #36]	; 0x24
  201f70:	6123      	str	r3, [r4, #16]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
  201f72:	2200      	movs	r2, #0

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
  201f74:	6b23      	ldr	r3, [r4, #48]	; 0x30
  obqp->ptr = NULL;
  201f76:	62a2      	str	r2, [r4, #40]	; 0x28
  if (obqp->notify != NULL) {
  201f78:	b133      	cbz	r3, 201f88 <obqPostFullBufferS+0x48>
    obqp->notify(obqp);
  201f7a:	4620      	mov	r0, r4
  }
}
  201f7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    obqp->notify(obqp);
  201f80:	4718      	bx	r3
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  201f82:	4802      	ldr	r0, [pc, #8]	; (201f8c <obqPostFullBufferS+0x4c>)
  201f84:	f7fe fdf4 	bl	200b70 <chSysHalt>
}
  201f88:	bd70      	pop	{r4, r5, r6, pc}
  201f8a:	bf00      	nop
  201f8c:	0800c144 	.word	0x0800c144

00201f90 <obqGetFullBufferI>:
                           size_t *sizep) {
  201f90:	b538      	push	{r3, r4, r5, lr}
  201f92:	4604      	mov	r4, r0
  201f94:	460d      	mov	r5, r1
  osalDbgCheckClassI();
  201f96:	f7fe fefb 	bl	200d90 <chDbgCheckClassI>
  if (obqIsEmptyI(obqp)) {
  201f9a:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
  201f9e:	4282      	cmp	r2, r0
  201fa0:	d003      	beq.n	201faa <obqGetFullBufferI+0x1a>
  *sizep = *((size_t *)obqp->brdptr);
  201fa2:	f850 3b04 	ldr.w	r3, [r0], #4
  201fa6:	602b      	str	r3, [r5, #0]
}
  201fa8:	bd38      	pop	{r3, r4, r5, pc}
  if (obqIsEmptyI(obqp)) {
  201faa:	68e2      	ldr	r2, [r4, #12]
  201fac:	2a00      	cmp	r2, #0
  201fae:	d0f8      	beq.n	201fa2 <obqGetFullBufferI+0x12>
    return NULL;
  201fb0:	2000      	movs	r0, #0
}
  201fb2:	bd38      	pop	{r3, r4, r5, pc}
	...

00201fc0 <obnotify>:
static void obnotify(io_buffers_queue_t *bqp) {
  201fc0:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
  201fc2:	6b44      	ldr	r4, [r0, #52]	; 0x34
static void obnotify(io_buffers_queue_t *bqp) {
  201fc4:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  201fc6:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
  201fca:	6813      	ldr	r3, [r2, #0]
  201fcc:	7819      	ldrb	r1, [r3, #0]
  201fce:	2904      	cmp	r1, #4
  201fd0:	d001      	beq.n	201fd6 <obnotify+0x16>
}
  201fd2:	b002      	add	sp, #8
  201fd4:	bd10      	pop	{r4, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  201fd6:	7a21      	ldrb	r1, [r4, #8]
  201fd8:	2902      	cmp	r1, #2
  201fda:	d1fa      	bne.n	201fd2 <obnotify+0x12>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  201fdc:	7910      	ldrb	r0, [r2, #4]
  201fde:	2201      	movs	r2, #1
  201fe0:	8919      	ldrh	r1, [r3, #8]
  201fe2:	fa02 f300 	lsl.w	r3, r2, r0
  201fe6:	420b      	tst	r3, r1
  201fe8:	d1f3      	bne.n	201fd2 <obnotify+0x12>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  201fea:	a901      	add	r1, sp, #4
  201fec:	f104 0044 	add.w	r0, r4, #68	; 0x44
  201ff0:	f7ff ffce 	bl	201f90 <obqGetFullBufferI>
    if (buf != NULL) {
  201ff4:	2800      	cmp	r0, #0
  201ff6:	d0ec      	beq.n	201fd2 <obnotify+0x12>
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  201ff8:	f8d4 448c 	ldr.w	r4, [r4, #1164]	; 0x48c
  201ffc:	4602      	mov	r2, r0
  201ffe:	9b01      	ldr	r3, [sp, #4]
  202000:	7921      	ldrb	r1, [r4, #4]
  202002:	6820      	ldr	r0, [r4, #0]
  202004:	f7ff fddc 	bl	201bc0 <usbStartTransmitI>
  202008:	e7e3      	b.n	201fd2 <obnotify+0x12>
  20200a:	bf00      	nop
  20200c:	0000      	movs	r0, r0
	...

00202010 <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
  202010:	b510      	push	{r4, lr}
  202012:	b082      	sub	sp, #8
  __ASM volatile ("cpsid i" : : : "memory");
  202014:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202016:	2320      	movs	r3, #32
  202018:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20201c:	b662      	cpsie	i
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  20201e:	4c24      	ldr	r4, [pc, #144]	; (2020b0 <sof_handler+0xa0>)
  _dbg_check_lock_from_isr();
  202020:	f7ff f94e 	bl	2012c0 <_dbg_check_lock_from_isr>
  202024:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
  202028:	6813      	ldr	r3, [r2, #0]
  20202a:	7819      	ldrb	r1, [r3, #0]
  20202c:	2904      	cmp	r1, #4
  20202e:	d006      	beq.n	20203e <sof_handler+0x2e>
  _dbg_check_unlock_from_isr();
  202030:	f7ff f92e 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202034:	2300      	movs	r3, #0
  202036:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&PORTAB_SDU1);
  osalSysUnlockFromISR();
}
  20203a:	b002      	add	sp, #8
  20203c:	bd10      	pop	{r4, pc}
  20203e:	7a21      	ldrb	r1, [r4, #8]
  202040:	2902      	cmp	r1, #2
  202042:	d1f5      	bne.n	202030 <sof_handler+0x20>
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  202044:	7910      	ldrb	r0, [r2, #4]
  202046:	2201      	movs	r2, #1
  202048:	8919      	ldrh	r1, [r3, #8]
  20204a:	fa02 f300 	lsl.w	r3, r2, r0
  20204e:	420b      	tst	r3, r1
  202050:	d1ee      	bne.n	202030 <sof_handler+0x20>
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
  202052:	f7fe fe9d 	bl	200d90 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
  202056:	e9d4 3215 	ldrd	r3, r2, [r4, #84]	; 0x54
  20205a:	4293      	cmp	r3, r2
  20205c:	d1e8      	bne.n	202030 <sof_handler+0x20>
  20205e:	6d22      	ldr	r2, [r4, #80]	; 0x50
  202060:	2a00      	cmp	r2, #0
  202062:	d0e5      	beq.n	202030 <sof_handler+0x20>
  202064:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  202066:	2a00      	cmp	r2, #0
  202068:	d0e2      	beq.n	202030 <sof_handler+0x20>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
  20206a:	3a04      	subs	r2, #4

    if (size > 0U) {
  20206c:	1ad2      	subs	r2, r2, r3
  20206e:	d0df      	beq.n	202030 <sof_handler+0x20>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
  202070:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
  202072:	6e20      	ldr	r0, [r4, #96]	; 0x60
      obqp->bcounter--;
  202074:	6d22      	ldr	r2, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
  202076:	4403      	add	r3, r0
      if (obqp->bwrptr >= obqp->btop) {
  202078:	6de1      	ldr	r1, [r4, #92]	; 0x5c
      obqp->bcounter--;
  20207a:	3a01      	subs	r2, #1
      if (obqp->bwrptr >= obqp->btop) {
  20207c:	428b      	cmp	r3, r1
      obqp->bwrptr += obqp->bsize;
  20207e:	6563      	str	r3, [r4, #84]	; 0x54
      obqp->bcounter--;
  202080:	6522      	str	r2, [r4, #80]	; 0x50
      if (obqp->bwrptr >= obqp->btop) {
  202082:	d301      	bcc.n	202088 <sof_handler+0x78>
        obqp->bwrptr = obqp->buffers;
  202084:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  202086:	6563      	str	r3, [r4, #84]	; 0x54
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
  202088:	2300      	movs	r3, #0
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  20208a:	a901      	add	r1, sp, #4
  20208c:	4809      	ldr	r0, [pc, #36]	; (2020b4 <sof_handler+0xa4>)
  20208e:	66e3      	str	r3, [r4, #108]	; 0x6c
  202090:	f7ff ff7e 	bl	201f90 <obqGetFullBufferI>
    osalDbgAssert(buf != NULL, "queue is empty");
  202094:	b140      	cbz	r0, 2020a8 <sof_handler+0x98>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  202096:	f8d4 448c 	ldr.w	r4, [r4, #1164]	; 0x48c
  20209a:	4602      	mov	r2, r0
  20209c:	9b01      	ldr	r3, [sp, #4]
  20209e:	7921      	ldrb	r1, [r4, #4]
  2020a0:	6820      	ldr	r0, [r4, #0]
  2020a2:	f7ff fd8d 	bl	201bc0 <usbStartTransmitI>
  2020a6:	e7c3      	b.n	202030 <sof_handler+0x20>
    osalDbgAssert(buf != NULL, "queue is empty");
  2020a8:	4803      	ldr	r0, [pc, #12]	; (2020b8 <sof_handler+0xa8>)
  2020aa:	f7fe fd61 	bl	200b70 <chSysHalt>
  2020ae:	bf00      	nop
  2020b0:	20000800 	.word	0x20000800
  2020b4:	20000844 	.word	0x20000844
  2020b8:	0800c020 	.word	0x0800c020
  2020bc:	00000000 	.word	0x00000000

002020c0 <sduDataTransmitted>:
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
  2020c0:	f101 030b 	add.w	r3, r1, #11
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  2020c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
  2020c8:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  2020cc:	b082      	sub	sp, #8
  if (sdup == NULL) {
  2020ce:	b324      	cbz	r4, 20211a <sduDataTransmitted+0x5a>
  2020d0:	4606      	mov	r6, r0
  2020d2:	460d      	mov	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
  2020d4:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2020d6:	2320      	movs	r3, #32
  2020d8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2020dc:	b662      	cpsie	i
  2020de:	eb00 0781 	add.w	r7, r0, r1, lsl #2
  2020e2:	f104 0844 	add.w	r8, r4, #68	; 0x44
  _dbg_check_lock_from_isr();
  2020e6:	f7ff f8eb 	bl	2012c0 <_dbg_check_lock_from_isr>
  chEvtBroadcastFlagsI(esp, flags);
  2020ea:	1d20      	adds	r0, r4, #4
  2020ec:	2108      	movs	r1, #8
  2020ee:	f7fe ffb7 	bl	201060 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
  2020f2:	68fb      	ldr	r3, [r7, #12]
  2020f4:	695b      	ldr	r3, [r3, #20]
  2020f6:	681b      	ldr	r3, [r3, #0]
  2020f8:	bb13      	cbnz	r3, 202140 <sduDataTransmitted+0x80>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
  2020fa:	4640      	mov	r0, r8
  2020fc:	a901      	add	r1, sp, #4
  2020fe:	f7ff ff47 	bl	201f90 <obqGetFullBufferI>
  if (buf != NULL) {
  202102:	b168      	cbz	r0, 202120 <sduDataTransmitted+0x60>
    usbStartTransmitI(usbp, ep, buf, n);
  202104:	4602      	mov	r2, r0
  202106:	4629      	mov	r1, r5
  202108:	4630      	mov	r0, r6
  20210a:	9b01      	ldr	r3, [sp, #4]
  20210c:	f7ff fd58 	bl	201bc0 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
  202110:	f7ff f8be 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202114:	2300      	movs	r3, #0
  202116:	f383 8811 	msr	BASEPRI, r3
}
  20211a:	b002      	add	sp, #8
  20211c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
  202120:	68fb      	ldr	r3, [r7, #12]
  202122:	695a      	ldr	r2, [r3, #20]
  202124:	6812      	ldr	r2, [r2, #0]
  202126:	2a00      	cmp	r2, #0
  202128:	d0f2      	beq.n	202110 <sduDataTransmitted+0x50>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
  20212a:	8a1b      	ldrh	r3, [r3, #16]
  20212c:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
  20212e:	4013      	ands	r3, r2
  202130:	d1ee      	bne.n	202110 <sduDataTransmitted+0x50>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
  202132:	4629      	mov	r1, r5
  202134:	f106 0280 	add.w	r2, r6, #128	; 0x80
  202138:	4630      	mov	r0, r6
  20213a:	f7ff fd41 	bl	201bc0 <usbStartTransmitI>
  20213e:	e7e7      	b.n	202110 <sduDataTransmitted+0x50>
  osalDbgCheckClassI();
  202140:	f7fe fe26 	bl	200d90 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
  202144:	e9d4 2315 	ldrd	r2, r3, [r4, #84]	; 0x54
  202148:	429a      	cmp	r2, r3
  20214a:	d00e      	beq.n	20216a <sduDataTransmitted+0xaa>
  obqp->brdptr += obqp->bsize;
  20214c:	6e21      	ldr	r1, [r4, #96]	; 0x60
  obqp->bcounter++;
  20214e:	6d22      	ldr	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
  202150:	440b      	add	r3, r1
  if (obqp->brdptr >= obqp->btop) {
  202152:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  obqp->bcounter++;
  202154:	3201      	adds	r2, #1
  if (obqp->brdptr >= obqp->btop) {
  202156:	428b      	cmp	r3, r1
  obqp->brdptr += obqp->bsize;
  202158:	65a3      	str	r3, [r4, #88]	; 0x58
  obqp->bcounter++;
  20215a:	6522      	str	r2, [r4, #80]	; 0x50
  if (obqp->brdptr >= obqp->btop) {
  20215c:	d301      	bcc.n	202162 <sduDataTransmitted+0xa2>
    obqp->brdptr = obqp->buffers;
  20215e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  202160:	65a3      	str	r3, [r4, #88]	; 0x58
  chThdDequeueNextI(tqp, msg);
  202162:	4640      	mov	r0, r8
  202164:	f7fe feec 	bl	200f40 <chThdDequeueNextI.constprop.80>
  202168:	e7c7      	b.n	2020fa <sduDataTransmitted+0x3a>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
  20216a:	6d22      	ldr	r2, [r4, #80]	; 0x50
  20216c:	2a00      	cmp	r2, #0
  20216e:	d0ed      	beq.n	20214c <sduDataTransmitted+0x8c>
  202170:	4801      	ldr	r0, [pc, #4]	; (202178 <sduDataTransmitted+0xb8>)
  202172:	f7fe fcfd 	bl	200b70 <chSysHalt>
  202176:	bf00      	nop
  202178:	0800c0e8 	.word	0x0800c0e8
  20217c:	00000000 	.word	0x00000000

00202180 <ibqReleaseEmptyBufferS>:
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
  202180:	b510      	push	{r4, lr}
  202182:	4604      	mov	r4, r0
  osalDbgCheckClassS();
  202184:	f7fe fdf4 	bl	200d70 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
  202188:	68e3      	ldr	r3, [r4, #12]
  20218a:	b19b      	cbz	r3, 2021b4 <ibqReleaseEmptyBufferS+0x34>
  ibqp->brdptr += ibqp->bsize;
  20218c:	6963      	ldr	r3, [r4, #20]
  20218e:	69e0      	ldr	r0, [r4, #28]
  ibqp->bcounter--;
  202190:	68e2      	ldr	r2, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
  202192:	4403      	add	r3, r0
  if (ibqp->brdptr >= ibqp->btop) {
  202194:	69a1      	ldr	r1, [r4, #24]
  ibqp->bcounter--;
  202196:	3a01      	subs	r2, #1
  if (ibqp->brdptr >= ibqp->btop) {
  202198:	428b      	cmp	r3, r1
  ibqp->brdptr += ibqp->bsize;
  20219a:	6163      	str	r3, [r4, #20]
  ibqp->bcounter--;
  20219c:	60e2      	str	r2, [r4, #12]
  if (ibqp->brdptr >= ibqp->btop) {
  20219e:	d301      	bcc.n	2021a4 <ibqReleaseEmptyBufferS+0x24>
    ibqp->brdptr = ibqp->buffers;
  2021a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
  2021a2:	6163      	str	r3, [r4, #20]
  ibqp->ptr = NULL;
  2021a4:	2200      	movs	r2, #0
  if (ibqp->notify != NULL) {
  2021a6:	6b23      	ldr	r3, [r4, #48]	; 0x30
  ibqp->ptr = NULL;
  2021a8:	62a2      	str	r2, [r4, #40]	; 0x28
  if (ibqp->notify != NULL) {
  2021aa:	b133      	cbz	r3, 2021ba <ibqReleaseEmptyBufferS+0x3a>
    ibqp->notify(ibqp);
  2021ac:	4620      	mov	r0, r4
}
  2021ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ibqp->notify(ibqp);
  2021b2:	4718      	bx	r3
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
  2021b4:	4801      	ldr	r0, [pc, #4]	; (2021bc <ibqReleaseEmptyBufferS+0x3c>)
  2021b6:	f7fe fcdb 	bl	200b70 <chSysHalt>
}
  2021ba:	bd10      	pop	{r4, pc}
  2021bc:	0800c05c 	.word	0x0800c05c

002021c0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
  2021c0:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
  2021c2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  2021c6:	68da      	ldr	r2, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
  2021c8:	0792      	lsls	r2, r2, #30
  2021ca:	d501      	bpl.n	2021d0 <stSetAlarm+0x10>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  2021cc:	6358      	str	r0, [r3, #52]	; 0x34

  st_lld_set_alarm(abstime);
}
  2021ce:	bd08      	pop	{r3, pc}
  osalDbgAssert(stIsAlarmActive() != false, "not active");
  2021d0:	4801      	ldr	r0, [pc, #4]	; (2021d8 <stSetAlarm+0x18>)
  2021d2:	f7fe fccd 	bl	200b70 <chSysHalt>
  2021d6:	bf00      	nop
  2021d8:	0800c000 	.word	0x0800c000
  2021dc:	00000000 	.word	0x00000000

002021e0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
  2021e0:	b538      	push	{r3, r4, r5, lr}
  2021e2:	4604      	mov	r4, r0

  chDbgCheckClassI();
  2021e4:	f7fe fdd4 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
  2021e8:	68e3      	ldr	r3, [r4, #12]
  2021ea:	2b00      	cmp	r3, #0
  2021ec:	d02f      	beq.n	20224e <chVTDoResetI+0x6e>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
  2021ee:	4b1b      	ldr	r3, [pc, #108]	; (20225c <chVTDoResetI+0x7c>)
  2021f0:	69da      	ldr	r2, [r3, #28]
  2021f2:	42a2      	cmp	r2, r4
  2021f4:	d00e      	beq.n	202214 <chVTDoResetI+0x34>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
  2021f6:	6822      	ldr	r2, [r4, #0]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
  2021f8:	331c      	adds	r3, #28
    vtp->prev->next = vtp->next;
  2021fa:	6861      	ldr	r1, [r4, #4]
    vtp->func = NULL;
  2021fc:	2000      	movs	r0, #0
    vtp->prev->next = vtp->next;
  2021fe:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
  202200:	6822      	ldr	r2, [r4, #0]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
  202202:	429a      	cmp	r2, r3
    vtp->next->prev = vtp->prev;
  202204:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
  202206:	60e0      	str	r0, [r4, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
  202208:	d003      	beq.n	202212 <chVTDoResetI+0x32>
      vtp->next->delta += vtp->delta;
  20220a:	68a1      	ldr	r1, [r4, #8]
  20220c:	6893      	ldr	r3, [r2, #8]
  20220e:	440b      	add	r3, r1
  202210:	6093      	str	r3, [r2, #8]
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
  202212:	bd38      	pop	{r3, r4, r5, pc}
  ch.vtlist.next = vtp->next;
  202214:	6811      	ldr	r1, [r2, #0]
  202216:	4618      	mov	r0, r3
  vtp->func = NULL;
  202218:	2400      	movs	r4, #0
  ch.vtlist.next = vtp->next;
  20221a:	f840 1f1c 	str.w	r1, [r0, #28]!
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  20221e:	4281      	cmp	r1, r0
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  202220:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
  202222:	60d4      	str	r4, [r2, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  202224:	d016      	beq.n	202254 <chVTDoResetI+0x74>
  ch.vtlist.next->delta += vtp->delta;
  202226:	6895      	ldr	r5, [r2, #8]
  return (systime_t)STM32_ST_TIM->CNT;
  202228:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  20222c:	688a      	ldr	r2, [r1, #8]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
  20222e:	6a98      	ldr	r0, [r3, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
  202230:	4415      	add	r5, r2
  202232:	608d      	str	r5, [r1, #8]
  202234:	6a62      	ldr	r2, [r4, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
  202236:	1a12      	subs	r2, r2, r0
  if (nowdelta >= ch.vtlist.next->delta) {
  202238:	4295      	cmp	r5, r2
  20223a:	d9ea      	bls.n	202212 <chVTDoResetI+0x32>
  delta = ch.vtlist.next->delta - nowdelta;
  20223c:	1aa9      	subs	r1, r5, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
  20223e:	2901      	cmp	r1, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
  202240:	bf98      	it	ls
  202242:	1c95      	addls	r5, r2, #2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
  202244:	4428      	add	r0, r5
}
  202246:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  20224a:	f7ff bfb9 	b.w	2021c0 <stSetAlarm>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
  20224e:	4804      	ldr	r0, [pc, #16]	; (202260 <chVTDoResetI+0x80>)
  202250:	f7fe fc8e 	bl	200b70 <chSysHalt>
  STM32_ST_TIM->DIER = 0;
  202254:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  202258:	60dc      	str	r4, [r3, #12]
}
  20225a:	bd38      	pop	{r3, r4, r5, pc}
  20225c:	20000dc8 	.word	0x20000dc8
  202260:	0800bdf4 	.word	0x0800bdf4
	...

00202270 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
  202270:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  202274:	460c      	mov	r4, r1
  202276:	4606      	mov	r6, r0
  202278:	4615      	mov	r5, r2
  20227a:	4698      	mov	r8, r3
  chDbgCheckClassI();
  20227c:	f7fe fd88 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
  202280:	b364      	cbz	r4, 2022dc <chVTDoSetI+0x6c>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  202282:	4f26      	ldr	r7, [pc, #152]	; (20231c <chVTDoSetI+0xac>)
  202284:	2c02      	cmp	r4, #2
  vtp->func = vtfunc;
  202286:	60f5      	str	r5, [r6, #12]
  return (systime_t)STM32_ST_TIM->CNT;
  202288:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  20228c:	463b      	mov	r3, r7
  20228e:	bf38      	it	cc
  202290:	2402      	movcc	r4, #2
  vtp->par = par;
  202292:	f8c6 8010 	str.w	r8, [r6, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  202296:	f853 5f1c 	ldr.w	r5, [r3, #28]!
  20229a:	6a51      	ldr	r1, [r2, #36]	; 0x24
  20229c:	429d      	cmp	r5, r3
  20229e:	d024      	beq.n	2022ea <chVTDoSetI+0x7a>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
  2022a0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  2022a2:	68ab      	ldr	r3, [r5, #8]
  2022a4:	1a09      	subs	r1, r1, r0
  2022a6:	1864      	adds	r4, r4, r1
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
  2022a8:	d21b      	bcs.n	2022e2 <chVTDoSetI+0x72>
    else if (delta < p->delta) {
  2022aa:	42a3      	cmp	r3, r4
  2022ac:	d830      	bhi.n	202310 <chVTDoSetI+0xa0>
  while (p->delta < delta) {
  2022ae:	429c      	cmp	r4, r3
  2022b0:	d906      	bls.n	2022c0 <chVTDoSetI+0x50>
    chDbgAssert(p != vtp, "timer already armed");
  2022b2:	42ae      	cmp	r6, r5
  2022b4:	d012      	beq.n	2022dc <chVTDoSetI+0x6c>
    p = p->next;
  2022b6:	682d      	ldr	r5, [r5, #0]
    delta -= p->delta;
  2022b8:	1ae4      	subs	r4, r4, r3
  while (p->delta < delta) {
  2022ba:	68ab      	ldr	r3, [r5, #8]
  2022bc:	42a3      	cmp	r3, r4
  2022be:	d3f8      	bcc.n	2022b2 <chVTDoSetI+0x42>
  vtp->prev = vtp->next->prev;
  2022c0:	686b      	ldr	r3, [r5, #4]
  ch.vtlist.delta = (sysinterval_t)-1;
  2022c2:	f04f 32ff 	mov.w	r2, #4294967295
  vtp->prev = vtp->next->prev;
  2022c6:	e9c6 5300 	strd	r5, r3, [r6]
  vtp->prev->next = vtp;
  2022ca:	601e      	str	r6, [r3, #0]
  p->prev = vtp;
  2022cc:	606e      	str	r6, [r5, #4]
  vtp->delta = delta;
  2022ce:	60b4      	str	r4, [r6, #8]
  p->delta -= delta;
  2022d0:	68ab      	ldr	r3, [r5, #8]
  2022d2:	1b1c      	subs	r4, r3, r4
  2022d4:	60ac      	str	r4, [r5, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
  2022d6:	627a      	str	r2, [r7, #36]	; 0x24
}
  2022d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
  2022dc:	4810      	ldr	r0, [pc, #64]	; (202320 <chVTDoSetI+0xb0>)
  2022de:	f7fe fc47 	bl	200b70 <chSysHalt>
      p = p->next;
  2022e2:	682d      	ldr	r5, [r5, #0]
      delta -= p->delta;
  2022e4:	1ae4      	subs	r4, r4, r3
  2022e6:	68ab      	ldr	r3, [r5, #8]
  2022e8:	e7e1      	b.n	2022ae <chVTDoSetI+0x3e>
      ch.vtlist.lasttime = now;
  2022ea:	62b9      	str	r1, [r7, #40]	; 0x28
      ch.vtlist.prev = vtp;
  2022ec:	e9c7 6607 	strd	r6, r6, [r7, #28]
      vtp->delta = delay;
  2022f0:	60b4      	str	r4, [r6, #8]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
  2022f2:	68d3      	ldr	r3, [r2, #12]
  osalDbgAssert(stIsAlarmActive() == false, "already active");
  2022f4:	f013 0302 	ands.w	r3, r3, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
  2022f8:	e9c6 5500 	strd	r5, r5, [r6]
  2022fc:	d105      	bne.n	20230a <chVTDoSetI+0x9a>
  return systime + (systime_t)interval;
  2022fe:	440c      	add	r4, r1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
  202300:	2102      	movs	r1, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  202302:	6354      	str	r4, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
  202304:	6113      	str	r3, [r2, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
  202306:	60d1      	str	r1, [r2, #12]
  202308:	e7e6      	b.n	2022d8 <chVTDoSetI+0x68>
  20230a:	4806      	ldr	r0, [pc, #24]	; (202324 <chVTDoSetI+0xb4>)
  20230c:	f7fe fc30 	bl	200b70 <chSysHalt>
  202310:	4420      	add	r0, r4
  202312:	f7ff ff55 	bl	2021c0 <stSetAlarm>
  202316:	68ab      	ldr	r3, [r5, #8]
  202318:	e7c9      	b.n	2022ae <chVTDoSetI+0x3e>
  20231a:	bf00      	nop
  20231c:	20000dc8 	.word	0x20000dc8
  202320:	0800bd74 	.word	0x0800bd74
  202324:	0800bff0 	.word	0x0800bff0
	...

00202330 <chCondSignalI.constprop.50>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
  202330:	b510      	push	{r4, lr}

  chDbgCheckClassI();
  202332:	f7fe fd2d 	bl	200d90 <chDbgCheckClassI>
  return (bool)(tqp->next != (const thread_t *)tqp);
  202336:	4b07      	ldr	r3, [pc, #28]	; (202354 <chCondSignalI.constprop.50+0x24>)
  202338:	681a      	ldr	r2, [r3, #0]
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
  20233a:	429a      	cmp	r2, r3
  20233c:	d009      	beq.n	202352 <chCondSignalI.constprop.50+0x22>
  tqp->next             = tp->queue.next;
  20233e:	6811      	ldr	r1, [r2, #0]
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
  202340:	2400      	movs	r4, #0
    (void) chSchReadyI(tp);
  202342:	4610      	mov	r0, r2
  tqp->next->queue.prev = (thread_t *)tqp;
  202344:	604b      	str	r3, [r1, #4]
  tqp->next             = tp->queue.next;
  202346:	6019      	str	r1, [r3, #0]
    tp->u.rdymsg = MSG_OK;
  202348:	6254      	str	r4, [r2, #36]	; 0x24
  }
}
  20234a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    (void) chSchReadyI(tp);
  20234e:	f7fe bdcf 	b.w	200ef0 <chSchReadyI>
}
  202352:	bd10      	pop	{r4, pc}
  202354:	20010404 	.word	0x20010404
	...

00202360 <chMBResetI.constprop.30>:
void chMBResetI(mailbox_t *mbp) {
  202360:	b510      	push	{r4, lr}
  mbp->wrptr = mbp->buffer;
  202362:	4c0a      	ldr	r4, [pc, #40]	; (20238c <chMBResetI.constprop.30+0x2c>)
  chDbgCheckClassI();
  202364:	f7fe fd14 	bl	200d90 <chDbgCheckClassI>
  mbp->cnt   = (size_t)0;
  202368:	2100      	movs	r1, #0
  mbp->reset = true;
  20236a:	2201      	movs	r2, #1
  mbp->wrptr = mbp->buffer;
  20236c:	6823      	ldr	r3, [r4, #0]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
  20236e:	f104 0018 	add.w	r0, r4, #24
  mbp->cnt   = (size_t)0;
  202372:	6121      	str	r1, [r4, #16]
  mbp->reset = true;
  202374:	7522      	strb	r2, [r4, #20]
  mbp->rdptr = mbp->buffer;
  202376:	e9c4 3302 	strd	r3, r3, [r4, #8]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
  20237a:	f7fe fe21 	bl	200fc0 <chThdDequeueAllI.constprop.82>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
  20237e:	f104 0020 	add.w	r0, r4, #32
}
  202382:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
  202386:	f7fe be1b 	b.w	200fc0 <chThdDequeueAllI.constprop.82>
  20238a:	bf00      	nop
  20238c:	20010458 	.word	0x20010458

00202390 <chMBPostI.constprop.26>:
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
  202390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (mbp->reset) {
  202392:	4c12      	ldr	r4, [pc, #72]	; (2023dc <chMBPostI.constprop.26+0x4c>)
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
  202394:	4607      	mov	r7, r0
  chDbgCheckClassI();
  202396:	f7fe fcfb 	bl	200d90 <chDbgCheckClassI>
  if (mbp->reset) {
  20239a:	7d23      	ldrb	r3, [r4, #20]
  20239c:	b9c3      	cbnz	r3, 2023d0 <chMBPostI.constprop.26+0x40>
 *
 * @iclass
 */
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();
  20239e:	f7fe fcf7 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  2023a2:	f7fe fcf5 	bl	200d90 <chDbgCheckClassI>
  return mbp->cnt;
  2023a6:	6923      	ldr	r3, [r4, #16]
  2023a8:	e9d4 6500 	ldrd	r6, r5, [r4]
  return (size_t)(mbp->top - mbp->buffer);
  2023ac:	1baa      	subs	r2, r5, r6
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  2023ae:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
  2023b2:	d010      	beq.n	2023d6 <chMBPostI.constprop.26+0x46>
    *mbp->wrptr++ = msg;
  2023b4:	68a1      	ldr	r1, [r4, #8]
    mbp->cnt++;
  2023b6:	3301      	adds	r3, #1
    chThdDequeueNextI(&mbp->qr, MSG_OK);
  2023b8:	4809      	ldr	r0, [pc, #36]	; (2023e0 <chMBPostI.constprop.26+0x50>)
    *mbp->wrptr++ = msg;
  2023ba:	1d0a      	adds	r2, r1, #4
    if (mbp->wrptr >= mbp->top) {
  2023bc:	4295      	cmp	r5, r2
    *mbp->wrptr++ = msg;
  2023be:	60a2      	str	r2, [r4, #8]
  2023c0:	600f      	str	r7, [r1, #0]
      mbp->wrptr = mbp->buffer;
  2023c2:	bf98      	it	ls
  2023c4:	60a6      	strls	r6, [r4, #8]
    mbp->cnt++;
  2023c6:	6123      	str	r3, [r4, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
  2023c8:	f7fe fdba 	bl	200f40 <chThdDequeueNextI.constprop.80>
    return MSG_OK;
  2023cc:	2000      	movs	r0, #0
}
  2023ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return MSG_RESET;
  2023d0:	f06f 0001 	mvn.w	r0, #1
}
  2023d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return MSG_TIMEOUT;
  2023d6:	f04f 30ff 	mov.w	r0, #4294967295
}
  2023da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  2023dc:	20010458 	.word	0x20010458
  2023e0:	20010478 	.word	0x20010478
	...

002023f0 <chMBPostAheadI.constprop.23>:
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
  2023f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (mbp->reset) {
  2023f2:	4c12      	ldr	r4, [pc, #72]	; (20243c <chMBPostAheadI.constprop.23+0x4c>)
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
  2023f4:	4607      	mov	r7, r0
  chDbgCheckClassI();
  2023f6:	f7fe fccb 	bl	200d90 <chDbgCheckClassI>
  if (mbp->reset) {
  2023fa:	7d23      	ldrb	r3, [r4, #20]
  2023fc:	b9c3      	cbnz	r3, 202430 <chMBPostAheadI.constprop.23+0x40>
  chDbgCheckClassI();
  2023fe:	f7fe fcc7 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  202402:	f7fe fcc5 	bl	200d90 <chDbgCheckClassI>
  return mbp->cnt;
  202406:	6922      	ldr	r2, [r4, #16]
  202408:	e9d4 5600 	ldrd	r5, r6, [r4]
  return (size_t)(mbp->top - mbp->buffer);
  20240c:	1b73      	subs	r3, r6, r5
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  20240e:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
  202412:	d010      	beq.n	202436 <chMBPostAheadI.constprop.23+0x46>
    if (--mbp->rdptr < mbp->buffer) {
  202414:	68e3      	ldr	r3, [r4, #12]
    mbp->cnt++;
  202416:	3201      	adds	r2, #1
    chThdDequeueNextI(&mbp->qr, MSG_OK);
  202418:	4809      	ldr	r0, [pc, #36]	; (202440 <chMBPostAheadI.constprop.23+0x50>)
    if (--mbp->rdptr < mbp->buffer) {
  20241a:	3b04      	subs	r3, #4
  20241c:	429d      	cmp	r5, r3
      mbp->rdptr = mbp->top - 1;
  20241e:	bf88      	it	hi
  202420:	1f33      	subhi	r3, r6, #4
  202422:	60e3      	str	r3, [r4, #12]
    *mbp->rdptr = msg;
  202424:	601f      	str	r7, [r3, #0]
    mbp->cnt++;
  202426:	6122      	str	r2, [r4, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
  202428:	f7fe fd8a 	bl	200f40 <chThdDequeueNextI.constprop.80>
    return MSG_OK;
  20242c:	2000      	movs	r0, #0
}
  20242e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return MSG_RESET;
  202430:	f06f 0001 	mvn.w	r0, #1
}
  202434:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return MSG_TIMEOUT;
  202436:	f04f 30ff 	mov.w	r0, #4294967295
}
  20243a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  20243c:	20010458 	.word	0x20010458
  202440:	20010478 	.word	0x20010478
	...

00202450 <rt_test_010_012_execute>:
 * - [10.12.8] The size of an event listener is printed.
 * - [10.12.9] The size of a mailbox is printed.
 * .
 */

static void rt_test_010_012_execute(void) {
  202450:	b570      	push	{r4, r5, r6, lr}

  /* [10.12.1] The size of the system area is printed.*/
  test_set_step(1);
  202452:	2301      	movs	r3, #1
  202454:	4d33      	ldr	r5, [pc, #204]	; (202524 <rt_test_010_012_execute+0xd4>)
  {
    test_print("--- System: ");
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
  202456:	4c34      	ldr	r4, [pc, #208]	; (202528 <rt_test_010_012_execute+0xd8>)
    test_printn(sizeof(virtual_timer_t));
    test_println(" bytes");
  }

  /* [10.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
  202458:	2604      	movs	r6, #4
    test_print("--- System: ");
  20245a:	4834      	ldr	r0, [pc, #208]	; (20252c <rt_test_010_012_execute+0xdc>)
  test_set_step(1);
  20245c:	602b      	str	r3, [r5, #0]
    test_print("--- System: ");
  20245e:	f7fe fa37 	bl	2008d0 <test_print>
  202462:	f640 0088 	movw	r0, #2184	; 0x888
  202466:	f7fe f9d3 	bl	200810 <test_printn.part.0>
    test_println(" bytes");
  20246a:	4620      	mov	r0, r4
  20246c:	f7fe fa10 	bl	200890 <test_println>
  test_set_step(2);
  202470:	2302      	movs	r3, #2
    test_print("--- Thread: ");
  202472:	482f      	ldr	r0, [pc, #188]	; (202530 <rt_test_010_012_execute+0xe0>)
  test_set_step(2);
  202474:	602b      	str	r3, [r5, #0]
    test_print("--- Thread: ");
  202476:	f7fe fa2b 	bl	2008d0 <test_print>
  20247a:	2044      	movs	r0, #68	; 0x44
  20247c:	f7fe f9c8 	bl	200810 <test_printn.part.0>
    test_println(" bytes");
  202480:	4620      	mov	r0, r4
  202482:	f7fe fa05 	bl	200890 <test_println>
  test_set_step(3);
  202486:	2303      	movs	r3, #3
    test_print("--- Timer : ");
  202488:	482a      	ldr	r0, [pc, #168]	; (202534 <rt_test_010_012_execute+0xe4>)
  test_set_step(3);
  20248a:	602b      	str	r3, [r5, #0]
    test_print("--- Timer : ");
  20248c:	f7fe fa20 	bl	2008d0 <test_print>
  202490:	2014      	movs	r0, #20
  202492:	f7fe f9bd 	bl	200810 <test_printn.part.0>
    test_println(" bytes");
  202496:	4620      	mov	r0, r4
  202498:	f7fe f9fa 	bl	200890 <test_println>
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
  20249c:	4826      	ldr	r0, [pc, #152]	; (202538 <rt_test_010_012_execute+0xe8>)
  test_set_step(4);
  20249e:	602e      	str	r6, [r5, #0]
    test_print("--- Semaph: ");
  2024a0:	f7fe fa16 	bl	2008d0 <test_print>
  2024a4:	200c      	movs	r0, #12
  2024a6:	f7fe f9b3 	bl	200810 <test_printn.part.0>
    test_printn(sizeof(semaphore_t));
    test_println(" bytes");
  2024aa:	4620      	mov	r0, r4
  2024ac:	f7fe f9f0 	bl	200890 <test_println>
#endif
  }

  /* [10.12.5] The size of a mutex is printed.*/
  test_set_step(5);
  2024b0:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
  2024b2:	4822      	ldr	r0, [pc, #136]	; (20253c <rt_test_010_012_execute+0xec>)
  test_set_step(5);
  2024b4:	602b      	str	r3, [r5, #0]
    test_print("--- Mutex : ");
  2024b6:	f7fe fa0b 	bl	2008d0 <test_print>
  2024ba:	2010      	movs	r0, #16
  2024bc:	f7fe f9a8 	bl	200810 <test_printn.part.0>
    test_printn(sizeof(mutex_t));
    test_println(" bytes");
  2024c0:	4620      	mov	r0, r4
  2024c2:	f7fe f9e5 	bl	200890 <test_println>
#endif
  }

  /* [10.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
  2024c6:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
  2024c8:	481d      	ldr	r0, [pc, #116]	; (202540 <rt_test_010_012_execute+0xf0>)
  test_set_step(6);
  2024ca:	602b      	str	r3, [r5, #0]
    test_print("--- CondV.: ");
  2024cc:	f7fe fa00 	bl	2008d0 <test_print>
  2024d0:	2008      	movs	r0, #8
  2024d2:	f7fe f99d 	bl	200810 <test_printn.part.0>
    test_printn(sizeof(condition_variable_t));
    test_println(" bytes");
  2024d6:	4620      	mov	r0, r4
  2024d8:	f7fe f9da 	bl	200890 <test_println>
#endif
  }

  /* [10.12.7] The size of an event source is printed.*/
  test_set_step(7);
  2024dc:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
  2024de:	4819      	ldr	r0, [pc, #100]	; (202544 <rt_test_010_012_execute+0xf4>)
  test_set_step(7);
  2024e0:	602b      	str	r3, [r5, #0]
    test_print("--- EventS: ");
  2024e2:	f7fe f9f5 	bl	2008d0 <test_print>
  2024e6:	4630      	mov	r0, r6
  2024e8:	f7fe f992 	bl	200810 <test_printn.part.0>
    test_printn(sizeof(event_source_t));
    test_println(" bytes");
  2024ec:	4620      	mov	r0, r4
  2024ee:	f7fe f9cf 	bl	200890 <test_println>
#endif
  }

  /* [10.12.8] The size of an event listener is printed.*/
  test_set_step(8);
  2024f2:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
  2024f4:	4814      	ldr	r0, [pc, #80]	; (202548 <rt_test_010_012_execute+0xf8>)
  test_set_step(8);
  2024f6:	602b      	str	r3, [r5, #0]
    test_print("--- EventL: ");
  2024f8:	f7fe f9ea 	bl	2008d0 <test_print>
  2024fc:	2014      	movs	r0, #20
  2024fe:	f7fe f987 	bl	200810 <test_printn.part.0>
    test_printn(sizeof(event_listener_t));
    test_println(" bytes");
  202502:	4620      	mov	r0, r4
  202504:	f7fe f9c4 	bl	200890 <test_println>
#endif
  }

  /* [10.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
  202508:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
  20250a:	4810      	ldr	r0, [pc, #64]	; (20254c <rt_test_010_012_execute+0xfc>)
  test_set_step(9);
  20250c:	602b      	str	r3, [r5, #0]
    test_print("--- MailB.: ");
  20250e:	f7fe f9df 	bl	2008d0 <test_print>
  202512:	2028      	movs	r0, #40	; 0x28
  202514:	f7fe f97c 	bl	200810 <test_printn.part.0>
    test_printn(sizeof(mailbox_t));
    test_println(" bytes");
  202518:	4620      	mov	r0, r4
#endif
  }
}
  20251a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_println(" bytes");
  20251e:	f7fe b9b7 	b.w	200890 <test_println>
  202522:	bf00      	nop
  202524:	20001f6c 	.word	0x20001f6c
  202528:	0800daec 	.word	0x0800daec
  20252c:	0800dadc 	.word	0x0800dadc
  202530:	0800daf4 	.word	0x0800daf4
  202534:	0800db04 	.word	0x0800db04
  202538:	0800db14 	.word	0x0800db14
  20253c:	0800db24 	.word	0x0800db24
  202540:	0800db34 	.word	0x0800db34
  202544:	0800db44 	.word	0x0800db44
  202548:	0800db54 	.word	0x0800db54
  20254c:	0800db64 	.word	0x0800db64

00202550 <rt_test_010_011_setup>:
  tqp->next = (thread_t *)tqp;
  202550:	4b02      	ldr	r3, [pc, #8]	; (20255c <rt_test_010_011_setup+0xc>)
  mp->owner = NULL;
  202552:	2200      	movs	r2, #0
  tqp->prev = (thread_t *)tqp;
  202554:	e9c3 3300 	strd	r3, r3, [r3]
  202558:	609a      	str	r2, [r3, #8]
}
  20255a:	4770      	bx	lr
  20255c:	20001818 	.word	0x20001818

00202560 <rt_test_008_002_execute>:

static void rt_test_008_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void rt_test_008_002_execute(void) {
  202560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
  202562:	2301      	movs	r3, #1
  202564:	4a10      	ldr	r2, [pc, #64]	; (2025a8 <rt_test_008_002_execute+0x48>)
  202566:	2507      	movs	r5, #7
  202568:	2400      	movs	r4, #0

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
  20256a:	461f      	mov	r7, r3
  20256c:	4e0f      	ldr	r6, [pc, #60]	; (2025ac <rt_test_008_002_execute+0x4c>)
  20256e:	6013      	str	r3, [r2, #0]
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
  202570:	fa25 f304 	lsr.w	r3, r5, r4
  202574:	07db      	lsls	r3, r3, #31
  202576:	d511      	bpl.n	20259c <rt_test_008_002_execute+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
  202578:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
  20257c:	b182      	cbz	r2, 2025a0 <rt_test_008_002_execute+0x40>
      events &= ~EVENT_MASK(eid);
  20257e:	fa07 f304 	lsl.w	r3, r7, r4
      handlers[eid](eid);
  202582:	4620      	mov	r0, r4
      events &= ~EVENT_MASK(eid);
  202584:	3401      	adds	r4, #1
  202586:	ea25 0503 	bic.w	r5, r5, r3
      handlers[eid](eid);
  20258a:	4790      	blx	r2
  while (events != (eventmask_t)0) {
  20258c:	2d00      	cmp	r5, #0
  20258e:	d1ef      	bne.n	202570 <rt_test_008_002_execute+0x10>
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
  202590:	4907      	ldr	r1, [pc, #28]	; (2025b0 <rt_test_008_002_execute+0x50>)
  202592:	4808      	ldr	r0, [pc, #32]	; (2025b4 <rt_test_008_002_execute+0x54>)
  }
}
  202594:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
  202598:	f7fe b9b2 	b.w	200900 <_test_assert_sequence>
    }
    eid++;
  20259c:	3401      	adds	r4, #1
  20259e:	e7e7      	b.n	202570 <rt_test_008_002_execute+0x10>
      chDbgAssert(handlers[eid] != NULL, "null handler");
  2025a0:	4805      	ldr	r0, [pc, #20]	; (2025b8 <rt_test_008_002_execute+0x58>)
  2025a2:	f7fe fae5 	bl	200b70 <chSysHalt>
  2025a6:	bf00      	nop
  2025a8:	20001f6c 	.word	0x20001f6c
  2025ac:	0800c55c 	.word	0x0800c55c
  2025b0:	0800d7d4 	.word	0x0800d7d4
  2025b4:	0800d7e8 	.word	0x0800d7e8
  2025b8:	0800bf40 	.word	0x0800bf40
  2025bc:	00000000 	.word	0x00000000

002025c0 <rt_test_006_009_setup>:
  2025c0:	2000      	movs	r0, #0
  tqp->next = (thread_t *)tqp;
  2025c2:	4a06      	ldr	r2, [pc, #24]	; (2025dc <rt_test_006_009_setup+0x1c>)
  2025c4:	4b06      	ldr	r3, [pc, #24]	; (2025e0 <rt_test_006_009_setup+0x20>)
  2025c6:	4907      	ldr	r1, [pc, #28]	; (2025e4 <rt_test_006_009_setup+0x24>)
  2025c8:	6090      	str	r0, [r2, #8]
  2025ca:	6098      	str	r0, [r3, #8]
  tqp->prev = (thread_t *)tqp;
  2025cc:	e9c1 1100 	strd	r1, r1, [r1]
  2025d0:	e9c2 2200 	strd	r2, r2, [r2]
  2025d4:	e9c3 3300 	strd	r3, r3, [r3]

static void rt_test_006_009_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
  2025d8:	4770      	bx	lr
  2025da:	bf00      	nop
  2025dc:	20010438 	.word	0x20010438
  2025e0:	20010448 	.word	0x20010448
  2025e4:	20010404 	.word	0x20010404
	...

002025f0 <rt_test_006_008_setup>:
  tqp->next = (thread_t *)tqp;
  2025f0:	4b04      	ldr	r3, [pc, #16]	; (202604 <rt_test_006_008_setup+0x14>)
  2025f2:	2100      	movs	r1, #0
  2025f4:	4a04      	ldr	r2, [pc, #16]	; (202608 <rt_test_006_008_setup+0x18>)
  2025f6:	6099      	str	r1, [r3, #8]
  tqp->prev = (thread_t *)tqp;
  2025f8:	e9c2 2200 	strd	r2, r2, [r2]
  2025fc:	e9c3 3300 	strd	r3, r3, [r3]
}
  202600:	4770      	bx	lr
  202602:	bf00      	nop
  202604:	20010438 	.word	0x20010438
  202608:	20010404 	.word	0x20010404
  20260c:	00000000 	.word	0x00000000

00202610 <rt_test_006_007_setup>:
  202610:	f7ff bfee 	b.w	2025f0 <rt_test_006_008_setup>
	...

00202620 <rt_test_006_005_setup>:
  tqp->next = (thread_t *)tqp;
  202620:	4b02      	ldr	r3, [pc, #8]	; (20262c <rt_test_006_005_setup+0xc>)
  202622:	2200      	movs	r2, #0
  tqp->prev = (thread_t *)tqp;
  202624:	e9c3 3300 	strd	r3, r3, [r3]
  202628:	609a      	str	r2, [r3, #8]
}
  20262a:	4770      	bx	lr
  20262c:	20010438 	.word	0x20010438

00202630 <rt_test_006_001_setup>:
  202630:	f7ff bff6 	b.w	202620 <rt_test_006_005_setup>
	...

00202640 <rt_test_006_004_setup>:
  tqp->next = (thread_t *)tqp;
  202640:	4a04      	ldr	r2, [pc, #16]	; (202654 <rt_test_006_004_setup+0x14>)
  202642:	2100      	movs	r1, #0
  202644:	4b04      	ldr	r3, [pc, #16]	; (202658 <rt_test_006_004_setup+0x18>)
  202646:	6091      	str	r1, [r2, #8]
  202648:	6099      	str	r1, [r3, #8]
  tqp->prev = (thread_t *)tqp;
  20264a:	e9c2 2200 	strd	r2, r2, [r2]
  20264e:	e9c3 3300 	strd	r3, r3, [r3]
}
  202652:	4770      	bx	lr
  202654:	20010438 	.word	0x20010438
  202658:	20010448 	.word	0x20010448
  20265c:	00000000 	.word	0x00000000

00202660 <rt_test_001_003_execute>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void rt_test_001_003_execute(void) {
  202660:	b538      	push	{r3, r4, r5, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
  202662:	4bc9      	ldr	r3, [pc, #804]	; (202988 <rt_test_001_003_execute+0x328>)
  202664:	2501      	movs	r5, #1
  {
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
    test_printn(CH_CFG_ST_RESOLUTION);
    test_println("");
  202666:	4cc9      	ldr	r4, [pc, #804]	; (20298c <rt_test_001_003_execute+0x32c>)
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
  202668:	48c9      	ldr	r0, [pc, #804]	; (202990 <rt_test_001_003_execute+0x330>)
  test_set_step(1);
  20266a:	601d      	str	r5, [r3, #0]
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
  20266c:	f7fe f930 	bl	2008d0 <test_print>
  202670:	2020      	movs	r0, #32
  202672:	f7fe f8cd 	bl	200810 <test_printn.part.0>
    test_println("");
  202676:	4620      	mov	r0, r4
  202678:	f7fe f90a 	bl	200890 <test_println>
    test_print("--- CH_CFG_ST_FREQUENCY:                ");
  20267c:	48c5      	ldr	r0, [pc, #788]	; (202994 <rt_test_001_003_execute+0x334>)
  20267e:	f7fe f927 	bl	2008d0 <test_print>
  202682:	f242 7010 	movw	r0, #10000	; 0x2710
  202686:	f7fe f8c3 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_ST_FREQUENCY);
    test_println("");
  20268a:	4620      	mov	r0, r4
  20268c:	f7fe f900 	bl	200890 <test_println>
    test_print("--- CH_CFG_INTERVALS_SIZE:              ");
  202690:	48c1      	ldr	r0, [pc, #772]	; (202998 <rt_test_001_003_execute+0x338>)
  202692:	f7fe f91d 	bl	2008d0 <test_print>
  202696:	2020      	movs	r0, #32
  202698:	f7fe f8ba 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_INTERVALS_SIZE);
    test_println("");
  20269c:	4620      	mov	r0, r4
  20269e:	f7fe f8f7 	bl	200890 <test_println>
    test_print("--- CH_CFG_TIME_TYPES_SIZE:             ");
  2026a2:	48be      	ldr	r0, [pc, #760]	; (20299c <rt_test_001_003_execute+0x33c>)
  2026a4:	f7fe f914 	bl	2008d0 <test_print>
  2026a8:	2020      	movs	r0, #32
  2026aa:	f7fe f8b1 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_TIME_TYPES_SIZE);
    test_println("");
  2026ae:	4620      	mov	r0, r4
  2026b0:	f7fe f8ee 	bl	200890 <test_println>
    test_print("--- CH_CFG_ST_TIMEDELTA:                ");
  2026b4:	48ba      	ldr	r0, [pc, #744]	; (2029a0 <rt_test_001_003_execute+0x340>)
  2026b6:	f7fe f90b 	bl	2008d0 <test_print>
  2026ba:	2002      	movs	r0, #2
  2026bc:	f7fe f8a8 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_ST_TIMEDELTA);
    test_println("");
  2026c0:	4620      	mov	r0, r4
  2026c2:	f7fe f8e5 	bl	200890 <test_println>
    test_print("--- CH_CFG_TIME_QUANTUM:                ");
  2026c6:	48b7      	ldr	r0, [pc, #732]	; (2029a4 <rt_test_001_003_execute+0x344>)
  2026c8:	f7fe f902 	bl	2008d0 <test_print>
    test_printn(CH_CFG_TIME_QUANTUM);
  2026cc:	2000      	movs	r0, #0
  2026ce:	f7fe f8cf 	bl	200870 <test_printn>
    test_println("");
  2026d2:	4620      	mov	r0, r4
  2026d4:	f7fe f8dc 	bl	200890 <test_println>
    test_print("--- CH_CFG_MEMCORE_SIZE:                ");
  2026d8:	48b3      	ldr	r0, [pc, #716]	; (2029a8 <rt_test_001_003_execute+0x348>)
  2026da:	f7fe f8f9 	bl	2008d0 <test_print>
    test_printn(CH_CFG_MEMCORE_SIZE);
  2026de:	2000      	movs	r0, #0
  2026e0:	f7fe f8c6 	bl	200870 <test_printn>
    test_println("");
  2026e4:	4620      	mov	r0, r4
  2026e6:	f7fe f8d3 	bl	200890 <test_println>
    test_print("--- CH_CFG_NO_IDLE_THREAD:              ");
  2026ea:	48b0      	ldr	r0, [pc, #704]	; (2029ac <rt_test_001_003_execute+0x34c>)
  2026ec:	f7fe f8f0 	bl	2008d0 <test_print>
    test_printn(CH_CFG_NO_IDLE_THREAD);
  2026f0:	2000      	movs	r0, #0
  2026f2:	f7fe f8bd 	bl	200870 <test_printn>
    test_println("");
  2026f6:	4620      	mov	r0, r4
  2026f8:	f7fe f8ca 	bl	200890 <test_println>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:              ");
  2026fc:	48ac      	ldr	r0, [pc, #688]	; (2029b0 <rt_test_001_003_execute+0x350>)
  2026fe:	f7fe f8e7 	bl	2008d0 <test_print>
  202702:	4628      	mov	r0, r5
  202704:	f7fe f884 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
    test_println("");
  202708:	4620      	mov	r0, r4
  20270a:	f7fe f8c1 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_TM:                      ");
  20270e:	48a9      	ldr	r0, [pc, #676]	; (2029b4 <rt_test_001_003_execute+0x354>)
  202710:	f7fe f8de 	bl	2008d0 <test_print>
  202714:	4628      	mov	r0, r5
  202716:	f7fe f87b 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_TM);
    test_println("");
  20271a:	4620      	mov	r0, r4
  20271c:	f7fe f8b8 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_REGISTRY:                ");
  202720:	48a5      	ldr	r0, [pc, #660]	; (2029b8 <rt_test_001_003_execute+0x358>)
  202722:	f7fe f8d5 	bl	2008d0 <test_print>
  202726:	4628      	mov	r0, r5
  202728:	f7fe f872 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_REGISTRY);
    test_println("");
  20272c:	4620      	mov	r0, r4
  20272e:	f7fe f8af 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_WAITEXIT:                ");
  202732:	48a2      	ldr	r0, [pc, #648]	; (2029bc <rt_test_001_003_execute+0x35c>)
  202734:	f7fe f8cc 	bl	2008d0 <test_print>
  202738:	4628      	mov	r0, r5
  20273a:	f7fe f869 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_WAITEXIT);
    test_println("");
  20273e:	4620      	mov	r0, r4
  202740:	f7fe f8a6 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES:              ");
  202744:	489e      	ldr	r0, [pc, #632]	; (2029c0 <rt_test_001_003_execute+0x360>)
  202746:	f7fe f8c3 	bl	2008d0 <test_print>
  20274a:	4628      	mov	r0, r5
  20274c:	f7fe f860 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_SEMAPHORES);
    test_println("");
  202750:	4620      	mov	r0, r4
  202752:	f7fe f89d 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRI:          ");
  202756:	489b      	ldr	r0, [pc, #620]	; (2029c4 <rt_test_001_003_execute+0x364>)
  202758:	f7fe f8ba 	bl	2008d0 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
  20275c:	2000      	movs	r0, #0
  20275e:	f7fe f887 	bl	200870 <test_printn>
    test_println("");
  202762:	4620      	mov	r0, r4
  202764:	f7fe f894 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES:                 ");
  202768:	4897      	ldr	r0, [pc, #604]	; (2029c8 <rt_test_001_003_execute+0x368>)
  20276a:	f7fe f8b1 	bl	2008d0 <test_print>
  20276e:	4628      	mov	r0, r5
  202770:	f7fe f84e 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_MUTEXES);
    test_println("");
  202774:	4620      	mov	r0, r4
  202776:	f7fe f88b 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES_RECURS:          ");
  20277a:	4894      	ldr	r0, [pc, #592]	; (2029cc <rt_test_001_003_execute+0x36c>)
  20277c:	f7fe f8a8 	bl	2008d0 <test_print>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
  202780:	2000      	movs	r0, #0
  202782:	f7fe f875 	bl	200870 <test_printn>
    test_println("");   
  202786:	4620      	mov	r0, r4
  202788:	f7fe f882 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS:                ");
  20278c:	4890      	ldr	r0, [pc, #576]	; (2029d0 <rt_test_001_003_execute+0x370>)
  20278e:	f7fe f89f 	bl	2008d0 <test_print>
  202792:	4628      	mov	r0, r5
  202794:	f7fe f83c 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_CONDVARS);
    test_println("");
  202798:	4620      	mov	r0, r4
  20279a:	f7fe f879 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEO:          ");
  20279e:	488d      	ldr	r0, [pc, #564]	; (2029d4 <rt_test_001_003_execute+0x374>)
  2027a0:	f7fe f896 	bl	2008d0 <test_print>
  2027a4:	4628      	mov	r0, r5
  2027a6:	f7fe f833 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
    test_println("");
  2027aa:	4620      	mov	r0, r4
  2027ac:	f7fe f870 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_EVENTS:                  ");
  2027b0:	4889      	ldr	r0, [pc, #548]	; (2029d8 <rt_test_001_003_execute+0x378>)
  2027b2:	f7fe f88d 	bl	2008d0 <test_print>
  2027b6:	4628      	mov	r0, r5
  2027b8:	f7fe f82a 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_EVENTS);
    test_println("");
  2027bc:	4620      	mov	r0, r4
  2027be:	f7fe f867 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT:          ");
  2027c2:	4886      	ldr	r0, [pc, #536]	; (2029dc <rt_test_001_003_execute+0x37c>)
  2027c4:	f7fe f884 	bl	2008d0 <test_print>
  2027c8:	4628      	mov	r0, r5
  2027ca:	f7fe f821 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
    test_println("");
  2027ce:	4620      	mov	r0, r4
  2027d0:	f7fe f85e 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES:                ");
  2027d4:	4882      	ldr	r0, [pc, #520]	; (2029e0 <rt_test_001_003_execute+0x380>)
  2027d6:	f7fe f87b 	bl	2008d0 <test_print>
  2027da:	4628      	mov	r0, r5
  2027dc:	f7fe f818 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_MESSAGES);
    test_println("");
  2027e0:	4620      	mov	r0, r4
  2027e2:	f7fe f855 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES_PRI:            ");
  2027e6:	487f      	ldr	r0, [pc, #508]	; (2029e4 <rt_test_001_003_execute+0x384>)
  2027e8:	f7fe f872 	bl	2008d0 <test_print>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
  2027ec:	2000      	movs	r0, #0
  2027ee:	f7fe f83f 	bl	200870 <test_printn>
    test_println("");
  2027f2:	4620      	mov	r0, r4
  2027f4:	f7fe f84c 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
  2027f8:	487b      	ldr	r0, [pc, #492]	; (2029e8 <rt_test_001_003_execute+0x388>)
  2027fa:	f7fe f869 	bl	2008d0 <test_print>
  2027fe:	4628      	mov	r0, r5
  202800:	f7fe f806 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_MAILBOXES);
    test_println("");
  202804:	4620      	mov	r0, r4
  202806:	f7fe f843 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_MEMCORE:                 ");
  20280a:	4878      	ldr	r0, [pc, #480]	; (2029ec <rt_test_001_003_execute+0x38c>)
  20280c:	f7fe f860 	bl	2008d0 <test_print>
  202810:	4628      	mov	r0, r5
  202812:	f7fd fffd 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_MEMCORE);
    test_println("");
  202816:	4620      	mov	r0, r4
  202818:	f7fe f83a 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_HEAP:                    ");
  20281c:	4874      	ldr	r0, [pc, #464]	; (2029f0 <rt_test_001_003_execute+0x390>)
  20281e:	f7fe f857 	bl	2008d0 <test_print>
  202822:	4628      	mov	r0, r5
  202824:	f7fd fff4 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_HEAP);
    test_println("");
  202828:	4620      	mov	r0, r4
  20282a:	f7fe f831 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_MEMPOOLS:                ");
  20282e:	4871      	ldr	r0, [pc, #452]	; (2029f4 <rt_test_001_003_execute+0x394>)
  202830:	f7fe f84e 	bl	2008d0 <test_print>
  202834:	4628      	mov	r0, r5
  202836:	f7fd ffeb 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_MEMPOOLS);
    test_println("");
  20283a:	4620      	mov	r0, r4
  20283c:	f7fe f828 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_OBJ_FIFOS:               ");
  202840:	486d      	ldr	r0, [pc, #436]	; (2029f8 <rt_test_001_003_execute+0x398>)
  202842:	f7fe f845 	bl	2008d0 <test_print>
  202846:	4628      	mov	r0, r5
  202848:	f7fd ffe2 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_OBJ_FIFOS);
    test_println("");
  20284c:	4620      	mov	r0, r4
  20284e:	f7fe f81f 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_DYNAMIC:                 ");
  202852:	486a      	ldr	r0, [pc, #424]	; (2029fc <rt_test_001_003_execute+0x39c>)
  202854:	f7fe f83c 	bl	2008d0 <test_print>
  202858:	4628      	mov	r0, r5
  20285a:	f7fd ffd9 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_DYNAMIC);
    test_println("");
  20285e:	4620      	mov	r0, r4
  202860:	f7fe f816 	bl	200890 <test_println>
    test_print("--- CH_CFG_USE_FACTORY:                 ");
  202864:	4866      	ldr	r0, [pc, #408]	; (202a00 <rt_test_001_003_execute+0x3a0>)
  202866:	f7fe f833 	bl	2008d0 <test_print>
  20286a:	4628      	mov	r0, r5
  20286c:	f7fd ffd0 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_USE_FACTORY);
    test_println("");
  202870:	4620      	mov	r0, r4
  202872:	f7fe f80d 	bl	200890 <test_println>
    test_print("--- CH_CFG_FACTORY_MAX_NAMES_LENGTH:    ");
  202876:	4863      	ldr	r0, [pc, #396]	; (202a04 <rt_test_001_003_execute+0x3a4>)
  202878:	f7fe f82a 	bl	2008d0 <test_print>
  20287c:	2008      	movs	r0, #8
  20287e:	f7fd ffc7 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_MAX_NAMES_LENGTH);
    test_println("");
  202882:	4620      	mov	r0, r4
  202884:	f7fe f804 	bl	200890 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJECTS_REGISTRY:    ");
  202888:	485f      	ldr	r0, [pc, #380]	; (202a08 <rt_test_001_003_execute+0x3a8>)
  20288a:	f7fe f821 	bl	2008d0 <test_print>
  20288e:	4628      	mov	r0, r5
  202890:	f7fd ffbe 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_OBJECTS_REGISTRY);
    test_println("");
  202894:	4620      	mov	r0, r4
  202896:	f7fd fffb 	bl	200890 <test_println>
    test_print("--- CH_CFG_FACTORY_GENERIC_BUFFERS:     ");
  20289a:	485c      	ldr	r0, [pc, #368]	; (202a0c <rt_test_001_003_execute+0x3ac>)
  20289c:	f7fe f818 	bl	2008d0 <test_print>
  2028a0:	4628      	mov	r0, r5
  2028a2:	f7fd ffb5 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_GENERIC_BUFFERS);
    test_println("");
  2028a6:	4620      	mov	r0, r4
  2028a8:	f7fd fff2 	bl	200890 <test_println>
    test_print("--- CH_CFG_FACTORY_SEMAPHORES:          ");
  2028ac:	4858      	ldr	r0, [pc, #352]	; (202a10 <rt_test_001_003_execute+0x3b0>)
  2028ae:	f7fe f80f 	bl	2008d0 <test_print>
  2028b2:	4628      	mov	r0, r5
  2028b4:	f7fd ffac 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_SEMAPHORES);
    test_println("");
  2028b8:	4620      	mov	r0, r4
  2028ba:	f7fd ffe9 	bl	200890 <test_println>
    test_print("--- CH_CFG_FACTORY_MAILBOXES:           ");
  2028be:	4855      	ldr	r0, [pc, #340]	; (202a14 <rt_test_001_003_execute+0x3b4>)
  2028c0:	f7fe f806 	bl	2008d0 <test_print>
  2028c4:	4628      	mov	r0, r5
  2028c6:	f7fd ffa3 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_MAILBOXES);
    test_println("");
  2028ca:	4620      	mov	r0, r4
  2028cc:	f7fd ffe0 	bl	200890 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJ_FIFOS:           ");
  2028d0:	4851      	ldr	r0, [pc, #324]	; (202a18 <rt_test_001_003_execute+0x3b8>)
  2028d2:	f7fd fffd 	bl	2008d0 <test_print>
  2028d6:	4628      	mov	r0, r5
  2028d8:	f7fd ff9a 	bl	200810 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_OBJ_FIFOS);
    test_println("");
  2028dc:	4620      	mov	r0, r4
  2028de:	f7fd ffd7 	bl	200890 <test_println>
    test_print("--- CH_DBG_STATISTICS:                  ");
  2028e2:	484e      	ldr	r0, [pc, #312]	; (202a1c <rt_test_001_003_execute+0x3bc>)
  2028e4:	f7fd fff4 	bl	2008d0 <test_print>
    test_printn(CH_DBG_STATISTICS);
  2028e8:	2000      	movs	r0, #0
  2028ea:	f7fd ffc1 	bl	200870 <test_printn>
    test_println("");
  2028ee:	4620      	mov	r0, r4
  2028f0:	f7fd ffce 	bl	200890 <test_println>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK:          ");
  2028f4:	484a      	ldr	r0, [pc, #296]	; (202a20 <rt_test_001_003_execute+0x3c0>)
  2028f6:	f7fd ffeb 	bl	2008d0 <test_print>
  2028fa:	4628      	mov	r0, r5
  2028fc:	f7fd ff88 	bl	200810 <test_printn.part.0>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
    test_println("");
  202900:	4620      	mov	r0, r4
  202902:	f7fd ffc5 	bl	200890 <test_println>
    test_print("--- CH_DBG_ENABLE_CHECKS:               ");
  202906:	4847      	ldr	r0, [pc, #284]	; (202a24 <rt_test_001_003_execute+0x3c4>)
  202908:	f7fd ffe2 	bl	2008d0 <test_print>
  20290c:	4628      	mov	r0, r5
  20290e:	f7fd ff7f 	bl	200810 <test_printn.part.0>
    test_printn(CH_DBG_ENABLE_CHECKS);
    test_println("");
  202912:	4620      	mov	r0, r4
  202914:	f7fd ffbc 	bl	200890 <test_println>
    test_print("--- CH_DBG_ENABLE_ASSERTS:              ");
  202918:	4843      	ldr	r0, [pc, #268]	; (202a28 <rt_test_001_003_execute+0x3c8>)
  20291a:	f7fd ffd9 	bl	2008d0 <test_print>
  20291e:	4628      	mov	r0, r5
  202920:	f7fd ff76 	bl	200810 <test_printn.part.0>
    test_printn(CH_DBG_ENABLE_ASSERTS);
    test_println("");
  202924:	4620      	mov	r0, r4
  202926:	f7fd ffb3 	bl	200890 <test_println>
    test_print("--- CH_DBG_TRACE_MASK:                  ");
  20292a:	4840      	ldr	r0, [pc, #256]	; (202a2c <rt_test_001_003_execute+0x3cc>)
  20292c:	f7fd ffd0 	bl	2008d0 <test_print>
  202930:	200f      	movs	r0, #15
  202932:	f7fd ff6d 	bl	200810 <test_printn.part.0>
    test_printn(CH_DBG_TRACE_MASK);
    test_println("");
  202936:	4620      	mov	r0, r4
  202938:	f7fd ffaa 	bl	200890 <test_println>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:           ");
  20293c:	483c      	ldr	r0, [pc, #240]	; (202a30 <rt_test_001_003_execute+0x3d0>)
  20293e:	f7fd ffc7 	bl	2008d0 <test_print>
  202942:	2080      	movs	r0, #128	; 0x80
  202944:	f7fd ff64 	bl	200810 <test_printn.part.0>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
    test_println("");
  202948:	4620      	mov	r0, r4
  20294a:	f7fd ffa1 	bl	200890 <test_println>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK:          ");
  20294e:	4839      	ldr	r0, [pc, #228]	; (202a34 <rt_test_001_003_execute+0x3d4>)
  202950:	f7fd ffbe 	bl	2008d0 <test_print>
  202954:	4628      	mov	r0, r5
  202956:	f7fd ff5b 	bl	200810 <test_printn.part.0>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
    test_println("");
  20295a:	4620      	mov	r0, r4
  20295c:	f7fd ff98 	bl	200890 <test_println>
    test_print("--- CH_DBG_FILL_THREADS:                ");
  202960:	4835      	ldr	r0, [pc, #212]	; (202a38 <rt_test_001_003_execute+0x3d8>)
  202962:	f7fd ffb5 	bl	2008d0 <test_print>
  202966:	4628      	mov	r0, r5
  202968:	f7fd ff52 	bl	200810 <test_printn.part.0>
    test_printn(CH_DBG_FILL_THREADS);
    test_println("");
  20296c:	4620      	mov	r0, r4
  20296e:	f7fd ff8f 	bl	200890 <test_println>
    test_print("--- CH_DBG_THREADS_PROFILING:           ");
  202972:	4832      	ldr	r0, [pc, #200]	; (202a3c <rt_test_001_003_execute+0x3dc>)
  202974:	f7fd ffac 	bl	2008d0 <test_print>
    test_printn(CH_DBG_THREADS_PROFILING);
  202978:	2000      	movs	r0, #0
  20297a:	f7fd ff79 	bl	200870 <test_printn>
    test_println("");
  20297e:	4620      	mov	r0, r4
  }
}
  202980:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println("");
  202984:	f7fd bf84 	b.w	200890 <test_println>
  202988:	20001f6c 	.word	0x20001f6c
  20298c:	0800dd4c 	.word	0x0800dd4c
  202990:	0800cc98 	.word	0x0800cc98
  202994:	0800ccc4 	.word	0x0800ccc4
  202998:	0800ccf0 	.word	0x0800ccf0
  20299c:	0800cd1c 	.word	0x0800cd1c
  2029a0:	0800cd48 	.word	0x0800cd48
  2029a4:	0800cd74 	.word	0x0800cd74
  2029a8:	0800cda0 	.word	0x0800cda0
  2029ac:	0800cdcc 	.word	0x0800cdcc
  2029b0:	0800cdf8 	.word	0x0800cdf8
  2029b4:	0800ce24 	.word	0x0800ce24
  2029b8:	0800ce50 	.word	0x0800ce50
  2029bc:	0800ce7c 	.word	0x0800ce7c
  2029c0:	0800cea8 	.word	0x0800cea8
  2029c4:	0800ced4 	.word	0x0800ced4
  2029c8:	0800cf00 	.word	0x0800cf00
  2029cc:	0800cf2c 	.word	0x0800cf2c
  2029d0:	0800cf58 	.word	0x0800cf58
  2029d4:	0800cf84 	.word	0x0800cf84
  2029d8:	0800cfb0 	.word	0x0800cfb0
  2029dc:	0800cfdc 	.word	0x0800cfdc
  2029e0:	0800d008 	.word	0x0800d008
  2029e4:	0800d034 	.word	0x0800d034
  2029e8:	0800d060 	.word	0x0800d060
  2029ec:	0800d08c 	.word	0x0800d08c
  2029f0:	0800d0b8 	.word	0x0800d0b8
  2029f4:	0800d0e4 	.word	0x0800d0e4
  2029f8:	0800d110 	.word	0x0800d110
  2029fc:	0800d13c 	.word	0x0800d13c
  202a00:	0800d168 	.word	0x0800d168
  202a04:	0800d194 	.word	0x0800d194
  202a08:	0800d1c0 	.word	0x0800d1c0
  202a0c:	0800d1ec 	.word	0x0800d1ec
  202a10:	0800d218 	.word	0x0800d218
  202a14:	0800d244 	.word	0x0800d244
  202a18:	0800d270 	.word	0x0800d270
  202a1c:	0800d29c 	.word	0x0800d29c
  202a20:	0800d2c8 	.word	0x0800d2c8
  202a24:	0800d2f4 	.word	0x0800d2f4
  202a28:	0800d320 	.word	0x0800d320
  202a2c:	0800d34c 	.word	0x0800d34c
  202a30:	0800d378 	.word	0x0800d378
  202a34:	0800d3a4 	.word	0x0800d3a4
  202a38:	0800d3d0 	.word	0x0800d3d0
  202a3c:	0800d3fc 	.word	0x0800d3fc

00202a40 <rt_test_001_002_execute>:
  test_set_step(1);
  202a40:	4b19      	ldr	r3, [pc, #100]	; (202aa8 <rt_test_001_002_execute+0x68>)
  202a42:	2201      	movs	r2, #1
    test_println("--- Product:                            ChibiOS/RT");
  202a44:	4819      	ldr	r0, [pc, #100]	; (202aac <rt_test_001_002_execute+0x6c>)
static void rt_test_001_002_execute(void) {
  202a46:	b510      	push	{r4, lr}
  test_set_step(1);
  202a48:	601a      	str	r2, [r3, #0]
    test_println("--- Product:                            ChibiOS/RT");
  202a4a:	f7fd ff21 	bl	200890 <test_println>
    test_println("");
  202a4e:	4c18      	ldr	r4, [pc, #96]	; (202ab0 <rt_test_001_002_execute+0x70>)
    test_print("--- Stable Flag:                        ");
  202a50:	4818      	ldr	r0, [pc, #96]	; (202ab4 <rt_test_001_002_execute+0x74>)
  202a52:	f7fd ff3d 	bl	2008d0 <test_print>
    test_printn(CH_KERNEL_STABLE);
  202a56:	2000      	movs	r0, #0
  202a58:	f7fd ff0a 	bl	200870 <test_printn>
    test_println("");
  202a5c:	4620      	mov	r0, r4
  202a5e:	f7fd ff17 	bl	200890 <test_println>
    test_print("--- Version String:                     ");
  202a62:	4815      	ldr	r0, [pc, #84]	; (202ab8 <rt_test_001_002_execute+0x78>)
  202a64:	f7fd ff34 	bl	2008d0 <test_print>
    test_println(CH_KERNEL_VERSION);
  202a68:	4814      	ldr	r0, [pc, #80]	; (202abc <rt_test_001_002_execute+0x7c>)
  202a6a:	f7fd ff11 	bl	200890 <test_println>
    test_print("--- Major Number:                       ");
  202a6e:	4814      	ldr	r0, [pc, #80]	; (202ac0 <rt_test_001_002_execute+0x80>)
  202a70:	f7fd ff2e 	bl	2008d0 <test_print>
  202a74:	2005      	movs	r0, #5
  202a76:	f7fd fecb 	bl	200810 <test_printn.part.0>
    test_println("");
  202a7a:	4620      	mov	r0, r4
  202a7c:	f7fd ff08 	bl	200890 <test_println>
    test_print("--- Minor Number:                       ");
  202a80:	4810      	ldr	r0, [pc, #64]	; (202ac4 <rt_test_001_002_execute+0x84>)
  202a82:	f7fd ff25 	bl	2008d0 <test_print>
    test_printn(CH_KERNEL_MINOR);
  202a86:	2000      	movs	r0, #0
  202a88:	f7fd fef2 	bl	200870 <test_printn>
    test_println("");
  202a8c:	4620      	mov	r0, r4
  202a8e:	f7fd feff 	bl	200890 <test_println>
    test_print("--- Patch Number:                       ");
  202a92:	480d      	ldr	r0, [pc, #52]	; (202ac8 <rt_test_001_002_execute+0x88>)
  202a94:	f7fd ff1c 	bl	2008d0 <test_print>
    test_printn(CH_KERNEL_PATCH);
  202a98:	2000      	movs	r0, #0
  202a9a:	f7fd fee9 	bl	200870 <test_printn>
    test_println("");
  202a9e:	4620      	mov	r0, r4
}
  202aa0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    test_println("");
  202aa4:	f7fd bef4 	b.w	200890 <test_println>
  202aa8:	20001f6c 	.word	0x20001f6c
  202aac:	0800cb70 	.word	0x0800cb70
  202ab0:	0800dd4c 	.word	0x0800dd4c
  202ab4:	0800cba4 	.word	0x0800cba4
  202ab8:	0800cbd0 	.word	0x0800cbd0
  202abc:	0800cbfc 	.word	0x0800cbfc
  202ac0:	0800cc04 	.word	0x0800cc04
  202ac4:	0800cc30 	.word	0x0800cc30
  202ac8:	0800cc5c 	.word	0x0800cc5c
  202acc:	00000000 	.word	0x00000000

00202ad0 <rt_test_001_001_execute>:
  test_set_step(1);
  202ad0:	4b1c      	ldr	r3, [pc, #112]	; (202b44 <rt_test_001_001_execute+0x74>)
  202ad2:	2201      	movs	r2, #1
    test_print("--- Architecture:                       ");
  202ad4:	481c      	ldr	r0, [pc, #112]	; (202b48 <rt_test_001_001_execute+0x78>)
static void rt_test_001_001_execute(void) {
  202ad6:	b510      	push	{r4, lr}
  test_set_step(1);
  202ad8:	601a      	str	r2, [r3, #0]
    test_print("--- Architecture:                       ");
  202ada:	f7fd fef9 	bl	2008d0 <test_print>
    test_println(PORT_ARCHITECTURE_NAME);
  202ade:	481b      	ldr	r0, [pc, #108]	; (202b4c <rt_test_001_001_execute+0x7c>)
  202ae0:	f7fd fed6 	bl	200890 <test_println>
    test_print("--- Core Variant:                       ");
  202ae4:	481a      	ldr	r0, [pc, #104]	; (202b50 <rt_test_001_001_execute+0x80>)
  202ae6:	f7fd fef3 	bl	2008d0 <test_print>
    test_println(PORT_CORE_VARIANT_NAME);
  202aea:	481a      	ldr	r0, [pc, #104]	; (202b54 <rt_test_001_001_execute+0x84>)
  202aec:	f7fd fed0 	bl	200890 <test_println>
    test_print("--- Compiler:                           ");
  202af0:	4819      	ldr	r0, [pc, #100]	; (202b58 <rt_test_001_001_execute+0x88>)
  202af2:	f7fd feed 	bl	2008d0 <test_print>
    test_println(PORT_COMPILER_NAME);
  202af6:	4819      	ldr	r0, [pc, #100]	; (202b5c <rt_test_001_001_execute+0x8c>)
  202af8:	f7fd feca 	bl	200890 <test_println>
    test_print("--- Port Info:                          ");
  202afc:	4818      	ldr	r0, [pc, #96]	; (202b60 <rt_test_001_001_execute+0x90>)
  202afe:	f7fd fee7 	bl	2008d0 <test_print>
    test_println(PORT_INFO);
  202b02:	4818      	ldr	r0, [pc, #96]	; (202b64 <rt_test_001_001_execute+0x94>)
    test_println("");
  202b04:	4c18      	ldr	r4, [pc, #96]	; (202b68 <rt_test_001_001_execute+0x98>)
    test_println(PORT_INFO);
  202b06:	f7fd fec3 	bl	200890 <test_println>
    test_print("--- Natural alignment:                  ");
  202b0a:	4818      	ldr	r0, [pc, #96]	; (202b6c <rt_test_001_001_execute+0x9c>)
  202b0c:	f7fd fee0 	bl	2008d0 <test_print>
  202b10:	2004      	movs	r0, #4
  202b12:	f7fd fe7d 	bl	200810 <test_printn.part.0>
    test_println("");
  202b16:	4620      	mov	r0, r4
  202b18:	f7fd feba 	bl	200890 <test_println>
    test_print("--- Stack alignment:                    ");
  202b1c:	4814      	ldr	r0, [pc, #80]	; (202b70 <rt_test_001_001_execute+0xa0>)
  202b1e:	f7fd fed7 	bl	2008d0 <test_print>
  202b22:	2008      	movs	r0, #8
  202b24:	f7fd fe74 	bl	200810 <test_printn.part.0>
    test_println("");
  202b28:	4620      	mov	r0, r4
  202b2a:	f7fd feb1 	bl	200890 <test_println>
    test_print("--- Working area alignment:             ");
  202b2e:	4811      	ldr	r0, [pc, #68]	; (202b74 <rt_test_001_001_execute+0xa4>)
  202b30:	f7fd fece 	bl	2008d0 <test_print>
  202b34:	2008      	movs	r0, #8
  202b36:	f7fd fe6b 	bl	200810 <test_printn.part.0>
    test_println("");
  202b3a:	4620      	mov	r0, r4
}
  202b3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    test_println("");
  202b40:	f7fd bea6 	b.w	200890 <test_println>
  202b44:	20001f6c 	.word	0x20001f6c
  202b48:	0800c9b4 	.word	0x0800c9b4
  202b4c:	0800c9e0 	.word	0x0800c9e0
  202b50:	0800c9ec 	.word	0x0800c9ec
  202b54:	0800ca18 	.word	0x0800ca18
  202b58:	0800ca24 	.word	0x0800ca24
  202b5c:	0800ca50 	.word	0x0800ca50
  202b60:	0800ca98 	.word	0x0800ca98
  202b64:	0800cac4 	.word	0x0800cac4
  202b68:	0800dd4c 	.word	0x0800dd4c
  202b6c:	0800cadc 	.word	0x0800cadc
  202b70:	0800cb08 	.word	0x0800cb08
  202b74:	0800cb34 	.word	0x0800cb34
	...

00202b80 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
  202b80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  202b84:	4604      	mov	r4, r0
  202b86:	460d      	mov	r5, r1
  202b88:	4616      	mov	r6, r2
  osalDbgCheckClassI();
  202b8a:	f7fe f901 	bl	200d90 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
  202b8e:	b144      	cbz	r4, 202ba2 <usbInitEndpointI+0x22>
  osalDbgAssert(usbp->state == USB_ACTIVE,
  202b90:	7823      	ldrb	r3, [r4, #0]
  202b92:	2b04      	cmp	r3, #4
  202b94:	d105      	bne.n	202ba2 <usbInitEndpointI+0x22>
  202b96:	fa0f f885 	sxth.w	r8, r5
  202b9a:	eb04 0788 	add.w	r7, r4, r8, lsl #2
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
  202b9e:	68fb      	ldr	r3, [r7, #12]
  202ba0:	b113      	cbz	r3, 202ba8 <usbInitEndpointI+0x28>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
  202ba2:	485b      	ldr	r0, [pc, #364]	; (202d10 <usbInitEndpointI+0x190>)
  202ba4:	f7fd ffe4 	bl	200b70 <chSysHalt>
  if (epcp->in_state != NULL) {
  202ba8:	6972      	ldr	r2, [r6, #20]
  usbp->epc[ep] = epcp;
  202baa:	60fe      	str	r6, [r7, #12]
  if (epcp->in_state != NULL) {
  202bac:	b11a      	cbz	r2, 202bb6 <usbInitEndpointI+0x36>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
  202bae:	6013      	str	r3, [r2, #0]
  202bb0:	6053      	str	r3, [r2, #4]
  202bb2:	6093      	str	r3, [r2, #8]
  202bb4:	60d3      	str	r3, [r2, #12]
  if (epcp->out_state != NULL) {
  202bb6:	69b3      	ldr	r3, [r6, #24]
  202bb8:	b123      	cbz	r3, 202bc4 <usbInitEndpointI+0x44>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
  202bba:	2200      	movs	r2, #0
  202bbc:	601a      	str	r2, [r3, #0]
  202bbe:	605a      	str	r2, [r3, #4]
  202bc0:	609a      	str	r2, [r3, #8]
  202bc2:	60da      	str	r2, [r3, #12]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
  202bc4:	68fb      	ldr	r3, [r7, #12]
  202bc6:	681a      	ldr	r2, [r3, #0]
  202bc8:	f002 0203 	and.w	r2, r2, #3
  202bcc:	2a02      	cmp	r2, #2
  202bce:	f000 8098 	beq.w	202d02 <usbInitEndpointI+0x182>
  202bd2:	2a03      	cmp	r2, #3
  202bd4:	f000 8092 	beq.w	202cfc <usbInitEndpointI+0x17c>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
  202bd8:	484e      	ldr	r0, [pc, #312]	; (202d14 <usbInitEndpointI+0x194>)
  202bda:	494f      	ldr	r1, [pc, #316]	; (202d18 <usbInitEndpointI+0x198>)
  202bdc:	2a01      	cmp	r2, #1
  202bde:	bf0c      	ite	eq
  202be0:	4681      	moveq	r9, r0
  202be2:	4689      	movne	r9, r1
  stm32_otg_t *otgp = usbp->otg;
  202be4:	f8d4 6090 	ldr.w	r6, [r4, #144]	; 0x90
  otgp->oe[ep].DOEPTSIZ = 0;
  202be8:	0169      	lsls	r1, r5, #5
  202bea:	f04f 0e00 	mov.w	lr, #0
  202bee:	f105 0210 	add.w	r2, r5, #16
  202bf2:	1870      	adds	r0, r6, r1
  202bf4:	f04f 0c01 	mov.w	ip, #1
  202bf8:	f8c0 eb10 	str.w	lr, [r0, #2832]	; 0xb10
  202bfc:	fa0c fc02 	lsl.w	ip, ip, r2
  if (usbp->epc[ep]->out_state != NULL) {
  202c00:	6998      	ldr	r0, [r3, #24]
  202c02:	2800      	cmp	r0, #0
  202c04:	d048      	beq.n	202c98 <usbInitEndpointI+0x118>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
  202c06:	8a58      	ldrh	r0, [r3, #18]
  202c08:	f105 0258 	add.w	r2, r5, #88	; 0x58
  202c0c:	ea40 0009 	orr.w	r0, r0, r9
  202c10:	0152      	lsls	r2, r2, #5
  202c12:	50b0      	str	r0, [r6, r2]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  202c14:	f8d6 281c 	ldr.w	r2, [r6, #2076]	; 0x81c
  202c18:	ea42 020c 	orr.w	r2, r2, ip
  202c1c:	f8c6 281c 	str.w	r2, [r6, #2076]	; 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
  202c20:	4431      	add	r1, r6
  202c22:	2000      	movs	r0, #0
  if (usbp->epc[ep]->in_state != NULL) {
  202c24:	695a      	ldr	r2, [r3, #20]
  otgp->ie[ep].DIEPTSIZ = 0;
  202c26:	f8c1 0910 	str.w	r0, [r1, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
  202c2a:	2a00      	cmp	r2, #0
  202c2c:	d043      	beq.n	202cb6 <usbInitEndpointI+0x136>
    if (usbp->epc[ep]->in_multiplier > 1)
  202c2e:	8b99      	ldrh	r1, [r3, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
  202c30:	8a1a      	ldrh	r2, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
  202c32:	2901      	cmp	r1, #1
    fsize = usbp->epc[ep]->in_maxsize / 4;
  202c34:	ea4f 0392 	mov.w	r3, r2, lsr #2
      fsize *= usbp->epc[ep]->in_multiplier;
  202c38:	bf88      	it	hi
  202c3a:	434b      	mulhi	r3, r1
  202c3c:	e9d4 1225 	ldrd	r1, r2, [r4, #148]	; 0x94
  usbp->pmnext += size;
  202c40:	1898      	adds	r0, r3, r2
  202c42:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
  202c46:	6849      	ldr	r1, [r1, #4]
  202c48:	4288      	cmp	r0, r1
  202c4a:	d85d      	bhi.n	202d08 <usbInitEndpointI+0x188>
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  202c4c:	f105 003f 	add.w	r0, r5, #63	; 0x3f
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  202c50:	01a9      	lsls	r1, r5, #6
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  202c52:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  202c56:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
  202c5a:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  202c5e:	f041 0120 	orr.w	r1, r1, #32
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  202c62:	6043      	str	r3, [r0, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  202c64:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  202c66:	6913      	ldr	r3, [r2, #16]
  202c68:	0699      	lsls	r1, r3, #26
  202c6a:	d4fc      	bmi.n	202c66 <usbInitEndpointI+0xe6>
  chSysPolledDelayX(cycles);
  202c6c:	2012      	movs	r0, #18
  202c6e:	f7fd ff6f 	bl	200b50 <chSysPolledDelayX>
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
  202c72:	68fa      	ldr	r2, [r7, #12]
    otgp->ie[ep].DIEPCTL = ctl |
  202c74:	f105 0148 	add.w	r1, r5, #72	; 0x48
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  202c78:	2301      	movs	r3, #1
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
  202c7a:	8a12      	ldrh	r2, [r2, #16]
    otgp->ie[ep].DIEPCTL = ctl |
  202c7c:	0149      	lsls	r1, r1, #5
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  202c7e:	40ab      	lsls	r3, r5
                           DIEPCTL_TXFNUM(ep) |
  202c80:	ea42 5285 	orr.w	r2, r2, r5, lsl #22
  202c84:	ea42 0209 	orr.w	r2, r2, r9
    otgp->ie[ep].DIEPCTL = ctl |
  202c88:	5072      	str	r2, [r6, r1]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  202c8a:	f8d6 281c 	ldr.w	r2, [r6, #2076]	; 0x81c
  202c8e:	4313      	orrs	r3, r2
  202c90:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
}
  202c94:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  202c98:	eb06 1048 	add.w	r0, r6, r8, lsl #5
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
  202c9c:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
  202ca0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  202ca4:	f8c0 2b00 	str.w	r2, [r0, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  202ca8:	f8d6 281c 	ldr.w	r2, [r6, #2076]	; 0x81c
  202cac:	ea22 020c 	bic.w	r2, r2, ip
  202cb0:	f8c6 281c 	str.w	r2, [r6, #2076]	; 0x81c
  202cb4:	e7b4      	b.n	202c20 <usbInitEndpointI+0xa0>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  202cb6:	f105 013f 	add.w	r1, r5, #63	; 0x3f
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  202cba:	01ab      	lsls	r3, r5, #6
  202cbc:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  202cc0:	eb06 0181 	add.w	r1, r6, r1, lsl #2
  202cc4:	4815      	ldr	r0, [pc, #84]	; (202d1c <usbInitEndpointI+0x19c>)
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  202cc6:	f043 0320 	orr.w	r3, r3, #32
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  202cca:	6048      	str	r0, [r1, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  202ccc:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  202cce:	6913      	ldr	r3, [r2, #16]
  202cd0:	069b      	lsls	r3, r3, #26
  202cd2:	d4fc      	bmi.n	202cce <usbInitEndpointI+0x14e>
  202cd4:	eb06 1848 	add.w	r8, r6, r8, lsl #5
  202cd8:	2012      	movs	r0, #18
  202cda:	f7fd ff39 	bl	200b50 <chSysPolledDelayX>
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  202cde:	2101      	movs	r1, #1
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
  202ce0:	f8d8 3900 	ldr.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  202ce4:	40a9      	lsls	r1, r5
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
  202ce6:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  202cea:	f8c8 3900 	str.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  202cee:	f8d6 581c 	ldr.w	r5, [r6, #2076]	; 0x81c
  202cf2:	ea25 0501 	bic.w	r5, r5, r1
  202cf6:	f8c6 581c 	str.w	r5, [r6, #2076]	; 0x81c
  202cfa:	e7cb      	b.n	202c94 <usbInitEndpointI+0x114>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
  202cfc:	f8df 9024 	ldr.w	r9, [pc, #36]	; 202d24 <usbInitEndpointI+0x1a4>
  202d00:	e770      	b.n	202be4 <usbInitEndpointI+0x64>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
  202d02:	f8df 9024 	ldr.w	r9, [pc, #36]	; 202d28 <usbInitEndpointI+0x1a8>
  202d06:	e76d      	b.n	202be4 <usbInitEndpointI+0x64>
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
  202d08:	4805      	ldr	r0, [pc, #20]	; (202d20 <usbInitEndpointI+0x1a0>)
  202d0a:	f7fd ff31 	bl	200b70 <chSysHalt>
  202d0e:	bf00      	nop
  202d10:	0800c0bc 	.word	0x0800c0bc
  202d14:	10048000 	.word	0x10048000
  202d18:	10008000 	.word	0x10008000
  202d1c:	02000400 	.word	0x02000400
  202d20:	0800c074 	.word	0x0800c074
  202d24:	100c8000 	.word	0x100c8000
  202d28:	10088000 	.word	0x10088000
  202d2c:	00000000 	.word	0x00000000

00202d30 <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
  202d30:	b570      	push	{r4, r5, r6, lr}
  switch (event) {
  202d32:	2905      	cmp	r1, #5
  202d34:	d818      	bhi.n	202d68 <usb_event+0x38>
  202d36:	e8df f001 	tbb	[pc, r1]
  202d3a:	1754      	.short	0x1754
  202d3c:	03545418 	.word	0x03545418
  __ASM volatile ("cpsid i" : : : "memory");
  202d40:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202d42:	2320      	movs	r3, #32
  202d44:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  202d48:	b662      	cpsie	i
  chEvtBroadcastFlagsI(esp, flags);
  202d4a:	4d35      	ldr	r5, [pc, #212]	; (202e20 <usb_event+0xf0>)
  bqResumeX(&sdup->ibqueue);
  202d4c:	2400      	movs	r4, #0
  _dbg_check_lock_from_isr();
  202d4e:	f7fe fab7 	bl	2012c0 <_dbg_check_lock_from_isr>
  202d52:	2101      	movs	r1, #1
  202d54:	1d28      	adds	r0, r5, #4
  202d56:	f7fe f983 	bl	201060 <chEvtBroadcastFlagsI>
  202d5a:	752c      	strb	r4, [r5, #20]
  bqResumeX(&sdup->obqueue);
  202d5c:	f885 404c 	strb.w	r4, [r5, #76]	; 0x4c
  _dbg_check_unlock_from_isr();
  202d60:	f7fe fa96 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202d64:	f384 8811 	msr	BASEPRI, r4
}
  202d68:	bd70      	pop	{r4, r5, r6, pc}
  202d6a:	4606      	mov	r6, r0
  __ASM volatile ("cpsid i" : : : "memory");
  202d6c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202d6e:	2320      	movs	r3, #32
  202d70:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  202d74:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  202d76:	f7fe faa3 	bl	2012c0 <_dbg_check_lock_from_isr>
  ibqp->bcounter  = 0;
  202d7a:	4c29      	ldr	r4, [pc, #164]	; (202e20 <usb_event+0xf0>)
    usbInitEndpointI(usbp, USB1_DATA_REQUEST_EP, &ep1config);
  202d7c:	4630      	mov	r0, r6
  202d7e:	4a29      	ldr	r2, [pc, #164]	; (202e24 <usb_event+0xf4>)
  202d80:	2101      	movs	r1, #1
  202d82:	2500      	movs	r5, #0
  202d84:	f7ff fefc 	bl	202b80 <usbInitEndpointI>
    usbInitEndpointI(usbp, USB1_INTERRUPT_REQUEST_EP, &ep2config);
  202d88:	2102      	movs	r1, #2
  202d8a:	4a27      	ldr	r2, [pc, #156]	; (202e28 <usb_event+0xf8>)
  202d8c:	4630      	mov	r0, r6
  202d8e:	f7ff fef7 	bl	202b80 <usbInitEndpointI>
  osalDbgCheckClassI();
  202d92:	f7fd fffd 	bl	200d90 <chDbgCheckClassI>
  ibqp->brdptr    = ibqp->buffers;
  202d96:	6b23      	ldr	r3, [r4, #48]	; 0x30
  chThdDequeueAllI(tqp, msg);
  202d98:	f104 000c 	add.w	r0, r4, #12
  ibqp->bcounter  = 0;
  202d9c:	61a5      	str	r5, [r4, #24]
  ibqp->bwrptr    = ibqp->buffers;
  202d9e:	e9c4 3307 	strd	r3, r3, [r4, #28]
  ibqp->top       = NULL;
  202da2:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  202da6:	f7fe f90b 	bl	200fc0 <chThdDequeueAllI.constprop.82>
  bqResumeX(&sdup->ibqueue);
  202daa:	7525      	strb	r5, [r4, #20]
  osalDbgCheckClassI();
  202dac:	f7fd fff0 	bl	200d90 <chDbgCheckClassI>
  obqp->bcounter  = bqSizeX(obqp);
  202db0:	6e62      	ldr	r2, [r4, #100]	; 0x64
  obqp->brdptr    = obqp->buffers;
  202db2:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  202db4:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->bcounter  = bqSizeX(obqp);
  202db8:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->bwrptr    = obqp->buffers;
  202dba:	e9c4 3315 	strd	r3, r3, [r4, #84]	; 0x54
  obqp->top       = NULL;
  202dbe:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
  202dc2:	f7fe f8fd 	bl	200fc0 <chThdDequeueAllI.constprop.82>
  chEvtBroadcastFlagsI(esp, flags);
  202dc6:	2101      	movs	r1, #1
  202dc8:	1d20      	adds	r0, r4, #4
  bqResumeX(&sdup->obqueue);
  202dca:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
  202dce:	f7fe f947 	bl	201060 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
  202dd2:	4620      	mov	r0, r4
  202dd4:	f7ff f83c 	bl	201e50 <sdu_start_receive>
  _dbg_check_unlock_from_isr();
  202dd8:	f7fe fa5a 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202ddc:	f385 8811 	msr	BASEPRI, r5
}
  202de0:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("cpsid i" : : : "memory");
  202de2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202de4:	2320      	movs	r3, #32
  202de6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  202dea:	b662      	cpsie	i
  202dec:	4c0c      	ldr	r4, [pc, #48]	; (202e20 <usb_event+0xf0>)
  _dbg_check_lock_from_isr();
  202dee:	f7fe fa67 	bl	2012c0 <_dbg_check_lock_from_isr>
  bqSuspendI(&sdup->ibqueue);
  202df2:	2501      	movs	r5, #1
  202df4:	2102      	movs	r1, #2
  202df6:	1d20      	adds	r0, r4, #4
  202df8:	f7fe f932 	bl	201060 <chEvtBroadcastFlagsI>
  chThdDequeueAllI(tqp, msg);
  202dfc:	f104 000c 	add.w	r0, r4, #12
  202e00:	7525      	strb	r5, [r4, #20]
  202e02:	f7fe f8dd 	bl	200fc0 <chThdDequeueAllI.constprop.82>
  202e06:	f104 0044 	add.w	r0, r4, #68	; 0x44
  bqSuspendI(&sdup->obqueue);
  202e0a:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
  202e0e:	f7fe f8d7 	bl	200fc0 <chThdDequeueAllI.constprop.82>
  _dbg_check_unlock_from_isr();
  202e12:	f7fe fa3d 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202e16:	2300      	movs	r3, #0
  202e18:	f383 8811 	msr	BASEPRI, r3
  202e1c:	bd70      	pop	{r4, r5, r6, pc}
  202e1e:	bf00      	nop
  202e20:	20000800 	.word	0x20000800
  202e24:	0800c514 	.word	0x0800c514
  202e28:	0800c538 	.word	0x0800c538
  202e2c:	00000000 	.word	0x00000000

00202e30 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
  202e30:	b538      	push	{r3, r4, r5, lr}
  202e32:	460d      	mov	r5, r1
  char *p;

  if (str != NULL)
  202e34:	b1e8      	cbz	r0, 202e72 <parse_arguments+0x42>
  202e36:	4604      	mov	r4, r0
    *saveptr = str;
  202e38:	6028      	str	r0, [r5, #0]
  if (!p) {
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
  202e3a:	4911      	ldr	r1, [pc, #68]	; (202e80 <parse_arguments+0x50>)
  202e3c:	4620      	mov	r0, r4
  202e3e:	f008 feb7 	bl	20bbb0 <strspn>

  if (*p == '"') {
  202e42:	5c21      	ldrb	r1, [r4, r0]
  p += strspn(p, " \t");
  202e44:	4404      	add	r4, r0
  if (*p == '"') {
  202e46:	2922      	cmp	r1, #34	; 0x22
  202e48:	d00d      	beq.n	202e66 <parse_arguments+0x36>
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
  202e4a:	490d      	ldr	r1, [pc, #52]	; (202e80 <parse_arguments+0x50>)
  202e4c:	4620      	mov	r0, r4
  202e4e:	f008 fe8d 	bl	20bb6c <strpbrk>
  202e52:	6028      	str	r0, [r5, #0]
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
  202e54:	b118      	cbz	r0, 202e5e <parse_arguments+0x2e>
    *(*saveptr)++ = '\0';
  202e56:	1c42      	adds	r2, r0, #1
  202e58:	2300      	movs	r3, #0
  202e5a:	602a      	str	r2, [r5, #0]
  202e5c:	7003      	strb	r3, [r0, #0]
  }

  return *p != '\0' ? p : NULL;
  202e5e:	7823      	ldrb	r3, [r4, #0]
  202e60:	b153      	cbz	r3, 202e78 <parse_arguments+0x48>
}
  202e62:	4620      	mov	r0, r4
  202e64:	bd38      	pop	{r3, r4, r5, pc}
    p++;
  202e66:	3401      	adds	r4, #1
    *saveptr = strpbrk(p, "\"");
  202e68:	4620      	mov	r0, r4
  202e6a:	f008 fd8d 	bl	20b988 <strchr>
  202e6e:	6028      	str	r0, [r5, #0]
  202e70:	e7f0      	b.n	202e54 <parse_arguments+0x24>
  p = *saveptr;
  202e72:	680c      	ldr	r4, [r1, #0]
  if (!p) {
  202e74:	2c00      	cmp	r4, #0
  202e76:	d1e0      	bne.n	202e3a <parse_arguments+0xa>
  return *p != '\0' ? p : NULL;
  202e78:	2400      	movs	r4, #0
}
  202e7a:	4620      	mov	r0, r4
  202e7c:	bd38      	pop	{r3, r4, r5, pc}
  202e7e:	bf00      	nop
  202e80:	0800c920 	.word	0x0800c920
	...

00202e90 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  202e90:	b40e      	push	{r1, r2, r3}
  202e92:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  202e96:	b086      	sub	sp, #24
  202e98:	4604      	mov	r4, r0
  int n = 0;
  202e9a:	2700      	movs	r7, #0
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  202e9c:	ae0f      	add	r6, sp, #60	; 0x3c
  202e9e:	f856 5b04 	ldr.w	r5, [r6], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  202ea2:	9602      	str	r6, [sp, #8]
    c = *fmt++;
  202ea4:	7829      	ldrb	r1, [r5, #0]
  202ea6:	1c6a      	adds	r2, r5, #1
    if (c == 0)
  202ea8:	b159      	cbz	r1, 202ec2 <chprintf+0x32>
    if (c != '%') {
  202eaa:	2925      	cmp	r1, #37	; 0x25
  202eac:	d00f      	beq.n	202ece <chprintf+0x3e>
      streamPut(chp, (uint8_t)c);
  202eae:	6823      	ldr	r3, [r4, #0]
    c = *fmt++;
  202eb0:	4615      	mov	r5, r2
      streamPut(chp, (uint8_t)c);
  202eb2:	4620      	mov	r0, r4
      n++;
  202eb4:	3701      	adds	r7, #1
      streamPut(chp, (uint8_t)c);
  202eb6:	68db      	ldr	r3, [r3, #12]
  202eb8:	4798      	blx	r3
    c = *fmt++;
  202eba:	7829      	ldrb	r1, [r5, #0]
  202ebc:	1c6a      	adds	r2, r5, #1
    if (c == 0)
  202ebe:	2900      	cmp	r1, #0
  202ec0:	d1f3      	bne.n	202eaa <chprintf+0x1a>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
  202ec2:	4638      	mov	r0, r7
  202ec4:	b006      	add	sp, #24
  202ec6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  202eca:	b003      	add	sp, #12
  202ecc:	4770      	bx	lr
    if (*fmt == '-') {
  202ece:	7869      	ldrb	r1, [r5, #1]
  202ed0:	292d      	cmp	r1, #45	; 0x2d
  202ed2:	f000 817e 	beq.w	2031d2 <chprintf+0x342>
    left_align = FALSE;
  202ed6:	f04f 0c00 	mov.w	ip, #0
    if (*fmt == '0') {
  202eda:	2930      	cmp	r1, #48	; 0x30
  202edc:	f000 8174 	beq.w	2031c8 <chprintf+0x338>
    filler = ' ';
  202ee0:	f04f 0b20 	mov.w	fp, #32
  202ee4:	3201      	adds	r2, #1
    width = 0;
  202ee6:	f04f 0800 	mov.w	r8, #0
  202eea:	e005      	b.n	202ef8 <chprintf+0x68>
        c = va_arg(ap, int);
  202eec:	7833      	ldrb	r3, [r6, #0]
  202eee:	3604      	adds	r6, #4
  202ef0:	f812 1b01 	ldrb.w	r1, [r2], #1
      width = width * 10 + c;
  202ef4:	eb03 0845 	add.w	r8, r3, r5, lsl #1
      if (c >= '0' && c <= '9')
  202ef8:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
      c = *fmt++;
  202efc:	4610      	mov	r0, r2
      width = width * 10 + c;
  202efe:	eb08 0588 	add.w	r5, r8, r8, lsl #2
      if (c >= '0' && c <= '9')
  202f02:	b2db      	uxtb	r3, r3
  202f04:	2b09      	cmp	r3, #9
  202f06:	d9f3      	bls.n	202ef0 <chprintf+0x60>
      else if (c == '*')
  202f08:	292a      	cmp	r1, #42	; 0x2a
  202f0a:	d0ef      	beq.n	202eec <chprintf+0x5c>
    if (c == '.') {
  202f0c:	292e      	cmp	r1, #46	; 0x2e
    precision = 0;
  202f0e:	f04f 0200 	mov.w	r2, #0
    if (c == '.') {
  202f12:	d048      	beq.n	202fa6 <chprintf+0x116>
    if (c == 'l' || c == 'L') {
  202f14:	f001 03df 	and.w	r3, r1, #223	; 0xdf
  202f18:	1c45      	adds	r5, r0, #1
  202f1a:	2b4c      	cmp	r3, #76	; 0x4c
  202f1c:	d14f      	bne.n	202fbe <chprintf+0x12e>
      if (*fmt)
  202f1e:	7803      	ldrb	r3, [r0, #0]
  202f20:	2b00      	cmp	r3, #0
  202f22:	f000 808b 	beq.w	20303c <chprintf+0x1ac>
    switch (c) {
  202f26:	f1a3 0144 	sub.w	r1, r3, #68	; 0x44
  202f2a:	2934      	cmp	r1, #52	; 0x34
  202f2c:	f200 813e 	bhi.w	2031ac <chprintf+0x31c>
  202f30:	e8df f011 	tbh	[pc, r1, lsl #1]
  202f34:	013c0158 	.word	0x013c0158
  202f38:	013c013c 	.word	0x013c013c
  202f3c:	0158013c 	.word	0x0158013c
  202f40:	013c013c 	.word	0x013c013c
  202f44:	013c013c 	.word	0x013c013c
  202f48:	0137013c 	.word	0x0137013c
  202f4c:	013c013c 	.word	0x013c013c
  202f50:	013c013c 	.word	0x013c013c
  202f54:	0107013c 	.word	0x0107013c
  202f58:	013c013c 	.word	0x013c013c
  202f5c:	013c0185 	.word	0x013c0185
  202f60:	013c013c 	.word	0x013c013c
  202f64:	013c013c 	.word	0x013c013c
  202f68:	013c013c 	.word	0x013c013c
  202f6c:	013c013c 	.word	0x013c013c
  202f70:	00ab013c 	.word	0x00ab013c
  202f74:	013c0158 	.word	0x013c0158
  202f78:	013c013c 	.word	0x013c013c
  202f7c:	0158013c 	.word	0x0158013c
  202f80:	013c013c 	.word	0x013c013c
  202f84:	013c013c 	.word	0x013c013c
  202f88:	0137013c 	.word	0x0137013c
  202f8c:	013c013c 	.word	0x013c013c
  202f90:	0088013c 	.word	0x0088013c
  202f94:	0107013c 	.word	0x0107013c
  202f98:	013c013c 	.word	0x013c013c
  202f9c:	0185      	.short	0x0185
          c = va_arg(ap, int);
  202f9e:	7833      	ldrb	r3, [r6, #0]
  202fa0:	3604      	adds	r6, #4
        precision += c;
  202fa2:	eb03 0245 	add.w	r2, r3, r5, lsl #1
        c = *fmt++;
  202fa6:	f810 1b01 	ldrb.w	r1, [r0], #1
        precision *= 10;
  202faa:	eb02 0582 	add.w	r5, r2, r2, lsl #2
        if (c >= '0' && c <= '9')
  202fae:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
  202fb2:	b2db      	uxtb	r3, r3
  202fb4:	2b09      	cmp	r3, #9
  202fb6:	d9f4      	bls.n	202fa2 <chprintf+0x112>
        else if (c == '*')
  202fb8:	292a      	cmp	r1, #42	; 0x2a
  202fba:	d0f0      	beq.n	202f9e <chprintf+0x10e>
  202fbc:	e7aa      	b.n	202f14 <chprintf+0x84>
      is_long = (c >= 'A') && (c <= 'Z');
  202fbe:	f1a1 0341 	sub.w	r3, r1, #65	; 0x41
    switch (c) {
  202fc2:	f1a1 0544 	sub.w	r5, r1, #68	; 0x44
      is_long = (c >= 'A') && (c <= 'Z');
  202fc6:	b2db      	uxtb	r3, r3
    switch (c) {
  202fc8:	2d34      	cmp	r5, #52	; 0x34
  202fca:	f200 80ed 	bhi.w	2031a8 <chprintf+0x318>
  202fce:	e8df f015 	tbh	[pc, r5, lsl #1]
  202fd2:	0139      	.short	0x0139
  202fd4:	00eb00eb 	.word	0x00eb00eb
  202fd8:	00eb00eb 	.word	0x00eb00eb
  202fdc:	00eb0139 	.word	0x00eb0139
  202fe0:	00eb00eb 	.word	0x00eb00eb
  202fe4:	00eb00eb 	.word	0x00eb00eb
  202fe8:	00eb00e7 	.word	0x00eb00e7
  202fec:	00eb00eb 	.word	0x00eb00eb
  202ff0:	00eb00eb 	.word	0x00eb00eb
  202ff4:	00eb00b7 	.word	0x00eb00b7
  202ff8:	010500eb 	.word	0x010500eb
  202ffc:	00eb00eb 	.word	0x00eb00eb
  203000:	00eb00eb 	.word	0x00eb00eb
  203004:	00eb00eb 	.word	0x00eb00eb
  203008:	00eb00eb 	.word	0x00eb00eb
  20300c:	00eb00eb 	.word	0x00eb00eb
  203010:	0139005b 	.word	0x0139005b
  203014:	00eb00eb 	.word	0x00eb00eb
  203018:	00eb00eb 	.word	0x00eb00eb
  20301c:	00eb0139 	.word	0x00eb0139
  203020:	00eb00eb 	.word	0x00eb00eb
  203024:	00eb00eb 	.word	0x00eb00eb
  203028:	00eb00e7 	.word	0x00eb00e7
  20302c:	00eb00eb 	.word	0x00eb00eb
  203030:	00eb0038 	.word	0x00eb0038
  203034:	00eb00b7 	.word	0x00eb00b7
  203038:	010500eb 	.word	0x010500eb
      if (*fmt)
  20303c:	460b      	mov	r3, r1
  20303e:	4605      	mov	r5, r0
  203040:	e771      	b.n	202f26 <chprintf+0x96>
    switch (c) {
  203042:	4605      	mov	r5, r0
      if ((s = va_arg(ap, char *)) == 0)
  203044:	f8d6 9000 	ldr.w	r9, [r6]
  203048:	3604      	adds	r6, #4
  20304a:	f1b9 0f00 	cmp.w	r9, #0
  20304e:	f000 810f 	beq.w	203270 <chprintf+0x3e0>
  203052:	f899 3000 	ldrb.w	r3, [r9]
  203056:	4648      	mov	r0, r9
      if (precision == 0)
  203058:	2a00      	cmp	r2, #0
  20305a:	f040 8110 	bne.w	20327e <chprintf+0x3ee>
      for (p = s; *p && (--precision >= 0); p++)
  20305e:	2b00      	cmp	r3, #0
  203060:	f000 811e 	beq.w	2032a0 <chprintf+0x410>
  203064:	f647 72fe 	movw	r2, #32766	; 0x7ffe
  203068:	464b      	mov	r3, r9
  20306a:	e001      	b.n	203070 <chprintf+0x1e0>
  20306c:	3a01      	subs	r2, #1
  20306e:	d403      	bmi.n	203078 <chprintf+0x1e8>
  203070:	f813 1f01 	ldrb.w	r1, [r3, #1]!
  203074:	2900      	cmp	r1, #0
  203076:	d1f9      	bne.n	20306c <chprintf+0x1dc>
  203078:	1a1b      	subs	r3, r3, r0
      filler = ' ';
  20307a:	f04f 0b20 	mov.w	fp, #32
  20307e:	eba8 0803 	sub.w	r8, r8, r3
  203082:	3b01      	subs	r3, #1
  203084:	9300      	str	r3, [sp, #0]
  203086:	e00c      	b.n	2030a2 <chprintf+0x212>
    switch (c) {
  203088:	4605      	mov	r5, r0
      *p++ = va_arg(ap, int);
  20308a:	6833      	ldr	r3, [r6, #0]
  20308c:	f10d 0918 	add.w	r9, sp, #24
  203090:	f108 38ff 	add.w	r8, r8, #4294967295
  203094:	3604      	adds	r6, #4
  203096:	f809 3d0c 	strb.w	r3, [r9, #-12]!
      filler = ' ';
  20309a:	f04f 0b20 	mov.w	fp, #32
      *p++ = va_arg(ap, int);
  20309e:	2300      	movs	r3, #0
  2030a0:	9300      	str	r3, [sp, #0]
    if ((width -= i) < 0)
  2030a2:	f1b8 0f00 	cmp.w	r8, #0
  2030a6:	db25      	blt.n	2030f4 <chprintf+0x264>
    if (left_align == FALSE)
  2030a8:	f1bc 0f00 	cmp.w	ip, #0
  2030ac:	f040 8088 	bne.w	2031c0 <chprintf+0x330>
      width = -width;
  2030b0:	f1c8 0300 	rsb	r3, r8, #0
    if (width < 0) {
  2030b4:	f1b8 0f00 	cmp.w	r8, #0
  2030b8:	f000 8081 	beq.w	2031be <chprintf+0x32e>
      if (*s == '-' && filler == '0') {
  2030bc:	f899 1000 	ldrb.w	r1, [r9]
  2030c0:	6822      	ldr	r2, [r4, #0]
  2030c2:	292d      	cmp	r1, #45	; 0x2d
  2030c4:	68d2      	ldr	r2, [r2, #12]
  2030c6:	d103      	bne.n	2030d0 <chprintf+0x240>
  2030c8:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
  2030cc:	f000 80c2 	beq.w	203254 <chprintf+0x3c4>
  2030d0:	469a      	mov	sl, r3
  2030d2:	e001      	b.n	2030d8 <chprintf+0x248>
  2030d4:	6823      	ldr	r3, [r4, #0]
  2030d6:	68da      	ldr	r2, [r3, #12]
        streamPut(chp, (uint8_t)filler);
  2030d8:	4659      	mov	r1, fp
  2030da:	4620      	mov	r0, r4
  2030dc:	4790      	blx	r2
      } while (++width != 0);
  2030de:	f11a 0a01 	adds.w	sl, sl, #1
  2030e2:	d1f7      	bne.n	2030d4 <chprintf+0x244>
    while (--i >= 0) {
  2030e4:	9a00      	ldr	r2, [sp, #0]
  2030e6:	4653      	mov	r3, sl
  2030e8:	4447      	add	r7, r8
  2030ea:	2a00      	cmp	r2, #0
  2030ec:	f6ff aeda 	blt.w	202ea4 <chprintf+0x14>
  2030f0:	4698      	mov	r8, r3
  2030f2:	e005      	b.n	203100 <chprintf+0x270>
  2030f4:	9b00      	ldr	r3, [sp, #0]
  2030f6:	2b00      	cmp	r3, #0
  2030f8:	f6ff aed4 	blt.w	202ea4 <chprintf+0x14>
      width = 0;
  2030fc:	f04f 0800 	mov.w	r8, #0
      width = -width;
  203100:	f8dd a000 	ldr.w	sl, [sp]
      streamPut(chp, (uint8_t)*s++);
  203104:	6823      	ldr	r3, [r4, #0]
    while (--i >= 0) {
  203106:	f10a 3aff 	add.w	sl, sl, #4294967295
      streamPut(chp, (uint8_t)*s++);
  20310a:	f819 1b01 	ldrb.w	r1, [r9], #1
  20310e:	4620      	mov	r0, r4
  203110:	68db      	ldr	r3, [r3, #12]
  203112:	4798      	blx	r3
    while (--i >= 0) {
  203114:	f1ba 3fff 	cmp.w	sl, #4294967295
  203118:	d1f4      	bne.n	203104 <chprintf+0x274>
  20311a:	3701      	adds	r7, #1
  20311c:	9b00      	ldr	r3, [sp, #0]
  20311e:	443b      	add	r3, r7
  203120:	461f      	mov	r7, r3
    while (width) {
  203122:	f1b8 0f00 	cmp.w	r8, #0
  203126:	f43f aebd 	beq.w	202ea4 <chprintf+0x14>
  20312a:	46c1      	mov	r9, r8
      streamPut(chp, (uint8_t)filler);
  20312c:	6823      	ldr	r3, [r4, #0]
  20312e:	4659      	mov	r1, fp
  203130:	4620      	mov	r0, r4
  203132:	68db      	ldr	r3, [r3, #12]
  203134:	4798      	blx	r3
    while (width) {
  203136:	f1b9 0901 	subs.w	r9, r9, #1
  20313a:	d1f7      	bne.n	20312c <chprintf+0x29c>
  20313c:	4447      	add	r7, r8
  20313e:	e6b1      	b.n	202ea4 <chprintf+0x14>
    switch (c) {
  203140:	4605      	mov	r5, r0
    case 'U':
  203142:	f04f 090a 	mov.w	r9, #10
  203146:	f856 eb04 	ldr.w	lr, [r6], #4
  q = p + MAX_FILLER;
  20314a:	f10d 0217 	add.w	r2, sp, #23
  20314e:	e000      	b.n	203152 <chprintf+0x2c2>
  } while ((ll /= radix) != 0);
  203150:	4602      	mov	r2, r0
    *--q = i;
  203152:	1e50      	subs	r0, r2, #1
    i = (int)(l % radix);
  203154:	fbbe f1f9 	udiv	r1, lr, r9
  203158:	fb09 ea11 	mls	sl, r9, r1, lr
    l /= radix;
  20315c:	468e      	mov	lr, r1
    i += '0';
  20315e:	f10a 0330 	add.w	r3, sl, #48	; 0x30
    if (i > '9')
  203162:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
  203164:	bfc8      	it	gt
  203166:	f10a 0337 	addgt.w	r3, sl, #55	; 0x37
    *--q = i;
  20316a:	b2db      	uxtb	r3, r3
  20316c:	f802 3c01 	strb.w	r3, [r2, #-1]
  } while ((ll /= radix) != 0);
  203170:	2900      	cmp	r1, #0
  203172:	d1ed      	bne.n	203150 <chprintf+0x2c0>
  i = (int)(p + MAX_FILLER - q);
  203174:	f10d 0117 	add.w	r1, sp, #23
  203178:	f10d 090c 	add.w	r9, sp, #12
  20317c:	eba1 0a00 	sub.w	sl, r1, r0
  203180:	46ce      	mov	lr, r9
  203182:	eb00 010a 	add.w	r1, r0, sl
  203186:	e001      	b.n	20318c <chprintf+0x2fc>
  203188:	f812 3b01 	ldrb.w	r3, [r2], #1
  while (--i);
  20318c:	428a      	cmp	r2, r1
    *p++ = *q++;
  20318e:	f80e 3b01 	strb.w	r3, [lr], #1
  while (--i);
  203192:	d1f9      	bne.n	203188 <chprintf+0x2f8>
  203194:	f10a 33ff 	add.w	r3, sl, #4294967295
  203198:	eba8 080a 	sub.w	r8, r8, sl
  20319c:	9300      	str	r3, [sp, #0]
  20319e:	e780      	b.n	2030a2 <chprintf+0x212>
    switch (c) {
  2031a0:	4605      	mov	r5, r0
    case 'O':
  2031a2:	f04f 0908 	mov.w	r9, #8
  2031a6:	e7ce      	b.n	203146 <chprintf+0x2b6>
    switch (c) {
  2031a8:	4605      	mov	r5, r0
  2031aa:	460b      	mov	r3, r1
      *p++ = c;
  2031ac:	f10d 0918 	add.w	r9, sp, #24
  2031b0:	2200      	movs	r2, #0
  2031b2:	f108 38ff 	add.w	r8, r8, #4294967295
  2031b6:	9200      	str	r2, [sp, #0]
  2031b8:	f809 3d0c 	strb.w	r3, [r9, #-12]!
  2031bc:	e771      	b.n	2030a2 <chprintf+0x212>
      width = -width;
  2031be:	4698      	mov	r8, r3
    while (--i >= 0) {
  2031c0:	9b00      	ldr	r3, [sp, #0]
  2031c2:	2b00      	cmp	r3, #0
  2031c4:	da9c      	bge.n	203100 <chprintf+0x270>
  2031c6:	e7ac      	b.n	203122 <chprintf+0x292>
  2031c8:	7851      	ldrb	r1, [r2, #1]
      filler = '0';
  2031ca:	f04f 0b30 	mov.w	fp, #48	; 0x30
      fmt++;
  2031ce:	3201      	adds	r2, #1
  2031d0:	e688      	b.n	202ee4 <chprintf+0x54>
      fmt++;
  2031d2:	1caa      	adds	r2, r5, #2
  2031d4:	78a9      	ldrb	r1, [r5, #2]
      left_align = TRUE;
  2031d6:	f04f 0c01 	mov.w	ip, #1
  2031da:	e67e      	b.n	202eda <chprintf+0x4a>
    switch (c) {
  2031dc:	4605      	mov	r5, r0
  2031de:	f04f 0910 	mov.w	r9, #16
  2031e2:	e7b0      	b.n	203146 <chprintf+0x2b6>
  2031e4:	1d31      	adds	r1, r6, #4
        l = va_arg(ap, long);
  2031e6:	6832      	ldr	r2, [r6, #0]
  2031e8:	460e      	mov	r6, r1
      if (l < 0) {
  2031ea:	2a00      	cmp	r2, #0
  2031ec:	db4f      	blt.n	20328e <chprintf+0x3fe>
    p = tmpbuf;
  2031ee:	f10d 090c 	add.w	r9, sp, #12
  2031f2:	4648      	mov	r0, r9
  q = p + MAX_FILLER;
  2031f4:	f100 030b 	add.w	r3, r0, #11
  2031f8:	4619      	mov	r1, r3
  2031fa:	9300      	str	r3, [sp, #0]
    i = (int)(l % radix);
  2031fc:	4b2b      	ldr	r3, [pc, #172]	; (2032ac <chprintf+0x41c>)
  2031fe:	fba3 e302 	umull	lr, r3, r3, r2
  203202:	08db      	lsrs	r3, r3, #3
  203204:	eb03 0a83 	add.w	sl, r3, r3, lsl #2
  203208:	469e      	mov	lr, r3
  20320a:	eba2 034a 	sub.w	r3, r2, sl, lsl #1
  } while ((ll /= radix) != 0);
  20320e:	4672      	mov	r2, lr
    i += '0';
  203210:	3330      	adds	r3, #48	; 0x30
    *--q = i;
  203212:	b2db      	uxtb	r3, r3
  203214:	f801 3d01 	strb.w	r3, [r1, #-1]!
  } while ((ll /= radix) != 0);
  203218:	2a00      	cmp	r2, #0
  20321a:	d1ef      	bne.n	2031fc <chprintf+0x36c>
  i = (int)(p + MAX_FILLER - q);
  20321c:	9a00      	ldr	r2, [sp, #0]
  20321e:	1a52      	subs	r2, r2, r1
  203220:	4402      	add	r2, r0
  203222:	e001      	b.n	203228 <chprintf+0x398>
  203224:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    *p++ = *q++;
  203228:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
  20322c:	4290      	cmp	r0, r2
  20322e:	d1f9      	bne.n	203224 <chprintf+0x394>
  203230:	eba0 0009 	sub.w	r0, r0, r9
  203234:	1e43      	subs	r3, r0, #1
  203236:	eba8 0800 	sub.w	r8, r8, r0
  20323a:	9300      	str	r3, [sp, #0]
  20323c:	e731      	b.n	2030a2 <chprintf+0x212>
    switch (c) {
  20323e:	f04f 0910 	mov.w	r9, #16
  203242:	e780      	b.n	203146 <chprintf+0x2b6>
  203244:	4631      	mov	r1, r6
      if (is_long)
  203246:	2b19      	cmp	r3, #25
  203248:	4605      	mov	r5, r0
  20324a:	f851 2b04 	ldr.w	r2, [r1], #4
  20324e:	d9ca      	bls.n	2031e6 <chprintf+0x356>
        l = va_arg(ap, int);
  203250:	460e      	mov	r6, r1
  203252:	e7ca      	b.n	2031ea <chprintf+0x35a>
        streamPut(chp, (uint8_t)*s++);
  203254:	4620      	mov	r0, r4
  203256:	9301      	str	r3, [sp, #4]
  203258:	4790      	blx	r2
  20325a:	9b00      	ldr	r3, [sp, #0]
  20325c:	6822      	ldr	r2, [r4, #0]
  20325e:	3701      	adds	r7, #1
  203260:	3b01      	subs	r3, #1
  203262:	f109 0901 	add.w	r9, r9, #1
  203266:	68d2      	ldr	r2, [r2, #12]
  203268:	9300      	str	r3, [sp, #0]
  20326a:	9b01      	ldr	r3, [sp, #4]
  20326c:	469a      	mov	sl, r3
  20326e:	e733      	b.n	2030d8 <chprintf+0x248>
  203270:	480f      	ldr	r0, [pc, #60]	; (2032b0 <chprintf+0x420>)
      if (precision == 0)
  203272:	4681      	mov	r9, r0
  203274:	2a00      	cmp	r2, #0
  203276:	f43f aef5 	beq.w	203064 <chprintf+0x1d4>
      for (p = s; *p && (--precision >= 0); p++)
  20327a:	3a01      	subs	r2, #1
  20327c:	e6f4      	b.n	203068 <chprintf+0x1d8>
  20327e:	2b00      	cmp	r3, #0
  203280:	d1fb      	bne.n	20327a <chprintf+0x3ea>
  203282:	f04f 33ff 	mov.w	r3, #4294967295
      filler = ' ';
  203286:	f04f 0b20 	mov.w	fp, #32
      for (p = s; *p && (--precision >= 0); p++)
  20328a:	9300      	str	r3, [sp, #0]
  20328c:	e709      	b.n	2030a2 <chprintf+0x212>
        *p++ = '-';
  20328e:	232d      	movs	r3, #45	; 0x2d
        l = -l;
  203290:	4252      	negs	r2, r2
        *p++ = '-';
  203292:	f10d 000d 	add.w	r0, sp, #13
  203296:	f10d 090c 	add.w	r9, sp, #12
  20329a:	f88d 300c 	strb.w	r3, [sp, #12]
  20329e:	e7a9      	b.n	2031f4 <chprintf+0x364>
      for (p = s; *p && (--precision >= 0); p++)
  2032a0:	f04f 33ff 	mov.w	r3, #4294967295
      filler = ' ';
  2032a4:	f04f 0b20 	mov.w	fp, #32
      for (p = s; *p && (--precision >= 0); p++)
  2032a8:	9300      	str	r3, [sp, #0]
  2032aa:	e6fd      	b.n	2030a8 <chprintf+0x218>
  2032ac:	cccccccd 	.word	0xcccccccd
  2032b0:	0800c258 	.word	0x0800c258
	...

002032c0 <cmd_write>:
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

  (void)argv;
  if (argc > 0) {
  2032c0:	2900      	cmp	r1, #0
  2032c2:	dc18      	bgt.n	2032f6 <cmd_write+0x36>
static void cmd_write(BaseSequentialStream *chp, int argc, char *argv[]) {
  2032c4:	b570      	push	{r4, r5, r6, lr}
  2032c6:	4604      	mov	r4, r0
  }

  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
#if 1
    /* Writing in channel mode.*/
    chnWrite(&PORTAB_SDU1, buf, sizeof buf - 1);
  2032c8:	4e0c      	ldr	r6, [pc, #48]	; (2032fc <cmd_write+0x3c>)
  2032ca:	4d0d      	ldr	r5, [pc, #52]	; (203300 <cmd_write+0x40>)
  2032cc:	e002      	b.n	2032d4 <cmd_write+0x14>
  2032ce:	6833      	ldr	r3, [r6, #0]
  2032d0:	685b      	ldr	r3, [r3, #4]
  2032d2:	4798      	blx	r3
  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
  2032d4:	6823      	ldr	r3, [r4, #0]
  2032d6:	2100      	movs	r1, #0
  2032d8:	4620      	mov	r0, r4
  2032da:	699b      	ldr	r3, [r3, #24]
  2032dc:	4798      	blx	r3
  2032de:	3001      	adds	r0, #1
    chnWrite(&PORTAB_SDU1, buf, sizeof buf - 1);
  2032e0:	f44f 6280 	mov.w	r2, #1024	; 0x400
  2032e4:	4629      	mov	r1, r5
  2032e6:	4805      	ldr	r0, [pc, #20]	; (2032fc <cmd_write+0x3c>)
  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
  2032e8:	d0f1      	beq.n	2032ce <cmd_write+0xe>
    (void) obqGetEmptyBufferTimeout(&PORTAB_SDU1.obqueue, TIME_INFINITE);
    memcpy(PORTAB_SDU1.obqueue.ptr, buf, SERIAL_USB_BUFFERS_SIZE);
    obqPostFullBuffer(&PORTAB_SDU1.obqueue, SERIAL_USB_BUFFERS_SIZE);
#endif
  }
  chprintf(chp, "\r\n\nstopped\r\n");
  2032ea:	4620      	mov	r0, r4
  2032ec:	4905      	ldr	r1, [pc, #20]	; (203304 <cmd_write+0x44>)
}
  2032ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chprintf(chp, "\r\n\nstopped\r\n");
  2032f2:	f7ff bdcd 	b.w	202e90 <chprintf>
    chprintf(chp, "Usage: write\r\n");
  2032f6:	4904      	ldr	r1, [pc, #16]	; (203308 <cmd_write+0x48>)
  2032f8:	f7ff bdca 	b.w	202e90 <chprintf>
  2032fc:	20000800 	.word	0x20000800
  203300:	20010000 	.word	0x20010000
  203304:	0800c4c0 	.word	0x0800c4c0
  203308:	0800c4d0 	.word	0x0800c4d0
  20330c:	00000000 	.word	0x00000000

00203310 <cmd_echo>:

#if (SHELL_CMD_ECHO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_echo(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc != 1) {
  203310:	2901      	cmp	r1, #1
  203312:	d003      	beq.n	20331c <cmd_echo+0xc>
    shellUsage(chp, "echo \"message\"");
  203314:	4a03      	ldr	r2, [pc, #12]	; (203324 <cmd_echo+0x14>)
  203316:	4904      	ldr	r1, [pc, #16]	; (203328 <cmd_echo+0x18>)
  203318:	f7ff bdba 	b.w	202e90 <chprintf>
    return;
  }
  chprintf(chp, "%s" SHELL_NEWLINE_STR, argv[0]);
  20331c:	6812      	ldr	r2, [r2, #0]
  20331e:	4903      	ldr	r1, [pc, #12]	; (20332c <cmd_echo+0x1c>)
  203320:	f7ff bdb6 	b.w	202e90 <chprintf>
  203324:	0800c260 	.word	0x0800c260
  203328:	0800c270 	.word	0x0800c270
  20332c:	0800c27c 	.word	0x0800c27c

00203330 <cmd_info>:
  if (argc > 0) {
  203330:	2900      	cmp	r1, #0
  203332:	dd03      	ble.n	20333c <cmd_info+0xc>
    shellUsage(chp, "info");
  203334:	4a19      	ldr	r2, [pc, #100]	; (20339c <cmd_info+0x6c>)
  203336:	491a      	ldr	r1, [pc, #104]	; (2033a0 <cmd_info+0x70>)
  203338:	f7ff bdaa 	b.w	202e90 <chprintf>
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
  20333c:	b510      	push	{r4, lr}
  20333e:	4604      	mov	r4, r0
  203340:	b082      	sub	sp, #8
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
  203342:	4a18      	ldr	r2, [pc, #96]	; (2033a4 <cmd_info+0x74>)
  203344:	4918      	ldr	r1, [pc, #96]	; (2033a8 <cmd_info+0x78>)
  203346:	f7ff fda3 	bl	202e90 <chprintf>
  chprintf(chp, "Compiler:     %s" SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
  20334a:	4a18      	ldr	r2, [pc, #96]	; (2033ac <cmd_info+0x7c>)
  20334c:	4918      	ldr	r1, [pc, #96]	; (2033b0 <cmd_info+0x80>)
  20334e:	4620      	mov	r0, r4
  203350:	f7ff fd9e 	bl	202e90 <chprintf>
  chprintf(chp, "Architecture: %s" SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
  203354:	4a17      	ldr	r2, [pc, #92]	; (2033b4 <cmd_info+0x84>)
  203356:	4918      	ldr	r1, [pc, #96]	; (2033b8 <cmd_info+0x88>)
  203358:	4620      	mov	r0, r4
  20335a:	f7ff fd99 	bl	202e90 <chprintf>
  chprintf(chp, "Core Variant: %s" SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
  20335e:	4a17      	ldr	r2, [pc, #92]	; (2033bc <cmd_info+0x8c>)
  203360:	4917      	ldr	r1, [pc, #92]	; (2033c0 <cmd_info+0x90>)
  203362:	4620      	mov	r0, r4
  203364:	f7ff fd94 	bl	202e90 <chprintf>
  chprintf(chp, "Port Info:    %s" SHELL_NEWLINE_STR, PORT_INFO);
  203368:	4a16      	ldr	r2, [pc, #88]	; (2033c4 <cmd_info+0x94>)
  20336a:	4917      	ldr	r1, [pc, #92]	; (2033c8 <cmd_info+0x98>)
  20336c:	4620      	mov	r0, r4
  20336e:	f7ff fd8f 	bl	202e90 <chprintf>
  chprintf(chp, "Platform:     %s" SHELL_NEWLINE_STR, PLATFORM_NAME);
  203372:	4a16      	ldr	r2, [pc, #88]	; (2033cc <cmd_info+0x9c>)
  203374:	4916      	ldr	r1, [pc, #88]	; (2033d0 <cmd_info+0xa0>)
  203376:	4620      	mov	r0, r4
  203378:	f7ff fd8a 	bl	202e90 <chprintf>
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
  20337c:	4a15      	ldr	r2, [pc, #84]	; (2033d4 <cmd_info+0xa4>)
  20337e:	4916      	ldr	r1, [pc, #88]	; (2033d8 <cmd_info+0xa8>)
  203380:	4620      	mov	r0, r4
  203382:	f7ff fd85 	bl	202e90 <chprintf>
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
  203386:	4a15      	ldr	r2, [pc, #84]	; (2033dc <cmd_info+0xac>)
  203388:	4b15      	ldr	r3, [pc, #84]	; (2033e0 <cmd_info+0xb0>)
  20338a:	4620      	mov	r0, r4
  20338c:	9200      	str	r2, [sp, #0]
  20338e:	4915      	ldr	r1, [pc, #84]	; (2033e4 <cmd_info+0xb4>)
  203390:	4a15      	ldr	r2, [pc, #84]	; (2033e8 <cmd_info+0xb8>)
  203392:	f7ff fd7d 	bl	202e90 <chprintf>
}
  203396:	b002      	add	sp, #8
  203398:	bd10      	pop	{r4, pc}
  20339a:	bf00      	nop
  20339c:	0800c284 	.word	0x0800c284
  2033a0:	0800c270 	.word	0x0800c270
  2033a4:	0800cbfc 	.word	0x0800cbfc
  2033a8:	0800c28c 	.word	0x0800c28c
  2033ac:	0800ca50 	.word	0x0800ca50
  2033b0:	0800c2a0 	.word	0x0800c2a0
  2033b4:	0800c9e0 	.word	0x0800c9e0
  2033b8:	0800c2b4 	.word	0x0800c2b4
  2033bc:	0800ca18 	.word	0x0800ca18
  2033c0:	0800c2c8 	.word	0x0800c2c8
  2033c4:	0800cac4 	.word	0x0800cac4
  2033c8:	0800c2dc 	.word	0x0800c2dc
  2033cc:	0800c2f0 	.word	0x0800c2f0
  2033d0:	0800c324 	.word	0x0800c324
  2033d4:	0800c338 	.word	0x0800c338
  2033d8:	0800c360 	.word	0x0800c360
  2033dc:	0800c39c 	.word	0x0800c39c
  2033e0:	0800c374 	.word	0x0800c374
  2033e4:	0800c384 	.word	0x0800c384
  2033e8:	0800c378 	.word	0x0800c378
  2033ec:	00000000 	.word	0x00000000

002033f0 <dyn_find_object>:
    chPoolFree(mp, (void *)dep);
  }
}
#endif /* CH_FACTORY_REQUIRES_POOLS */

static dyn_element_t *dyn_find_object(const char *name, dyn_list_t *dlp) {
  2033f0:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
  2033f2:	680c      	ldr	r4, [r1, #0]
  while (p != (dyn_element_t *)dlp) {
  2033f4:	42a1      	cmp	r1, r4
  2033f6:	d012      	beq.n	20341e <dyn_find_object+0x2e>
  2033f8:	460d      	mov	r5, r1
  2033fa:	4606      	mov	r6, r0
  2033fc:	e002      	b.n	203404 <dyn_find_object+0x14>
    p = p->next;
  2033fe:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
  203400:	42a5      	cmp	r5, r4
  203402:	d00c      	beq.n	20341e <dyn_find_object+0x2e>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
  203404:	2208      	movs	r2, #8
  203406:	4631      	mov	r1, r6
  203408:	18a0      	adds	r0, r4, r2
  20340a:	f008 fb31 	bl	20ba70 <strncmp>
  20340e:	2800      	cmp	r0, #0
  203410:	d1f5      	bne.n	2033fe <dyn_find_object+0xe>

  chDbgCheck(name != NULL);

  /* Checking if an object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
  if (dep != NULL) {
  203412:	b12c      	cbz	r4, 203420 <dyn_find_object+0x30>
    /* Increasing references counter.*/
    dep->refs++;
  203414:	6863      	ldr	r3, [r4, #4]
  }

  return dep;
}
  203416:	4620      	mov	r0, r4
    dep->refs++;
  203418:	3301      	adds	r3, #1
  20341a:	6063      	str	r3, [r4, #4]
}
  20341c:	bd70      	pop	{r4, r5, r6, pc}
  return NULL;
  20341e:	2400      	movs	r4, #0
}
  203420:	4620      	mov	r0, r4
  203422:	bd70      	pop	{r4, r5, r6, pc}
	...

00203430 <chSchWakeupS>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  203430:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
  203432:	4d18      	ldr	r5, [pc, #96]	; (203494 <chSchWakeupS+0x64>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  203434:	4604      	mov	r4, r0
  203436:	460e      	mov	r6, r1
  chDbgCheckClassS();
  203438:	f7fd fc9a 	bl	200d70 <chDbgCheckClassS>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20343c:	682a      	ldr	r2, [r5, #0]
  thread_t *otp = currp;
  20343e:	69a8      	ldr	r0, [r5, #24]
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203440:	42aa      	cmp	r2, r5
  203442:	6883      	ldr	r3, [r0, #8]
  203444:	d002      	beq.n	20344c <chSchWakeupS+0x1c>
  203446:	6892      	ldr	r2, [r2, #8]
  203448:	429a      	cmp	r2, r3
  20344a:	d818      	bhi.n	20347e <chSchWakeupS+0x4e>
  if (ntp->prio <= otp->prio) {
  20344c:	68a2      	ldr	r2, [r4, #8]
  ntp->u.rdymsg = msg;
  20344e:	6266      	str	r6, [r4, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
  203450:	429a      	cmp	r2, r3
  203452:	d917      	bls.n	203484 <chSchWakeupS+0x54>
    otp = chSchReadyI(otp);
  203454:	f7fd fd4c 	bl	200ef0 <chSchReadyI>
    ntp->state = CH_STATE_CURRENT;
  203458:	2301      	movs	r3, #1
    otp = chSchReadyI(otp);
  20345a:	4606      	mov	r6, r0
    currp = ntp;
  20345c:	61ac      	str	r4, [r5, #24]
    ntp->state = CH_STATE_CURRENT;
  20345e:	f884 3020 	strb.w	r3, [r4, #32]
    chSysSwitch(ntp, otp);
  203462:	f7fd fb25 	bl	200ab0 <_trace_switch.constprop.79>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  203466:	f3ef 8309 	mrs	r3, PSP
  20346a:	3b24      	subs	r3, #36	; 0x24
  20346c:	69f2      	ldr	r2, [r6, #28]
  20346e:	429a      	cmp	r2, r3
  203470:	d80d      	bhi.n	20348e <chSchWakeupS+0x5e>
  203472:	4631      	mov	r1, r6
  203474:	4620      	mov	r0, r4
}
  203476:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
  20347a:	f7fc bf31 	b.w	2002e0 <_port_switch>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20347e:	4806      	ldr	r0, [pc, #24]	; (203498 <chSchWakeupS+0x68>)
  203480:	f7fd fb76 	bl	200b70 <chSysHalt>
    (void) chSchReadyI(ntp);
  203484:	4620      	mov	r0, r4
}
  203486:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    (void) chSchReadyI(ntp);
  20348a:	f7fd bd31 	b.w	200ef0 <chSchReadyI>
    chSysSwitch(ntp, otp);
  20348e:	4803      	ldr	r0, [pc, #12]	; (20349c <chSchWakeupS+0x6c>)
  203490:	f7fd fb6e 	bl	200b70 <chSysHalt>
  203494:	20000dc8 	.word	0x20000dc8
  203498:	0800bebc 	.word	0x0800bebc
  20349c:	0800c228 	.word	0x0800c228

002034a0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  2034a0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
  2034a2:	4c10      	ldr	r4, [pc, #64]	; (2034e4 <chSchGoSleepS+0x44>)
void chSchGoSleepS(tstate_t newstate) {
  2034a4:	4606      	mov	r6, r0
  chDbgCheckClassS();
  2034a6:	f7fd fc63 	bl	200d70 <chDbgCheckClassS>
  currp->state = CH_STATE_CURRENT;
  2034aa:	2101      	movs	r1, #1
  thread_t *otp = currp;
  2034ac:	69a5      	ldr	r5, [r4, #24]
  thread_t *tp = tqp->next;
  2034ae:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
  2034b0:	f885 6020 	strb.w	r6, [r5, #32]
  chSysSwitch(currp, otp);
  2034b4:	4628      	mov	r0, r5
  tqp->next             = tp->queue.next;
  2034b6:	681a      	ldr	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  2034b8:	6054      	str	r4, [r2, #4]
  currp->state = CH_STATE_CURRENT;
  2034ba:	f883 1020 	strb.w	r1, [r3, #32]
  tqp->next             = tp->queue.next;
  2034be:	6022      	str	r2, [r4, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
  2034c0:	61a3      	str	r3, [r4, #24]
  chSysSwitch(currp, otp);
  2034c2:	f7fd faf5 	bl	200ab0 <_trace_switch.constprop.79>
  2034c6:	f3ef 8309 	mrs	r3, PSP
  2034ca:	3b24      	subs	r3, #36	; 0x24
  2034cc:	69ea      	ldr	r2, [r5, #28]
  2034ce:	429a      	cmp	r2, r3
  2034d0:	d805      	bhi.n	2034de <chSchGoSleepS+0x3e>
  2034d2:	4629      	mov	r1, r5
  2034d4:	69a0      	ldr	r0, [r4, #24]
}
  2034d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(currp, otp);
  2034da:	f7fc bf01 	b.w	2002e0 <_port_switch>
  2034de:	4802      	ldr	r0, [pc, #8]	; (2034e8 <chSchGoSleepS+0x48>)
  2034e0:	f7fd fb46 	bl	200b70 <chSysHalt>
  2034e4:	20000dc8 	.word	0x20000dc8
  2034e8:	0800c228 	.word	0x0800c228
  2034ec:	00000000 	.word	0x00000000

002034f0 <chMtxLockS>:
void chMtxLockS(mutex_t *mp) {
  2034f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  2034f2:	4604      	mov	r4, r0
  thread_t *ctp = currp;
  2034f4:	4b3e      	ldr	r3, [pc, #248]	; (2035f0 <chMtxLockS+0x100>)
  2034f6:	699d      	ldr	r5, [r3, #24]
  chDbgCheckClassS();
  2034f8:	f7fd fc3a 	bl	200d70 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
  2034fc:	b32c      	cbz	r4, 20354a <chMtxLockS+0x5a>
  if (mp->owner != NULL) {
  2034fe:	68a3      	ldr	r3, [r4, #8]
  203500:	2b00      	cmp	r3, #0
  203502:	d04b      	beq.n	20359c <chMtxLockS+0xac>
      while (tp->prio < ctp->prio) {
  203504:	68a9      	ldr	r1, [r5, #8]
  203506:	689a      	ldr	r2, [r3, #8]
  203508:	4291      	cmp	r1, r2
  20350a:	d908      	bls.n	20351e <chMtxLockS+0x2e>
        switch (tp->state) {
  20350c:	f893 2020 	ldrb.w	r2, [r3, #32]
        tp->prio = ctp->prio;
  203510:	6099      	str	r1, [r3, #8]
        switch (tp->state) {
  203512:	2a06      	cmp	r2, #6
  203514:	d047      	beq.n	2035a6 <chMtxLockS+0xb6>
  203516:	2a07      	cmp	r2, #7
  203518:	d01e      	beq.n	203558 <chMtxLockS+0x68>
  20351a:	2a00      	cmp	r2, #0
  20351c:	d030      	beq.n	203580 <chMtxLockS+0x90>
      queue_prio_insert(ctp, &mp->queue);
  20351e:	4626      	mov	r6, r4
  203520:	4623      	mov	r3, r4
  203522:	e003      	b.n	20352c <chMtxLockS+0x3c>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  203524:	6899      	ldr	r1, [r3, #8]
  203526:	68aa      	ldr	r2, [r5, #8]
  203528:	4291      	cmp	r1, r2
  20352a:	d335      	bcc.n	203598 <chMtxLockS+0xa8>
    cp = cp->queue.next;
  20352c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  20352e:	429c      	cmp	r4, r3
  203530:	d1f8      	bne.n	203524 <chMtxLockS+0x34>
  tp->queue.prev             = cp->queue.prev;
  203532:	6873      	ldr	r3, [r6, #4]
      chSchGoSleepS(CH_STATE_WTMTX);
  203534:	2006      	movs	r0, #6
  203536:	e9c5 6300 	strd	r6, r3, [r5]
  tp->queue.prev->queue.next = tp;
  20353a:	601d      	str	r5, [r3, #0]
  cp->queue.prev             = tp;
  20353c:	6075      	str	r5, [r6, #4]
      ctp->u.wtmtxp = mp;
  20353e:	626c      	str	r4, [r5, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
  203540:	f7ff ffae 	bl	2034a0 <chSchGoSleepS>
      chDbgAssert(mp->owner == ctp, "not owner");
  203544:	68a3      	ldr	r3, [r4, #8]
  203546:	42ab      	cmp	r3, r5
  203548:	d002      	beq.n	203550 <chMtxLockS+0x60>
  chDbgCheck(mp != NULL);
  20354a:	482a      	ldr	r0, [pc, #168]	; (2035f4 <chMtxLockS+0x104>)
  20354c:	f7fd fb10 	bl	200b70 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
  203550:	6bab      	ldr	r3, [r5, #56]	; 0x38
  203552:	42a3      	cmp	r3, r4
  203554:	d1f9      	bne.n	20354a <chMtxLockS+0x5a>
}
  203556:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  tp->queue.prev->queue.next = tp->queue.next;
  203558:	e9d3 2000 	ldrd	r2, r0, [r3]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
  20355c:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  20355e:	6002      	str	r2, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  203560:	681f      	ldr	r7, [r3, #0]
  203562:	4632      	mov	r2, r6
  203564:	6078      	str	r0, [r7, #4]
  203566:	e002      	b.n	20356e <chMtxLockS+0x7e>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  203568:	6890      	ldr	r0, [r2, #8]
  20356a:	4288      	cmp	r0, r1
  20356c:	d337      	bcc.n	2035de <chMtxLockS+0xee>
    cp = cp->queue.next;
  20356e:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  203570:	4296      	cmp	r6, r2
  203572:	d1f9      	bne.n	203568 <chMtxLockS+0x78>
  tp->queue.prev             = cp->queue.prev;
  203574:	6872      	ldr	r2, [r6, #4]
  203576:	e9c3 6200 	strd	r6, r2, [r3]
  tp->queue.prev->queue.next = tp;
  20357a:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
  20357c:	6073      	str	r3, [r6, #4]
  20357e:	e7ce      	b.n	20351e <chMtxLockS+0x2e>
  tp->queue.prev->queue.next = tp->queue.next;
  203580:	e9d3 1200 	ldrd	r1, r2, [r3]
          tp->state = CH_STATE_CURRENT;
  203584:	2001      	movs	r0, #1
  203586:	f883 0020 	strb.w	r0, [r3, #32]
          (void) chSchReadyI(queue_dequeue(tp));
  20358a:	4618      	mov	r0, r3
  20358c:	6011      	str	r1, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  20358e:	681b      	ldr	r3, [r3, #0]
  203590:	605a      	str	r2, [r3, #4]
  203592:	f7fd fcad 	bl	200ef0 <chSchReadyI>
  203596:	e7c2      	b.n	20351e <chMtxLockS+0x2e>
    cp = cp->queue.next;
  203598:	461e      	mov	r6, r3
  20359a:	e7ca      	b.n	203532 <chMtxLockS+0x42>
    mp->next = ctp->mtxlist;
  20359c:	6bab      	ldr	r3, [r5, #56]	; 0x38
  20359e:	e9c4 5302 	strd	r5, r3, [r4, #8]
    ctp->mtxlist = mp;
  2035a2:	63ac      	str	r4, [r5, #56]	; 0x38
}
  2035a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  tp->queue.prev->queue.next = tp->queue.next;
  2035a6:	e9d3 2c00 	ldrd	r2, ip, [r3]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
  2035aa:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  2035ac:	f8cc 2000 	str.w	r2, [ip]
  tp->queue.next->queue.prev = tp->queue.prev;
  2035b0:	6818      	ldr	r0, [r3, #0]
  2035b2:	4637      	mov	r7, r6
  2035b4:	4632      	mov	r2, r6
  2035b6:	f8c0 c004 	str.w	ip, [r0, #4]
  2035ba:	e002      	b.n	2035c2 <chMtxLockS+0xd2>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  2035bc:	6890      	ldr	r0, [r2, #8]
  2035be:	4288      	cmp	r0, r1
  2035c0:	d314      	bcc.n	2035ec <chMtxLockS+0xfc>
    cp = cp->queue.next;
  2035c2:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  2035c4:	4296      	cmp	r6, r2
  2035c6:	d1f9      	bne.n	2035bc <chMtxLockS+0xcc>
  tp->queue.prev             = cp->queue.prev;
  2035c8:	687a      	ldr	r2, [r7, #4]
      while (tp->prio < ctp->prio) {
  2035ca:	68a9      	ldr	r1, [r5, #8]
  2035cc:	e9c3 7200 	strd	r7, r2, [r3]
  tp->queue.prev->queue.next = tp;
  2035d0:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
  2035d2:	607b      	str	r3, [r7, #4]
          tp = tp->u.wtmtxp->owner;
  2035d4:	68b3      	ldr	r3, [r6, #8]
      while (tp->prio < ctp->prio) {
  2035d6:	689a      	ldr	r2, [r3, #8]
  2035d8:	428a      	cmp	r2, r1
  2035da:	d397      	bcc.n	20350c <chMtxLockS+0x1c>
  2035dc:	e79f      	b.n	20351e <chMtxLockS+0x2e>
    cp = cp->queue.next;
  2035de:	4616      	mov	r6, r2
  tp->queue.prev             = cp->queue.prev;
  2035e0:	6872      	ldr	r2, [r6, #4]
  2035e2:	e9c3 6200 	strd	r6, r2, [r3]
  tp->queue.prev->queue.next = tp;
  2035e6:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
  2035e8:	6073      	str	r3, [r6, #4]
  2035ea:	e798      	b.n	20351e <chMtxLockS+0x2e>
    cp = cp->queue.next;
  2035ec:	4617      	mov	r7, r2
  2035ee:	e7eb      	b.n	2035c8 <chMtxLockS+0xd8>
  2035f0:	20000dc8 	.word	0x20000dc8
  2035f4:	0800bd80 	.word	0x0800bd80
	...

00203600 <chThdExitS>:
void chThdExitS(msg_t msg) {
  203600:	b508      	push	{r3, lr}
  thread_t *tp = currp;
  203602:	4b11      	ldr	r3, [pc, #68]	; (203648 <chThdExitS+0x48>)
  203604:	699c      	ldr	r4, [r3, #24]
  while (list_notempty(&tp->waiting)) {
  203606:	f104 0528 	add.w	r5, r4, #40	; 0x28
  return (bool)(tlp->next != (thread_t *)tlp);
  20360a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
  20360c:	6260      	str	r0, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
  20360e:	42ab      	cmp	r3, r5
  203610:	d007      	beq.n	203622 <chThdExitS+0x22>
  tlp->next = tp->queue.next;
  203612:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(list_remove(&tp->waiting));
  203614:	4618      	mov	r0, r3
  203616:	62a2      	str	r2, [r4, #40]	; 0x28
  203618:	f7fd fc6a 	bl	200ef0 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
  20361c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
  20361e:	42ab      	cmp	r3, r5
  203620:	d1f7      	bne.n	203612 <chThdExitS+0x12>
  if ((tp->refs == (trefs_t)0) &&
  203622:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
  203626:	b943      	cbnz	r3, 20363a <chThdExitS+0x3a>
  203628:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
  20362c:	079b      	lsls	r3, r3, #30
  20362e:	d104      	bne.n	20363a <chThdExitS+0x3a>
    REG_REMOVE(tp);
  203630:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
  203634:	611a      	str	r2, [r3, #16]
  203636:	6922      	ldr	r2, [r4, #16]
  203638:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
  20363a:	200f      	movs	r0, #15
  20363c:	f7ff ff30 	bl	2034a0 <chSchGoSleepS>
  chDbgAssert(false, "zombies apocalypse");
  203640:	4802      	ldr	r0, [pc, #8]	; (20364c <chThdExitS+0x4c>)
  203642:	f7fd fa95 	bl	200b70 <chSysHalt>
  203646:	bf00      	nop
  203648:	20000dc8 	.word	0x20000dc8
  20364c:	0800bf50 	.word	0x0800bf50

00203650 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
  203650:	b570      	push	{r4, r5, r6, lr}
  203652:	460d      	mov	r5, r1
  203654:	b086      	sub	sp, #24
  203656:	4606      	mov	r6, r0
  chDbgCheckClassS();
  203658:	f7fd fb8a 	bl	200d70 <chDbgCheckClassS>
  if (TIME_INFINITE != timeout) {
  20365c:	1c6b      	adds	r3, r5, #1
    chVTDoSetI(&vt, timeout, wakeup, currp);
  20365e:	4c0e      	ldr	r4, [pc, #56]	; (203698 <chSchGoSleepTimeoutS+0x48>)
  if (TIME_INFINITE != timeout) {
  203660:	d013      	beq.n	20368a <chSchGoSleepTimeoutS+0x3a>
    chVTDoSetI(&vt, timeout, wakeup, currp);
  203662:	69a3      	ldr	r3, [r4, #24]
  203664:	4629      	mov	r1, r5
  203666:	4a0d      	ldr	r2, [pc, #52]	; (20369c <chSchGoSleepTimeoutS+0x4c>)
  203668:	a801      	add	r0, sp, #4
  20366a:	f7fe fe01 	bl	202270 <chVTDoSetI>
    chSchGoSleepS(newstate);
  20366e:	4630      	mov	r0, r6
  203670:	f7ff ff16 	bl	2034a0 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {

  chDbgCheckClassI();
  203674:	f7fd fb8c 	bl	200d90 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
  203678:	9b04      	ldr	r3, [sp, #16]
  20367a:	b113      	cbz	r3, 203682 <chSchGoSleepTimeoutS+0x32>
      chVTDoResetI(&vt);
  20367c:	a801      	add	r0, sp, #4
  20367e:	f7fe fdaf 	bl	2021e0 <chVTDoResetI>
  return currp->u.rdymsg;
  203682:	69a3      	ldr	r3, [r4, #24]
}
  203684:	6a58      	ldr	r0, [r3, #36]	; 0x24
  203686:	b006      	add	sp, #24
  203688:	bd70      	pop	{r4, r5, r6, pc}
    chSchGoSleepS(newstate);
  20368a:	4630      	mov	r0, r6
  20368c:	f7ff ff08 	bl	2034a0 <chSchGoSleepS>
  return currp->u.rdymsg;
  203690:	69a3      	ldr	r3, [r4, #24]
}
  203692:	6a58      	ldr	r0, [r3, #36]	; 0x24
  203694:	b006      	add	sp, #24
  203696:	bd70      	pop	{r4, r5, r6, pc}
  203698:	20000dc8 	.word	0x20000dc8
  20369c:	002012f1 	.word	0x002012f1

002036a0 <chSemWaitTimeoutS>:
msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout) {
  2036a0:	b538      	push	{r3, r4, r5, lr}
  2036a2:	4604      	mov	r4, r0
  2036a4:	460d      	mov	r5, r1
  chDbgCheckClassS();
  2036a6:	f7fd fb63 	bl	200d70 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
  2036aa:	b12c      	cbz	r4, 2036b8 <chSemWaitTimeoutS+0x18>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  2036ac:	68a3      	ldr	r3, [r4, #8]
  2036ae:	6822      	ldr	r2, [r4, #0]
  2036b0:	2b00      	cmp	r3, #0
  2036b2:	db04      	blt.n	2036be <chSemWaitTimeoutS+0x1e>
  2036b4:	42a2      	cmp	r2, r4
  2036b6:	d004      	beq.n	2036c2 <chSemWaitTimeoutS+0x22>
  chDbgCheck(sp != NULL);
  2036b8:	480e      	ldr	r0, [pc, #56]	; (2036f4 <chSemWaitTimeoutS+0x54>)
  2036ba:	f7fd fa59 	bl	200b70 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  2036be:	42a2      	cmp	r2, r4
  2036c0:	d0fa      	beq.n	2036b8 <chSemWaitTimeoutS+0x18>
  if (--sp->cnt < (cnt_t)0) {
  2036c2:	1e5a      	subs	r2, r3, #1
  2036c4:	2a00      	cmp	r2, #0
  2036c6:	60a2      	str	r2, [r4, #8]
  2036c8:	db01      	blt.n	2036ce <chSemWaitTimeoutS+0x2e>
  return MSG_OK;
  2036ca:	2000      	movs	r0, #0
}
  2036cc:	bd38      	pop	{r3, r4, r5, pc}
    if (TIME_IMMEDIATE == timeout) {
  2036ce:	b16d      	cbz	r5, 2036ec <chSemWaitTimeoutS+0x4c>
    currp->u.wtsemp = sp;
  2036d0:	4b09      	ldr	r3, [pc, #36]	; (2036f8 <chSemWaitTimeoutS+0x58>)
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
  2036d2:	4629      	mov	r1, r5
  2036d4:	2005      	movs	r0, #5
    currp->u.wtsemp = sp;
  2036d6:	699b      	ldr	r3, [r3, #24]
  2036d8:	625c      	str	r4, [r3, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
  2036da:	6862      	ldr	r2, [r4, #4]
  2036dc:	e9c3 4200 	strd	r4, r2, [r3]
  tp->queue.prev->queue.next = tp;
  2036e0:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
  2036e2:	6063      	str	r3, [r4, #4]
}
  2036e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
  2036e8:	f7ff bfb2 	b.w	203650 <chSchGoSleepTimeoutS>
      sp->cnt++;
  2036ec:	60a3      	str	r3, [r4, #8]
      return MSG_TIMEOUT;
  2036ee:	f04f 30ff 	mov.w	r0, #4294967295
}
  2036f2:	bd38      	pop	{r3, r4, r5, pc}
  2036f4:	0800be78 	.word	0x0800be78
  2036f8:	20000dc8 	.word	0x20000dc8
  2036fc:	00000000 	.word	0x00000000

00203700 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
  203700:	b161      	cbz	r1, 20371c <chThdEnqueueTimeoutS+0x1c>
  203702:	4602      	mov	r2, r0
  queue_insert(currp, tqp);
  203704:	4b07      	ldr	r3, [pc, #28]	; (203724 <chThdEnqueueTimeoutS+0x24>)
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  203706:	2004      	movs	r0, #4
  queue_insert(currp, tqp);
  203708:	699b      	ldr	r3, [r3, #24]
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
  20370a:	b410      	push	{r4}
  tp->queue.prev             = tqp->prev;
  20370c:	6854      	ldr	r4, [r2, #4]
  20370e:	e9c3 2400 	strd	r2, r4, [r3]
  tp->queue.prev->queue.next = tp;
  203712:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
  203714:	6053      	str	r3, [r2, #4]
}
  203716:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  203718:	f7ff bf9a 	b.w	203650 <chSchGoSleepTimeoutS>
}
  20371c:	f04f 30ff 	mov.w	r0, #4294967295
  203720:	4770      	bx	lr
  203722:	bf00      	nop
  203724:	20000dc8 	.word	0x20000dc8
	...

00203730 <obqGetEmptyBufferTimeoutS>:
                                sysinterval_t timeout) {
  203730:	b538      	push	{r3, r4, r5, lr}
  203732:	4604      	mov	r4, r0
  203734:	460d      	mov	r5, r1
  osalDbgCheckClassS();
  203736:	f7fd fb1b 	bl	200d70 <chDbgCheckClassS>
  20373a:	e007      	b.n	20374c <obqGetEmptyBufferTimeoutS+0x1c>
    if (obqp->suspended) {
  20373c:	7a23      	ldrb	r3, [r4, #8]
  20373e:	b993      	cbnz	r3, 203766 <obqGetEmptyBufferTimeoutS+0x36>
  return chThdEnqueueTimeoutS(tqp, timeout);
  203740:	4629      	mov	r1, r5
  203742:	4620      	mov	r0, r4
  203744:	f7ff ffdc 	bl	203700 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
  203748:	2800      	cmp	r0, #0
  20374a:	db0b      	blt.n	203764 <obqGetEmptyBufferTimeoutS+0x34>
  while (obqIsFullI(obqp)) {
  20374c:	68e3      	ldr	r3, [r4, #12]
  20374e:	2b00      	cmp	r3, #0
  203750:	d0f4      	beq.n	20373c <obqGetEmptyBufferTimeoutS+0xc>
  osalDbgAssert(!obqIsFullI(obqp), "still full");
  203752:	68e3      	ldr	r3, [r4, #12]
  203754:	b153      	cbz	r3, 20376c <obqGetEmptyBufferTimeoutS+0x3c>
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  203756:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
  203758:	2000      	movs	r0, #0
  20375a:	69e1      	ldr	r1, [r4, #28]
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  20375c:	1d1a      	adds	r2, r3, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
  20375e:	440b      	add	r3, r1
  203760:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
}
  203764:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
  203766:	f06f 0001 	mvn.w	r0, #1
}
  20376a:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!obqIsFullI(obqp), "still full");
  20376c:	4801      	ldr	r0, [pc, #4]	; (203774 <obqGetEmptyBufferTimeoutS+0x44>)
  20376e:	f7fd f9ff 	bl	200b70 <chSysHalt>
  203772:	bf00      	nop
  203774:	0800c114 	.word	0x0800c114
	...

00203780 <ibqGetFullBufferTimeoutS>:
                                 sysinterval_t timeout) {
  203780:	b538      	push	{r3, r4, r5, lr}
  203782:	4604      	mov	r4, r0
  203784:	460d      	mov	r5, r1
  osalDbgCheckClassS();
  203786:	f7fd faf3 	bl	200d70 <chDbgCheckClassS>
  20378a:	e007      	b.n	20379c <ibqGetFullBufferTimeoutS+0x1c>
    if (ibqp->suspended) {
  20378c:	7a23      	ldrb	r3, [r4, #8]
  20378e:	b993      	cbnz	r3, 2037b6 <ibqGetFullBufferTimeoutS+0x36>
  203790:	4629      	mov	r1, r5
  203792:	4620      	mov	r0, r4
  203794:	f7ff ffb4 	bl	203700 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
  203798:	2800      	cmp	r0, #0
  20379a:	db0b      	blt.n	2037b4 <ibqGetFullBufferTimeoutS+0x34>
  while (ibqIsEmptyI(ibqp)) {
  20379c:	68e3      	ldr	r3, [r4, #12]
  20379e:	2b00      	cmp	r3, #0
  2037a0:	d0f4      	beq.n	20378c <ibqGetFullBufferTimeoutS+0xc>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
  2037a2:	68e3      	ldr	r3, [r4, #12]
  2037a4:	b153      	cbz	r3, 2037bc <ibqGetFullBufferTimeoutS+0x3c>
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  2037a6:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
  2037a8:	2000      	movs	r0, #0
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  2037aa:	1d1a      	adds	r2, r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
  2037ac:	681b      	ldr	r3, [r3, #0]
  2037ae:	4413      	add	r3, r2
  2037b0:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
}
  2037b4:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
  2037b6:	f06f 0001 	mvn.w	r0, #1
}
  2037ba:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
  2037bc:	4801      	ldr	r0, [pc, #4]	; (2037c4 <ibqGetFullBufferTimeoutS+0x44>)
  2037be:	f7fd f9d7 	bl	200b70 <chSysHalt>
  2037c2:	bf00      	nop
  2037c4:	0800c040 	.word	0x0800c040
	...

002037d0 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
  2037d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
  2037d2:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
  2037d6:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
  2037d8:	b113      	cbz	r3, 2037e0 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
  2037da:	2300      	movs	r3, #0
  2037dc:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
  2037e0:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  if ((usbp->config->requests_hook_cb == NULL) ||
  2037e4:	6862      	ldr	r2, [r4, #4]
  2037e6:	68cb      	ldr	r3, [r1, #12]
  2037e8:	6a1b      	ldr	r3, [r3, #32]
  2037ea:	6819      	ldr	r1, [r3, #0]
  2037ec:	685b      	ldr	r3, [r3, #4]
  2037ee:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
  2037f2:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  2037f6:	6893      	ldr	r3, [r2, #8]
  2037f8:	b353      	cbz	r3, 203850 <_usb_ep0setup+0x80>
      !(usbp->config->requests_hook_cb(usbp))) {
  2037fa:	4620      	mov	r0, r4
  2037fc:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
  2037fe:	b338      	cbz	r0, 203850 <_usb_ep0setup+0x80>
  203800:	6fa1      	ldr	r1, [r4, #120]	; 0x78
  203802:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
  hw |= (uint16_t)*p << 8U;
  203806:	f894 0087 	ldrb.w	r0, [r4, #135]	; 0x87
  20380a:	f894 2086 	ldrb.w	r2, [r4, #134]	; 0x86
  max = (size_t)get_hword(&usbp->setup[6]);
  20380e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  if (usbp->ep0n > max) {
  203812:	428a      	cmp	r2, r1
  203814:	bf2c      	ite	cs
  203816:	460a      	movcs	r2, r1
    usbp->ep0n = max;
  203818:	67a2      	strcc	r2, [r4, #120]	; 0x78
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
  20381a:	0619      	lsls	r1, r3, #24
  20381c:	f100 808d 	bmi.w	20393a <_usb_ep0setup+0x16a>
    if (usbp->ep0n != 0U) {
  203820:	2a00      	cmp	r2, #0
  203822:	d05d      	beq.n	2038e0 <_usb_ep0setup+0x110>
      usbp->ep0state = USB_EP0_OUT_RX;
  203824:	2315      	movs	r3, #21
  203826:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
  __ASM volatile ("cpsid i" : : : "memory");
  20382a:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20382c:	2320      	movs	r3, #32
  20382e:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203832:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  203834:	f7fd fd44 	bl	2012c0 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
  203838:	4620      	mov	r0, r4
  20383a:	e9d4 231d 	ldrd	r2, r3, [r4, #116]	; 0x74
  20383e:	2100      	movs	r1, #0
  203840:	f7fe fa2e 	bl	201ca0 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
  203844:	f7fd fd24 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203848:	2300      	movs	r3, #0
  20384a:	f383 8811 	msr	BASEPRI, r3
}
  20384e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
  203850:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
  203854:	f013 0560 	ands.w	r5, r3, #96	; 0x60
  203858:	4619      	mov	r1, r3
  20385a:	d017      	beq.n	20388c <_usb_ep0setup+0xbc>
  20385c:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  203860:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  203864:	6861      	ldr	r1, [r4, #4]
  203866:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  20386a:	680d      	ldr	r5, [r1, #0]
  20386c:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  203870:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  203874:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  203878:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  20387c:	b115      	cbz	r5, 203884 <_usb_ep0setup+0xb4>
  20387e:	2106      	movs	r1, #6
  203880:	4620      	mov	r0, r4
  203882:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
  203884:	2306      	movs	r3, #6
  203886:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
  20388a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
           ((uint32_t)usbp->setup[1] << 8U))) {
  20388c:	f894 6081 	ldrb.w	r6, [r4, #129]	; 0x81
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  203890:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  203894:	f240 3002 	movw	r0, #770	; 0x302
                                        USB_RTYPE_TYPE_MASK)) |
  203898:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  20389c:	4282      	cmp	r2, r0
  20389e:	f000 80e0 	beq.w	203a62 <_usb_ep0setup+0x292>
  2038a2:	d833      	bhi.n	20390c <_usb_ep0setup+0x13c>
  2038a4:	2a02      	cmp	r2, #2
  2038a6:	f000 80ca 	beq.w	203a3e <_usb_ep0setup+0x26e>
  2038aa:	f240 809b 	bls.w	2039e4 <_usb_ep0setup+0x214>
  2038ae:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
  2038b2:	f000 80a0 	beq.w	2039f6 <_usb_ep0setup+0x226>
  2038b6:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
  2038ba:	d073      	beq.n	2039a4 <_usb_ep0setup+0x1d4>
  2038bc:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  2038c0:	d1cc      	bne.n	20385c <_usb_ep0setup+0x8c>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
  2038c2:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
  2038c6:	2b01      	cmp	r3, #1
  2038c8:	d1c8      	bne.n	20385c <_usb_ep0setup+0x8c>
      usbp->status &= ~2U;
  2038ca:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
      usbSetupTransfer(usbp, NULL, 0, NULL);
  2038ce:	6765      	str	r5, [r4, #116]	; 0x74
      usbp->status &= ~2U;
  2038d0:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
  2038d4:	e9c4 551e 	strd	r5, r5, [r4, #120]	; 0x78
      usbp->status &= ~2U;
  2038d8:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
  2038dc:	060b      	lsls	r3, r1, #24
  2038de:	d43b      	bmi.n	203958 <_usb_ep0setup+0x188>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
  2038e0:	230b      	movs	r3, #11
  2038e2:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
  __ASM volatile ("cpsid i" : : : "memory");
  2038e6:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2038e8:	2320      	movs	r3, #32
  2038ea:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2038ee:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  2038f0:	f7fd fce6 	bl	2012c0 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
  2038f4:	2300      	movs	r3, #0
  2038f6:	4620      	mov	r0, r4
  2038f8:	461a      	mov	r2, r3
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
  2038fa:	2100      	movs	r1, #0
  2038fc:	f7fe f960 	bl	201bc0 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
  203900:	f7fd fcc6 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203904:	2300      	movs	r3, #0
  203906:	f383 8811 	msr	BASEPRI, r3
}
  20390a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  20390c:	f240 6001 	movw	r0, #1537	; 0x601
  203910:	4282      	cmp	r2, r0
  203912:	d956      	bls.n	2039c2 <_usb_ep0setup+0x1f2>
  203914:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
  203918:	d02c      	beq.n	203974 <_usb_ep0setup+0x1a4>
  20391a:	f640 4102 	movw	r1, #3074	; 0xc02
  20391e:	428a      	cmp	r2, r1
  203920:	f000 8085 	beq.w	203a2e <_usb_ep0setup+0x25e>
  203924:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
  203928:	d198      	bne.n	20385c <_usb_ep0setup+0x8c>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
  20392a:	f104 018b 	add.w	r1, r4, #139	; 0x8b
  20392e:	2201      	movs	r2, #1
  203930:	67e5      	str	r5, [r4, #124]	; 0x7c
  203932:	6761      	str	r1, [r4, #116]	; 0x74
  203934:	4611      	mov	r1, r2
  203936:	67a2      	str	r2, [r4, #120]	; 0x78
  203938:	e765      	b.n	203806 <_usb_ep0setup+0x36>
    if (usbp->ep0n != 0U) {
  20393a:	b16a      	cbz	r2, 203958 <_usb_ep0setup+0x188>
      usbp->ep0state = USB_EP0_IN_TX;
  20393c:	2309      	movs	r3, #9
  20393e:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
  __ASM volatile ("cpsid i" : : : "memory");
  203942:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203944:	2320      	movs	r3, #32
  203946:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20394a:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  20394c:	f7fd fcb8 	bl	2012c0 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
  203950:	4620      	mov	r0, r4
  203952:	e9d4 231d 	ldrd	r2, r3, [r4, #116]	; 0x74
  203956:	e7d0      	b.n	2038fa <_usb_ep0setup+0x12a>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
  203958:	2314      	movs	r3, #20
  20395a:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
  __ASM volatile ("cpsid i" : : : "memory");
  20395e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203960:	2320      	movs	r3, #32
  203962:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203966:	b662      	cpsie	i
  203968:	f7fd fcaa 	bl	2012c0 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, NULL, 0);
  20396c:	2300      	movs	r3, #0
  20396e:	4620      	mov	r0, r4
  203970:	461a      	mov	r2, r3
  203972:	e764      	b.n	20383e <_usb_ep0setup+0x6e>
      if (usbp->state == USB_ACTIVE) {
  203974:	7823      	ldrb	r3, [r4, #0]
  203976:	2b04      	cmp	r3, #4
  203978:	f000 80c5 	beq.w	203b06 <_usb_ep0setup+0x336>
      if (usbp->setup[2] != 0U) {
  20397c:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
  203980:	b14b      	cbz	r3, 203996 <_usb_ep0setup+0x1c6>
        usbp->state = USB_ACTIVE;
  203982:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
  203984:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
  203986:	f884 308b 	strb.w	r3, [r4, #139]	; 0x8b
        usbp->state = USB_ACTIVE;
  20398a:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
  20398c:	6813      	ldr	r3, [r2, #0]
  20398e:	b113      	cbz	r3, 203996 <_usb_ep0setup+0x1c6>
  203990:	2102      	movs	r1, #2
  203992:	4620      	mov	r0, r4
  203994:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
  203996:	2300      	movs	r3, #0
  203998:	f894 1080 	ldrb.w	r1, [r4, #128]	; 0x80
  20399c:	e9c4 331d 	strd	r3, r3, [r4, #116]	; 0x74
  2039a0:	67e3      	str	r3, [r4, #124]	; 0x7c
  2039a2:	e79b      	b.n	2038dc <_usb_ep0setup+0x10c>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
  2039a4:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
  2039a8:	2b01      	cmp	r3, #1
  2039aa:	f47f af57 	bne.w	20385c <_usb_ep0setup+0x8c>
      usbp->status |= 2U;
  2039ae:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
      usbSetupTransfer(usbp, NULL, 0, NULL);
  2039b2:	6765      	str	r5, [r4, #116]	; 0x74
      usbp->status |= 2U;
  2039b4:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
  2039b8:	e9c4 551e 	strd	r5, r5, [r4, #120]	; 0x78
      usbp->status |= 2U;
  2039bc:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
  2039c0:	e78c      	b.n	2038dc <_usb_ep0setup+0x10c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  2039c2:	f5b2 6fc0 	cmp.w	r2, #1536	; 0x600
  2039c6:	d263      	bcs.n	203a90 <_usb_ep0setup+0x2c0>
  2039c8:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
  2039cc:	f47f af46 	bne.w	20385c <_usb_ep0setup+0x8c>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
  2039d0:	f8b4 3080 	ldrh.w	r3, [r4, #128]	; 0x80
  2039d4:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
  2039d8:	d07c      	beq.n	203ad4 <_usb_ep0setup+0x304>
    usbSetupTransfer(usbp, NULL, 0, NULL);
  2039da:	2300      	movs	r3, #0
  2039dc:	e9c4 331d 	strd	r3, r3, [r4, #116]	; 0x74
  2039e0:	67e3      	str	r3, [r4, #124]	; 0x7c
  2039e2:	e77b      	b.n	2038dc <_usb_ep0setup+0x10c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  2039e4:	bb02      	cbnz	r2, 203a28 <_usb_ep0setup+0x258>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
  2039e6:	f104 0188 	add.w	r1, r4, #136	; 0x88
  2039ea:	2002      	movs	r0, #2
  2039ec:	67e2      	str	r2, [r4, #124]	; 0x7c
  2039ee:	6761      	str	r1, [r4, #116]	; 0x74
  2039f0:	4601      	mov	r1, r0
  2039f2:	67a0      	str	r0, [r4, #120]	; 0x78
  2039f4:	e707      	b.n	203806 <_usb_ep0setup+0x36>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
  2039f6:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
  2039fa:	2b00      	cmp	r3, #0
  2039fc:	f47f af2e 	bne.w	20385c <_usb_ep0setup+0x8c>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
  203a00:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
  203a04:	f013 000f 	ands.w	r0, r3, #15
  203a08:	d0e7      	beq.n	2039da <_usb_ep0setup+0x20a>
  203a0a:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
      if ((usbp->setup[4] & 0x80U) != 0U) {
  203a0e:	f013 0f80 	tst.w	r3, #128	; 0x80
  203a12:	eb02 1340 	add.w	r3, r2, r0, lsl #5
  203a16:	f040 8085 	bne.w	203b24 <_usb_ep0setup+0x354>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
  203a1a:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  203a1e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  203a22:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  203a26:	e7d8      	b.n	2039da <_usb_ep0setup+0x20a>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  203a28:	2a01      	cmp	r2, #1
  203a2a:	f47f af17 	bne.w	20385c <_usb_ep0setup+0x8c>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
  203a2e:	4965      	ldr	r1, [pc, #404]	; (203bc4 <_usb_ep0setup+0x3f4>)
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
  203a30:	2202      	movs	r2, #2
  203a32:	2000      	movs	r0, #0
  203a34:	6761      	str	r1, [r4, #116]	; 0x74
  203a36:	4611      	mov	r1, r2
  203a38:	e9c4 201e 	strd	r2, r0, [r4, #120]	; 0x78
  203a3c:	e6e3      	b.n	203806 <_usb_ep0setup+0x36>
    if ((usbp->setup[4] & 0x80U) != 0U) {
  203a3e:	f894 0084 	ldrb.w	r0, [r4, #132]	; 0x84
  203a42:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
  203a46:	f000 010f 	and.w	r1, r0, #15
  203a4a:	0600      	lsls	r0, r0, #24
  203a4c:	d439      	bmi.n	203ac2 <_usb_ep0setup+0x2f2>
  ctl = usbp->otg->oe[ep].DOEPCTL;
  203a4e:	3158      	adds	r1, #88	; 0x58
  203a50:	0149      	lsls	r1, r1, #5
  203a52:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
  203a54:	040d      	lsls	r5, r1, #16
  203a56:	f57f af03 	bpl.w	203860 <_usb_ep0setup+0x90>
  if (ctl & DIEPCTL_STALL)
  203a5a:	028e      	lsls	r6, r1, #10
  203a5c:	d538      	bpl.n	203ad0 <_usb_ep0setup+0x300>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
  203a5e:	495a      	ldr	r1, [pc, #360]	; (203bc8 <_usb_ep0setup+0x3f8>)
  203a60:	e7e6      	b.n	203a30 <_usb_ep0setup+0x260>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
  203a62:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
  203a66:	2b00      	cmp	r3, #0
  203a68:	f47f aef8 	bne.w	20385c <_usb_ep0setup+0x8c>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
  203a6c:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
  203a70:	f013 000f 	ands.w	r0, r3, #15
  203a74:	d0b1      	beq.n	2039da <_usb_ep0setup+0x20a>
  203a76:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
  203a7a:	eb02 1240 	add.w	r2, r2, r0, lsl #5
      if ((usbp->setup[4] & 0x80U) != 0U) {
  203a7e:	0618      	lsls	r0, r3, #24
  203a80:	d457      	bmi.n	203b32 <_usb_ep0setup+0x362>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  203a82:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  203a86:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  203a8a:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  203a8e:	e7a4      	b.n	2039da <_usb_ep0setup+0x20a>
  hw |= (uint16_t)*p << 8U;
  203a90:	f894 2085 	ldrb.w	r2, [r4, #133]	; 0x85
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
  203a94:	4620      	mov	r0, r4
  203a96:	6861      	ldr	r1, [r4, #4]
  hw |= (uint16_t)*p << 8U;
  203a98:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
  203a9c:	684e      	ldr	r6, [r1, #4]
  203a9e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  203aa2:	f894 1083 	ldrb.w	r1, [r4, #131]	; 0x83
  203aa6:	f894 2082 	ldrb.w	r2, [r4, #130]	; 0x82
  203aaa:	47b0      	blx	r6
    if (dp == NULL) {
  203aac:	2800      	cmp	r0, #0
  203aae:	f43f aed5 	beq.w	20385c <_usb_ep0setup+0x8c>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
  203ab2:	e9d0 1300 	ldrd	r1, r3, [r0]
  203ab6:	67e5      	str	r5, [r4, #124]	; 0x7c
  203ab8:	e9c4 311d 	strd	r3, r1, [r4, #116]	; 0x74
  203abc:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
  203ac0:	e6a1      	b.n	203806 <_usb_ep0setup+0x36>
  ctl = usbp->otg->ie[ep].DIEPCTL;
  203ac2:	3148      	adds	r1, #72	; 0x48
  203ac4:	0149      	lsls	r1, r1, #5
  203ac6:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DIEPCTL_USBAEP))
  203ac8:	040f      	lsls	r7, r1, #16
  203aca:	f57f aec9 	bpl.w	203860 <_usb_ep0setup+0x90>
  203ace:	e7c4      	b.n	203a5a <_usb_ep0setup+0x28a>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
  203ad0:	493e      	ldr	r1, [pc, #248]	; (203bcc <_usb_ep0setup+0x3fc>)
  203ad2:	e7ad      	b.n	203a30 <_usb_ep0setup+0x260>
  usbp->address = usbp->setup[2];
  203ad4:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
  stm32_otg_t *otgp = usbp->otg;
  203ad8:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
  203adc:	f884 108a 	strb.w	r1, [r4, #138]	; 0x8a
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
  203ae0:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
  203ae4:	6860      	ldr	r0, [r4, #4]
  203ae6:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
  203aea:	6805      	ldr	r5, [r0, #0]
  203aec:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
  203af0:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
  203af4:	b115      	cbz	r5, 203afc <_usb_ep0setup+0x32c>
  203af6:	2101      	movs	r1, #1
  203af8:	4620      	mov	r0, r4
  203afa:	47a8      	blx	r5
  usbp->state = USB_SELECTED;
  203afc:	2303      	movs	r3, #3
  203afe:	f894 1080 	ldrb.w	r1, [r4, #128]	; 0x80
  203b02:	7023      	strb	r3, [r4, #0]
  203b04:	e769      	b.n	2039da <_usb_ep0setup+0x20a>
  __ASM volatile ("cpsid i" : : : "memory");
  203b06:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203b08:	2320      	movs	r3, #32
  203b0a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203b0e:	b662      	cpsie	i
  203b10:	f7fd fbd6 	bl	2012c0 <_dbg_check_lock_from_isr>
  osalDbgCheckClassI();
  203b14:	f7fd f93c 	bl	200d90 <chDbgCheckClassI>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
  203b18:	7823      	ldrb	r3, [r4, #0]
  203b1a:	2b04      	cmp	r3, #4
  203b1c:	d010      	beq.n	203b40 <_usb_ep0setup+0x370>
  203b1e:	482c      	ldr	r0, [pc, #176]	; (203bd0 <_usb_ep0setup+0x400>)
  203b20:	f7fd f826 	bl	200b70 <chSysHalt>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
  203b24:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  203b28:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  203b2c:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  203b30:	e753      	b.n	2039da <_usb_ep0setup+0x20a>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  203b32:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
  203b36:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  203b3a:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  203b3e:	e74c      	b.n	2039da <_usb_ep0setup+0x20a>
  203b40:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  203b44:	462a      	mov	r2, r5
  usbp->transmitting &= 1U;
  203b46:	8927      	ldrh	r7, [r4, #8]
    otgp->ie[i].DIEPCTL = 0;
  203b48:	462e      	mov	r6, r5
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  203b4a:	6818      	ldr	r0, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  203b4c:	f04f 31ff 	mov.w	r1, #4294967295
  203b50:	f007 0701 	and.w	r7, r7, #1
    usbp->epc[i] = NULL;
  203b54:	6125      	str	r5, [r4, #16]
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  203b56:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
  203b5a:	6898      	ldr	r0, [r3, #8]
  usbp->receiving    &= 1U;
  203b5c:	8963      	ldrh	r3, [r4, #10]
    usbp->epc[i] = NULL;
  203b5e:	6165      	str	r5, [r4, #20]
  203b60:	3001      	adds	r0, #1
  usbp->receiving    &= 1U;
  203b62:	f003 0301 	and.w	r3, r3, #1
  usbp->transmitting &= 1U;
  203b66:	8127      	strh	r7, [r4, #8]
    usbp->epc[i] = NULL;
  203b68:	e9c4 5506 	strd	r5, r5, [r4, #24]
  203b6c:	e9c4 5508 	strd	r5, r5, [r4, #32]
  203b70:	e9c4 550a 	strd	r5, r5, [r4, #40]	; 0x28
  203b74:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
  usbp->receiving    &= 1U;
  203b78:	8163      	strh	r3, [r4, #10]
  203b7a:	eb05 1342 	add.w	r3, r5, r2, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  203b7e:	3201      	adds	r2, #1
  203b80:	4290      	cmp	r0, r2
    otgp->ie[i].DIEPCTL = 0;
  203b82:	f8c3 6900 	str.w	r6, [r3, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
  203b86:	f8c3 6910 	str.w	r6, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  203b8a:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
  203b8e:	f8c3 6b00 	str.w	r6, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
  203b92:	f8c3 6b10 	str.w	r6, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  203b96:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  203b9a:	d1ee      	bne.n	203b7a <_usb_ep0setup+0x3aa>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  203b9c:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  203ba0:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
  _dbg_check_unlock_from_isr();
  203ba4:	f7fd fb74 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203ba8:	f386 8811 	msr	BASEPRI, r6
        usbp->state = USB_SELECTED;
  203bac:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
  203bae:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
  203bb0:	f884 608b 	strb.w	r6, [r4, #139]	; 0x8b
        usbp->state = USB_SELECTED;
  203bb4:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
  203bb6:	681b      	ldr	r3, [r3, #0]
  203bb8:	2b00      	cmp	r3, #0
  203bba:	f43f aedf 	beq.w	20397c <_usb_ep0setup+0x1ac>
  203bbe:	4620      	mov	r0, r4
  203bc0:	4798      	blx	r3
  203bc2:	e6db      	b.n	20397c <_usb_ep0setup+0x1ac>
  203bc4:	0800e950 	.word	0x0800e950
  203bc8:	0800c574 	.word	0x0800c574
  203bcc:	0800c1ec 	.word	0x0800c1ec
  203bd0:	0800c0d0 	.word	0x0800c0d0
	...

00203be0 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  203be0:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
  203be4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  203be6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203bea:	2300      	movs	r3, #0
  203bec:	f383 8811 	msr	BASEPRI, r3
}
  203bf0:	4770      	bx	lr
  203bf2:	bf00      	nop
	...

00203c00 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  203c00:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
  203c02:	4e1c      	ldr	r6, [pc, #112]	; (203c74 <chSchDoReschedule+0x74>)

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
  203c04:	2201      	movs	r2, #1
  thread_t *tp = tqp->next;
  203c06:	6833      	ldr	r3, [r6, #0]
  thread_t *otp = currp;
  203c08:	69b5      	ldr	r5, [r6, #24]
  tqp->next             = tp->queue.next;
  203c0a:	681c      	ldr	r4, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  203c0c:	6066      	str	r6, [r4, #4]
  currp->state = CH_STATE_CURRENT;
  203c0e:	f883 2020 	strb.w	r2, [r3, #32]
  tqp->next             = tp->queue.next;
  203c12:	6034      	str	r4, [r6, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
  203c14:	61b3      	str	r3, [r6, #24]
  chDbgCheckClassI();
  203c16:	f7fd f8bb 	bl	200d90 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
  203c1a:	b33d      	cbz	r5, 203c6c <chSchDoReschedule+0x6c>
  chDbgAssert((tp->state != CH_STATE_READY) &&
  203c1c:	f895 3020 	ldrb.w	r3, [r5, #32]
  203c20:	b323      	cbz	r3, 203c6c <chSchDoReschedule+0x6c>
  203c22:	f1a3 030f 	sub.w	r3, r3, #15
  203c26:	fab3 f383 	clz	r3, r3
  203c2a:	095b      	lsrs	r3, r3, #5
  203c2c:	b9f3      	cbnz	r3, 203c6c <chSchDoReschedule+0x6c>
  } while (cp->prio > tp->prio);
  203c2e:	68aa      	ldr	r2, [r5, #8]
  tp->state = CH_STATE_READY;
  203c30:	f885 3020 	strb.w	r3, [r5, #32]
  203c34:	e000      	b.n	203c38 <chSchDoReschedule+0x38>
  203c36:	6824      	ldr	r4, [r4, #0]
  } while (cp->prio > tp->prio);
  203c38:	68a3      	ldr	r3, [r4, #8]
  203c3a:	4293      	cmp	r3, r2
  203c3c:	d8fb      	bhi.n	203c36 <chSchDoReschedule+0x36>
  tp->queue.prev             = cp->queue.prev;
  203c3e:	6863      	ldr	r3, [r4, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  203c40:	4628      	mov	r0, r5
  tp->queue.prev             = cp->queue.prev;
  203c42:	e9c5 4300 	strd	r4, r3, [r5]
  tp->queue.prev->queue.next = tp;
  203c46:	601d      	str	r5, [r3, #0]
  cp->queue.prev             = tp;
  203c48:	6065      	str	r5, [r4, #4]
  chSysSwitch(currp, otp);
  203c4a:	f7fc ff31 	bl	200ab0 <_trace_switch.constprop.79>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  203c4e:	f3ef 8309 	mrs	r3, PSP
  203c52:	3b24      	subs	r3, #36	; 0x24
  203c54:	69ea      	ldr	r2, [r5, #28]
  203c56:	429a      	cmp	r2, r3
  203c58:	d805      	bhi.n	203c66 <chSchDoReschedule+0x66>
  203c5a:	4629      	mov	r1, r5
  203c5c:	69b0      	ldr	r0, [r6, #24]
}
  203c5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(currp, otp);
  203c62:	f7fc bb3d 	b.w	2002e0 <_port_switch>
  203c66:	4804      	ldr	r0, [pc, #16]	; (203c78 <chSchDoReschedule+0x78>)
  203c68:	f7fc ff82 	bl	200b70 <chSysHalt>
  chDbgCheck(tp != NULL);
  203c6c:	4803      	ldr	r0, [pc, #12]	; (203c7c <chSchDoReschedule+0x7c>)
  203c6e:	f7fc ff7f 	bl	200b70 <chSysHalt>
  203c72:	bf00      	nop
  203c74:	20000dc8 	.word	0x20000dc8
  203c78:	0800c228 	.word	0x0800c228
  203c7c:	0800bda8 	.word	0x0800bda8

00203c80 <chSchRescheduleS>:
void chSchRescheduleS(void) {
  203c80:	b508      	push	{r3, lr}
  chDbgCheckClassS();
  203c82:	f7fd f875 	bl	200d70 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
  203c86:	f7fd f883 	bl	200d90 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
  203c8a:	4b06      	ldr	r3, [pc, #24]	; (203ca4 <chSchRescheduleS+0x24>)
  203c8c:	681a      	ldr	r2, [r3, #0]
  203c8e:	699b      	ldr	r3, [r3, #24]
  if (chSchIsRescRequiredI()) {
  203c90:	6892      	ldr	r2, [r2, #8]
  203c92:	689b      	ldr	r3, [r3, #8]
  203c94:	429a      	cmp	r2, r3
  203c96:	d800      	bhi.n	203c9a <chSchRescheduleS+0x1a>
}
  203c98:	bd08      	pop	{r3, pc}
  203c9a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    chSchDoRescheduleAhead();
  203c9e:	f7ff bfaf 	b.w	203c00 <chSchDoReschedule>
  203ca2:	bf00      	nop
  203ca4:	20000dc8 	.word	0x20000dc8
	...

00203cb0 <_dbg_check_unlock>:
void _dbg_check_unlock(void) {
  203cb0:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
  203cb2:	4b05      	ldr	r3, [pc, #20]	; (203cc8 <_dbg_check_unlock+0x18>)
  203cb4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  203cb6:	b922      	cbnz	r2, 203cc2 <_dbg_check_unlock+0x12>
  203cb8:	6b59      	ldr	r1, [r3, #52]	; 0x34
  203cba:	2900      	cmp	r1, #0
  203cbc:	dd01      	ble.n	203cc2 <_dbg_check_unlock+0x12>
  _dbg_leave_lock();
  203cbe:	635a      	str	r2, [r3, #52]	; 0x34
}
  203cc0:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
  203cc2:	4802      	ldr	r0, [pc, #8]	; (203ccc <_dbg_check_unlock+0x1c>)
  203cc4:	f7fc ff54 	bl	200b70 <chSysHalt>
  203cc8:	20000dc8 	.word	0x20000dc8
  203ccc:	0800c1c8 	.word	0x0800c1c8

00203cd0 <chSysUnlock.lto_priv.111>:
static inline void chSysUnlock(void) {
  203cd0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
  203cd2:	f7ff ffed 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203cd6:	4b08      	ldr	r3, [pc, #32]	; (203cf8 <chSysUnlock.lto_priv.111+0x28>)
  203cd8:	681a      	ldr	r2, [r3, #0]
  203cda:	429a      	cmp	r2, r3
  203cdc:	d004      	beq.n	203ce8 <chSysUnlock.lto_priv.111+0x18>
  203cde:	6999      	ldr	r1, [r3, #24]
  203ce0:	6893      	ldr	r3, [r2, #8]
  203ce2:	688a      	ldr	r2, [r1, #8]
  203ce4:	429a      	cmp	r2, r3
  203ce6:	d303      	bcc.n	203cf0 <chSysUnlock.lto_priv.111+0x20>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203ce8:	2300      	movs	r3, #0
  203cea:	f383 8811 	msr	BASEPRI, r3
}
  203cee:	bd08      	pop	{r3, pc}
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203cf0:	4802      	ldr	r0, [pc, #8]	; (203cfc <chSysUnlock.lto_priv.111+0x2c>)
  203cf2:	f7fc ff3d 	bl	200b70 <chSysHalt>
  203cf6:	bf00      	nop
  203cf8:	20000dc8 	.word	0x20000dc8
  203cfc:	0800bce8 	.word	0x0800bce8

00203d00 <chSysRestoreStatusX.part.2>:
void chSysRestoreStatusX(syssts_t sts) {
  203d00:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  203d02:	f3ef 8305 	mrs	r3, IPSR
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
  203d06:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (port_is_isr_context()) {
  203d0a:	b983      	cbnz	r3, 203d2e <chSysRestoreStatusX.part.2+0x2e>
      chSchRescheduleS();
  203d0c:	f7ff ffb8 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  203d10:	f7ff ffce 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203d14:	4b0a      	ldr	r3, [pc, #40]	; (203d40 <chSysRestoreStatusX.part.2+0x40>)
  203d16:	681a      	ldr	r2, [r3, #0]
  203d18:	429a      	cmp	r2, r3
  203d1a:	d004      	beq.n	203d26 <chSysRestoreStatusX.part.2+0x26>
  203d1c:	6999      	ldr	r1, [r3, #24]
  203d1e:	6893      	ldr	r3, [r2, #8]
  203d20:	688a      	ldr	r2, [r1, #8]
  203d22:	429a      	cmp	r2, r3
  203d24:	d309      	bcc.n	203d3a <chSysRestoreStatusX.part.2+0x3a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203d26:	2300      	movs	r3, #0
  203d28:	f383 8811 	msr	BASEPRI, r3
}
  203d2c:	bd08      	pop	{r3, pc}
  _dbg_check_unlock_from_isr();
  203d2e:	f7fd faaf 	bl	201290 <_dbg_check_unlock_from_isr>
  203d32:	2300      	movs	r3, #0
  203d34:	f383 8811 	msr	BASEPRI, r3
  203d38:	bd08      	pop	{r3, pc}
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203d3a:	4802      	ldr	r0, [pc, #8]	; (203d44 <chSysRestoreStatusX.part.2+0x44>)
  203d3c:	f7fc ff18 	bl	200b70 <chSysHalt>
  203d40:	20000dc8 	.word	0x20000dc8
  203d44:	0800bbf8 	.word	0x0800bbf8
	...

00203d50 <_dbg_check_lock>:
void _dbg_check_lock(void) {
  203d50:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
  203d52:	4b05      	ldr	r3, [pc, #20]	; (203d68 <_dbg_check_lock+0x18>)
  203d54:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  203d56:	b90a      	cbnz	r2, 203d5c <_dbg_check_lock+0xc>
  203d58:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  203d5a:	b112      	cbz	r2, 203d62 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
  203d5c:	4803      	ldr	r0, [pc, #12]	; (203d6c <_dbg_check_lock+0x1c>)
  203d5e:	f7fc ff07 	bl	200b70 <chSysHalt>
  _dbg_enter_lock();
  203d62:	2201      	movs	r2, #1
  203d64:	635a      	str	r2, [r3, #52]	; 0x34
}
  203d66:	bd08      	pop	{r3, pc}
  203d68:	20000dc8 	.word	0x20000dc8
  203d6c:	0800c1b0 	.word	0x0800c1b0

00203d70 <chSemWaitTimeout.constprop.58>:
msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout) {
  203d70:	b510      	push	{r4, lr}
  203d72:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  203d74:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203d76:	2320      	movs	r3, #32
  203d78:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203d7c:	b662      	cpsie	i
  _dbg_check_lock();
  203d7e:	f7ff ffe7 	bl	203d50 <_dbg_check_lock>
  msg = chSemWaitTimeoutS(sp, timeout);
  203d82:	4621      	mov	r1, r4
  203d84:	480b      	ldr	r0, [pc, #44]	; (203db4 <chSemWaitTimeout.constprop.58+0x44>)
  203d86:	f7ff fc8b 	bl	2036a0 <chSemWaitTimeoutS>
  203d8a:	4604      	mov	r4, r0
  _dbg_check_unlock();
  203d8c:	f7ff ff90 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203d90:	4b09      	ldr	r3, [pc, #36]	; (203db8 <chSemWaitTimeout.constprop.58+0x48>)
  203d92:	681a      	ldr	r2, [r3, #0]
  203d94:	429a      	cmp	r2, r3
  203d96:	d004      	beq.n	203da2 <chSemWaitTimeout.constprop.58+0x32>
  203d98:	6999      	ldr	r1, [r3, #24]
  203d9a:	6893      	ldr	r3, [r2, #8]
  203d9c:	688a      	ldr	r2, [r1, #8]
  203d9e:	429a      	cmp	r2, r3
  203da0:	d304      	bcc.n	203dac <chSemWaitTimeout.constprop.58+0x3c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203da2:	2300      	movs	r3, #0
  203da4:	f383 8811 	msr	BASEPRI, r3
}
  203da8:	4620      	mov	r0, r4
  203daa:	bd10      	pop	{r4, pc}
  203dac:	4803      	ldr	r0, [pc, #12]	; (203dbc <chSemWaitTimeout.constprop.58+0x4c>)
  203dae:	f7fc fedf 	bl	200b70 <chSysHalt>
  203db2:	bf00      	nop
  203db4:	20001838 	.word	0x20001838
  203db8:	20000dc8 	.word	0x20000dc8
  203dbc:	0800bc10 	.word	0x0800bc10

00203dc0 <chSemSignalWait.constprop.56>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
  203dc0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  203dc2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203dc4:	2320      	movs	r3, #32
  203dc6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203dca:	b662      	cpsie	i
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));

  chSysLock();
  chDbgAssert(((sps->cnt >= (cnt_t)0) && queue_isempty(&sps->queue)) ||
  203dcc:	4c21      	ldr	r4, [pc, #132]	; (203e54 <chSemSignalWait.constprop.56+0x94>)
  _dbg_check_lock();
  203dce:	f7ff ffbf 	bl	203d50 <_dbg_check_lock>
  203dd2:	68a3      	ldr	r3, [r4, #8]
  203dd4:	6822      	ldr	r2, [r4, #0]
  203dd6:	2b00      	cmp	r3, #0
  203dd8:	db04      	blt.n	203de4 <chSemSignalWait.constprop.56+0x24>
  203dda:	42a2      	cmp	r2, r4
  203ddc:	d004      	beq.n	203de8 <chSemSignalWait.constprop.56+0x28>
  203dde:	481e      	ldr	r0, [pc, #120]	; (203e58 <chSemSignalWait.constprop.56+0x98>)
  203de0:	f7fc fec6 	bl	200b70 <chSysHalt>
  203de4:	42a2      	cmp	r2, r4
  203de6:	d0fa      	beq.n	203dde <chSemSignalWait.constprop.56+0x1e>
              ((sps->cnt < (cnt_t)0) && queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
  203de8:	3301      	adds	r3, #1
  203dea:	2b00      	cmp	r3, #0
  203dec:	60a3      	str	r3, [r4, #8]
  203dee:	dd23      	ble.n	203e38 <chSemSignalWait.constprop.56+0x78>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
  203df0:	3b01      	subs	r3, #1
  203df2:	2b00      	cmp	r3, #0
  203df4:	60a3      	str	r3, [r4, #8]
  203df6:	db12      	blt.n	203e1e <chSemSignalWait.constprop.56+0x5e>
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
    msg = MSG_OK;
  203df8:	2400      	movs	r4, #0
  203dfa:	4d18      	ldr	r5, [pc, #96]	; (203e5c <chSemSignalWait.constprop.56+0x9c>)
    chSchRescheduleS();
  203dfc:	f7ff ff40 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  203e00:	f7ff ff56 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203e04:	682b      	ldr	r3, [r5, #0]
  203e06:	42ab      	cmp	r3, r5
  203e08:	d004      	beq.n	203e14 <chSemSignalWait.constprop.56+0x54>
  203e0a:	69aa      	ldr	r2, [r5, #24]
  203e0c:	689b      	ldr	r3, [r3, #8]
  203e0e:	6892      	ldr	r2, [r2, #8]
  203e10:	429a      	cmp	r2, r3
  203e12:	d31b      	bcc.n	203e4c <chSemSignalWait.constprop.56+0x8c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203e14:	2300      	movs	r3, #0
  203e16:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
  203e1a:	4620      	mov	r0, r4
  203e1c:	bd70      	pop	{r4, r5, r6, pc}
    thread_t *ctp = currp;
  203e1e:	4d0f      	ldr	r5, [pc, #60]	; (203e5c <chSemSignalWait.constprop.56+0x9c>)
    chSchGoSleepS(CH_STATE_WTSEM);
  203e20:	2005      	movs	r0, #5
  tp->queue.prev             = tqp->prev;
  203e22:	6863      	ldr	r3, [r4, #4]
    thread_t *ctp = currp;
  203e24:	69ae      	ldr	r6, [r5, #24]
  203e26:	e9c6 4300 	strd	r4, r3, [r6]
  tp->queue.prev->queue.next = tp;
  203e2a:	601e      	str	r6, [r3, #0]
    ctp->u.wtsemp = spw;
  203e2c:	6274      	str	r4, [r6, #36]	; 0x24
  tqp->prev                  = tp;
  203e2e:	6066      	str	r6, [r4, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
  203e30:	f7ff fb36 	bl	2034a0 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
  203e34:	6a74      	ldr	r4, [r6, #36]	; 0x24
  203e36:	e7e3      	b.n	203e00 <chSemSignalWait.constprop.56+0x40>
  thread_t *tp = tqp->next;
  203e38:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
  203e3a:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  203e3c:	605c      	str	r4, [r3, #4]
  tqp->next             = tp->queue.next;
  203e3e:	6023      	str	r3, [r4, #0]
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  203e40:	f7fd f856 	bl	200ef0 <chSchReadyI>
  203e44:	2200      	movs	r2, #0
  203e46:	68a3      	ldr	r3, [r4, #8]
  203e48:	6242      	str	r2, [r0, #36]	; 0x24
  203e4a:	e7d1      	b.n	203df0 <chSemSignalWait.constprop.56+0x30>
  203e4c:	4804      	ldr	r0, [pc, #16]	; (203e60 <chSemSignalWait.constprop.56+0xa0>)
  203e4e:	f7fc fe8f 	bl	200b70 <chSysHalt>
  203e52:	bf00      	nop
  203e54:	20001838 	.word	0x20001838
  203e58:	0800bf30 	.word	0x0800bf30
  203e5c:	20000dc8 	.word	0x20000dc8
  203e60:	0800bc10 	.word	0x0800bc10
	...

00203e70 <chMtxTryLock.constprop.53>:
bool chMtxTryLock(mutex_t *mp) {
  203e70:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  203e72:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203e74:	2320      	movs	r3, #32
  203e76:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203e7a:	b662      	cpsie	i
  _dbg_check_lock();
  203e7c:	f7ff ff68 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassS();
  203e80:	f7fc ff76 	bl	200d70 <chDbgCheckClassS>
  if (mp->owner != NULL) {
  203e84:	4b0f      	ldr	r3, [pc, #60]	; (203ec4 <chMtxTryLock.constprop.53+0x54>)
  203e86:	689a      	ldr	r2, [r3, #8]
  203e88:	b19a      	cbz	r2, 203eb2 <chMtxTryLock.constprop.53+0x42>
    return false;
  203e8a:	2500      	movs	r5, #0
  203e8c:	4c0e      	ldr	r4, [pc, #56]	; (203ec8 <chMtxTryLock.constprop.53+0x58>)
  _dbg_check_unlock();
  203e8e:	f7ff ff0f 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203e92:	6823      	ldr	r3, [r4, #0]
  203e94:	42a3      	cmp	r3, r4
  203e96:	d004      	beq.n	203ea2 <chMtxTryLock.constprop.53+0x32>
  203e98:	69a2      	ldr	r2, [r4, #24]
  203e9a:	689b      	ldr	r3, [r3, #8]
  203e9c:	6892      	ldr	r2, [r2, #8]
  203e9e:	429a      	cmp	r2, r3
  203ea0:	d304      	bcc.n	203eac <chMtxTryLock.constprop.53+0x3c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203ea2:	2300      	movs	r3, #0
  203ea4:	f383 8811 	msr	BASEPRI, r3
}
  203ea8:	4628      	mov	r0, r5
  203eaa:	bd38      	pop	{r3, r4, r5, pc}
  203eac:	4807      	ldr	r0, [pc, #28]	; (203ecc <chMtxTryLock.constprop.53+0x5c>)
  203eae:	f7fc fe5f 	bl	200b70 <chSysHalt>
  mp->owner = currp;
  203eb2:	4c05      	ldr	r4, [pc, #20]	; (203ec8 <chMtxTryLock.constprop.53+0x58>)
  currp->mtxlist = mp;
  203eb4:	2501      	movs	r5, #1
  mp->owner = currp;
  203eb6:	69a2      	ldr	r2, [r4, #24]
  mp->next = currp->mtxlist;
  203eb8:	6b91      	ldr	r1, [r2, #56]	; 0x38
  currp->mtxlist = mp;
  203eba:	6393      	str	r3, [r2, #56]	; 0x38
  mp->next = currp->mtxlist;
  203ebc:	e9c3 2102 	strd	r2, r1, [r3, #8]
  203ec0:	e7e5      	b.n	203e8e <chMtxTryLock.constprop.53+0x1e>
  203ec2:	bf00      	nop
  203ec4:	20010438 	.word	0x20010438
  203ec8:	20000dc8 	.word	0x20000dc8
  203ecc:	0800bc1c 	.word	0x0800bc1c

00203ed0 <chCondSignal.constprop.51>:
void chCondSignal(condition_variable_t *cp) {
  203ed0:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  203ed2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203ed4:	2320      	movs	r3, #32
  203ed6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203eda:	b662      	cpsie	i
  _dbg_check_lock();
  203edc:	f7ff ff38 	bl	203d50 <_dbg_check_lock>
  return (bool)(tqp->next != (const thread_t *)tqp);
  203ee0:	4b0d      	ldr	r3, [pc, #52]	; (203f18 <chCondSignal.constprop.51+0x48>)
  203ee2:	6818      	ldr	r0, [r3, #0]
  if (queue_notempty(&cp->queue)) {
  203ee4:	4298      	cmp	r0, r3
  203ee6:	d005      	beq.n	203ef4 <chCondSignal.constprop.51+0x24>
  tqp->next             = tp->queue.next;
  203ee8:	6802      	ldr	r2, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
  203eea:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
  203eec:	6053      	str	r3, [r2, #4]
  tqp->next             = tp->queue.next;
  203eee:	601a      	str	r2, [r3, #0]
  203ef0:	f7ff fa9e 	bl	203430 <chSchWakeupS>
  _dbg_check_unlock();
  203ef4:	f7ff fedc 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203ef8:	4b08      	ldr	r3, [pc, #32]	; (203f1c <chCondSignal.constprop.51+0x4c>)
  203efa:	681a      	ldr	r2, [r3, #0]
  203efc:	429a      	cmp	r2, r3
  203efe:	d004      	beq.n	203f0a <chCondSignal.constprop.51+0x3a>
  203f00:	6999      	ldr	r1, [r3, #24]
  203f02:	6893      	ldr	r3, [r2, #8]
  203f04:	688a      	ldr	r2, [r1, #8]
  203f06:	429a      	cmp	r2, r3
  203f08:	d303      	bcc.n	203f12 <chCondSignal.constprop.51+0x42>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203f0a:	2300      	movs	r3, #0
  203f0c:	f383 8811 	msr	BASEPRI, r3
}
  203f10:	bd08      	pop	{r3, pc}
  203f12:	4803      	ldr	r0, [pc, #12]	; (203f20 <chCondSignal.constprop.51+0x50>)
  203f14:	f7fc fe2c 	bl	200b70 <chSysHalt>
  203f18:	20010404 	.word	0x20010404
  203f1c:	20000dc8 	.word	0x20000dc8
  203f20:	0800bc28 	.word	0x0800bc28
	...

00203f30 <chEvtRegisterMaskWithFlags.constprop.43>:
void chEvtRegisterMaskWithFlags(event_source_t *esp,
  203f30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  203f32:	4606      	mov	r6, r0
  203f34:	460c      	mov	r4, r1
  203f36:	4617      	mov	r7, r2
  __ASM volatile ("cpsid i" : : : "memory");
  203f38:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203f3a:	2320      	movs	r3, #32
  203f3c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203f40:	b662      	cpsie	i
  elp->listener = currp;
  203f42:	4d0f      	ldr	r5, [pc, #60]	; (203f80 <chEvtRegisterMaskWithFlags.constprop.43+0x50>)
  _dbg_check_lock();
  203f44:	f7ff ff04 	bl	203d50 <_dbg_check_lock>
  elp->next     = esp->next;
  203f48:	6830      	ldr	r0, [r6, #0]
  elp->wflags   = wflags;
  203f4a:	f04f 33ff 	mov.w	r3, #4294967295
  elp->listener = currp;
  203f4e:	69aa      	ldr	r2, [r5, #24]
  elp->flags    = (eventflags_t)0;
  203f50:	2100      	movs	r1, #0
  elp->next     = esp->next;
  203f52:	6020      	str	r0, [r4, #0]
  esp->next     = elp;
  203f54:	6034      	str	r4, [r6, #0]
  elp->wflags   = wflags;
  203f56:	e9c4 1303 	strd	r1, r3, [r4, #12]
  elp->events   = events;
  203f5a:	e9c4 2701 	strd	r2, r7, [r4, #4]
  _dbg_check_unlock();
  203f5e:	f7ff fea7 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203f62:	682b      	ldr	r3, [r5, #0]
  203f64:	42ab      	cmp	r3, r5
  203f66:	d004      	beq.n	203f72 <chEvtRegisterMaskWithFlags.constprop.43+0x42>
  203f68:	69aa      	ldr	r2, [r5, #24]
  203f6a:	689b      	ldr	r3, [r3, #8]
  203f6c:	6892      	ldr	r2, [r2, #8]
  203f6e:	429a      	cmp	r2, r3
  203f70:	d303      	bcc.n	203f7a <chEvtRegisterMaskWithFlags.constprop.43+0x4a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203f72:	2300      	movs	r3, #0
  203f74:	f383 8811 	msr	BASEPRI, r3
}
  203f78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  203f7a:	4802      	ldr	r0, [pc, #8]	; (203f84 <chEvtRegisterMaskWithFlags.constprop.43+0x54>)
  203f7c:	f7fc fdf8 	bl	200b70 <chSysHalt>
  203f80:	20000dc8 	.word	0x20000dc8
  203f84:	0800bc34 	.word	0x0800bc34
	...

00203f90 <chEvtGetAndClearEvents.constprop.42>:
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  203f90:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  203f92:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203f94:	2320      	movs	r3, #32
  203f96:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  203f9a:	b662      	cpsie	i
  m = currp->epending & events;
  203f9c:	4c0c      	ldr	r4, [pc, #48]	; (203fd0 <chEvtGetAndClearEvents.constprop.42+0x40>)
  _dbg_check_lock();
  203f9e:	f7ff fed7 	bl	203d50 <_dbg_check_lock>
  currp->epending &= ~events;
  203fa2:	2200      	movs	r2, #0
  m = currp->epending & events;
  203fa4:	69a3      	ldr	r3, [r4, #24]
  203fa6:	6b5d      	ldr	r5, [r3, #52]	; 0x34
  currp->epending &= ~events;
  203fa8:	635a      	str	r2, [r3, #52]	; 0x34
  _dbg_check_unlock();
  203faa:	f7ff fe81 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  203fae:	6823      	ldr	r3, [r4, #0]
  203fb0:	42a3      	cmp	r3, r4
  203fb2:	d004      	beq.n	203fbe <chEvtGetAndClearEvents.constprop.42+0x2e>
  203fb4:	69a2      	ldr	r2, [r4, #24]
  203fb6:	689b      	ldr	r3, [r3, #8]
  203fb8:	6892      	ldr	r2, [r2, #8]
  203fba:	429a      	cmp	r2, r3
  203fbc:	d304      	bcc.n	203fc8 <chEvtGetAndClearEvents.constprop.42+0x38>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  203fbe:	2300      	movs	r3, #0
  203fc0:	f383 8811 	msr	BASEPRI, r3
}
  203fc4:	4628      	mov	r0, r5
  203fc6:	bd38      	pop	{r3, r4, r5, pc}
  203fc8:	4802      	ldr	r0, [pc, #8]	; (203fd4 <chEvtGetAndClearEvents.constprop.42+0x44>)
  203fca:	f7fc fdd1 	bl	200b70 <chSysHalt>
  203fce:	bf00      	nop
  203fd0:	20000dc8 	.word	0x20000dc8
  203fd4:	0800bc34 	.word	0x0800bc34
	...

00203fe0 <rt_test_008_007_setup>:
 *   has been emptied.
 * - [8.7.4] Unregistering from the Event Sources.
 * .
 */

static void rt_test_008_007_setup(void) {
  203fe0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
  203fe2:	f7ff ffd5 	bl	203f90 <chEvtGetAndClearEvents.constprop.42>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
  203fe6:	4a02      	ldr	r2, [pc, #8]	; (203ff0 <rt_test_008_007_setup+0x10>)
  203fe8:	4b02      	ldr	r3, [pc, #8]	; (203ff4 <rt_test_008_007_setup+0x14>)
  203fea:	6012      	str	r2, [r2, #0]
  203fec:	601b      	str	r3, [r3, #0]
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}
  203fee:	bd08      	pop	{r3, pc}
  203ff0:	2001040c 	.word	0x2001040c
  203ff4:	20010410 	.word	0x20010410
	...

00204000 <rt_test_008_006_setup>:
  chEvtGetAndClearEvents(ALL_EVENTS);
  204000:	f7ff bfc6 	b.w	203f90 <chEvtGetAndClearEvents.constprop.42>
	...

00204010 <rt_test_008_005_setup>:
  204010:	f7ff bff6 	b.w	204000 <rt_test_008_006_setup>
	...

00204020 <rt_test_008_004_setup>:
  204020:	f7ff bfee 	b.w	204000 <rt_test_008_006_setup>
	...

00204030 <rt_test_008_003_setup>:
  204030:	f7ff bfe6 	b.w	204000 <rt_test_008_006_setup>
	...

00204040 <rt_test_008_002_setup>:
  204040:	f7ff bfde 	b.w	204000 <rt_test_008_006_setup>
	...

00204050 <chEvtWaitOne.constprop.38>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  204050:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
  204052:	4c14      	ldr	r4, [pc, #80]	; (2040a4 <chEvtWaitOne.constprop.38+0x54>)
  204054:	69a6      	ldr	r6, [r4, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  204056:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204058:	2320      	movs	r3, #32
  20405a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20405e:	b662      	cpsie	i
  _dbg_check_lock();
  204060:	f7ff fe76 	bl	203d50 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  204064:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
  204066:	b933      	cbnz	r3, 204076 <chEvtWaitOne.constprop.38+0x26>
    ctp->u.ewmask = events;
  204068:	f04f 33ff 	mov.w	r3, #4294967295
    chSchGoSleepS(CH_STATE_WTOREVT);
  20406c:	200a      	movs	r0, #10
    ctp->u.ewmask = events;
  20406e:	6273      	str	r3, [r6, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
  204070:	f7ff fa16 	bl	2034a0 <chSchGoSleepS>
    m = ctp->epending & events;
  204074:	6b73      	ldr	r3, [r6, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
  204076:	425d      	negs	r5, r3
  204078:	401d      	ands	r5, r3
  ctp->epending &= ~m;
  20407a:	ea23 0305 	bic.w	r3, r3, r5
  20407e:	6373      	str	r3, [r6, #52]	; 0x34
  _dbg_check_unlock();
  204080:	f7ff fe16 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204084:	6823      	ldr	r3, [r4, #0]
  204086:	42a3      	cmp	r3, r4
  204088:	d004      	beq.n	204094 <chEvtWaitOne.constprop.38+0x44>
  20408a:	69a2      	ldr	r2, [r4, #24]
  20408c:	689b      	ldr	r3, [r3, #8]
  20408e:	6892      	ldr	r2, [r2, #8]
  204090:	429a      	cmp	r2, r3
  204092:	d304      	bcc.n	20409e <chEvtWaitOne.constprop.38+0x4e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204094:	2300      	movs	r3, #0
  204096:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
  20409a:	4628      	mov	r0, r5
  20409c:	bd70      	pop	{r4, r5, r6, pc}
  20409e:	4802      	ldr	r0, [pc, #8]	; (2040a8 <chEvtWaitOne.constprop.38+0x58>)
  2040a0:	f7fc fd66 	bl	200b70 <chSysHalt>
  2040a4:	20000dc8 	.word	0x20000dc8
  2040a8:	0800bc34 	.word	0x0800bc34
  2040ac:	00000000 	.word	0x00000000

002040b0 <chEvtWaitAny.constprop.37>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  2040b0:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
  2040b2:	4c13      	ldr	r4, [pc, #76]	; (204100 <chEvtWaitAny.constprop.37+0x50>)
  2040b4:	69a5      	ldr	r5, [r4, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  2040b6:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2040b8:	2320      	movs	r3, #32
  2040ba:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2040be:	b662      	cpsie	i
  _dbg_check_lock();
  2040c0:	f7ff fe46 	bl	203d50 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  2040c4:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
  2040c6:	b936      	cbnz	r6, 2040d6 <chEvtWaitAny.constprop.37+0x26>
    ctp->u.ewmask = events;
  2040c8:	f04f 33ff 	mov.w	r3, #4294967295
    chSchGoSleepS(CH_STATE_WTOREVT);
  2040cc:	200a      	movs	r0, #10
    ctp->u.ewmask = events;
  2040ce:	626b      	str	r3, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
  2040d0:	f7ff f9e6 	bl	2034a0 <chSchGoSleepS>
    m = ctp->epending & events;
  2040d4:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  }
  ctp->epending &= ~m;
  2040d6:	2300      	movs	r3, #0
  2040d8:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
  2040da:	f7ff fde9 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2040de:	6823      	ldr	r3, [r4, #0]
  2040e0:	42a3      	cmp	r3, r4
  2040e2:	d004      	beq.n	2040ee <chEvtWaitAny.constprop.37+0x3e>
  2040e4:	69a2      	ldr	r2, [r4, #24]
  2040e6:	689b      	ldr	r3, [r3, #8]
  2040e8:	6892      	ldr	r2, [r2, #8]
  2040ea:	429a      	cmp	r2, r3
  2040ec:	d304      	bcc.n	2040f8 <chEvtWaitAny.constprop.37+0x48>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2040ee:	2300      	movs	r3, #0
  2040f0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
  2040f4:	4630      	mov	r0, r6
  2040f6:	bd70      	pop	{r4, r5, r6, pc}
  2040f8:	4802      	ldr	r0, [pc, #8]	; (204104 <chEvtWaitAny.constprop.37+0x54>)
  2040fa:	f7fc fd39 	bl	200b70 <chSysHalt>
  2040fe:	bf00      	nop
  204100:	20000dc8 	.word	0x20000dc8
  204104:	0800bc34 	.word	0x0800bc34
	...

00204110 <chEvtWaitAll.constprop.36>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  204110:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
  204112:	4c14      	ldr	r4, [pc, #80]	; (204164 <chEvtWaitAll.constprop.36+0x54>)
  204114:	69a5      	ldr	r5, [r4, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  204116:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204118:	2320      	movs	r3, #32
  20411a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20411e:	b662      	cpsie	i
  _dbg_check_lock();
  204120:	f7ff fe16 	bl	203d50 <_dbg_check_lock>

  chSysLock();
  if ((ctp->epending & events) != events) {
  204124:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  204126:	f003 0205 	and.w	r2, r3, #5
  20412a:	2a05      	cmp	r2, #5
  20412c:	d005      	beq.n	20413a <chEvtWaitAll.constprop.36+0x2a>
    ctp->u.ewmask = events;
  20412e:	2305      	movs	r3, #5
    chSchGoSleepS(CH_STATE_WTANDEVT);
  204130:	200b      	movs	r0, #11
    ctp->u.ewmask = events;
  204132:	626b      	str	r3, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
  204134:	f7ff f9b4 	bl	2034a0 <chSchGoSleepS>
  204138:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  ctp->epending &= ~events;
  20413a:	f023 0305 	bic.w	r3, r3, #5
  20413e:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
  204140:	f7ff fdb6 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204144:	6823      	ldr	r3, [r4, #0]
  204146:	42a3      	cmp	r3, r4
  204148:	d004      	beq.n	204154 <chEvtWaitAll.constprop.36+0x44>
  20414a:	69a2      	ldr	r2, [r4, #24]
  20414c:	689b      	ldr	r3, [r3, #8]
  20414e:	6892      	ldr	r2, [r2, #8]
  204150:	429a      	cmp	r2, r3
  204152:	d304      	bcc.n	20415e <chEvtWaitAll.constprop.36+0x4e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204154:	2300      	movs	r3, #0
  204156:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
  20415a:	2005      	movs	r0, #5
  20415c:	bd38      	pop	{r3, r4, r5, pc}
  20415e:	4802      	ldr	r0, [pc, #8]	; (204168 <chEvtWaitAll.constprop.36+0x58>)
  204160:	f7fc fd06 	bl	200b70 <chSysHalt>
  204164:	20000dc8 	.word	0x20000dc8
  204168:	0800bc34 	.word	0x0800bc34
  20416c:	00000000 	.word	0x00000000

00204170 <chEvtWaitOneTimeout.constprop.35>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
  204170:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
  204172:	4c1e      	ldr	r4, [pc, #120]	; (2041ec <chEvtWaitOneTimeout.constprop.35+0x7c>)
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
  204174:	4605      	mov	r5, r0
  thread_t *ctp = currp;
  204176:	69a6      	ldr	r6, [r4, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  204178:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20417a:	2320      	movs	r3, #32
  20417c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204180:	b662      	cpsie	i
  _dbg_check_lock();
  204182:	f7ff fde5 	bl	203d50 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  204186:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
  204188:	b953      	cbnz	r3, 2041a0 <chEvtWaitOneTimeout.constprop.35+0x30>
    if (TIME_IMMEDIATE == timeout) {
  20418a:	b1ed      	cbz	r5, 2041c8 <chEvtWaitOneTimeout.constprop.35+0x58>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
  20418c:	f04f 33ff 	mov.w	r3, #4294967295
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
  204190:	4629      	mov	r1, r5
  204192:	200a      	movs	r0, #10
    ctp->u.ewmask = events;
  204194:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
  204196:	f7ff fa5b 	bl	203650 <chSchGoSleepTimeoutS>
  20419a:	2800      	cmp	r0, #0
  20419c:	db14      	blt.n	2041c8 <chEvtWaitOneTimeout.constprop.35+0x58>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  20419e:	6b73      	ldr	r3, [r6, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
  2041a0:	425d      	negs	r5, r3
  2041a2:	401d      	ands	r5, r3
  ctp->epending &= ~m;
  2041a4:	ea23 0305 	bic.w	r3, r3, r5
  2041a8:	6373      	str	r3, [r6, #52]	; 0x34
  _dbg_check_unlock();
  2041aa:	f7ff fd81 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2041ae:	6823      	ldr	r3, [r4, #0]
  2041b0:	42a3      	cmp	r3, r4
  2041b2:	d004      	beq.n	2041be <chEvtWaitOneTimeout.constprop.35+0x4e>
  2041b4:	69a2      	ldr	r2, [r4, #24]
  2041b6:	689b      	ldr	r3, [r3, #8]
  2041b8:	6892      	ldr	r2, [r2, #8]
  2041ba:	429a      	cmp	r2, r3
  2041bc:	d313      	bcc.n	2041e6 <chEvtWaitOneTimeout.constprop.35+0x76>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2041be:	2300      	movs	r3, #0
  2041c0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
  2041c4:	4628      	mov	r0, r5
  2041c6:	bd70      	pop	{r4, r5, r6, pc}
  _dbg_check_unlock();
  2041c8:	f7ff fd72 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2041cc:	6823      	ldr	r3, [r4, #0]
  2041ce:	42a3      	cmp	r3, r4
  2041d0:	d004      	beq.n	2041dc <chEvtWaitOneTimeout.constprop.35+0x6c>
  2041d2:	69a2      	ldr	r2, [r4, #24]
  2041d4:	689b      	ldr	r3, [r3, #8]
  2041d6:	6892      	ldr	r2, [r2, #8]
  2041d8:	429a      	cmp	r2, r3
  2041da:	d304      	bcc.n	2041e6 <chEvtWaitOneTimeout.constprop.35+0x76>
  2041dc:	2500      	movs	r5, #0
  2041de:	f385 8811 	msr	BASEPRI, r5
  2041e2:	4628      	mov	r0, r5
  2041e4:	bd70      	pop	{r4, r5, r6, pc}
  2041e6:	4802      	ldr	r0, [pc, #8]	; (2041f0 <chEvtWaitOneTimeout.constprop.35+0x80>)
  2041e8:	f7fc fcc2 	bl	200b70 <chSysHalt>
  2041ec:	20000dc8 	.word	0x20000dc8
  2041f0:	0800bc34 	.word	0x0800bc34
	...

00204200 <chEvtWaitAnyTimeout.constprop.34>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
  204200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
  204202:	4c1a      	ldr	r4, [pc, #104]	; (20426c <chEvtWaitAnyTimeout.constprop.34+0x6c>)
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
  204204:	4607      	mov	r7, r0
  thread_t *ctp = currp;
  204206:	69a6      	ldr	r6, [r4, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  204208:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20420a:	2320      	movs	r3, #32
  20420c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204210:	b662      	cpsie	i
  _dbg_check_lock();
  204212:	f7ff fd9d 	bl	203d50 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  204216:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
  204218:	b955      	cbnz	r5, 204230 <chEvtWaitAnyTimeout.constprop.34+0x30>
    if (TIME_IMMEDIATE == timeout) {
  20421a:	b1d7      	cbz	r7, 204252 <chEvtWaitAnyTimeout.constprop.34+0x52>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
  20421c:	f04f 33ff 	mov.w	r3, #4294967295
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
  204220:	4639      	mov	r1, r7
  204222:	200a      	movs	r0, #10
    ctp->u.ewmask = events;
  204224:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
  204226:	f7ff fa13 	bl	203650 <chSchGoSleepTimeoutS>
  20422a:	2800      	cmp	r0, #0
  20422c:	db11      	blt.n	204252 <chEvtWaitAnyTimeout.constprop.34+0x52>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  20422e:	6b75      	ldr	r5, [r6, #52]	; 0x34
  }
  ctp->epending &= ~m;
  204230:	2300      	movs	r3, #0
  204232:	6373      	str	r3, [r6, #52]	; 0x34
  _dbg_check_unlock();
  204234:	f7ff fd3c 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204238:	6823      	ldr	r3, [r4, #0]
  20423a:	42a3      	cmp	r3, r4
  20423c:	d004      	beq.n	204248 <chEvtWaitAnyTimeout.constprop.34+0x48>
  20423e:	69a2      	ldr	r2, [r4, #24]
  204240:	689b      	ldr	r3, [r3, #8]
  204242:	6892      	ldr	r2, [r2, #8]
  204244:	429a      	cmp	r2, r3
  204246:	d30e      	bcc.n	204266 <chEvtWaitAnyTimeout.constprop.34+0x66>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204248:	2300      	movs	r3, #0
  20424a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
  20424e:	4628      	mov	r0, r5
  204250:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  _dbg_check_unlock();
  204252:	f7ff fd2d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204256:	6823      	ldr	r3, [r4, #0]
  204258:	42a3      	cmp	r3, r4
  20425a:	d0f5      	beq.n	204248 <chEvtWaitAnyTimeout.constprop.34+0x48>
  20425c:	69a2      	ldr	r2, [r4, #24]
  20425e:	689b      	ldr	r3, [r3, #8]
  204260:	6892      	ldr	r2, [r2, #8]
  204262:	429a      	cmp	r2, r3
  204264:	d2f0      	bcs.n	204248 <chEvtWaitAnyTimeout.constprop.34+0x48>
  204266:	4802      	ldr	r0, [pc, #8]	; (204270 <chEvtWaitAnyTimeout.constprop.34+0x70>)
  204268:	f7fc fc82 	bl	200b70 <chSysHalt>
  20426c:	20000dc8 	.word	0x20000dc8
  204270:	0800bc34 	.word	0x0800bc34
	...

00204280 <chMBReset.constprop.29>:
void chMBReset(mailbox_t *mbp) {
  204280:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  204282:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204284:	2320      	movs	r3, #32
  204286:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20428a:	b662      	cpsie	i
  _dbg_check_lock();
  20428c:	f7ff fd60 	bl	203d50 <_dbg_check_lock>
  chMBResetI(mbp);
  204290:	f7fe f866 	bl	202360 <chMBResetI.constprop.30>
  chSchRescheduleS();
  204294:	f7ff fcf4 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  204298:	f7ff fd0a 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20429c:	4b07      	ldr	r3, [pc, #28]	; (2042bc <chMBReset.constprop.29+0x3c>)
  20429e:	681a      	ldr	r2, [r3, #0]
  2042a0:	429a      	cmp	r2, r3
  2042a2:	d004      	beq.n	2042ae <chMBReset.constprop.29+0x2e>
  2042a4:	6999      	ldr	r1, [r3, #24]
  2042a6:	6893      	ldr	r3, [r2, #8]
  2042a8:	688a      	ldr	r2, [r1, #8]
  2042aa:	429a      	cmp	r2, r3
  2042ac:	d303      	bcc.n	2042b6 <chMBReset.constprop.29+0x36>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2042ae:	2300      	movs	r3, #0
  2042b0:	f383 8811 	msr	BASEPRI, r3
}
  2042b4:	bd08      	pop	{r3, pc}
  2042b6:	4802      	ldr	r0, [pc, #8]	; (2042c0 <chMBReset.constprop.29+0x40>)
  2042b8:	f7fc fc5a 	bl	200b70 <chSysHalt>
  2042bc:	20000dc8 	.word	0x20000dc8
  2042c0:	0800bc58 	.word	0x0800bc58
	...

002042d0 <oslib_test_001_003_teardown>:

static void oslib_test_001_003_teardown(void) {
  chMBReset(&mb1);
  2042d0:	f7ff bfd6 	b.w	204280 <chMBReset.constprop.29>
	...

002042e0 <oslib_test_001_002_teardown>:
  2042e0:	f7ff bff6 	b.w	2042d0 <oslib_test_001_003_teardown>
	...

002042f0 <oslib_test_001_001_teardown>:
  2042f0:	f7ff bfee 	b.w	2042d0 <oslib_test_001_003_teardown>
	...

00204300 <chMBPostTimeout.constprop.27>:
msg_t chMBPostTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
  204300:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  204304:	4680      	mov	r8, r0
  204306:	460f      	mov	r7, r1
  __ASM volatile ("cpsid i" : : : "memory");
  204308:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20430a:	2320      	movs	r3, #32
  20430c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204310:	b662      	cpsie	i
  204312:	4c23      	ldr	r4, [pc, #140]	; (2043a0 <chMBPostTimeout.constprop.27+0xa0>)
  _dbg_check_lock();
  204314:	f7ff fd1c 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassS();
  204318:	f7fc fd2a 	bl	200d70 <chDbgCheckClassS>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
  20431c:	f104 0618 	add.w	r6, r4, #24
  204320:	e011      	b.n	204346 <chMBPostTimeout.constprop.27+0x46>
  chDbgCheckClassI();
  204322:	f7fc fd35 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  204326:	f7fc fd33 	bl	200d90 <chDbgCheckClassI>
  return mbp->cnt;
  20432a:	6923      	ldr	r3, [r4, #16]
  20432c:	e9d4 9500 	ldrd	r9, r5, [r4]
  return (size_t)(mbp->top - mbp->buffer);
  204330:	eba5 0209 	sub.w	r2, r5, r9
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
  204334:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
  204338:	d11e      	bne.n	204378 <chMBPostTimeout.constprop.27+0x78>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
  20433a:	4639      	mov	r1, r7
  20433c:	4630      	mov	r0, r6
  20433e:	f7ff f9df 	bl	203700 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
  204342:	4605      	mov	r5, r0
  204344:	b920      	cbnz	r0, 204350 <chMBPostTimeout.constprop.27+0x50>
    if (mbp->reset) {
  204346:	7d23      	ldrb	r3, [r4, #20]
  204348:	2b00      	cmp	r3, #0
  20434a:	d0ea      	beq.n	204322 <chMBPostTimeout.constprop.27+0x22>
      return MSG_RESET;
  20434c:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
  204350:	f7ff fcae 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204354:	4b13      	ldr	r3, [pc, #76]	; (2043a4 <chMBPostTimeout.constprop.27+0xa4>)
  204356:	681a      	ldr	r2, [r3, #0]
  204358:	429a      	cmp	r2, r3
  20435a:	d004      	beq.n	204366 <chMBPostTimeout.constprop.27+0x66>
  20435c:	6999      	ldr	r1, [r3, #24]
  20435e:	6893      	ldr	r3, [r2, #8]
  204360:	688a      	ldr	r2, [r1, #8]
  204362:	429a      	cmp	r2, r3
  204364:	d305      	bcc.n	204372 <chMBPostTimeout.constprop.27+0x72>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204366:	2300      	movs	r3, #0
  204368:	f383 8811 	msr	BASEPRI, r3
}
  20436c:	4628      	mov	r0, r5
  20436e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  204372:	480d      	ldr	r0, [pc, #52]	; (2043a8 <chMBPostTimeout.constprop.27+0xa8>)
  204374:	f7fc fbfc 	bl	200b70 <chSysHalt>
      *mbp->wrptr++ = msg;
  204378:	68a1      	ldr	r1, [r4, #8]
      mbp->cnt++;
  20437a:	3301      	adds	r3, #1
      chThdDequeueNextI(&mbp->qr, MSG_OK);
  20437c:	480b      	ldr	r0, [pc, #44]	; (2043ac <chMBPostTimeout.constprop.27+0xac>)
      *mbp->wrptr++ = msg;
  20437e:	1d0a      	adds	r2, r1, #4
      if (mbp->wrptr >= mbp->top) {
  204380:	4295      	cmp	r5, r2
      *mbp->wrptr++ = msg;
  204382:	60a2      	str	r2, [r4, #8]
  204384:	f8c1 8000 	str.w	r8, [r1]
      return MSG_OK;
  204388:	f04f 0500 	mov.w	r5, #0
        mbp->wrptr = mbp->buffer;
  20438c:	bf98      	it	ls
  20438e:	f8c4 9008 	strls.w	r9, [r4, #8]
      mbp->cnt++;
  204392:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
  204394:	f7fc fdd4 	bl	200f40 <chThdDequeueNextI.constprop.80>
      chSchRescheduleS();
  204398:	f7ff fc72 	bl	203c80 <chSchRescheduleS>
  20439c:	e7d8      	b.n	204350 <chMBPostTimeout.constprop.27+0x50>
  20439e:	bf00      	nop
  2043a0:	20010458 	.word	0x20010458
  2043a4:	20000dc8 	.word	0x20000dc8
  2043a8:	0800bc58 	.word	0x0800bc58
  2043ac:	20010478 	.word	0x20010478

002043b0 <chMBPostAheadTimeout.constprop.24>:
msg_t chMBPostAheadTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
  2043b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  2043b4:	4681      	mov	r9, r0
  2043b6:	4688      	mov	r8, r1
  __ASM volatile ("cpsid i" : : : "memory");
  2043b8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2043ba:	2320      	movs	r3, #32
  2043bc:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2043c0:	b662      	cpsie	i
  2043c2:	4c22      	ldr	r4, [pc, #136]	; (20444c <chMBPostAheadTimeout.constprop.24+0x9c>)
  _dbg_check_lock();
  2043c4:	f7ff fcc4 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassS();
  2043c8:	f7fc fcd2 	bl	200d70 <chDbgCheckClassS>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
  2043cc:	f104 0618 	add.w	r6, r4, #24
  2043d0:	e010      	b.n	2043f4 <chMBPostAheadTimeout.constprop.24+0x44>
  chDbgCheckClassI();
  2043d2:	f7fc fcdd 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  2043d6:	f7fc fcdb 	bl	200d90 <chDbgCheckClassI>
  return mbp->cnt;
  2043da:	6923      	ldr	r3, [r4, #16]
  2043dc:	e9d4 5700 	ldrd	r5, r7, [r4]
  return (size_t)(mbp->top - mbp->buffer);
  2043e0:	1b7a      	subs	r2, r7, r5
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
  2043e2:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
  2043e6:	d11e      	bne.n	204426 <chMBPostAheadTimeout.constprop.24+0x76>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
  2043e8:	4641      	mov	r1, r8
  2043ea:	4630      	mov	r0, r6
  2043ec:	f7ff f988 	bl	203700 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
  2043f0:	4605      	mov	r5, r0
  2043f2:	b920      	cbnz	r0, 2043fe <chMBPostAheadTimeout.constprop.24+0x4e>
    if (mbp->reset) {
  2043f4:	7d23      	ldrb	r3, [r4, #20]
  2043f6:	2b00      	cmp	r3, #0
  2043f8:	d0eb      	beq.n	2043d2 <chMBPostAheadTimeout.constprop.24+0x22>
      return MSG_RESET;
  2043fa:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
  2043fe:	f7ff fc57 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204402:	4b13      	ldr	r3, [pc, #76]	; (204450 <chMBPostAheadTimeout.constprop.24+0xa0>)
  204404:	681a      	ldr	r2, [r3, #0]
  204406:	429a      	cmp	r2, r3
  204408:	d004      	beq.n	204414 <chMBPostAheadTimeout.constprop.24+0x64>
  20440a:	6999      	ldr	r1, [r3, #24]
  20440c:	6893      	ldr	r3, [r2, #8]
  20440e:	688a      	ldr	r2, [r1, #8]
  204410:	429a      	cmp	r2, r3
  204412:	d305      	bcc.n	204420 <chMBPostAheadTimeout.constprop.24+0x70>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204414:	2300      	movs	r3, #0
  204416:	f383 8811 	msr	BASEPRI, r3
}
  20441a:	4628      	mov	r0, r5
  20441c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  204420:	480c      	ldr	r0, [pc, #48]	; (204454 <chMBPostAheadTimeout.constprop.24+0xa4>)
  204422:	f7fc fba5 	bl	200b70 <chSysHalt>
      if (--mbp->rdptr < mbp->buffer) {
  204426:	68e2      	ldr	r2, [r4, #12]
      mbp->cnt++;
  204428:	3301      	adds	r3, #1
      chThdDequeueNextI(&mbp->qr, MSG_OK);
  20442a:	480b      	ldr	r0, [pc, #44]	; (204458 <chMBPostAheadTimeout.constprop.24+0xa8>)
      if (--mbp->rdptr < mbp->buffer) {
  20442c:	3a04      	subs	r2, #4
  20442e:	4295      	cmp	r5, r2
      return MSG_OK;
  204430:	f04f 0500 	mov.w	r5, #0
        mbp->rdptr = mbp->top - 1;
  204434:	bf88      	it	hi
  204436:	1f3a      	subhi	r2, r7, #4
  204438:	60e2      	str	r2, [r4, #12]
      *mbp->rdptr = msg;
  20443a:	f8c2 9000 	str.w	r9, [r2]
      mbp->cnt++;
  20443e:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
  204440:	f7fc fd7e 	bl	200f40 <chThdDequeueNextI.constprop.80>
      chSchRescheduleS();
  204444:	f7ff fc1c 	bl	203c80 <chSchRescheduleS>
  204448:	e7d9      	b.n	2043fe <chMBPostAheadTimeout.constprop.24+0x4e>
  20444a:	bf00      	nop
  20444c:	20010458 	.word	0x20010458
  204450:	20000dc8 	.word	0x20000dc8
  204454:	0800bc58 	.word	0x0800bc58
  204458:	20010478 	.word	0x20010478
  20445c:	00000000 	.word	0x00000000

00204460 <chMBFetchTimeout.constprop.21>:
msg_t chMBFetchTimeout(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
  204460:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  204464:	4680      	mov	r8, r0
  204466:	460f      	mov	r7, r1
  __ASM volatile ("cpsid i" : : : "memory");
  204468:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20446a:	2320      	movs	r3, #32
  20446c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204470:	b662      	cpsie	i
  204472:	4c22      	ldr	r4, [pc, #136]	; (2044fc <chMBFetchTimeout.constprop.21+0x9c>)
  _dbg_check_lock();
  204474:	f7ff fc6c 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassS();
  204478:	f7fc fc7a 	bl	200d70 <chDbgCheckClassS>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
  20447c:	f104 0620 	add.w	r6, r4, #32
  204480:	e009      	b.n	204496 <chMBFetchTimeout.constprop.21+0x36>
  chDbgCheckClassI();
  204482:	f7fc fc85 	bl	200d90 <chDbgCheckClassI>
  return mbp->cnt;
  204486:	6923      	ldr	r3, [r4, #16]
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
  204488:	b9db      	cbnz	r3, 2044c2 <chMBFetchTimeout.constprop.21+0x62>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
  20448a:	4639      	mov	r1, r7
  20448c:	4630      	mov	r0, r6
  20448e:	f7ff f937 	bl	203700 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
  204492:	4605      	mov	r5, r0
  204494:	b920      	cbnz	r0, 2044a0 <chMBFetchTimeout.constprop.21+0x40>
    if (mbp->reset) {
  204496:	7d23      	ldrb	r3, [r4, #20]
  204498:	2b00      	cmp	r3, #0
  20449a:	d0f2      	beq.n	204482 <chMBFetchTimeout.constprop.21+0x22>
      return MSG_RESET;
  20449c:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
  2044a0:	f7ff fc06 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2044a4:	4b16      	ldr	r3, [pc, #88]	; (204500 <chMBFetchTimeout.constprop.21+0xa0>)
  2044a6:	681a      	ldr	r2, [r3, #0]
  2044a8:	429a      	cmp	r2, r3
  2044aa:	d004      	beq.n	2044b6 <chMBFetchTimeout.constprop.21+0x56>
  2044ac:	6999      	ldr	r1, [r3, #24]
  2044ae:	6893      	ldr	r3, [r2, #8]
  2044b0:	688a      	ldr	r2, [r1, #8]
  2044b2:	429a      	cmp	r2, r3
  2044b4:	d31f      	bcc.n	2044f6 <chMBFetchTimeout.constprop.21+0x96>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2044b6:	2300      	movs	r3, #0
  2044b8:	f383 8811 	msr	BASEPRI, r3
}
  2044bc:	4628      	mov	r0, r5
  2044be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *msgp = *mbp->rdptr++;
  2044c2:	68e1      	ldr	r1, [r4, #12]
      if (mbp->rdptr >= mbp->top) {
  2044c4:	6860      	ldr	r0, [r4, #4]
      *msgp = *mbp->rdptr++;
  2044c6:	1d0a      	adds	r2, r1, #4
  2044c8:	6809      	ldr	r1, [r1, #0]
      if (mbp->rdptr >= mbp->top) {
  2044ca:	4282      	cmp	r2, r0
      *msgp = *mbp->rdptr++;
  2044cc:	60e2      	str	r2, [r4, #12]
  2044ce:	f8c8 1000 	str.w	r1, [r8]
      if (mbp->rdptr >= mbp->top) {
  2044d2:	d301      	bcc.n	2044d8 <chMBFetchTimeout.constprop.21+0x78>
        mbp->rdptr = mbp->buffer;
  2044d4:	6822      	ldr	r2, [r4, #0]
  2044d6:	60e2      	str	r2, [r4, #12]
      mbp->cnt--;
  2044d8:	3b01      	subs	r3, #1
      chThdDequeueNextI(&mbp->qw, MSG_OK);
  2044da:	480a      	ldr	r0, [pc, #40]	; (204504 <chMBFetchTimeout.constprop.21+0xa4>)
      return MSG_OK;
  2044dc:	2500      	movs	r5, #0
      mbp->cnt--;
  2044de:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
  2044e0:	f7fc fd2e 	bl	200f40 <chThdDequeueNextI.constprop.80>
      chSchRescheduleS();
  2044e4:	f7ff fbcc 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  2044e8:	f7ff fbe2 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2044ec:	4b04      	ldr	r3, [pc, #16]	; (204500 <chMBFetchTimeout.constprop.21+0xa0>)
  2044ee:	681a      	ldr	r2, [r3, #0]
  2044f0:	429a      	cmp	r2, r3
  2044f2:	d1db      	bne.n	2044ac <chMBFetchTimeout.constprop.21+0x4c>
  2044f4:	e7df      	b.n	2044b6 <chMBFetchTimeout.constprop.21+0x56>
  2044f6:	4804      	ldr	r0, [pc, #16]	; (204508 <chMBFetchTimeout.constprop.21+0xa8>)
  2044f8:	f7fc fb3a 	bl	200b70 <chSysHalt>
  2044fc:	20010458 	.word	0x20010458
  204500:	20000dc8 	.word	0x20000dc8
  204504:	20010470 	.word	0x20010470
  204508:	0800bc58 	.word	0x0800bc58
  20450c:	00000000 	.word	0x00000000

00204510 <chGuardedPoolAllocTimeout.constprop.16>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
  204510:	b538      	push	{r3, r4, r5, lr}
  204512:	4605      	mov	r5, r0
  __ASM volatile ("cpsid i" : : : "memory");
  204514:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204516:	2320      	movs	r3, #32
  204518:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20451c:	b662      	cpsie	i
  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
  20451e:	4c15      	ldr	r4, [pc, #84]	; (204574 <chGuardedPoolAllocTimeout.constprop.16+0x64>)
  _dbg_check_lock();
  204520:	f7ff fc16 	bl	203d50 <_dbg_check_lock>
  204524:	4629      	mov	r1, r5
  204526:	4620      	mov	r0, r4
  204528:	f7ff f8ba 	bl	2036a0 <chSemWaitTimeoutS>
  if (msg != MSG_OK) {
  20452c:	bb00      	cbnz	r0, 204570 <chGuardedPoolAllocTimeout.constprop.16+0x60>
  chDbgCheckClassI();
  20452e:	f7fc fc2f 	bl	200d90 <chDbgCheckClassI>
  objp = mp->next;
  204532:	68e5      	ldr	r5, [r4, #12]
  if (objp != NULL) {
  204534:	b1a5      	cbz	r5, 204560 <chGuardedPoolAllocTimeout.constprop.16+0x50>
    mp->next = mp->next->next;
  204536:	682b      	ldr	r3, [r5, #0]
  204538:	60e3      	str	r3, [r4, #12]
  _dbg_check_unlock();
  20453a:	f7ff fbb9 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20453e:	4b0e      	ldr	r3, [pc, #56]	; (204578 <chGuardedPoolAllocTimeout.constprop.16+0x68>)
  204540:	681a      	ldr	r2, [r3, #0]
  204542:	429a      	cmp	r2, r3
  204544:	d004      	beq.n	204550 <chGuardedPoolAllocTimeout.constprop.16+0x40>
  204546:	6999      	ldr	r1, [r3, #24]
  204548:	6893      	ldr	r3, [r2, #8]
  20454a:	688a      	ldr	r2, [r1, #8]
  20454c:	429a      	cmp	r2, r3
  20454e:	d304      	bcc.n	20455a <chGuardedPoolAllocTimeout.constprop.16+0x4a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204550:	2300      	movs	r3, #0
  204552:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
  204556:	4628      	mov	r0, r5
  204558:	bd38      	pop	{r3, r4, r5, pc}
  20455a:	4808      	ldr	r0, [pc, #32]	; (20457c <chGuardedPoolAllocTimeout.constprop.16+0x6c>)
  20455c:	f7fc fb08 	bl	200b70 <chSysHalt>
  else if (mp->provider != NULL) {
  204560:	69a3      	ldr	r3, [r4, #24]
  204562:	2b00      	cmp	r3, #0
  204564:	d0e9      	beq.n	20453a <chGuardedPoolAllocTimeout.constprop.16+0x2a>
    objp = mp->provider(mp->object_size, mp->align);
  204566:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
  20456a:	4798      	blx	r3
  20456c:	4605      	mov	r5, r0
  20456e:	e7e4      	b.n	20453a <chGuardedPoolAllocTimeout.constprop.16+0x2a>
    return NULL;
  204570:	2500      	movs	r5, #0
  204572:	e7e2      	b.n	20453a <chGuardedPoolAllocTimeout.constprop.16+0x2a>
  204574:	20010414 	.word	0x20010414
  204578:	20000dc8 	.word	0x20000dc8
  20457c:	0800bc70 	.word	0x0800bc70

00204580 <oslib_test_002_003_execute>:

static void oslib_test_002_003_execute(void) {
  204580:	b508      	push	{r3, lr}

  /* [2.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
  204582:	2201      	movs	r2, #1
  204584:	4b06      	ldr	r3, [pc, #24]	; (2045a0 <oslib_test_002_003_execute+0x20>)
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
  204586:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(1);
  20458a:	601a      	str	r2, [r3, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
  20458c:	f7ff ffc0 	bl	204510 <chGuardedPoolAllocTimeout.constprop.16>
  204590:	fab0 f080 	clz	r0, r0
  204594:	4903      	ldr	r1, [pc, #12]	; (2045a4 <oslib_test_002_003_execute+0x24>)
  204596:	0940      	lsrs	r0, r0, #5
  }
}
  204598:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
  20459c:	f7fc b910 	b.w	2007c0 <_test_assert>
  2045a0:	20001f6c 	.word	0x20001f6c
  2045a4:	0800c710 	.word	0x0800c710
	...

002045b0 <shellExit.constprop.4>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
  2045b0:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  2045b2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2045b4:	2320      	movs	r3, #32
  2045b6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2045ba:	b662      	cpsie	i
  _dbg_check_lock();
  2045bc:	f7ff fbc8 	bl	203d50 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
  2045c0:	4803      	ldr	r0, [pc, #12]	; (2045d0 <shellExit.constprop.4+0x20>)
  2045c2:	2100      	movs	r1, #0
  2045c4:	f7fc fd4c 	bl	201060 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
  2045c8:	2000      	movs	r0, #0
  2045ca:	f7ff f819 	bl	203600 <chThdExitS>
  2045ce:	bf00      	nop
  2045d0:	20001850 	.word	0x20001850
	...

002045e0 <shellThread>:
THD_FUNCTION(shellThread, p) {
  2045e0:	4681      	mov	r9, r0
  chprintf(chp, SHELL_NEWLINE_STR);
  2045e2:	4975      	ldr	r1, [pc, #468]	; (2047b8 <shellThread+0x1d8>)
    chprintf(chp, SHELL_PROMPT_STR);
  2045e4:	f8df a204 	ldr.w	sl, [pc, #516]	; 2047ec <shellThread+0x20c>
  const ShellCommand *scp = scfg->sc_commands;
  2045e8:	f8d9 3004 	ldr.w	r3, [r9, #4]
THD_FUNCTION(shellThread, p) {
  2045ec:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  BaseSequentialStream *chp = scfg->sc_channel;
  2045f0:	6807      	ldr	r7, [r0, #0]
THD_FUNCTION(shellThread, p) {
  2045f2:	b09b      	sub	sp, #108	; 0x6c
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
  2045f4:	468b      	mov	fp, r1
  chprintf(chp, SHELL_NEWLINE_STR);
  2045f6:	4638      	mov	r0, r7
  const ShellCommand *scp = scfg->sc_commands;
  2045f8:	9301      	str	r3, [sp, #4]
  chprintf(chp, SHELL_NEWLINE_STR);
  2045fa:	f7fe fc49 	bl	202e90 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
  2045fe:	4638      	mov	r0, r7
  204600:	496e      	ldr	r1, [pc, #440]	; (2047bc <shellThread+0x1dc>)
  204602:	ae0a      	add	r6, sp, #40	; 0x28
  204604:	f7fe fc44 	bl	202e90 <chprintf>
    chprintf(chp, SHELL_PROMPT_STR);
  204608:	4651      	mov	r1, sl
  20460a:	4638      	mov	r0, r7
  20460c:	f7fe fc40 	bl	202e90 <chprintf>
  BaseSequentialStream *chp = scfg->sc_channel;
  204610:	f8d9 5000 	ldr.w	r5, [r9]
  char *p = line;
  204614:	4634      	mov	r4, r6
  204616:	682b      	ldr	r3, [r5, #0]
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
  204618:	689b      	ldr	r3, [r3, #8]
  20461a:	2201      	movs	r2, #1
  20461c:	f10d 010f 	add.w	r1, sp, #15
  204620:	4628      	mov	r0, r5
  204622:	4798      	blx	r3
  204624:	2800      	cmp	r0, #0
  204626:	d072      	beq.n	20470e <shellThread+0x12e>
    if (c == 4) {
  204628:	f89d 100f 	ldrb.w	r1, [sp, #15]
  20462c:	2904      	cmp	r1, #4
  20462e:	d06a      	beq.n	204706 <shellThread+0x126>
    if ((c == 8) || (c == 127)) {
  204630:	2908      	cmp	r1, #8
  204632:	d018      	beq.n	204666 <shellThread+0x86>
  204634:	f1a1 037f 	sub.w	r3, r1, #127	; 0x7f
  204638:	fab3 f383 	clz	r3, r3
  20463c:	095b      	lsrs	r3, r3, #5
  20463e:	b993      	cbnz	r3, 204666 <shellThread+0x86>
    if (c == '\r') {
  204640:	290d      	cmp	r1, #13
  204642:	d024      	beq.n	20468e <shellThread+0xae>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
  204644:	291f      	cmp	r1, #31
  204646:	682b      	ldr	r3, [r5, #0]
  204648:	d9e6      	bls.n	204618 <shellThread+0x38>
      continue;
    if (p < line + size - 1) {
  20464a:	f10d 0267 	add.w	r2, sp, #103	; 0x67
  20464e:	4294      	cmp	r4, r2
  204650:	d2e2      	bcs.n	204618 <shellThread+0x38>
      streamPut(chp, c);
  204652:	68db      	ldr	r3, [r3, #12]
  204654:	4628      	mov	r0, r5
  204656:	4798      	blx	r3
      *p++ = (char)c;
  204658:	f89d 300f 	ldrb.w	r3, [sp, #15]
  20465c:	3401      	adds	r4, #1
  20465e:	f804 3c01 	strb.w	r3, [r4, #-1]
  204662:	682b      	ldr	r3, [r5, #0]
  204664:	e7d8      	b.n	204618 <shellThread+0x38>
      if (p != line) {
  204666:	42b4      	cmp	r4, r6
  204668:	682b      	ldr	r3, [r5, #0]
  20466a:	d0d5      	beq.n	204618 <shellThread+0x38>
        streamPut(chp, 0x08);
  20466c:	68db      	ldr	r3, [r3, #12]
  20466e:	2108      	movs	r1, #8
  204670:	4628      	mov	r0, r5
        p--;
  204672:	3c01      	subs	r4, #1
        streamPut(chp, 0x08);
  204674:	4798      	blx	r3
        streamPut(chp, 0x20);
  204676:	682b      	ldr	r3, [r5, #0]
  204678:	2120      	movs	r1, #32
  20467a:	4628      	mov	r0, r5
  20467c:	68db      	ldr	r3, [r3, #12]
  20467e:	4798      	blx	r3
        streamPut(chp, 0x08);
  204680:	682b      	ldr	r3, [r5, #0]
  204682:	2108      	movs	r1, #8
  204684:	4628      	mov	r0, r5
  204686:	68db      	ldr	r3, [r3, #12]
  204688:	4798      	blx	r3
  20468a:	682b      	ldr	r3, [r5, #0]
  20468c:	e7c4      	b.n	204618 <shellThread+0x38>
  20468e:	4698      	mov	r8, r3
      chprintf(chp, SHELL_NEWLINE_STR);
  204690:	4628      	mov	r0, r5
  204692:	4659      	mov	r1, fp
  204694:	f7fe fbfc 	bl	202e90 <chprintf>
    lp = parse_arguments(line, &tokp);
  204698:	a904      	add	r1, sp, #16
      *p = 0;
  20469a:	f884 8000 	strb.w	r8, [r4]
    lp = parse_arguments(line, &tokp);
  20469e:	4630      	mov	r0, r6
  2046a0:	f7fe fbc6 	bl	202e30 <parse_arguments>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
  2046a4:	a904      	add	r1, sp, #16
    lp = parse_arguments(line, &tokp);
  2046a6:	4605      	mov	r5, r0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
  2046a8:	2000      	movs	r0, #0
  2046aa:	ac05      	add	r4, sp, #20
  2046ac:	f7fe fbc0 	bl	202e30 <parse_arguments>
  2046b0:	b160      	cbz	r0, 2046cc <shellThread+0xec>
      if (n >= SHELL_MAX_ARGUMENTS) {
  2046b2:	f1b8 0f04 	cmp.w	r8, #4
  2046b6:	d01f      	beq.n	2046f8 <shellThread+0x118>
      args[n++] = lp;
  2046b8:	f844 0b04 	str.w	r0, [r4], #4
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
  2046bc:	a904      	add	r1, sp, #16
  2046be:	2000      	movs	r0, #0
      args[n++] = lp;
  2046c0:	f108 0801 	add.w	r8, r8, #1
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
  2046c4:	f7fe fbb4 	bl	202e30 <parse_arguments>
  2046c8:	2800      	cmp	r0, #0
  2046ca:	d1f2      	bne.n	2046b2 <shellThread+0xd2>
    args[n] = NULL;
  2046cc:	ab1a      	add	r3, sp, #104	; 0x68
  2046ce:	eb03 0388 	add.w	r3, r3, r8, lsl #2
  2046d2:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
  2046d6:	2d00      	cmp	r5, #0
  2046d8:	d096      	beq.n	204608 <shellThread+0x28>
      if (strcmp(cmd, "help") == 0) {
  2046da:	4939      	ldr	r1, [pc, #228]	; (2047c0 <shellThread+0x1e0>)
  2046dc:	4628      	mov	r0, r5
  2046de:	f7fb fec3 	bl	200468 <strcmp>
  2046e2:	2800      	cmp	r0, #0
  2046e4:	d13e      	bne.n	204764 <shellThread+0x184>
        if (n > 0) {
  2046e6:	f1b8 0f00 	cmp.w	r8, #0
  2046ea:	d01a      	beq.n	204722 <shellThread+0x142>
          shellUsage(chp, "help");
  2046ec:	4a34      	ldr	r2, [pc, #208]	; (2047c0 <shellThread+0x1e0>)
  2046ee:	4638      	mov	r0, r7
  2046f0:	4934      	ldr	r1, [pc, #208]	; (2047c4 <shellThread+0x1e4>)
  2046f2:	f7fe fbcd 	bl	202e90 <chprintf>
  2046f6:	e787      	b.n	204608 <shellThread+0x28>
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
  2046f8:	4933      	ldr	r1, [pc, #204]	; (2047c8 <shellThread+0x1e8>)
  2046fa:	4638      	mov	r0, r7
  2046fc:	f7fe fbc8 	bl	202e90 <chprintf>
    args[n] = NULL;
  204700:	2300      	movs	r3, #0
  204702:	9309      	str	r3, [sp, #36]	; 0x24
  204704:	e780      	b.n	204608 <shellThread+0x28>
      chprintf(chp, "^D");
  204706:	4628      	mov	r0, r5
  204708:	4930      	ldr	r1, [pc, #192]	; (2047cc <shellThread+0x1ec>)
  20470a:	f7fe fbc1 	bl	202e90 <chprintf>
      chprintf(chp, SHELL_NEWLINE_STR);
  20470e:	492a      	ldr	r1, [pc, #168]	; (2047b8 <shellThread+0x1d8>)
  204710:	4638      	mov	r0, r7
  204712:	f7fe fbbd 	bl	202e90 <chprintf>
      chprintf(chp, "logout");
  204716:	492e      	ldr	r1, [pc, #184]	; (2047d0 <shellThread+0x1f0>)
  204718:	4638      	mov	r0, r7
  20471a:	f7fe fbb9 	bl	202e90 <chprintf>
  shellExit(MSG_OK);
  20471e:	f7ff ff47 	bl	2045b0 <shellExit.constprop.4>
        chprintf(chp, "Commands: help ");
  204722:	492c      	ldr	r1, [pc, #176]	; (2047d4 <shellThread+0x1f4>)
  204724:	4638      	mov	r0, r7
  204726:	f7fe fbb3 	bl	202e90 <chprintf>
  20472a:	4c2b      	ldr	r4, [pc, #172]	; (2047d8 <shellThread+0x1f8>)
  while (scp->sc_name != NULL) {
  20472c:	4a2b      	ldr	r2, [pc, #172]	; (2047dc <shellThread+0x1fc>)
    chprintf(chp, "%s ", scp->sc_name);
  20472e:	4d2c      	ldr	r5, [pc, #176]	; (2047e0 <shellThread+0x200>)
  204730:	4629      	mov	r1, r5
  204732:	4638      	mov	r0, r7
  204734:	f7fe fbac 	bl	202e90 <chprintf>
  while (scp->sc_name != NULL) {
  204738:	f854 2f08 	ldr.w	r2, [r4, #8]!
  20473c:	2a00      	cmp	r2, #0
  20473e:	d1f7      	bne.n	204730 <shellThread+0x150>
        if (scp != NULL)
  204740:	9c01      	ldr	r4, [sp, #4]
  204742:	b154      	cbz	r4, 20475a <shellThread+0x17a>
  while (scp->sc_name != NULL) {
  204744:	6822      	ldr	r2, [r4, #0]
  204746:	b142      	cbz	r2, 20475a <shellThread+0x17a>
    chprintf(chp, "%s ", scp->sc_name);
  204748:	4d25      	ldr	r5, [pc, #148]	; (2047e0 <shellThread+0x200>)
  20474a:	4629      	mov	r1, r5
  20474c:	4638      	mov	r0, r7
  20474e:	f7fe fb9f 	bl	202e90 <chprintf>
  while (scp->sc_name != NULL) {
  204752:	f854 2f08 	ldr.w	r2, [r4, #8]!
  204756:	2a00      	cmp	r2, #0
  204758:	d1f7      	bne.n	20474a <shellThread+0x16a>
        chprintf(chp, SHELL_NEWLINE_STR);
  20475a:	4659      	mov	r1, fp
  20475c:	4638      	mov	r0, r7
  20475e:	f7fe fb97 	bl	202e90 <chprintf>
  204762:	e751      	b.n	204608 <shellThread+0x28>
  204764:	4c1c      	ldr	r4, [pc, #112]	; (2047d8 <shellThread+0x1f8>)
  while (scp->sc_name != NULL) {
  204766:	481d      	ldr	r0, [pc, #116]	; (2047dc <shellThread+0x1fc>)
  204768:	e002      	b.n	204770 <shellThread+0x190>
  20476a:	f854 0f08 	ldr.w	r0, [r4, #8]!
  20476e:	b150      	cbz	r0, 204786 <shellThread+0x1a6>
    if (strcmp(scp->sc_name, name) == 0) {
  204770:	4629      	mov	r1, r5
  204772:	f7fb fe79 	bl	200468 <strcmp>
  204776:	2800      	cmp	r0, #0
  204778:	d1f7      	bne.n	20476a <shellThread+0x18a>
      scp->sc_function(chp, argc, argv);
  20477a:	6863      	ldr	r3, [r4, #4]
  20477c:	aa05      	add	r2, sp, #20
  20477e:	4641      	mov	r1, r8
  204780:	4638      	mov	r0, r7
  204782:	4798      	blx	r3
  204784:	e740      	b.n	204608 <shellThread+0x28>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
  204786:	9c01      	ldr	r4, [sp, #4]
  204788:	b15c      	cbz	r4, 2047a2 <shellThread+0x1c2>
  while (scp->sc_name != NULL) {
  20478a:	6820      	ldr	r0, [r4, #0]
  20478c:	b918      	cbnz	r0, 204796 <shellThread+0x1b6>
  20478e:	e008      	b.n	2047a2 <shellThread+0x1c2>
  204790:	f854 0f08 	ldr.w	r0, [r4, #8]!
  204794:	b128      	cbz	r0, 2047a2 <shellThread+0x1c2>
    if (strcmp(scp->sc_name, name) == 0) {
  204796:	4629      	mov	r1, r5
  204798:	f7fb fe66 	bl	200468 <strcmp>
  20479c:	2800      	cmp	r0, #0
  20479e:	d1f7      	bne.n	204790 <shellThread+0x1b0>
  2047a0:	e7eb      	b.n	20477a <shellThread+0x19a>
        chprintf(chp, "%s", cmd);
  2047a2:	462a      	mov	r2, r5
  2047a4:	490f      	ldr	r1, [pc, #60]	; (2047e4 <shellThread+0x204>)
  2047a6:	4638      	mov	r0, r7
  2047a8:	f7fe fb72 	bl	202e90 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
  2047ac:	490e      	ldr	r1, [pc, #56]	; (2047e8 <shellThread+0x208>)
  2047ae:	4638      	mov	r0, r7
  2047b0:	f7fe fb6e 	bl	202e90 <chprintf>
  2047b4:	e728      	b.n	204608 <shellThread+0x28>
  2047b6:	bf00      	nop
  2047b8:	0800c4dc 	.word	0x0800c4dc
  2047bc:	0800dce8 	.word	0x0800dce8
  2047c0:	0800dd28 	.word	0x0800dd28
  2047c4:	0800c270 	.word	0x0800c270
  2047c8:	0800dd10 	.word	0x0800dd10
  2047cc:	0800dd04 	.word	0x0800dd04
  2047d0:	0800dd08 	.word	0x0800dd08
  2047d4:	0800dd30 	.word	0x0800dd30
  2047d8:	0800dd58 	.word	0x0800dd58
  2047dc:	0800dce0 	.word	0x0800dce0
  2047e0:	0800dd40 	.word	0x0800dd40
  2047e4:	0800dd44 	.word	0x0800dd44
  2047e8:	0800dd48 	.word	0x0800dd48
  2047ec:	0800dcfc 	.word	0x0800dcfc

002047f0 <cmd_exit>:
  if (argc > 0) {
  2047f0:	2900      	cmp	r1, #0
  2047f2:	dd03      	ble.n	2047fc <cmd_exit+0xc>
    shellUsage(chp, "exit");
  2047f4:	4a03      	ldr	r2, [pc, #12]	; (204804 <cmd_exit+0x14>)
  2047f6:	4904      	ldr	r1, [pc, #16]	; (204808 <cmd_exit+0x18>)
  2047f8:	f7fe bb4a 	b.w	202e90 <chprintf>
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
  2047fc:	b508      	push	{r3, lr}
  shellExit(MSG_OK);
  2047fe:	f7ff fed7 	bl	2045b0 <shellExit.constprop.4>
  204802:	bf00      	nop
  204804:	0800dce0 	.word	0x0800dce0
  204808:	0800c270 	.word	0x0800c270
  20480c:	00000000 	.word	0x00000000

00204810 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
  204810:	b570      	push	{r4, r5, r6, lr}
  204812:	4604      	mov	r4, r0
  204814:	460d      	mov	r5, r1
  204816:	4616      	mov	r6, r2
  __ASM volatile ("cpsid i" : : : "memory");
  204818:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20481a:	2320      	movs	r3, #32
  20481c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204820:	b662      	cpsie	i
  204822:	f7ff fa95 	bl	203d50 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  204826:	4632      	mov	r2, r6
  204828:	4629      	mov	r1, r5
  20482a:	4620      	mov	r0, r4
  20482c:	f7fc fad8 	bl	200de0 <chCoreAllocAlignedWithOffsetI>
  204830:	4604      	mov	r4, r0
  _dbg_check_unlock();
  204832:	f7ff fa3d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204836:	4b08      	ldr	r3, [pc, #32]	; (204858 <chCoreAllocAlignedWithOffset+0x48>)
  204838:	681a      	ldr	r2, [r3, #0]
  20483a:	429a      	cmp	r2, r3
  20483c:	d004      	beq.n	204848 <chCoreAllocAlignedWithOffset+0x38>
  20483e:	6999      	ldr	r1, [r3, #24]
  204840:	6893      	ldr	r3, [r2, #8]
  204842:	688a      	ldr	r2, [r1, #8]
  204844:	429a      	cmp	r2, r3
  204846:	d304      	bcc.n	204852 <chCoreAllocAlignedWithOffset+0x42>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204848:	2300      	movs	r3, #0
  20484a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
  20484e:	4620      	mov	r0, r4
  204850:	bd70      	pop	{r4, r5, r6, pc}
  204852:	4802      	ldr	r0, [pc, #8]	; (20485c <chCoreAllocAlignedWithOffset+0x4c>)
  204854:	f7fc f98c 	bl	200b70 <chSysHalt>
  204858:	20000dc8 	.word	0x20000dc8
  20485c:	0800bc64 	.word	0x0800bc64

00204860 <oslib_test_001_003_execute>:
}

static void oslib_test_001_003_execute(void) {
  204860:	b570      	push	{r4, r5, r6, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [1.3.1] Filling the mailbox.*/
  test_set_step(1);
  204862:	2301      	movs	r3, #1
  204864:	4e59      	ldr	r6, [pc, #356]	; (2049cc <oslib_test_001_003_execute+0x16c>)
static void oslib_test_001_003_execute(void) {
  204866:	b082      	sub	sp, #8
  test_set_step(1);
  204868:	2442      	movs	r4, #66	; 0x42
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20486a:	4d59      	ldr	r5, [pc, #356]	; (2049d0 <oslib_test_001_003_execute+0x170>)
  test_set_step(1);
  20486c:	6033      	str	r3, [r6, #0]
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  20486e:	f04f 31ff 	mov.w	r1, #4294967295
  204872:	4620      	mov	r0, r4
  204874:	f7ff fd44 	bl	204300 <chMBPostTimeout.constprop.27>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  204878:	fab0 f080 	clz	r0, r0
  20487c:	4629      	mov	r1, r5
  20487e:	0940      	lsrs	r0, r0, #5
  204880:	f7fb ff9e 	bl	2007c0 <_test_assert>
  204884:	b988      	cbnz	r0, 2048aa <oslib_test_001_003_execute+0x4a>
  204886:	3401      	adds	r4, #1
    for (i = 0; i < MB_SIZE; i++) {
  204888:	2c46      	cmp	r4, #70	; 0x46
  20488a:	d1f0      	bne.n	20486e <oslib_test_001_003_execute+0xe>
    }
  }

  /* [1.3.2] Testing chMBPostTimeout(), chMBPostI(),
     chMBPostAheadTimeout() and chMBPostAheadI() timeout.*/
  test_set_step(2);
  20488c:	2302      	movs	r3, #2
  {
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
  20488e:	2101      	movs	r1, #1
  204890:	2058      	movs	r0, #88	; 0x58
  test_set_step(2);
  204892:	6033      	str	r3, [r6, #0]
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
  204894:	f7ff fd34 	bl	204300 <chMBPostTimeout.constprop.27>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  204898:	f1a0 30ff 	sub.w	r0, r0, #4294967295
  20489c:	494c      	ldr	r1, [pc, #304]	; (2049d0 <oslib_test_001_003_execute+0x170>)
  20489e:	fab0 f080 	clz	r0, r0
  2048a2:	0940      	lsrs	r0, r0, #5
  2048a4:	f7fb ff8c 	bl	2007c0 <_test_assert>
  2048a8:	b108      	cbz	r0, 2048ae <oslib_test_001_003_execute+0x4e>
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
}
  2048aa:	b002      	add	sp, #8
  2048ac:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("cpsid i" : : : "memory");
  2048ae:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2048b0:	2320      	movs	r3, #32
  2048b2:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2048b6:	b662      	cpsie	i
  2048b8:	4c46      	ldr	r4, [pc, #280]	; (2049d4 <oslib_test_001_003_execute+0x174>)
  _dbg_check_lock();
  2048ba:	f7ff fa49 	bl	203d50 <_dbg_check_lock>
    msg1 = chMBPostI(&mb1, 'X');
  2048be:	2058      	movs	r0, #88	; 0x58
  2048c0:	f7fd fd66 	bl	202390 <chMBPostI.constprop.26>
  2048c4:	4605      	mov	r5, r0
  _dbg_check_unlock();
  2048c6:	f7ff f9f3 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2048ca:	6823      	ldr	r3, [r4, #0]
  2048cc:	42a3      	cmp	r3, r4
  2048ce:	d004      	beq.n	2048da <oslib_test_001_003_execute+0x7a>
  2048d0:	69a2      	ldr	r2, [r4, #24]
  2048d2:	689b      	ldr	r3, [r3, #8]
  2048d4:	6892      	ldr	r2, [r2, #8]
  2048d6:	429a      	cmp	r2, r3
  2048d8:	d375      	bcc.n	2049c6 <oslib_test_001_003_execute+0x166>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2048da:	2300      	movs	r3, #0
  2048dc:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  2048e0:	f1a5 30ff 	sub.w	r0, r5, #4294967295
  2048e4:	493a      	ldr	r1, [pc, #232]	; (2049d0 <oslib_test_001_003_execute+0x170>)
  2048e6:	fab0 f080 	clz	r0, r0
  2048ea:	0940      	lsrs	r0, r0, #5
  2048ec:	f7fb ff68 	bl	2007c0 <_test_assert>
  2048f0:	2800      	cmp	r0, #0
  2048f2:	d1da      	bne.n	2048aa <oslib_test_001_003_execute+0x4a>
    msg1 = chMBPostAheadTimeout(&mb1, 'X', 1);
  2048f4:	2101      	movs	r1, #1
  2048f6:	2058      	movs	r0, #88	; 0x58
  2048f8:	f7ff fd5a 	bl	2043b0 <chMBPostAheadTimeout.constprop.24>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  2048fc:	f1a0 30ff 	sub.w	r0, r0, #4294967295
  204900:	4933      	ldr	r1, [pc, #204]	; (2049d0 <oslib_test_001_003_execute+0x170>)
  204902:	fab0 f080 	clz	r0, r0
  204906:	0940      	lsrs	r0, r0, #5
  204908:	f7fb ff5a 	bl	2007c0 <_test_assert>
  20490c:	2800      	cmp	r0, #0
  20490e:	d1cc      	bne.n	2048aa <oslib_test_001_003_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
  204910:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204912:	2320      	movs	r3, #32
  204914:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204918:	b662      	cpsie	i
  _dbg_check_lock();
  20491a:	f7ff fa19 	bl	203d50 <_dbg_check_lock>
    msg1 = chMBPostAheadI(&mb1, 'X');
  20491e:	2058      	movs	r0, #88	; 0x58
  204920:	f7fd fd66 	bl	2023f0 <chMBPostAheadI.constprop.23>
  204924:	4605      	mov	r5, r0
  _dbg_check_unlock();
  204926:	f7ff f9c3 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20492a:	6823      	ldr	r3, [r4, #0]
  20492c:	42a3      	cmp	r3, r4
  20492e:	d004      	beq.n	20493a <oslib_test_001_003_execute+0xda>
  204930:	69a2      	ldr	r2, [r4, #24]
  204932:	689b      	ldr	r3, [r3, #8]
  204934:	6892      	ldr	r2, [r2, #8]
  204936:	429a      	cmp	r2, r3
  204938:	d345      	bcc.n	2049c6 <oslib_test_001_003_execute+0x166>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20493a:	2300      	movs	r3, #0
  20493c:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  204940:	f1a5 30ff 	sub.w	r0, r5, #4294967295
  204944:	4922      	ldr	r1, [pc, #136]	; (2049d0 <oslib_test_001_003_execute+0x170>)
  204946:	fab0 f080 	clz	r0, r0
  20494a:	0940      	lsrs	r0, r0, #5
  20494c:	f7fb ff38 	bl	2007c0 <_test_assert>
  204950:	4605      	mov	r5, r0
  204952:	2800      	cmp	r0, #0
  204954:	d1a9      	bne.n	2048aa <oslib_test_001_003_execute+0x4a>
  test_set_step(3);
  204956:	2303      	movs	r3, #3
  204958:	6033      	str	r3, [r6, #0]
    chMBReset(&mb1);
  20495a:	f7ff fc91 	bl	204280 <chMBReset.constprop.29>
  test_set_step(4);
  20495e:	2304      	movs	r3, #4
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
  204960:	4a1d      	ldr	r2, [pc, #116]	; (2049d8 <oslib_test_001_003_execute+0x178>)
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
  204962:	2101      	movs	r1, #1
  204964:	eb0d 0003 	add.w	r0, sp, r3
  204968:	7515      	strb	r5, [r2, #20]
  test_set_step(4);
  20496a:	6033      	str	r3, [r6, #0]
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
  20496c:	f7ff fd78 	bl	204460 <chMBFetchTimeout.constprop.21>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  204970:	f1a0 30ff 	sub.w	r0, r0, #4294967295
  204974:	4916      	ldr	r1, [pc, #88]	; (2049d0 <oslib_test_001_003_execute+0x170>)
  204976:	fab0 f080 	clz	r0, r0
  20497a:	0940      	lsrs	r0, r0, #5
  20497c:	f7fb ff20 	bl	2007c0 <_test_assert>
  204980:	2800      	cmp	r0, #0
  204982:	d192      	bne.n	2048aa <oslib_test_001_003_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
  204984:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204986:	2320      	movs	r3, #32
  204988:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20498c:	b662      	cpsie	i
  _dbg_check_lock();
  20498e:	f7ff f9df 	bl	203d50 <_dbg_check_lock>
    msg1 = chMBFetchI(&mb1, &msg2);
  204992:	a801      	add	r0, sp, #4
  204994:	f7fc faec 	bl	200f70 <chMBFetchI.constprop.20>
  204998:	4605      	mov	r5, r0
  _dbg_check_unlock();
  20499a:	f7ff f989 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20499e:	6823      	ldr	r3, [r4, #0]
  2049a0:	42a3      	cmp	r3, r4
  2049a2:	d004      	beq.n	2049ae <oslib_test_001_003_execute+0x14e>
  2049a4:	69a2      	ldr	r2, [r4, #24]
  2049a6:	689b      	ldr	r3, [r3, #8]
  2049a8:	6892      	ldr	r2, [r2, #8]
  2049aa:	429a      	cmp	r2, r3
  2049ac:	d30b      	bcc.n	2049c6 <oslib_test_001_003_execute+0x166>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2049ae:	2300      	movs	r3, #0
  2049b0:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  2049b4:	f1a5 30ff 	sub.w	r0, r5, #4294967295
  2049b8:	4905      	ldr	r1, [pc, #20]	; (2049d0 <oslib_test_001_003_execute+0x170>)
  2049ba:	fab0 f080 	clz	r0, r0
  2049be:	0940      	lsrs	r0, r0, #5
  2049c0:	f7fb fefe 	bl	2007c0 <_test_assert>
  2049c4:	e771      	b.n	2048aa <oslib_test_001_003_execute+0x4a>
  2049c6:	4805      	ldr	r0, [pc, #20]	; (2049dc <oslib_test_001_003_execute+0x17c>)
  2049c8:	f7fc f8d2 	bl	200b70 <chSysHalt>
  2049cc:	20001f6c 	.word	0x20001f6c
  2049d0:	0800c6a0 	.word	0x0800c6a0
  2049d4:	20000dc8 	.word	0x20000dc8
  2049d8:	20010458 	.word	0x20010458
  2049dc:	0800bce8 	.word	0x0800bce8

002049e0 <bmk_thread4>:
static THD_FUNCTION(bmk_thread4, p) {
  2049e0:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
  2049e2:	4d10      	ldr	r5, [pc, #64]	; (204a24 <bmk_thread4+0x44>)
  2049e4:	69ac      	ldr	r4, [r5, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  2049e6:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2049e8:	2320      	movs	r3, #32
  2049ea:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2049ee:	b662      	cpsie	i
  _dbg_check_lock();
  2049f0:	f7ff f9ae 	bl	203d50 <_dbg_check_lock>
    chSchGoSleepS(CH_STATE_SUSPENDED);
  2049f4:	2003      	movs	r0, #3
  2049f6:	f7fe fd53 	bl	2034a0 <chSchGoSleepS>
  } while (msg == MSG_OK);
  2049fa:	6a63      	ldr	r3, [r4, #36]	; 0x24
  2049fc:	2b00      	cmp	r3, #0
  2049fe:	d0f9      	beq.n	2049f4 <bmk_thread4+0x14>
  _dbg_check_unlock();
  204a00:	f7ff f956 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204a04:	682b      	ldr	r3, [r5, #0]
  204a06:	42ab      	cmp	r3, r5
  204a08:	d004      	beq.n	204a14 <bmk_thread4+0x34>
  204a0a:	69aa      	ldr	r2, [r5, #24]
  204a0c:	689b      	ldr	r3, [r3, #8]
  204a0e:	6892      	ldr	r2, [r2, #8]
  204a10:	429a      	cmp	r2, r3
  204a12:	d303      	bcc.n	204a1c <bmk_thread4+0x3c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204a14:	2300      	movs	r3, #0
  204a16:	f383 8811 	msr	BASEPRI, r3
}
  204a1a:	bd38      	pop	{r3, r4, r5, pc}
  204a1c:	4802      	ldr	r0, [pc, #8]	; (204a28 <bmk_thread4+0x48>)
  204a1e:	f7fc f8a7 	bl	200b70 <chSysHalt>
  204a22:	bf00      	nop
  204a24:	20000dc8 	.word	0x20000dc8
  204a28:	0800bcdc 	.word	0x0800bcdc
  204a2c:	00000000 	.word	0x00000000

00204a30 <rt_test_008_006_execute>:
static void rt_test_008_006_execute(void) {
  204a30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
  204a32:	2301      	movs	r3, #1
  204a34:	4c4e      	ldr	r4, [pc, #312]	; (204b70 <rt_test_008_006_execute+0x140>)
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  204a36:	2000      	movs	r0, #0
  test_set_step(1);
  204a38:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  204a3a:	f7ff fb99 	bl	204170 <chEvtWaitOneTimeout.constprop.35>
    test_assert(m == 0, "spurious event");
  204a3e:	fab0 f080 	clz	r0, r0
  204a42:	494c      	ldr	r1, [pc, #304]	; (204b74 <rt_test_008_006_execute+0x144>)
  204a44:	0940      	lsrs	r0, r0, #5
  204a46:	f7fb febb 	bl	2007c0 <_test_assert>
  204a4a:	b100      	cbz	r0, 204a4e <rt_test_008_006_execute+0x1e>
}
  204a4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  204a4e:	f7ff fbd7 	bl	204200 <chEvtWaitAnyTimeout.constprop.34>
    test_assert(m == 0, "spurious event");
  204a52:	fab0 f080 	clz	r0, r0
  204a56:	4947      	ldr	r1, [pc, #284]	; (204b74 <rt_test_008_006_execute+0x144>)
  204a58:	0940      	lsrs	r0, r0, #5
  204a5a:	f7fb feb1 	bl	2007c0 <_test_assert>
  204a5e:	4605      	mov	r5, r0
  204a60:	2800      	cmp	r0, #0
  204a62:	d1f3      	bne.n	204a4c <rt_test_008_006_execute+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
  204a64:	4e44      	ldr	r6, [pc, #272]	; (204b78 <rt_test_008_006_execute+0x148>)
  204a66:	69b7      	ldr	r7, [r6, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  204a68:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204a6a:	2320      	movs	r3, #32
  204a6c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204a70:	b662      	cpsie	i
  _dbg_check_lock();
  204a72:	f7ff f96d 	bl	203d50 <_dbg_check_lock>

  chSysLock();
  if ((ctp->epending & events) != events) {
  204a76:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  204a78:	3301      	adds	r3, #1
  204a7a:	d05b      	beq.n	204b34 <rt_test_008_006_execute+0x104>
  _dbg_check_unlock();
  204a7c:	f7ff f918 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204a80:	6833      	ldr	r3, [r6, #0]
  204a82:	42b3      	cmp	r3, r6
  204a84:	d004      	beq.n	204a90 <rt_test_008_006_execute+0x60>
  204a86:	69b2      	ldr	r2, [r6, #24]
  204a88:	689b      	ldr	r3, [r3, #8]
  204a8a:	6892      	ldr	r2, [r2, #8]
  204a8c:	429a      	cmp	r2, r3
  204a8e:	d34e      	bcc.n	204b2e <rt_test_008_006_execute+0xfe>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204a90:	2300      	movs	r3, #0
  204a92:	f383 8811 	msr	BASEPRI, r3
  204a96:	2501      	movs	r5, #1
    test_assert(m == 0, "spurious event");
  204a98:	4628      	mov	r0, r5
  204a9a:	4936      	ldr	r1, [pc, #216]	; (204b74 <rt_test_008_006_execute+0x144>)
  204a9c:	f7fb fe90 	bl	2007c0 <_test_assert>
  204aa0:	2800      	cmp	r0, #0
  204aa2:	d1d3      	bne.n	204a4c <rt_test_008_006_execute+0x1c>
  test_set_step(2);
  204aa4:	2302      	movs	r3, #2
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
  204aa6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  test_set_step(2);
  204aaa:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
  204aac:	f7ff fb60 	bl	204170 <chEvtWaitOneTimeout.constprop.35>
    test_assert(m == 0, "spurious event");
  204ab0:	fab0 f080 	clz	r0, r0
  204ab4:	492f      	ldr	r1, [pc, #188]	; (204b74 <rt_test_008_006_execute+0x144>)
  204ab6:	0940      	lsrs	r0, r0, #5
  204ab8:	f7fb fe82 	bl	2007c0 <_test_assert>
  204abc:	2800      	cmp	r0, #0
  204abe:	d1c5      	bne.n	204a4c <rt_test_008_006_execute+0x1c>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_MS2I(50));
  204ac0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  204ac4:	f7ff fb9c 	bl	204200 <chEvtWaitAnyTimeout.constprop.34>
    test_assert(m == 0, "spurious event");
  204ac8:	fab0 f080 	clz	r0, r0
  204acc:	4929      	ldr	r1, [pc, #164]	; (204b74 <rt_test_008_006_execute+0x144>)
  204ace:	0940      	lsrs	r0, r0, #5
  204ad0:	f7fb fe76 	bl	2007c0 <_test_assert>
  204ad4:	4604      	mov	r4, r0
  204ad6:	2800      	cmp	r0, #0
  204ad8:	d1b8      	bne.n	204a4c <rt_test_008_006_execute+0x1c>
  thread_t *ctp = currp;
  204ada:	69b5      	ldr	r5, [r6, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  204adc:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204ade:	2320      	movs	r3, #32
  204ae0:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204ae4:	b662      	cpsie	i
  _dbg_check_lock();
  204ae6:	f7ff f933 	bl	203d50 <_dbg_check_lock>
  if ((ctp->epending & events) != events) {
  204aea:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  204aec:	3301      	adds	r3, #1
  204aee:	d009      	beq.n	204b04 <rt_test_008_006_execute+0xd4>
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
  204af0:	f04f 33ff 	mov.w	r3, #4294967295
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
  204af4:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  204af8:	200b      	movs	r0, #11
    ctp->u.ewmask = events;
  204afa:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
  204afc:	f7fe fda8 	bl	203650 <chSchGoSleepTimeoutS>
  204b00:	2800      	cmp	r0, #0
  204b02:	db26      	blt.n	204b52 <rt_test_008_006_execute+0x122>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
  204b04:	2300      	movs	r3, #0
  204b06:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
  204b08:	f7ff f8d2 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204b0c:	6833      	ldr	r3, [r6, #0]
  204b0e:	42b3      	cmp	r3, r6
  204b10:	d004      	beq.n	204b1c <rt_test_008_006_execute+0xec>
  204b12:	69b2      	ldr	r2, [r6, #24]
  204b14:	689b      	ldr	r3, [r3, #8]
  204b16:	6892      	ldr	r2, [r2, #8]
  204b18:	429a      	cmp	r2, r3
  204b1a:	d308      	bcc.n	204b2e <rt_test_008_006_execute+0xfe>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204b1c:	2300      	movs	r3, #0
  204b1e:	f383 8811 	msr	BASEPRI, r3
    test_assert(m == 0, "spurious event");
  204b22:	4620      	mov	r0, r4
  204b24:	4913      	ldr	r1, [pc, #76]	; (204b74 <rt_test_008_006_execute+0x144>)
}
  204b26:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(m == 0, "spurious event");
  204b2a:	f7fb be49 	b.w	2007c0 <_test_assert>
  204b2e:	4813      	ldr	r0, [pc, #76]	; (204b7c <rt_test_008_006_execute+0x14c>)
  204b30:	f7fc f81e 	bl	200b70 <chSysHalt>
  204b34:	637d      	str	r5, [r7, #52]	; 0x34
  _dbg_check_unlock();
  204b36:	f7ff f8bb 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204b3a:	6833      	ldr	r3, [r6, #0]
  204b3c:	42b3      	cmp	r3, r6
  204b3e:	d004      	beq.n	204b4a <rt_test_008_006_execute+0x11a>
  204b40:	69b2      	ldr	r2, [r6, #24]
  204b42:	689b      	ldr	r3, [r3, #8]
  204b44:	6892      	ldr	r2, [r2, #8]
  204b46:	429a      	cmp	r2, r3
  204b48:	d3f1      	bcc.n	204b2e <rt_test_008_006_execute+0xfe>
  204b4a:	2300      	movs	r3, #0
  204b4c:	f383 8811 	msr	BASEPRI, r3
  204b50:	e7a2      	b.n	204a98 <rt_test_008_006_execute+0x68>
  _dbg_check_unlock();
  204b52:	f7ff f8ad 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204b56:	6833      	ldr	r3, [r6, #0]
  204b58:	42b3      	cmp	r3, r6
  204b5a:	d004      	beq.n	204b66 <rt_test_008_006_execute+0x136>
  204b5c:	69b2      	ldr	r2, [r6, #24]
  204b5e:	689b      	ldr	r3, [r3, #8]
  204b60:	6892      	ldr	r2, [r2, #8]
  204b62:	429a      	cmp	r2, r3
  204b64:	d3e3      	bcc.n	204b2e <rt_test_008_006_execute+0xfe>
  204b66:	2300      	movs	r3, #0
  204b68:	f383 8811 	msr	BASEPRI, r3
  204b6c:	2401      	movs	r4, #1
  204b6e:	e7d8      	b.n	204b22 <rt_test_008_006_execute+0xf2>
  204b70:	20001f6c 	.word	0x20001f6c
  204b74:	0800d880 	.word	0x0800d880
  204b78:	20000dc8 	.word	0x20000dc8
  204b7c:	0800bc34 	.word	0x0800bc34

00204b80 <thread4>:
static THD_FUNCTION(thread4, p) {
  204b80:	b510      	push	{r4, lr}
  204b82:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  204b84:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204b86:	2320      	movs	r3, #32
  204b88:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204b8c:	b662      	cpsie	i
  _dbg_check_lock();
  204b8e:	f7ff f8df 	bl	203d50 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
  204b92:	f7fc f8fd 	bl	200d90 <chDbgCheckClassI>

  if (bsp->sem.cnt < (cnt_t)1) {
  204b96:	68a3      	ldr	r3, [r4, #8]
  204b98:	2b00      	cmp	r3, #0
  204b9a:	dd13      	ble.n	204bc4 <thread4+0x44>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
  204b9c:	f7ff f870 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  204ba0:	f7ff f886 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204ba4:	4b09      	ldr	r3, [pc, #36]	; (204bcc <thread4+0x4c>)
  204ba6:	681a      	ldr	r2, [r3, #0]
  204ba8:	429a      	cmp	r2, r3
  204baa:	d004      	beq.n	204bb6 <thread4+0x36>
  204bac:	6999      	ldr	r1, [r3, #24]
  204bae:	6893      	ldr	r3, [r2, #8]
  204bb0:	688a      	ldr	r2, [r1, #8]
  204bb2:	429a      	cmp	r2, r3
  204bb4:	d303      	bcc.n	204bbe <thread4+0x3e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204bb6:	2300      	movs	r3, #0
  204bb8:	f383 8811 	msr	BASEPRI, r3
}
  204bbc:	bd10      	pop	{r4, pc}
  204bbe:	4804      	ldr	r0, [pc, #16]	; (204bd0 <thread4+0x50>)
  204bc0:	f7fb ffd6 	bl	200b70 <chSysHalt>
    chSemSignalI(&bsp->sem);
  204bc4:	4620      	mov	r0, r4
  204bc6:	f7fc fab3 	bl	201130 <chSemSignalI>
  204bca:	e7e7      	b.n	204b9c <thread4+0x1c>
  204bcc:	20000dc8 	.word	0x20000dc8
  204bd0:	0800bcb8 	.word	0x0800bcb8
	...

00204be0 <rt_test_002_001_execute>:
static void rt_test_002_001_execute(void) {
  204be0:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
  204be2:	4e46      	ldr	r6, [pc, #280]	; (204cfc <rt_test_002_001_execute+0x11c>)
  204be4:	2501      	movs	r5, #1
  204be6:	6035      	str	r5, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  204be8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204bea:	2320      	movs	r3, #32
  204bec:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204bf0:	b662      	cpsie	i
  204bf2:	4c43      	ldr	r4, [pc, #268]	; (204d00 <rt_test_002_001_execute+0x120>)
  _dbg_check_lock();
  204bf4:	f7ff f8ac 	bl	203d50 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
  204bf8:	4628      	mov	r0, r5
  204bfa:	f7fc fac1 	bl	201180 <chSysIntegrityCheckI>
  204bfe:	4605      	mov	r5, r0
  _dbg_check_unlock();
  204c00:	f7ff f856 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204c04:	6823      	ldr	r3, [r4, #0]
  204c06:	42a3      	cmp	r3, r4
  204c08:	d004      	beq.n	204c14 <rt_test_002_001_execute+0x34>
  204c0a:	69a2      	ldr	r2, [r4, #24]
  204c0c:	689b      	ldr	r3, [r3, #8]
  204c0e:	6892      	ldr	r2, [r2, #8]
  204c10:	429a      	cmp	r2, r3
  204c12:	d343      	bcc.n	204c9c <rt_test_002_001_execute+0xbc>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204c14:	2300      	movs	r3, #0
  204c16:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "ready list check failed");
  204c1a:	f085 0001 	eor.w	r0, r5, #1
  204c1e:	4939      	ldr	r1, [pc, #228]	; (204d04 <rt_test_002_001_execute+0x124>)
  204c20:	b2c0      	uxtb	r0, r0
  204c22:	f7fb fdcd 	bl	2007c0 <_test_assert>
  204c26:	b100      	cbz	r0, 204c2a <rt_test_002_001_execute+0x4a>
}
  204c28:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(2);
  204c2a:	2502      	movs	r5, #2
  204c2c:	6035      	str	r5, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  204c2e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204c30:	2320      	movs	r3, #32
  204c32:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204c36:	b662      	cpsie	i
  _dbg_check_lock();
  204c38:	f7ff f88a 	bl	203d50 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
  204c3c:	4628      	mov	r0, r5
  204c3e:	f7fc fa9f 	bl	201180 <chSysIntegrityCheckI>
  204c42:	4605      	mov	r5, r0
  _dbg_check_unlock();
  204c44:	f7ff f834 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204c48:	6823      	ldr	r3, [r4, #0]
  204c4a:	42a3      	cmp	r3, r4
  204c4c:	d004      	beq.n	204c58 <rt_test_002_001_execute+0x78>
  204c4e:	69a2      	ldr	r2, [r4, #24]
  204c50:	689b      	ldr	r3, [r3, #8]
  204c52:	6892      	ldr	r2, [r2, #8]
  204c54:	429a      	cmp	r2, r3
  204c56:	d321      	bcc.n	204c9c <rt_test_002_001_execute+0xbc>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204c58:	2300      	movs	r3, #0
  204c5a:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "virtual timers list check failed");
  204c5e:	f085 0001 	eor.w	r0, r5, #1
  204c62:	4929      	ldr	r1, [pc, #164]	; (204d08 <rt_test_002_001_execute+0x128>)
  204c64:	b2c0      	uxtb	r0, r0
  204c66:	f7fb fdab 	bl	2007c0 <_test_assert>
  204c6a:	2800      	cmp	r0, #0
  204c6c:	d1dc      	bne.n	204c28 <rt_test_002_001_execute+0x48>
  test_set_step(3);
  204c6e:	2303      	movs	r3, #3
  204c70:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  204c72:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204c74:	2320      	movs	r3, #32
  204c76:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204c7a:	b662      	cpsie	i
  _dbg_check_lock();
  204c7c:	f7ff f868 	bl	203d50 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
  204c80:	2004      	movs	r0, #4
  204c82:	f7fc fa7d 	bl	201180 <chSysIntegrityCheckI>
  204c86:	4605      	mov	r5, r0
  _dbg_check_unlock();
  204c88:	f7ff f812 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204c8c:	6823      	ldr	r3, [r4, #0]
  204c8e:	42a3      	cmp	r3, r4
  204c90:	d007      	beq.n	204ca2 <rt_test_002_001_execute+0xc2>
  204c92:	69a2      	ldr	r2, [r4, #24]
  204c94:	689b      	ldr	r3, [r3, #8]
  204c96:	6892      	ldr	r2, [r2, #8]
  204c98:	429a      	cmp	r2, r3
  204c9a:	d202      	bcs.n	204ca2 <rt_test_002_001_execute+0xc2>
  204c9c:	481b      	ldr	r0, [pc, #108]	; (204d0c <rt_test_002_001_execute+0x12c>)
  204c9e:	f7fb ff67 	bl	200b70 <chSysHalt>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204ca2:	2300      	movs	r3, #0
  204ca4:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "registry list check failed");
  204ca8:	f085 0001 	eor.w	r0, r5, #1
  204cac:	4918      	ldr	r1, [pc, #96]	; (204d10 <rt_test_002_001_execute+0x130>)
  204cae:	b2c0      	uxtb	r0, r0
  204cb0:	f7fb fd86 	bl	2007c0 <_test_assert>
  204cb4:	2800      	cmp	r0, #0
  204cb6:	d1b7      	bne.n	204c28 <rt_test_002_001_execute+0x48>
  test_set_step(4);
  204cb8:	2304      	movs	r3, #4
  204cba:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  204cbc:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204cbe:	2320      	movs	r3, #32
  204cc0:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204cc4:	b662      	cpsie	i
  _dbg_check_lock();
  204cc6:	f7ff f843 	bl	203d50 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
  204cca:	2008      	movs	r0, #8
  204ccc:	f7fc fa58 	bl	201180 <chSysIntegrityCheckI>
  204cd0:	4605      	mov	r5, r0
  _dbg_check_unlock();
  204cd2:	f7fe ffed 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204cd6:	6823      	ldr	r3, [r4, #0]
  204cd8:	42a3      	cmp	r3, r4
  204cda:	d004      	beq.n	204ce6 <rt_test_002_001_execute+0x106>
  204cdc:	69a2      	ldr	r2, [r4, #24]
  204cde:	689b      	ldr	r3, [r3, #8]
  204ce0:	6892      	ldr	r2, [r2, #8]
  204ce2:	429a      	cmp	r2, r3
  204ce4:	d3da      	bcc.n	204c9c <rt_test_002_001_execute+0xbc>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204ce6:	2300      	movs	r3, #0
  204ce8:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "port layer check failed");
  204cec:	f085 0001 	eor.w	r0, r5, #1
  204cf0:	4908      	ldr	r1, [pc, #32]	; (204d14 <rt_test_002_001_execute+0x134>)
  204cf2:	b2c0      	uxtb	r0, r0
}
  204cf4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(result == false, "port layer check failed");
  204cf8:	f7fb bd62 	b.w	2007c0 <_test_assert>
  204cfc:	20001f6c 	.word	0x20001f6c
  204d00:	20000dc8 	.word	0x20000dc8
  204d04:	0800d438 	.word	0x0800d438
  204d08:	0800d450 	.word	0x0800d450
  204d0c:	0800bc94 	.word	0x0800bc94
  204d10:	0800d474 	.word	0x0800d474
  204d14:	0800d490 	.word	0x0800d490
	...

00204d20 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  204d20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  204d24:	4c14      	ldr	r4, [pc, #80]	; (204d78 <test_terminate_threads+0x58>)
  204d26:	2720      	movs	r7, #32
  204d28:	4e14      	ldr	r6, [pc, #80]	; (204d7c <test_terminate_threads+0x5c>)
  204d2a:	f04f 0800 	mov.w	r8, #0
  204d2e:	f104 0914 	add.w	r9, r4, #20
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
  204d32:	f854 5b04 	ldr.w	r5, [r4], #4
  204d36:	b1bd      	cbz	r5, 204d68 <test_terminate_threads+0x48>
  __ASM volatile ("cpsid i" : : : "memory");
  204d38:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204d3a:	f387 8811 	msr	BASEPRI, r7
  __ASM volatile ("cpsie i" : : : "memory");
  204d3e:	b662      	cpsie	i
  _dbg_check_lock();
  204d40:	f7ff f806 	bl	203d50 <_dbg_check_lock>
  tp->flags |= CH_FLAG_TERMINATE;
  204d44:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
  204d48:	f043 0304 	orr.w	r3, r3, #4
  204d4c:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
  _dbg_check_unlock();
  204d50:	f7fe ffae 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204d54:	6833      	ldr	r3, [r6, #0]
  204d56:	42b3      	cmp	r3, r6
  204d58:	d004      	beq.n	204d64 <test_terminate_threads+0x44>
  204d5a:	69b2      	ldr	r2, [r6, #24]
  204d5c:	689b      	ldr	r3, [r3, #8]
  204d5e:	6892      	ldr	r2, [r2, #8]
  204d60:	429a      	cmp	r2, r3
  204d62:	d305      	bcc.n	204d70 <test_terminate_threads+0x50>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204d64:	f388 8811 	msr	BASEPRI, r8
  for (i = 0; i < MAX_THREADS; i++)
  204d68:	454c      	cmp	r4, r9
  204d6a:	d1e2      	bne.n	204d32 <test_terminate_threads+0x12>
      chThdTerminate(threads[i]);
}
  204d6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  204d70:	4803      	ldr	r0, [pc, #12]	; (204d80 <test_terminate_threads+0x60>)
  204d72:	f7fb fefd 	bl	200b70 <chSysHalt>
  204d76:	bf00      	nop
  204d78:	20001f84 	.word	0x20001f84
  204d7c:	20000dc8 	.word	0x20000dc8
  204d80:	0800bc04 	.word	0x0800bc04
	...

00204d90 <test_emit_token>:
 *
 * @param[in] token     the token as a char
 *
 * @api
 */
void test_emit_token(char token) {
  204d90:	b510      	push	{r4, lr}
  204d92:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  204d94:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204d96:	2320      	movs	r3, #32
  204d98:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204d9c:	b662      	cpsie	i
  _dbg_check_lock();
  204d9e:	f7fe ffd7 	bl	203d50 <_dbg_check_lock>

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
  204da2:	4a0d      	ldr	r2, [pc, #52]	; (204dd8 <test_emit_token+0x48>)
  204da4:	490d      	ldr	r1, [pc, #52]	; (204ddc <test_emit_token+0x4c>)
  204da6:	6813      	ldr	r3, [r2, #0]
  204da8:	428b      	cmp	r3, r1
  204daa:	d202      	bcs.n	204db2 <test_emit_token+0x22>
    *test_tokp++ = token;
  204dac:	1c59      	adds	r1, r3, #1
  204dae:	701c      	strb	r4, [r3, #0]
  204db0:	6011      	str	r1, [r2, #0]
  _dbg_check_unlock();
  204db2:	f7fe ff7d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204db6:	4b0a      	ldr	r3, [pc, #40]	; (204de0 <test_emit_token+0x50>)
  204db8:	681a      	ldr	r2, [r3, #0]
  204dba:	429a      	cmp	r2, r3
  204dbc:	d004      	beq.n	204dc8 <test_emit_token+0x38>
  204dbe:	6999      	ldr	r1, [r3, #24]
  204dc0:	6893      	ldr	r3, [r2, #8]
  204dc2:	688a      	ldr	r2, [r1, #8]
  204dc4:	429a      	cmp	r2, r3
  204dc6:	d303      	bcc.n	204dd0 <test_emit_token+0x40>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204dc8:	2300      	movs	r3, #0
  204dca:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
  204dce:	bd10      	pop	{r4, pc}
  204dd0:	4804      	ldr	r0, [pc, #16]	; (204de4 <test_emit_token+0x54>)
  204dd2:	f7fb fecd 	bl	200b70 <chSysHalt>
  204dd6:	bf00      	nop
  204dd8:	20001f80 	.word	0x20001f80
  204ddc:	20001f80 	.word	0x20001f80
  204de0:	20000dc8 	.word	0x20000dc8
  204de4:	0800bc7c 	.word	0x0800bc7c
	...

00204df0 <oslib_test_001_002_execute>:
static void oslib_test_001_002_execute(void) {
  204df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_set_step(1);
  204df4:	2301      	movs	r3, #1
  204df6:	4ec4      	ldr	r6, [pc, #784]	; (205108 <oslib_test_001_002_execute+0x318>)
static void oslib_test_001_002_execute(void) {
  204df8:	b083      	sub	sp, #12
  test_set_step(1);
  204dfa:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  204dfc:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204dfe:	2320      	movs	r3, #32
  204e00:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204e04:	b662      	cpsie	i
  return (size_t)(mbp->top - mbp->buffer);
  204e06:	4cc1      	ldr	r4, [pc, #772]	; (20510c <oslib_test_001_002_execute+0x31c>)
  _dbg_check_lock();
  204e08:	f7fe ffa2 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  204e0c:	f7fb ffc0 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  204e10:	f7fb ffbe 	bl	200d90 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  204e14:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  204e16:	49be      	ldr	r1, [pc, #760]	; (205110 <oslib_test_001_002_execute+0x320>)
  return (size_t)(mbp->top - mbp->buffer);
  204e18:	e9d4 2300 	ldrd	r2, r3, [r4]
  204e1c:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  204e1e:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
  204e22:	f1a0 0004 	sub.w	r0, r0, #4
  204e26:	fab0 f080 	clz	r0, r0
  204e2a:	0940      	lsrs	r0, r0, #5
  204e2c:	f7fb fcc8 	bl	2007c0 <_test_assert>
  204e30:	2800      	cmp	r0, #0
  204e32:	f040 822b 	bne.w	20528c <oslib_test_001_002_execute+0x49c>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204e36:	4db7      	ldr	r5, [pc, #732]	; (205114 <oslib_test_001_002_execute+0x324>)
  _dbg_check_unlock();
  204e38:	f7fe ff3a 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204e3c:	682b      	ldr	r3, [r5, #0]
  204e3e:	42ab      	cmp	r3, r5
  204e40:	d005      	beq.n	204e4e <oslib_test_001_002_execute+0x5e>
  204e42:	69aa      	ldr	r2, [r5, #24]
  204e44:	689b      	ldr	r3, [r3, #8]
  204e46:	6892      	ldr	r2, [r2, #8]
  204e48:	429a      	cmp	r2, r3
  204e4a:	f0c0 822a 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204e4e:	2300      	movs	r3, #0
  204e50:	f383 8811 	msr	BASEPRI, r3
  test_set_step(2);
  204e54:	2302      	movs	r3, #2
  204e56:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  204e58:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204e5a:	2320      	movs	r3, #32
  204e5c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204e60:	b662      	cpsie	i
  _dbg_check_lock();
  204e62:	f7fe ff75 	bl	203d50 <_dbg_check_lock>
    chMBResetI(&mb1);
  204e66:	f7fd fa7b 	bl	202360 <chMBResetI.constprop.30>
  _dbg_check_unlock();
  204e6a:	f7fe ff21 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204e6e:	682b      	ldr	r3, [r5, #0]
  204e70:	42ab      	cmp	r3, r5
  204e72:	d005      	beq.n	204e80 <oslib_test_001_002_execute+0x90>
  204e74:	69aa      	ldr	r2, [r5, #24]
  204e76:	689b      	ldr	r3, [r3, #8]
  204e78:	6892      	ldr	r2, [r2, #8]
  204e7a:	429a      	cmp	r2, r3
  204e7c:	f0c0 8211 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204e80:	2300      	movs	r3, #0
  204e82:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  204e86:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204e88:	2320      	movs	r3, #32
  204e8a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204e8e:	b662      	cpsie	i
  _dbg_check_lock();
  204e90:	f7fe ff5e 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  204e94:	f7fb ff7c 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  204e98:	f7fb ff7a 	bl	200d90 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  204e9c:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  204e9e:	499e      	ldr	r1, [pc, #632]	; (205118 <oslib_test_001_002_execute+0x328>)
  return (size_t)(mbp->top - mbp->buffer);
  204ea0:	e9d4 2300 	ldrd	r2, r3, [r4]
  204ea4:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  204ea6:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
  204eaa:	f1a0 0004 	sub.w	r0, r0, #4
  204eae:	fab0 f080 	clz	r0, r0
  204eb2:	0940      	lsrs	r0, r0, #5
  204eb4:	f7fb fc84 	bl	2007c0 <_test_assert>
  204eb8:	2800      	cmp	r0, #0
  204eba:	f040 81d7 	bne.w	20526c <oslib_test_001_002_execute+0x47c>
  _dbg_check_unlock();
  204ebe:	f7fe fef7 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204ec2:	682b      	ldr	r3, [r5, #0]
  204ec4:	42ab      	cmp	r3, r5
  204ec6:	d005      	beq.n	204ed4 <oslib_test_001_002_execute+0xe4>
  204ec8:	69aa      	ldr	r2, [r5, #24]
  204eca:	689b      	ldr	r3, [r3, #8]
  204ecc:	6892      	ldr	r2, [r2, #8]
  204ece:	429a      	cmp	r2, r3
  204ed0:	f0c0 81e7 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204ed4:	2300      	movs	r3, #0
  204ed6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  204eda:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204edc:	2320      	movs	r3, #32
  204ede:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204ee2:	b662      	cpsie	i
  _dbg_check_lock();
  204ee4:	f7fe ff34 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  204ee8:	f7fb ff52 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
  204eec:	6920      	ldr	r0, [r4, #16]
  204eee:	498b      	ldr	r1, [pc, #556]	; (20511c <oslib_test_001_002_execute+0x32c>)
  204ef0:	fab0 f080 	clz	r0, r0
  204ef4:	0940      	lsrs	r0, r0, #5
  204ef6:	f7fb fc63 	bl	2007c0 <_test_assert>
  204efa:	2800      	cmp	r0, #0
  204efc:	f040 81b6 	bne.w	20526c <oslib_test_001_002_execute+0x47c>
  _dbg_check_unlock();
  204f00:	f7fe fed6 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204f04:	682b      	ldr	r3, [r5, #0]
  204f06:	42ab      	cmp	r3, r5
  204f08:	d005      	beq.n	204f16 <oslib_test_001_002_execute+0x126>
  204f0a:	69aa      	ldr	r2, [r5, #24]
  204f0c:	689b      	ldr	r3, [r3, #8]
  204f0e:	6892      	ldr	r2, [r2, #8]
  204f10:	429a      	cmp	r2, r3
  204f12:	f0c0 81c6 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204f16:	2300      	movs	r3, #0
  204f18:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  204f1c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204f1e:	2320      	movs	r3, #32
  204f20:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204f24:	b662      	cpsie	i
  _dbg_check_lock();
  204f26:	f7fe ff13 	bl	203d50 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
  204f2a:	6820      	ldr	r0, [r4, #0]
  204f2c:	68a3      	ldr	r3, [r4, #8]
  204f2e:	497c      	ldr	r1, [pc, #496]	; (205120 <oslib_test_001_002_execute+0x330>)
  204f30:	1ac0      	subs	r0, r0, r3
  204f32:	fab0 f080 	clz	r0, r0
  204f36:	0940      	lsrs	r0, r0, #5
  204f38:	f7fb fc42 	bl	2007c0 <_test_assert>
  204f3c:	2800      	cmp	r0, #0
  204f3e:	f040 8195 	bne.w	20526c <oslib_test_001_002_execute+0x47c>
  _dbg_check_unlock();
  204f42:	f7fe feb5 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204f46:	682b      	ldr	r3, [r5, #0]
  204f48:	42ab      	cmp	r3, r5
  204f4a:	d005      	beq.n	204f58 <oslib_test_001_002_execute+0x168>
  204f4c:	69aa      	ldr	r2, [r5, #24]
  204f4e:	689b      	ldr	r3, [r3, #8]
  204f50:	6892      	ldr	r2, [r2, #8]
  204f52:	429a      	cmp	r2, r3
  204f54:	f0c0 81a5 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204f58:	2300      	movs	r3, #0
  204f5a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  204f5e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204f60:	2320      	movs	r3, #32
  204f62:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204f66:	b662      	cpsie	i
  _dbg_check_lock();
  204f68:	f7fe fef2 	bl	203d50 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  204f6c:	6820      	ldr	r0, [r4, #0]
  204f6e:	68e3      	ldr	r3, [r4, #12]
  204f70:	496c      	ldr	r1, [pc, #432]	; (205124 <oslib_test_001_002_execute+0x334>)
  204f72:	1ac0      	subs	r0, r0, r3
  204f74:	fab0 f080 	clz	r0, r0
  204f78:	0940      	lsrs	r0, r0, #5
  204f7a:	f7fb fc21 	bl	2007c0 <_test_assert>
  204f7e:	2800      	cmp	r0, #0
  204f80:	f040 8174 	bne.w	20526c <oslib_test_001_002_execute+0x47c>
  _dbg_check_unlock();
  204f84:	f7fe fe94 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204f88:	682b      	ldr	r3, [r5, #0]
  204f8a:	42ab      	cmp	r3, r5
  204f8c:	d005      	beq.n	204f9a <oslib_test_001_002_execute+0x1aa>
  204f8e:	69aa      	ldr	r2, [r5, #24]
  204f90:	689b      	ldr	r3, [r3, #8]
  204f92:	6892      	ldr	r2, [r2, #8]
  204f94:	429a      	cmp	r2, r3
  204f96:	f0c0 8184 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204f9a:	2300      	movs	r3, #0
  204f9c:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
  204fa0:	2203      	movs	r2, #3
  204fa2:	469a      	mov	sl, r3
  204fa4:	2742      	movs	r7, #66	; 0x42
  204fa6:	f04f 0820 	mov.w	r8, #32
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  204faa:	f8df b17c 	ldr.w	fp, [pc, #380]	; 205128 <oslib_test_001_002_execute+0x338>
  mbp->reset = false;
  204fae:	7523      	strb	r3, [r4, #20]
  test_set_step(3);
  204fb0:	6032      	str	r2, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  204fb2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204fb4:	f388 8811 	msr	BASEPRI, r8
  __ASM volatile ("cpsie i" : : : "memory");
  204fb8:	b662      	cpsie	i
  _dbg_check_lock();
  204fba:	f7fe fec9 	bl	203d50 <_dbg_check_lock>
      msg1 = chMBPostI(&mb1, 'B' + i);
  204fbe:	4638      	mov	r0, r7
  204fc0:	f7fd f9e6 	bl	202390 <chMBPostI.constprop.26>
  204fc4:	4681      	mov	r9, r0
  _dbg_check_unlock();
  204fc6:	f7fe fe73 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  204fca:	682a      	ldr	r2, [r5, #0]
  204fcc:	42aa      	cmp	r2, r5
  204fce:	d005      	beq.n	204fdc <oslib_test_001_002_execute+0x1ec>
  204fd0:	69ab      	ldr	r3, [r5, #24]
  204fd2:	6892      	ldr	r2, [r2, #8]
  204fd4:	689b      	ldr	r3, [r3, #8]
  204fd6:	4293      	cmp	r3, r2
  204fd8:	f0c0 8163 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204fdc:	f38a 8811 	msr	BASEPRI, sl
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  204fe0:	fab9 f089 	clz	r0, r9
  204fe4:	4659      	mov	r1, fp
  204fe6:	0940      	lsrs	r0, r0, #5
  204fe8:	f7fb fbea 	bl	2007c0 <_test_assert>
  204fec:	2800      	cmp	r0, #0
  204fee:	f040 814a 	bne.w	205286 <oslib_test_001_002_execute+0x496>
  204ff2:	3701      	adds	r7, #1
    for (i = 0; i < MB_SIZE - 1; i++) {
  204ff4:	2f45      	cmp	r7, #69	; 0x45
  204ff6:	d1dc      	bne.n	204fb2 <oslib_test_001_002_execute+0x1c2>
  __ASM volatile ("cpsid i" : : : "memory");
  204ff8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204ffa:	2320      	movs	r3, #32
  204ffc:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205000:	b662      	cpsie	i
  _dbg_check_lock();
  205002:	f7fe fea5 	bl	203d50 <_dbg_check_lock>
    msg1 = chMBPostAheadI(&mb1, 'A');
  205006:	2041      	movs	r0, #65	; 0x41
  205008:	f7fd f9f2 	bl	2023f0 <chMBPostAheadI.constprop.23>
  20500c:	4607      	mov	r7, r0
  _dbg_check_unlock();
  20500e:	f7fe fe4f 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205012:	682b      	ldr	r3, [r5, #0]
  205014:	42ab      	cmp	r3, r5
  205016:	d005      	beq.n	205024 <oslib_test_001_002_execute+0x234>
  205018:	69aa      	ldr	r2, [r5, #24]
  20501a:	689b      	ldr	r3, [r3, #8]
  20501c:	6892      	ldr	r2, [r2, #8]
  20501e:	429a      	cmp	r2, r3
  205020:	f0c0 813f 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205024:	2300      	movs	r3, #0
  205026:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20502a:	fab7 f087 	clz	r0, r7
  20502e:	493e      	ldr	r1, [pc, #248]	; (205128 <oslib_test_001_002_execute+0x338>)
  205030:	0940      	lsrs	r0, r0, #5
  205032:	f7fb fbc5 	bl	2007c0 <_test_assert>
  205036:	2800      	cmp	r0, #0
  205038:	f040 8125 	bne.w	205286 <oslib_test_001_002_execute+0x496>
  test_set_step(4);
  20503c:	2304      	movs	r3, #4
  20503e:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  205040:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205042:	2320      	movs	r3, #32
  205044:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205048:	b662      	cpsie	i
  _dbg_check_lock();
  20504a:	f7fe fe81 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  20504e:	f7fb fe9f 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  205052:	f7fb fe9d 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
  205056:	6922      	ldr	r2, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
  205058:	e9d4 1300 	ldrd	r1, r3, [r4]
  20505c:	1a5b      	subs	r3, r3, r1
  20505e:	4933      	ldr	r1, [pc, #204]	; (20512c <oslib_test_001_002_execute+0x33c>)
  205060:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
  205064:	bf0c      	ite	eq
  205066:	2001      	moveq	r0, #1
  205068:	2000      	movne	r0, #0
  20506a:	f7fb fba9 	bl	2007c0 <_test_assert>
  20506e:	2800      	cmp	r0, #0
  205070:	f040 80fc 	bne.w	20526c <oslib_test_001_002_execute+0x47c>
  _dbg_check_unlock();
  205074:	f7fe fe1c 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205078:	682b      	ldr	r3, [r5, #0]
  20507a:	42ab      	cmp	r3, r5
  20507c:	d005      	beq.n	20508a <oslib_test_001_002_execute+0x29a>
  20507e:	69aa      	ldr	r2, [r5, #24]
  205080:	689b      	ldr	r3, [r3, #8]
  205082:	6892      	ldr	r2, [r2, #8]
  205084:	429a      	cmp	r2, r3
  205086:	f0c0 810c 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20508a:	2300      	movs	r3, #0
  20508c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  205090:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205092:	2320      	movs	r3, #32
  205094:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205098:	b662      	cpsie	i
  _dbg_check_lock();
  20509a:	f7fe fe59 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  20509e:	f7fb fe77 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
  2050a2:	6920      	ldr	r0, [r4, #16]
  2050a4:	4922      	ldr	r1, [pc, #136]	; (205130 <oslib_test_001_002_execute+0x340>)
  2050a6:	f1a0 0c04 	sub.w	ip, r0, #4
  2050aa:	f1dc 0000 	rsbs	r0, ip, #0
  2050ae:	eb40 000c 	adc.w	r0, r0, ip
  2050b2:	f7fb fb85 	bl	2007c0 <_test_assert>
  2050b6:	2800      	cmp	r0, #0
  2050b8:	f040 80d8 	bne.w	20526c <oslib_test_001_002_execute+0x47c>
  _dbg_check_unlock();
  2050bc:	f7fe fdf8 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2050c0:	682b      	ldr	r3, [r5, #0]
  2050c2:	42ab      	cmp	r3, r5
  2050c4:	d005      	beq.n	2050d2 <oslib_test_001_002_execute+0x2e2>
  2050c6:	69aa      	ldr	r2, [r5, #24]
  2050c8:	689b      	ldr	r3, [r3, #8]
  2050ca:	6892      	ldr	r2, [r2, #8]
  2050cc:	429a      	cmp	r2, r3
  2050ce:	f0c0 80e8 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2050d2:	2300      	movs	r3, #0
  2050d4:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  2050d8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2050da:	2320      	movs	r3, #32
  2050dc:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2050e0:	b662      	cpsie	i
  _dbg_check_lock();
  2050e2:	f7fe fe35 	bl	203d50 <_dbg_check_lock>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
  2050e6:	4913      	ldr	r1, [pc, #76]	; (205134 <oslib_test_001_002_execute+0x344>)
  2050e8:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
  2050ec:	1ac7      	subs	r7, r0, r3
  2050ee:	4278      	negs	r0, r7
  2050f0:	4178      	adcs	r0, r7
  2050f2:	f7fb fb65 	bl	2007c0 <_test_assert>
  2050f6:	2800      	cmp	r0, #0
  2050f8:	f040 80d6 	bne.w	2052a8 <oslib_test_001_002_execute+0x4b8>
  _dbg_check_unlock();
  2050fc:	f7fe fdd8 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205100:	682b      	ldr	r3, [r5, #0]
  205102:	42ab      	cmp	r3, r5
  205104:	d01e      	beq.n	205144 <oslib_test_001_002_execute+0x354>
  205106:	e017      	b.n	205138 <oslib_test_001_002_execute+0x348>
  205108:	20001f6c 	.word	0x20001f6c
  20510c:	20010458 	.word	0x20010458
  205110:	0800c5d8 	.word	0x0800c5d8
  205114:	20000dc8 	.word	0x20000dc8
  205118:	0800c5e4 	.word	0x0800c5e4
  20511c:	0800c5f0 	.word	0x0800c5f0
  205120:	0800c5fc 	.word	0x0800c5fc
  205124:	0800c620 	.word	0x0800c620
  205128:	0800c6a0 	.word	0x0800c6a0
  20512c:	0800c644 	.word	0x0800c644
  205130:	0800c650 	.word	0x0800c650
  205134:	0800c65c 	.word	0x0800c65c
  205138:	69aa      	ldr	r2, [r5, #24]
  20513a:	689b      	ldr	r3, [r3, #8]
  20513c:	6892      	ldr	r2, [r2, #8]
  20513e:	429a      	cmp	r2, r3
  205140:	f0c0 80af 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205144:	2300      	movs	r3, #0
  205146:	f383 8811 	msr	BASEPRI, r3
  test_set_step(5);
  20514a:	2205      	movs	r2, #5
  20514c:	4698      	mov	r8, r3
  20514e:	2704      	movs	r7, #4
  205150:	f04f 0a20 	mov.w	sl, #32
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  205154:	f8df 9160 	ldr.w	r9, [pc, #352]	; 2052b8 <oslib_test_001_002_execute+0x4c8>
  test_set_step(5);
  205158:	6032      	str	r2, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20515a:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20515c:	f38a 8811 	msr	BASEPRI, sl
  __ASM volatile ("cpsie i" : : : "memory");
  205160:	b662      	cpsie	i
  _dbg_check_lock();
  205162:	f7fe fdf5 	bl	203d50 <_dbg_check_lock>
      msg1 = chMBFetchI(&mb1, &msg2);
  205166:	a801      	add	r0, sp, #4
  205168:	f7fb ff02 	bl	200f70 <chMBFetchI.constprop.20>
  20516c:	4683      	mov	fp, r0
  _dbg_check_unlock();
  20516e:	f7fe fd9f 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205172:	682b      	ldr	r3, [r5, #0]
  205174:	42ab      	cmp	r3, r5
  205176:	d005      	beq.n	205184 <oslib_test_001_002_execute+0x394>
  205178:	69aa      	ldr	r2, [r5, #24]
  20517a:	689b      	ldr	r3, [r3, #8]
  20517c:	6892      	ldr	r2, [r2, #8]
  20517e:	429a      	cmp	r2, r3
  205180:	f0c0 808f 	bcc.w	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205184:	f388 8811 	msr	BASEPRI, r8
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  205188:	fabb f08b 	clz	r0, fp
  20518c:	4649      	mov	r1, r9
  20518e:	0940      	lsrs	r0, r0, #5
  205190:	f7fb fb16 	bl	2007c0 <_test_assert>
  205194:	2800      	cmp	r0, #0
  205196:	d176      	bne.n	205286 <oslib_test_001_002_execute+0x496>
      test_emit_token(msg2);
  205198:	f89d 0004 	ldrb.w	r0, [sp, #4]
  20519c:	f7ff fdf8 	bl	204d90 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
  2051a0:	3f01      	subs	r7, #1
  2051a2:	d1da      	bne.n	20515a <oslib_test_001_002_execute+0x36a>
    test_assert_sequence("ABCD", "wrong get sequence");
  2051a4:	4942      	ldr	r1, [pc, #264]	; (2052b0 <oslib_test_001_002_execute+0x4c0>)
  2051a6:	4843      	ldr	r0, [pc, #268]	; (2052b4 <oslib_test_001_002_execute+0x4c4>)
  2051a8:	f7fb fbaa 	bl	200900 <_test_assert_sequence>
  2051ac:	2800      	cmp	r0, #0
  2051ae:	d16a      	bne.n	205286 <oslib_test_001_002_execute+0x496>
  test_set_step(6);
  2051b0:	2306      	movs	r3, #6
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  2051b2:	f04f 31ff 	mov.w	r1, #4294967295
  2051b6:	2046      	movs	r0, #70	; 0x46
  test_set_step(6);
  2051b8:	6033      	str	r3, [r6, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  2051ba:	f7ff f8a1 	bl	204300 <chMBPostTimeout.constprop.27>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  2051be:	fab0 f080 	clz	r0, r0
  2051c2:	493d      	ldr	r1, [pc, #244]	; (2052b8 <oslib_test_001_002_execute+0x4c8>)
  2051c4:	0940      	lsrs	r0, r0, #5
  2051c6:	f7fb fafb 	bl	2007c0 <_test_assert>
  2051ca:	2800      	cmp	r0, #0
  2051cc:	d15b      	bne.n	205286 <oslib_test_001_002_execute+0x496>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  2051ce:	f04f 31ff 	mov.w	r1, #4294967295
  2051d2:	a801      	add	r0, sp, #4
  2051d4:	f7ff f944 	bl	204460 <chMBFetchTimeout.constprop.21>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  2051d8:	fab0 f080 	clz	r0, r0
  2051dc:	4936      	ldr	r1, [pc, #216]	; (2052b8 <oslib_test_001_002_execute+0x4c8>)
  2051de:	0940      	lsrs	r0, r0, #5
  2051e0:	f7fb faee 	bl	2007c0 <_test_assert>
  2051e4:	2800      	cmp	r0, #0
  2051e6:	d14e      	bne.n	205286 <oslib_test_001_002_execute+0x496>
  test_set_step(7);
  2051e8:	2307      	movs	r3, #7
  2051ea:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  2051ec:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2051ee:	2520      	movs	r5, #32
  2051f0:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  2051f4:	b662      	cpsie	i
  _dbg_check_lock();
  2051f6:	f7fe fdab 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  2051fa:	f7fb fdc9 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  2051fe:	f7fb fdc7 	bl	200d90 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  205202:	6923      	ldr	r3, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
  205204:	e9d4 1200 	ldrd	r1, r2, [r4]
  205208:	1a52      	subs	r2, r2, r1
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  20520a:	492c      	ldr	r1, [pc, #176]	; (2052bc <oslib_test_001_002_execute+0x4cc>)
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  20520c:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
  205210:	1f1e      	subs	r6, r3, #4
  205212:	4270      	negs	r0, r6
  205214:	4170      	adcs	r0, r6
  205216:	f7fb fad3 	bl	2007c0 <_test_assert>
  20521a:	2800      	cmp	r0, #0
  20521c:	d144      	bne.n	2052a8 <oslib_test_001_002_execute+0x4b8>
  chSysUnlock();
  20521e:	f7fe fd57 	bl	203cd0 <chSysUnlock.lto_priv.111>
  __ASM volatile ("cpsid i" : : : "memory");
  205222:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205224:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  205228:	b662      	cpsie	i
  20522a:	f7fe fd91 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  20522e:	f7fb fdaf 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
  205232:	6920      	ldr	r0, [r4, #16]
  205234:	4922      	ldr	r1, [pc, #136]	; (2052c0 <oslib_test_001_002_execute+0x4d0>)
  205236:	fab0 f080 	clz	r0, r0
  20523a:	0940      	lsrs	r0, r0, #5
  20523c:	f7fb fac0 	bl	2007c0 <_test_assert>
  205240:	2800      	cmp	r0, #0
  205242:	d131      	bne.n	2052a8 <oslib_test_001_002_execute+0x4b8>
  205244:	f7fe fd44 	bl	203cd0 <chSysUnlock.lto_priv.111>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
  205248:	6820      	ldr	r0, [r4, #0]
  20524a:	68a3      	ldr	r3, [r4, #8]
  20524c:	491d      	ldr	r1, [pc, #116]	; (2052c4 <oslib_test_001_002_execute+0x4d4>)
  20524e:	1ac2      	subs	r2, r0, r3
  205250:	4250      	negs	r0, r2
  205252:	4150      	adcs	r0, r2
  205254:	f7fb fab4 	bl	2007c0 <_test_assert>
  205258:	b9a8      	cbnz	r0, 205286 <oslib_test_001_002_execute+0x496>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  20525a:	6820      	ldr	r0, [r4, #0]
  20525c:	68e3      	ldr	r3, [r4, #12]
  20525e:	491a      	ldr	r1, [pc, #104]	; (2052c8 <oslib_test_001_002_execute+0x4d8>)
  205260:	1ac3      	subs	r3, r0, r3
  205262:	4258      	negs	r0, r3
  205264:	4158      	adcs	r0, r3
  205266:	f7fb faab 	bl	2007c0 <_test_assert>
  20526a:	e00c      	b.n	205286 <oslib_test_001_002_execute+0x496>
  _dbg_check_unlock();
  20526c:	f7fe fd20 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205270:	682b      	ldr	r3, [r5, #0]
  205272:	42ab      	cmp	r3, r5
  205274:	d004      	beq.n	205280 <oslib_test_001_002_execute+0x490>
  205276:	69aa      	ldr	r2, [r5, #24]
  205278:	689b      	ldr	r3, [r3, #8]
  20527a:	6892      	ldr	r2, [r2, #8]
  20527c:	429a      	cmp	r2, r3
  20527e:	d310      	bcc.n	2052a2 <oslib_test_001_002_execute+0x4b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205280:	2300      	movs	r3, #0
  205282:	f383 8811 	msr	BASEPRI, r3
}
  205286:	b003      	add	sp, #12
  205288:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  _dbg_check_unlock();
  20528c:	f7fe fd10 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205290:	4b0e      	ldr	r3, [pc, #56]	; (2052cc <oslib_test_001_002_execute+0x4dc>)
  205292:	681a      	ldr	r2, [r3, #0]
  205294:	429a      	cmp	r2, r3
  205296:	d0f3      	beq.n	205280 <oslib_test_001_002_execute+0x490>
  205298:	6999      	ldr	r1, [r3, #24]
  20529a:	6893      	ldr	r3, [r2, #8]
  20529c:	688a      	ldr	r2, [r1, #8]
  20529e:	429a      	cmp	r2, r3
  2052a0:	d2ee      	bcs.n	205280 <oslib_test_001_002_execute+0x490>
  2052a2:	480b      	ldr	r0, [pc, #44]	; (2052d0 <oslib_test_001_002_execute+0x4e0>)
  2052a4:	f7fb fc64 	bl	200b70 <chSysHalt>
  2052a8:	f7fe fd12 	bl	203cd0 <chSysUnlock.lto_priv.111>
  2052ac:	e7eb      	b.n	205286 <oslib_test_001_002_execute+0x496>
  2052ae:	bf00      	nop
  2052b0:	0800c674 	.word	0x0800c674
  2052b4:	0800c688 	.word	0x0800c688
  2052b8:	0800c6a0 	.word	0x0800c6a0
  2052bc:	0800c5e4 	.word	0x0800c5e4
  2052c0:	0800c5f0 	.word	0x0800c5f0
  2052c4:	0800c5fc 	.word	0x0800c5fc
  2052c8:	0800c620 	.word	0x0800c620
  2052cc:	20000dc8 	.word	0x20000dc8
  2052d0:	0800bce8 	.word	0x0800bce8
	...

002052e0 <oslib_test_001_001_execute>:
static void oslib_test_001_001_execute(void) {
  2052e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  test_set_step(1);
  2052e2:	2301      	movs	r3, #1
  2052e4:	4ec3      	ldr	r6, [pc, #780]	; (2055f4 <oslib_test_001_001_execute+0x314>)
static void oslib_test_001_001_execute(void) {
  2052e6:	b083      	sub	sp, #12
  test_set_step(1);
  2052e8:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  2052ea:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2052ec:	2320      	movs	r3, #32
  2052ee:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2052f2:	b662      	cpsie	i
  return (size_t)(mbp->top - mbp->buffer);
  2052f4:	4cc0      	ldr	r4, [pc, #768]	; (2055f8 <oslib_test_001_001_execute+0x318>)
  _dbg_check_lock();
  2052f6:	f7fe fd2b 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  2052fa:	f7fb fd49 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  2052fe:	f7fb fd47 	bl	200d90 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  205302:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  205304:	49bd      	ldr	r1, [pc, #756]	; (2055fc <oslib_test_001_001_execute+0x31c>)
  return (size_t)(mbp->top - mbp->buffer);
  205306:	e9d4 2300 	ldrd	r2, r3, [r4]
  20530a:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  20530c:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
  205310:	f1a0 0004 	sub.w	r0, r0, #4
  205314:	fab0 f080 	clz	r0, r0
  205318:	0940      	lsrs	r0, r0, #5
  20531a:	f7fb fa51 	bl	2007c0 <_test_assert>
  20531e:	2800      	cmp	r0, #0
  205320:	f040 81d5 	bne.w	2056ce <oslib_test_001_001_execute+0x3ee>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205324:	4db6      	ldr	r5, [pc, #728]	; (205600 <oslib_test_001_001_execute+0x320>)
  _dbg_check_unlock();
  205326:	f7fe fcc3 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20532a:	682b      	ldr	r3, [r5, #0]
  20532c:	42ab      	cmp	r3, r5
  20532e:	d005      	beq.n	20533c <oslib_test_001_001_execute+0x5c>
  205330:	69aa      	ldr	r2, [r5, #24]
  205332:	689b      	ldr	r3, [r3, #8]
  205334:	6892      	ldr	r2, [r2, #8]
  205336:	429a      	cmp	r2, r3
  205338:	f0c0 81e3 	bcc.w	205702 <oslib_test_001_001_execute+0x422>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20533c:	2300      	movs	r3, #0
  20533e:	f383 8811 	msr	BASEPRI, r3
  test_set_step(2);
  205342:	2302      	movs	r3, #2
  205344:	6033      	str	r3, [r6, #0]
    chMBReset(&mb1);
  205346:	f7fe ff9b 	bl	204280 <chMBReset.constprop.29>
  __ASM volatile ("cpsid i" : : : "memory");
  20534a:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20534c:	2320      	movs	r3, #32
  20534e:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205352:	b662      	cpsie	i
  _dbg_check_lock();
  205354:	f7fe fcfc 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  205358:	f7fb fd1a 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  20535c:	f7fb fd18 	bl	200d90 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  205360:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  205362:	49a8      	ldr	r1, [pc, #672]	; (205604 <oslib_test_001_001_execute+0x324>)
  return (size_t)(mbp->top - mbp->buffer);
  205364:	e9d4 2300 	ldrd	r2, r3, [r4]
  205368:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  20536a:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
  20536e:	f1a0 0004 	sub.w	r0, r0, #4
  205372:	fab0 f080 	clz	r0, r0
  205376:	0940      	lsrs	r0, r0, #5
  205378:	f7fb fa22 	bl	2007c0 <_test_assert>
  20537c:	2800      	cmp	r0, #0
  20537e:	f040 81b6 	bne.w	2056ee <oslib_test_001_001_execute+0x40e>
  _dbg_check_unlock();
  205382:	f7fe fc95 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205386:	682b      	ldr	r3, [r5, #0]
  205388:	42ab      	cmp	r3, r5
  20538a:	d005      	beq.n	205398 <oslib_test_001_001_execute+0xb8>
  20538c:	69aa      	ldr	r2, [r5, #24]
  20538e:	689b      	ldr	r3, [r3, #8]
  205390:	6892      	ldr	r2, [r2, #8]
  205392:	429a      	cmp	r2, r3
  205394:	f0c0 81b5 	bcc.w	205702 <oslib_test_001_001_execute+0x422>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205398:	2300      	movs	r3, #0
  20539a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  20539e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2053a0:	2320      	movs	r3, #32
  2053a2:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2053a6:	b662      	cpsie	i
  _dbg_check_lock();
  2053a8:	f7fe fcd2 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  2053ac:	f7fb fcf0 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
  2053b0:	6920      	ldr	r0, [r4, #16]
  2053b2:	4995      	ldr	r1, [pc, #596]	; (205608 <oslib_test_001_001_execute+0x328>)
  2053b4:	fab0 f080 	clz	r0, r0
  2053b8:	0940      	lsrs	r0, r0, #5
  2053ba:	f7fb fa01 	bl	2007c0 <_test_assert>
  2053be:	2800      	cmp	r0, #0
  2053c0:	f040 8195 	bne.w	2056ee <oslib_test_001_001_execute+0x40e>
  _dbg_check_unlock();
  2053c4:	f7fe fc74 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2053c8:	682b      	ldr	r3, [r5, #0]
  2053ca:	42ab      	cmp	r3, r5
  2053cc:	d005      	beq.n	2053da <oslib_test_001_001_execute+0xfa>
  2053ce:	69aa      	ldr	r2, [r5, #24]
  2053d0:	689b      	ldr	r3, [r3, #8]
  2053d2:	6892      	ldr	r2, [r2, #8]
  2053d4:	429a      	cmp	r2, r3
  2053d6:	f0c0 8194 	bcc.w	205702 <oslib_test_001_001_execute+0x422>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2053da:	2300      	movs	r3, #0
  2053dc:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  2053e0:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2053e2:	2320      	movs	r3, #32
  2053e4:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2053e8:	b662      	cpsie	i
  _dbg_check_lock();
  2053ea:	f7fe fcb1 	bl	203d50 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
  2053ee:	6820      	ldr	r0, [r4, #0]
  2053f0:	68a3      	ldr	r3, [r4, #8]
  2053f2:	4986      	ldr	r1, [pc, #536]	; (20560c <oslib_test_001_001_execute+0x32c>)
  2053f4:	1ac0      	subs	r0, r0, r3
  2053f6:	fab0 f080 	clz	r0, r0
  2053fa:	0940      	lsrs	r0, r0, #5
  2053fc:	f7fb f9e0 	bl	2007c0 <_test_assert>
  205400:	2800      	cmp	r0, #0
  205402:	f040 8174 	bne.w	2056ee <oslib_test_001_001_execute+0x40e>
  _dbg_check_unlock();
  205406:	f7fe fc53 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20540a:	682b      	ldr	r3, [r5, #0]
  20540c:	42ab      	cmp	r3, r5
  20540e:	d005      	beq.n	20541c <oslib_test_001_001_execute+0x13c>
  205410:	69aa      	ldr	r2, [r5, #24]
  205412:	689b      	ldr	r3, [r3, #8]
  205414:	6892      	ldr	r2, [r2, #8]
  205416:	429a      	cmp	r2, r3
  205418:	f0c0 8173 	bcc.w	205702 <oslib_test_001_001_execute+0x422>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20541c:	2300      	movs	r3, #0
  20541e:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  205422:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205424:	2320      	movs	r3, #32
  205426:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20542a:	b662      	cpsie	i
  _dbg_check_lock();
  20542c:	f7fe fc90 	bl	203d50 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  205430:	6820      	ldr	r0, [r4, #0]
  205432:	68e3      	ldr	r3, [r4, #12]
  205434:	4976      	ldr	r1, [pc, #472]	; (205610 <oslib_test_001_001_execute+0x330>)
  205436:	1ac0      	subs	r0, r0, r3
  205438:	fab0 f080 	clz	r0, r0
  20543c:	0940      	lsrs	r0, r0, #5
  20543e:	f7fb f9bf 	bl	2007c0 <_test_assert>
  205442:	2800      	cmp	r0, #0
  205444:	f040 8153 	bne.w	2056ee <oslib_test_001_001_execute+0x40e>
  _dbg_check_unlock();
  205448:	f7fe fc32 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20544c:	682b      	ldr	r3, [r5, #0]
  20544e:	42ab      	cmp	r3, r5
  205450:	d005      	beq.n	20545e <oslib_test_001_001_execute+0x17e>
  205452:	69aa      	ldr	r2, [r5, #24]
  205454:	689b      	ldr	r3, [r3, #8]
  205456:	6892      	ldr	r2, [r2, #8]
  205458:	429a      	cmp	r2, r3
  20545a:	f0c0 8152 	bcc.w	205702 <oslib_test_001_001_execute+0x422>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20545e:	2000      	movs	r0, #0
  205460:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
  205464:	2303      	movs	r3, #3
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
  205466:	f04f 31ff 	mov.w	r1, #4294967295
  test_set_step(3);
  20546a:	6033      	str	r3, [r6, #0]
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
  20546c:	f7fe ff48 	bl	204300 <chMBPostTimeout.constprop.27>
    test_assert(msg1 == MSG_RESET, "not in reset state");
  205470:	1c85      	adds	r5, r0, #2
  205472:	4968      	ldr	r1, [pc, #416]	; (205614 <oslib_test_001_001_execute+0x334>)
  205474:	bf14      	ite	ne
  205476:	2000      	movne	r0, #0
  205478:	2001      	moveq	r0, #1
  20547a:	f7fb f9a1 	bl	2007c0 <_test_assert>
  20547e:	2800      	cmp	r0, #0
  205480:	f040 8133 	bne.w	2056ea <oslib_test_001_001_execute+0x40a>
    msg1 = chMBPostAheadTimeout(&mb1, (msg_t)0, TIME_INFINITE);
  205484:	f04f 31ff 	mov.w	r1, #4294967295
  205488:	f7fe ff92 	bl	2043b0 <chMBPostAheadTimeout.constprop.24>
    test_assert(msg1 == MSG_RESET, "not in reset state");
  20548c:	1c82      	adds	r2, r0, #2
  20548e:	4961      	ldr	r1, [pc, #388]	; (205614 <oslib_test_001_001_execute+0x334>)
  205490:	bf14      	ite	ne
  205492:	2000      	movne	r0, #0
  205494:	2001      	moveq	r0, #1
  205496:	f7fb f993 	bl	2007c0 <_test_assert>
  20549a:	2800      	cmp	r0, #0
  20549c:	f040 8125 	bne.w	2056ea <oslib_test_001_001_execute+0x40a>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  2054a0:	f04f 31ff 	mov.w	r1, #4294967295
  2054a4:	a801      	add	r0, sp, #4
  2054a6:	f7fe ffdb 	bl	204460 <chMBFetchTimeout.constprop.21>
    test_assert(msg1 == MSG_RESET, "not in reset state");
  2054aa:	1c83      	adds	r3, r0, #2
  2054ac:	4959      	ldr	r1, [pc, #356]	; (205614 <oslib_test_001_001_execute+0x334>)
  2054ae:	bf14      	ite	ne
  2054b0:	2000      	movne	r0, #0
  2054b2:	2001      	moveq	r0, #1
  2054b4:	f7fb f984 	bl	2007c0 <_test_assert>
  2054b8:	2800      	cmp	r0, #0
  2054ba:	f040 8116 	bne.w	2056ea <oslib_test_001_001_execute+0x40a>
  test_set_step(4);
  2054be:	2304      	movs	r3, #4
  2054c0:	2542      	movs	r5, #66	; 0x42
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  2054c2:	4f55      	ldr	r7, [pc, #340]	; (205618 <oslib_test_001_001_execute+0x338>)
  mbp->reset = false;
  2054c4:	7520      	strb	r0, [r4, #20]
  test_set_step(4);
  2054c6:	6033      	str	r3, [r6, #0]
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  2054c8:	f04f 31ff 	mov.w	r1, #4294967295
  2054cc:	4628      	mov	r0, r5
  2054ce:	f7fe ff17 	bl	204300 <chMBPostTimeout.constprop.27>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  2054d2:	fab0 f080 	clz	r0, r0
  2054d6:	4639      	mov	r1, r7
  2054d8:	0940      	lsrs	r0, r0, #5
  2054da:	f7fb f971 	bl	2007c0 <_test_assert>
  2054de:	2800      	cmp	r0, #0
  2054e0:	f040 8103 	bne.w	2056ea <oslib_test_001_001_execute+0x40a>
  2054e4:	3501      	adds	r5, #1
    for (i = 0; i < MB_SIZE - 1; i++) {
  2054e6:	2d45      	cmp	r5, #69	; 0x45
  2054e8:	d1ee      	bne.n	2054c8 <oslib_test_001_001_execute+0x1e8>
    msg1 = chMBPostAheadTimeout(&mb1, 'A', TIME_INFINITE);
  2054ea:	f04f 31ff 	mov.w	r1, #4294967295
  2054ee:	2041      	movs	r0, #65	; 0x41
  2054f0:	f7fe ff5e 	bl	2043b0 <chMBPostAheadTimeout.constprop.24>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  2054f4:	fab0 f080 	clz	r0, r0
  2054f8:	4947      	ldr	r1, [pc, #284]	; (205618 <oslib_test_001_001_execute+0x338>)
  2054fa:	0940      	lsrs	r0, r0, #5
  2054fc:	f7fb f960 	bl	2007c0 <_test_assert>
  205500:	2800      	cmp	r0, #0
  205502:	f040 80f2 	bne.w	2056ea <oslib_test_001_001_execute+0x40a>
  test_set_step(5);
  205506:	2305      	movs	r3, #5
  205508:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20550a:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20550c:	2520      	movs	r5, #32
  20550e:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  205512:	b662      	cpsie	i
  _dbg_check_lock();
  205514:	f7fe fc1c 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  205518:	f7fb fc3a 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  20551c:	f7fb fc38 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
  205520:	6922      	ldr	r2, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
  205522:	e9d4 1300 	ldrd	r1, r3, [r4]
  205526:	1a5b      	subs	r3, r3, r1
  205528:	493c      	ldr	r1, [pc, #240]	; (20561c <oslib_test_001_001_execute+0x33c>)
  20552a:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
  20552e:	bf0c      	ite	eq
  205530:	2001      	moveq	r0, #1
  205532:	2000      	movne	r0, #0
  205534:	f7fb f944 	bl	2007c0 <_test_assert>
  205538:	2800      	cmp	r0, #0
  20553a:	f040 80e5 	bne.w	205708 <oslib_test_001_001_execute+0x428>
  20553e:	f7fe fbc7 	bl	203cd0 <chSysUnlock.lto_priv.111>
  __ASM volatile ("cpsid i" : : : "memory");
  205542:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205544:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  205548:	b662      	cpsie	i
  20554a:	f7fe fc01 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  20554e:	f7fb fc1f 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
  205552:	6920      	ldr	r0, [r4, #16]
  205554:	4932      	ldr	r1, [pc, #200]	; (205620 <oslib_test_001_001_execute+0x340>)
  205556:	f1a0 0c04 	sub.w	ip, r0, #4
  20555a:	f1dc 0000 	rsbs	r0, ip, #0
  20555e:	eb40 000c 	adc.w	r0, r0, ip
  205562:	f7fb f92d 	bl	2007c0 <_test_assert>
  205566:	2800      	cmp	r0, #0
  205568:	f040 80ce 	bne.w	205708 <oslib_test_001_001_execute+0x428>
  20556c:	f7fe fbb0 	bl	203cd0 <chSysUnlock.lto_priv.111>
  __ASM volatile ("cpsid i" : : : "memory");
  205570:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205572:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  205576:	b662      	cpsie	i
  205578:	f7fe fbea 	bl	203d50 <_dbg_check_lock>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
  20557c:	4929      	ldr	r1, [pc, #164]	; (205624 <oslib_test_001_001_execute+0x344>)
  20557e:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
  205582:	1ac7      	subs	r7, r0, r3
  205584:	4278      	negs	r0, r7
  205586:	4178      	adcs	r0, r7
  205588:	f7fb f91a 	bl	2007c0 <_test_assert>
  20558c:	2800      	cmp	r0, #0
  20558e:	f040 80bb 	bne.w	205708 <oslib_test_001_001_execute+0x428>
  205592:	f7fe fb9d 	bl	203cd0 <chSysUnlock.lto_priv.111>
  test_set_step(6);
  205596:	2504      	movs	r5, #4
  205598:	2306      	movs	r3, #6
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20559a:	4f1f      	ldr	r7, [pc, #124]	; (205618 <oslib_test_001_001_execute+0x338>)
  test_set_step(6);
  20559c:	6033      	str	r3, [r6, #0]
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  20559e:	f04f 31ff 	mov.w	r1, #4294967295
  2055a2:	a801      	add	r0, sp, #4
  2055a4:	f7fe ff5c 	bl	204460 <chMBFetchTimeout.constprop.21>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
  2055a8:	fab0 f080 	clz	r0, r0
  2055ac:	4639      	mov	r1, r7
  2055ae:	0940      	lsrs	r0, r0, #5
  2055b0:	f7fb f906 	bl	2007c0 <_test_assert>
  2055b4:	2800      	cmp	r0, #0
  2055b6:	f040 8098 	bne.w	2056ea <oslib_test_001_001_execute+0x40a>
      test_emit_token(msg2);
  2055ba:	f89d 0004 	ldrb.w	r0, [sp, #4]
  2055be:	f7ff fbe7 	bl	204d90 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
  2055c2:	3d01      	subs	r5, #1
  2055c4:	d1eb      	bne.n	20559e <oslib_test_001_001_execute+0x2be>
    test_assert_sequence("ABCD", "wrong get sequence");
  2055c6:	4918      	ldr	r1, [pc, #96]	; (205628 <oslib_test_001_001_execute+0x348>)
  2055c8:	4818      	ldr	r0, [pc, #96]	; (20562c <oslib_test_001_001_execute+0x34c>)
  2055ca:	f7fb f999 	bl	200900 <_test_assert_sequence>
  2055ce:	2800      	cmp	r0, #0
  2055d0:	f040 808b 	bne.w	2056ea <oslib_test_001_001_execute+0x40a>
  test_set_step(7);
  2055d4:	2307      	movs	r3, #7
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  2055d6:	f04f 31ff 	mov.w	r1, #4294967295
  2055da:	2046      	movs	r0, #70	; 0x46
  test_set_step(7);
  2055dc:	6033      	str	r3, [r6, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  2055de:	f7fe fe8f 	bl	204300 <chMBPostTimeout.constprop.27>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  2055e2:	fab0 f080 	clz	r0, r0
  2055e6:	490c      	ldr	r1, [pc, #48]	; (205618 <oslib_test_001_001_execute+0x338>)
  2055e8:	0940      	lsrs	r0, r0, #5
  2055ea:	f7fb f8e9 	bl	2007c0 <_test_assert>
  2055ee:	2800      	cmp	r0, #0
  2055f0:	d17b      	bne.n	2056ea <oslib_test_001_001_execute+0x40a>
  2055f2:	e01d      	b.n	205630 <oslib_test_001_001_execute+0x350>
  2055f4:	20001f6c 	.word	0x20001f6c
  2055f8:	20010458 	.word	0x20010458
  2055fc:	0800c5d8 	.word	0x0800c5d8
  205600:	20000dc8 	.word	0x20000dc8
  205604:	0800c5e4 	.word	0x0800c5e4
  205608:	0800c5f0 	.word	0x0800c5f0
  20560c:	0800c5fc 	.word	0x0800c5fc
  205610:	0800c620 	.word	0x0800c620
  205614:	0800c5b4 	.word	0x0800c5b4
  205618:	0800c6a0 	.word	0x0800c6a0
  20561c:	0800c644 	.word	0x0800c644
  205620:	0800c650 	.word	0x0800c650
  205624:	0800c65c 	.word	0x0800c65c
  205628:	0800c674 	.word	0x0800c674
  20562c:	0800c688 	.word	0x0800c688
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  205630:	f04f 31ff 	mov.w	r1, #4294967295
  205634:	a801      	add	r0, sp, #4
  205636:	f7fe ff13 	bl	204460 <chMBFetchTimeout.constprop.21>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
  20563a:	fab0 f080 	clz	r0, r0
  20563e:	4934      	ldr	r1, [pc, #208]	; (205710 <oslib_test_001_001_execute+0x430>)
  205640:	0940      	lsrs	r0, r0, #5
  205642:	f7fb f8bd 	bl	2007c0 <_test_assert>
  205646:	2800      	cmp	r0, #0
  205648:	d14f      	bne.n	2056ea <oslib_test_001_001_execute+0x40a>
  test_set_step(8);
  20564a:	2308      	movs	r3, #8
  20564c:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20564e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205650:	2520      	movs	r5, #32
  205652:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  205656:	b662      	cpsie	i
  205658:	f7fe fb7a 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  20565c:	f7fb fb98 	bl	200d90 <chDbgCheckClassI>
  chDbgCheckClassI();
  205660:	f7fb fb96 	bl	200d90 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  205664:	6923      	ldr	r3, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
  205666:	e9d4 1200 	ldrd	r1, r2, [r4]
  20566a:	1a52      	subs	r2, r2, r1
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  20566c:	4929      	ldr	r1, [pc, #164]	; (205714 <oslib_test_001_001_execute+0x434>)
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
  20566e:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
  205672:	1f1e      	subs	r6, r3, #4
  205674:	4270      	negs	r0, r6
  205676:	4170      	adcs	r0, r6
  205678:	f7fb f8a2 	bl	2007c0 <_test_assert>
  20567c:	2800      	cmp	r0, #0
  20567e:	d143      	bne.n	205708 <oslib_test_001_001_execute+0x428>
  205680:	f7fe fb26 	bl	203cd0 <chSysUnlock.lto_priv.111>
  __ASM volatile ("cpsid i" : : : "memory");
  205684:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205686:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  20568a:	b662      	cpsie	i
  20568c:	f7fe fb60 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  205690:	f7fb fb7e 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
  205694:	6920      	ldr	r0, [r4, #16]
  205696:	4920      	ldr	r1, [pc, #128]	; (205718 <oslib_test_001_001_execute+0x438>)
  205698:	fab0 f080 	clz	r0, r0
  20569c:	0940      	lsrs	r0, r0, #5
  20569e:	f7fb f88f 	bl	2007c0 <_test_assert>
  2056a2:	2800      	cmp	r0, #0
  2056a4:	d130      	bne.n	205708 <oslib_test_001_001_execute+0x428>
  2056a6:	f7fe fb13 	bl	203cd0 <chSysUnlock.lto_priv.111>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
  2056aa:	6820      	ldr	r0, [r4, #0]
  2056ac:	68a3      	ldr	r3, [r4, #8]
  2056ae:	491b      	ldr	r1, [pc, #108]	; (20571c <oslib_test_001_001_execute+0x43c>)
  2056b0:	1ac2      	subs	r2, r0, r3
  2056b2:	4250      	negs	r0, r2
  2056b4:	4150      	adcs	r0, r2
  2056b6:	f7fb f883 	bl	2007c0 <_test_assert>
  2056ba:	b9b0      	cbnz	r0, 2056ea <oslib_test_001_001_execute+0x40a>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  2056bc:	6820      	ldr	r0, [r4, #0]
  2056be:	68e3      	ldr	r3, [r4, #12]
  2056c0:	4917      	ldr	r1, [pc, #92]	; (205720 <oslib_test_001_001_execute+0x440>)
  2056c2:	1ac3      	subs	r3, r0, r3
  2056c4:	4258      	negs	r0, r3
  2056c6:	4158      	adcs	r0, r3
  2056c8:	f7fb f87a 	bl	2007c0 <_test_assert>
  2056cc:	e00d      	b.n	2056ea <oslib_test_001_001_execute+0x40a>
  _dbg_check_unlock();
  2056ce:	f7fe faef 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2056d2:	4b14      	ldr	r3, [pc, #80]	; (205724 <oslib_test_001_001_execute+0x444>)
  2056d4:	681a      	ldr	r2, [r3, #0]
  2056d6:	429a      	cmp	r2, r3
  2056d8:	d004      	beq.n	2056e4 <oslib_test_001_001_execute+0x404>
  2056da:	6999      	ldr	r1, [r3, #24]
  2056dc:	6893      	ldr	r3, [r2, #8]
  2056de:	688a      	ldr	r2, [r1, #8]
  2056e0:	429a      	cmp	r2, r3
  2056e2:	d30e      	bcc.n	205702 <oslib_test_001_001_execute+0x422>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2056e4:	2300      	movs	r3, #0
  2056e6:	f383 8811 	msr	BASEPRI, r3
}
  2056ea:	b003      	add	sp, #12
  2056ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
  _dbg_check_unlock();
  2056ee:	f7fe fadf 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2056f2:	682b      	ldr	r3, [r5, #0]
  2056f4:	42ab      	cmp	r3, r5
  2056f6:	d0f5      	beq.n	2056e4 <oslib_test_001_001_execute+0x404>
  2056f8:	69aa      	ldr	r2, [r5, #24]
  2056fa:	689b      	ldr	r3, [r3, #8]
  2056fc:	6892      	ldr	r2, [r2, #8]
  2056fe:	429a      	cmp	r2, r3
  205700:	d2f0      	bcs.n	2056e4 <oslib_test_001_001_execute+0x404>
  205702:	4809      	ldr	r0, [pc, #36]	; (205728 <oslib_test_001_001_execute+0x448>)
  205704:	f7fb fa34 	bl	200b70 <chSysHalt>
  205708:	f7fe fae2 	bl	203cd0 <chSysUnlock.lto_priv.111>
  20570c:	e7ed      	b.n	2056ea <oslib_test_001_001_execute+0x40a>
  20570e:	bf00      	nop
  205710:	0800c6a0 	.word	0x0800c6a0
  205714:	0800c5e4 	.word	0x0800c5e4
  205718:	0800c5f0 	.word	0x0800c5f0
  20571c:	0800c5fc 	.word	0x0800c5fc
  205720:	0800c620 	.word	0x0800c620
  205724:	20000dc8 	.word	0x20000dc8
  205728:	0800bce8 	.word	0x0800bce8
  20572c:	00000000 	.word	0x00000000

00205730 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
  205730:	2043      	movs	r0, #67	; 0x43
  205732:	f7ff bb2d 	b.w	204d90 <test_emit_token>
  205736:	bf00      	nop
	...

00205740 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
  205740:	2042      	movs	r0, #66	; 0x42
  205742:	f7ff bb25 	b.w	204d90 <test_emit_token>
  205746:	bf00      	nop
	...

00205750 <h1>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
  205750:	2041      	movs	r0, #65	; 0x41
  205752:	f7ff bb1d 	b.w	204d90 <test_emit_token>
  205756:	bf00      	nop
	...

00205760 <thread1.lto_priv.169>:
static THD_FUNCTION(thread1, p) {
  205760:	b510      	push	{r4, lr}
  205762:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  205764:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205766:	2320      	movs	r3, #32
  205768:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20576c:	b662      	cpsie	i
  _dbg_check_lock();
  20576e:	f7fe faef 	bl	203d50 <_dbg_check_lock>
  if (*trp != NULL) {
  205772:	4a14      	ldr	r2, [pc, #80]	; (2057c4 <thread1.lto_priv.169+0x64>)
  205774:	6813      	ldr	r3, [r2, #0]
  205776:	b14b      	cbz	r3, 20578c <thread1.lto_priv.169+0x2c>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
  205778:	f893 1020 	ldrb.w	r1, [r3, #32]
  20577c:	2903      	cmp	r1, #3
  20577e:	d11a      	bne.n	2057b6 <thread1.lto_priv.169+0x56>
    *trp = NULL;
  205780:	2100      	movs	r1, #0
    (void) chSchReadyI(tp);
  205782:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
  205784:	6259      	str	r1, [r3, #36]	; 0x24
    *trp = NULL;
  205786:	6011      	str	r1, [r2, #0]
    (void) chSchReadyI(tp);
  205788:	f7fb fbb2 	bl	200ef0 <chSchReadyI>
  chSchRescheduleS();
  20578c:	f7fe fa78 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  205790:	f7fe fa8e 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205794:	4b0c      	ldr	r3, [pc, #48]	; (2057c8 <thread1.lto_priv.169+0x68>)
  205796:	681a      	ldr	r2, [r3, #0]
  205798:	429a      	cmp	r2, r3
  20579a:	d004      	beq.n	2057a6 <thread1.lto_priv.169+0x46>
  20579c:	6999      	ldr	r1, [r3, #24]
  20579e:	6893      	ldr	r3, [r2, #8]
  2057a0:	688a      	ldr	r2, [r1, #8]
  2057a2:	429a      	cmp	r2, r3
  2057a4:	d30a      	bcc.n	2057bc <thread1.lto_priv.169+0x5c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2057a6:	2300      	movs	r3, #0
  2057a8:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
  2057ac:	7820      	ldrb	r0, [r4, #0]
}
  2057ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
  2057b2:	f7ff baed 	b.w	204d90 <test_emit_token>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
  2057b6:	4805      	ldr	r0, [pc, #20]	; (2057cc <thread1.lto_priv.169+0x6c>)
  2057b8:	f7fb f9da 	bl	200b70 <chSysHalt>
  2057bc:	4804      	ldr	r0, [pc, #16]	; (2057d0 <thread1.lto_priv.169+0x70>)
  2057be:	f7fb f9d7 	bl	200b70 <chSysHalt>
  2057c2:	bf00      	nop
  2057c4:	20001f98 	.word	0x20001f98
  2057c8:	20000dc8 	.word	0x20000dc8
  2057cc:	0800bf94 	.word	0x0800bf94
  2057d0:	0800bcac 	.word	0x0800bcac
	...

002057e0 <thread>:
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
  2057e0:	7800      	ldrb	r0, [r0, #0]
  2057e2:	f7ff bad5 	b.w	204d90 <test_emit_token>
  2057e6:	bf00      	nop
	...

002057f0 <dyn_thread1>:
  2057f0:	f7ff bff6 	b.w	2057e0 <thread>
	...

00205800 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
  205800:	2900      	cmp	r1, #0
  205802:	dd03      	ble.n	20580c <cmd_systime+0xc>
    shellUsage(chp, "systime");
  205804:	4a13      	ldr	r2, [pc, #76]	; (205854 <cmd_systime+0x54>)
  205806:	4914      	ldr	r1, [pc, #80]	; (205858 <cmd_systime+0x58>)
  205808:	f7fd bb42 	b.w	202e90 <chprintf>
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
  20580c:	b538      	push	{r3, r4, r5, lr}
  20580e:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  205810:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205812:	2320      	movs	r3, #32
  205814:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205818:	b662      	cpsie	i
  _dbg_check_lock();
  20581a:	f7fe fa99 	bl	203d50 <_dbg_check_lock>
  return (systime_t)STM32_ST_TIM->CNT;
  20581e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  205822:	6a5d      	ldr	r5, [r3, #36]	; 0x24
  _dbg_check_unlock();
  205824:	f7fe fa44 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205828:	4b0c      	ldr	r3, [pc, #48]	; (20585c <cmd_systime+0x5c>)
  20582a:	6819      	ldr	r1, [r3, #0]
  20582c:	4299      	cmp	r1, r3
  20582e:	d004      	beq.n	20583a <cmd_systime+0x3a>
  205830:	699a      	ldr	r2, [r3, #24]
  205832:	688b      	ldr	r3, [r1, #8]
  205834:	6892      	ldr	r2, [r2, #8]
  205836:	429a      	cmp	r2, r3
  205838:	d309      	bcc.n	20584e <cmd_systime+0x4e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20583a:	2300      	movs	r3, #0
  20583c:	f383 8811 	msr	BASEPRI, r3
    return;
  }
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
  205840:	4907      	ldr	r1, [pc, #28]	; (205860 <cmd_systime+0x60>)
  205842:	462a      	mov	r2, r5
  205844:	4620      	mov	r0, r4
}
  205846:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
  20584a:	f7fd bb21 	b.w	202e90 <chprintf>
  20584e:	4805      	ldr	r0, [pc, #20]	; (205864 <cmd_systime+0x64>)
  205850:	f7fb f98e 	bl	200b70 <chSysHalt>
  205854:	0800c424 	.word	0x0800c424
  205858:	0800c270 	.word	0x0800c270
  20585c:	20000dc8 	.word	0x20000dc8
  205860:	0800c42c 	.word	0x0800c42c
  205864:	0800bd38 	.word	0x0800bd38
	...

00205870 <chGuardedPoolFree>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {
  205870:	b538      	push	{r3, r4, r5, lr}
  205872:	4604      	mov	r4, r0
  205874:	460d      	mov	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
  205876:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205878:	2320      	movs	r3, #32
  20587a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20587e:	b662      	cpsie	i
  _dbg_check_lock();
  205880:	f7fe fa66 	bl	203d50 <_dbg_check_lock>
  chPoolFreeI(&gmp->pool, objp);
  205884:	4629      	mov	r1, r5
  205886:	f104 000c 	add.w	r0, r4, #12
  20588a:	f7fb fa91 	bl	200db0 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
  20588e:	4620      	mov	r0, r4
  205890:	f7fb fc4e 	bl	201130 <chSemSignalI>

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
  205894:	f7fe f9f4 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  205898:	f7fe fa0a 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20589c:	4b07      	ldr	r3, [pc, #28]	; (2058bc <chGuardedPoolFree+0x4c>)
  20589e:	681a      	ldr	r2, [r3, #0]
  2058a0:	429a      	cmp	r2, r3
  2058a2:	d004      	beq.n	2058ae <chGuardedPoolFree+0x3e>
  2058a4:	6999      	ldr	r1, [r3, #24]
  2058a6:	6893      	ldr	r3, [r2, #8]
  2058a8:	688a      	ldr	r2, [r1, #8]
  2058aa:	429a      	cmp	r2, r3
  2058ac:	d303      	bcc.n	2058b6 <chGuardedPoolFree+0x46>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2058ae:	2300      	movs	r3, #0
  2058b0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
  2058b4:	bd38      	pop	{r3, r4, r5, pc}
  2058b6:	4802      	ldr	r0, [pc, #8]	; (2058c0 <chGuardedPoolFree+0x50>)
  2058b8:	f7fb f95a 	bl	200b70 <chSysHalt>
  2058bc:	20000dc8 	.word	0x20000dc8
  2058c0:	0800bc70 	.word	0x0800bc70
	...

002058d0 <oslib_test_002_002_execute>:
static void oslib_test_002_002_execute(void) {
  2058d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  2058d4:	4e30      	ldr	r6, [pc, #192]	; (205998 <oslib_test_002_002_execute+0xc8>)
  test_set_step(1);
  2058d6:	2301      	movs	r3, #1
  2058d8:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 2059b4 <oslib_test_002_002_execute+0xe4>
  2058dc:	2504      	movs	r5, #4
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {

  chGuardedPoolFree(gmp, objp);
  2058de:	4637      	mov	r7, r6
  2058e0:	4c2e      	ldr	r4, [pc, #184]	; (20599c <oslib_test_002_002_execute+0xcc>)
  2058e2:	f8c8 3000 	str.w	r3, [r8]
  2058e6:	4621      	mov	r1, r4
  2058e8:	4638      	mov	r0, r7
  2058ea:	f7ff ffc1 	bl	205870 <chGuardedPoolFree>
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
  2058ee:	6933      	ldr	r3, [r6, #16]
  while (n != 0U) {
  2058f0:	3d01      	subs	r5, #1
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
  2058f2:	441c      	add	r4, r3
  while (n != 0U) {
  2058f4:	d1f7      	bne.n	2058e6 <oslib_test_002_002_execute+0x16>
  test_set_step(2);
  2058f6:	2302      	movs	r3, #2
  2058f8:	2404      	movs	r4, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  2058fa:	4d29      	ldr	r5, [pc, #164]	; (2059a0 <oslib_test_002_002_execute+0xd0>)
  test_set_step(2);
  2058fc:	f8c8 3000 	str.w	r3, [r8]
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  205900:	2000      	movs	r0, #0
  205902:	f7fe fe05 	bl	204510 <chGuardedPoolAllocTimeout.constprop.16>
  205906:	3000      	adds	r0, #0
  205908:	4629      	mov	r1, r5
  20590a:	bf18      	it	ne
  20590c:	2001      	movne	r0, #1
  20590e:	f7fa ff57 	bl	2007c0 <_test_assert>
  205912:	2800      	cmp	r0, #0
  205914:	d13d      	bne.n	205992 <oslib_test_002_002_execute+0xc2>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  205916:	3c01      	subs	r4, #1
  205918:	d1f2      	bne.n	205900 <oslib_test_002_002_execute+0x30>
  test_set_step(3);
  20591a:	2303      	movs	r3, #3
  20591c:	f8c8 3000 	str.w	r3, [r8]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
  205920:	f7fe fdf6 	bl	204510 <chGuardedPoolAllocTimeout.constprop.16>
  205924:	fab0 f080 	clz	r0, r0
  205928:	491e      	ldr	r1, [pc, #120]	; (2059a4 <oslib_test_002_002_execute+0xd4>)
  20592a:	0940      	lsrs	r0, r0, #5
  20592c:	f7fa ff48 	bl	2007c0 <_test_assert>
  205930:	bb78      	cbnz	r0, 205992 <oslib_test_002_002_execute+0xc2>
  test_set_step(4);
  205932:	2404      	movs	r4, #4
      chGuardedPoolFree(&gmp1, &objects[i]);
  205934:	4919      	ldr	r1, [pc, #100]	; (20599c <oslib_test_002_002_execute+0xcc>)
  205936:	4818      	ldr	r0, [pc, #96]	; (205998 <oslib_test_002_002_execute+0xc8>)
  test_set_step(4);
  205938:	f8c8 4000 	str.w	r4, [r8]
      chGuardedPoolFree(&gmp1, &objects[i]);
  20593c:	f7ff ff98 	bl	205870 <chGuardedPoolFree>
  205940:	4919      	ldr	r1, [pc, #100]	; (2059a8 <oslib_test_002_002_execute+0xd8>)
  205942:	4815      	ldr	r0, [pc, #84]	; (205998 <oslib_test_002_002_execute+0xc8>)
  205944:	f7ff ff94 	bl	205870 <chGuardedPoolFree>
  205948:	4918      	ldr	r1, [pc, #96]	; (2059ac <oslib_test_002_002_execute+0xdc>)
  20594a:	4813      	ldr	r0, [pc, #76]	; (205998 <oslib_test_002_002_execute+0xc8>)
  20594c:	f7ff ff90 	bl	205870 <chGuardedPoolFree>
  205950:	4917      	ldr	r1, [pc, #92]	; (2059b0 <oslib_test_002_002_execute+0xe0>)
  205952:	4811      	ldr	r0, [pc, #68]	; (205998 <oslib_test_002_002_execute+0xc8>)
  205954:	f7ff ff8c 	bl	205870 <chGuardedPoolFree>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  205958:	4d11      	ldr	r5, [pc, #68]	; (2059a0 <oslib_test_002_002_execute+0xd0>)
  test_set_step(5);
  20595a:	2305      	movs	r3, #5
  20595c:	f8c8 3000 	str.w	r3, [r8]
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  205960:	2000      	movs	r0, #0
  205962:	f7fe fdd5 	bl	204510 <chGuardedPoolAllocTimeout.constprop.16>
  205966:	3000      	adds	r0, #0
  205968:	4629      	mov	r1, r5
  20596a:	bf18      	it	ne
  20596c:	2001      	movne	r0, #1
  20596e:	f7fa ff27 	bl	2007c0 <_test_assert>
  205972:	b970      	cbnz	r0, 205992 <oslib_test_002_002_execute+0xc2>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  205974:	3c01      	subs	r4, #1
  205976:	d1f3      	bne.n	205960 <oslib_test_002_002_execute+0x90>
  test_set_step(6);
  205978:	2306      	movs	r3, #6
  20597a:	f8c8 3000 	str.w	r3, [r8]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
  20597e:	f7fe fdc7 	bl	204510 <chGuardedPoolAllocTimeout.constprop.16>
  205982:	fab0 f080 	clz	r0, r0
  205986:	4907      	ldr	r1, [pc, #28]	; (2059a4 <oslib_test_002_002_execute+0xd4>)
  205988:	0940      	lsrs	r0, r0, #5
}
  20598a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
  20598e:	f7fa bf17 	b.w	2007c0 <_test_assert>
}
  205992:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  205996:	bf00      	nop
  205998:	20010414 	.word	0x20010414
  20599c:	20001828 	.word	0x20001828
  2059a0:	0800c6f4 	.word	0x0800c6f4
  2059a4:	0800c710 	.word	0x0800c710
  2059a8:	2000182c 	.word	0x2000182c
  2059ac:	20001830 	.word	0x20001830
  2059b0:	20001834 	.word	0x20001834
  2059b4:	20001f6c 	.word	0x20001f6c
	...

002059c0 <chPoolFree>:
void chPoolFree(memory_pool_t *mp, void *objp) {
  2059c0:	b538      	push	{r3, r4, r5, lr}
  2059c2:	4604      	mov	r4, r0
  2059c4:	460d      	mov	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
  2059c6:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2059c8:	2320      	movs	r3, #32
  2059ca:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2059ce:	b662      	cpsie	i
  _dbg_check_lock();
  2059d0:	f7fe f9be 	bl	203d50 <_dbg_check_lock>
  chPoolFreeI(mp, objp);
  2059d4:	4629      	mov	r1, r5
  2059d6:	4620      	mov	r0, r4
  2059d8:	f7fb f9ea 	bl	200db0 <chPoolFreeI>
  _dbg_check_unlock();
  2059dc:	f7fe f968 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2059e0:	4b07      	ldr	r3, [pc, #28]	; (205a00 <chPoolFree+0x40>)
  2059e2:	681a      	ldr	r2, [r3, #0]
  2059e4:	429a      	cmp	r2, r3
  2059e6:	d004      	beq.n	2059f2 <chPoolFree+0x32>
  2059e8:	6999      	ldr	r1, [r3, #24]
  2059ea:	6893      	ldr	r3, [r2, #8]
  2059ec:	688a      	ldr	r2, [r1, #8]
  2059ee:	429a      	cmp	r2, r3
  2059f0:	d303      	bcc.n	2059fa <chPoolFree+0x3a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2059f2:	2300      	movs	r3, #0
  2059f4:	f383 8811 	msr	BASEPRI, r3
}
  2059f8:	bd38      	pop	{r3, r4, r5, pc}
  2059fa:	4802      	ldr	r0, [pc, #8]	; (205a04 <chPoolFree+0x44>)
  2059fc:	f7fb f8b8 	bl	200b70 <chSysHalt>
  205a00:	20000dc8 	.word	0x20000dc8
  205a04:	0800bc70 	.word	0x0800bc70
	...

00205a10 <dyn_release_object_pool>:
                                    memory_pool_t *mp) {
  205a10:	b510      	push	{r4, lr}
  chDbgCheck(dep != NULL);
  205a12:	b1a0      	cbz	r0, 205a3e <dyn_release_object_pool+0x2e>
  chDbgAssert(dep->refs > (ucnt_t)0, "invalid references number");
  205a14:	6843      	ldr	r3, [r0, #4]
  205a16:	b193      	cbz	r3, 205a3e <dyn_release_object_pool+0x2e>
  dep->refs--;
  205a18:	3b01      	subs	r3, #1
  205a1a:	6043      	str	r3, [r0, #4]
  if (dep->refs == (ucnt_t)0) {
  205a1c:	b973      	cbnz	r3, 205a3c <dyn_release_object_pool+0x2c>
  dyn_element_t *prev = (dyn_element_t *)dlp;
  205a1e:	460c      	mov	r4, r1
  205a20:	e002      	b.n	205a28 <dyn_release_object_pool+0x18>
    if (prev->next == element) {
  205a22:	4298      	cmp	r0, r3
  205a24:	d00e      	beq.n	205a44 <dyn_release_object_pool+0x34>
  205a26:	461c      	mov	r4, r3
  while (prev->next != (dyn_element_t *)dlp) {
  205a28:	6823      	ldr	r3, [r4, #0]
  205a2a:	4299      	cmp	r1, r3
  205a2c:	d1f9      	bne.n	205a22 <dyn_release_object_pool+0x12>
  return NULL;
  205a2e:	2000      	movs	r0, #0
}
  205a30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chPoolFree(mp, (void *)dep);
  205a34:	4601      	mov	r1, r0
  205a36:	4610      	mov	r0, r2
  205a38:	f7ff bfc2 	b.w	2059c0 <chPoolFree>
}
  205a3c:	bd10      	pop	{r4, pc}
  chDbgCheck(dep != NULL);
  205a3e:	4805      	ldr	r0, [pc, #20]	; (205a54 <dyn_release_object_pool+0x44>)
  205a40:	f7fb f896 	bl	200b70 <chSysHalt>
      prev->next = element->next;
  205a44:	6803      	ldr	r3, [r0, #0]
    chPoolFree(mp, (void *)dep);
  205a46:	4601      	mov	r1, r0
  205a48:	4610      	mov	r0, r2
      prev->next = element->next;
  205a4a:	6023      	str	r3, [r4, #0]
}
  205a4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chPoolFree(mp, (void *)dep);
  205a50:	f7ff bfb6 	b.w	2059c0 <chPoolFree>
  205a54:	0800bfcc 	.word	0x0800bfcc
	...

00205a60 <chPoolAlloc>:
void *chPoolAlloc(memory_pool_t *mp) {
  205a60:	b538      	push	{r3, r4, r5, lr}
  205a62:	4605      	mov	r5, r0
  __ASM volatile ("cpsid i" : : : "memory");
  205a64:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205a66:	2320      	movs	r3, #32
  205a68:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205a6c:	b662      	cpsie	i
  _dbg_check_lock();
  205a6e:	f7fe f96f 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  205a72:	f7fb f98d 	bl	200d90 <chDbgCheckClassI>
  objp = mp->next;
  205a76:	682c      	ldr	r4, [r5, #0]
  if (objp != NULL) {
  205a78:	b1a4      	cbz	r4, 205aa4 <chPoolAlloc+0x44>
    mp->next = mp->next->next;
  205a7a:	6823      	ldr	r3, [r4, #0]
  205a7c:	602b      	str	r3, [r5, #0]
  _dbg_check_unlock();
  205a7e:	f7fe f917 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205a82:	4b0c      	ldr	r3, [pc, #48]	; (205ab4 <chPoolAlloc+0x54>)
  205a84:	681a      	ldr	r2, [r3, #0]
  205a86:	429a      	cmp	r2, r3
  205a88:	d004      	beq.n	205a94 <chPoolAlloc+0x34>
  205a8a:	6999      	ldr	r1, [r3, #24]
  205a8c:	6893      	ldr	r3, [r2, #8]
  205a8e:	688a      	ldr	r2, [r1, #8]
  205a90:	429a      	cmp	r2, r3
  205a92:	d304      	bcc.n	205a9e <chPoolAlloc+0x3e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205a94:	2300      	movs	r3, #0
  205a96:	f383 8811 	msr	BASEPRI, r3
}
  205a9a:	4620      	mov	r0, r4
  205a9c:	bd38      	pop	{r3, r4, r5, pc}
  205a9e:	4806      	ldr	r0, [pc, #24]	; (205ab8 <chPoolAlloc+0x58>)
  205aa0:	f7fb f866 	bl	200b70 <chSysHalt>
  else if (mp->provider != NULL) {
  205aa4:	68eb      	ldr	r3, [r5, #12]
  205aa6:	2b00      	cmp	r3, #0
  205aa8:	d0e9      	beq.n	205a7e <chPoolAlloc+0x1e>
    objp = mp->provider(mp->object_size, mp->align);
  205aaa:	e9d5 0101 	ldrd	r0, r1, [r5, #4]
  205aae:	4798      	blx	r3
  205ab0:	4604      	mov	r4, r0
  205ab2:	e7e4      	b.n	205a7e <chPoolAlloc+0x1e>
  205ab4:	20000dc8 	.word	0x20000dc8
  205ab8:	0800bc70 	.word	0x0800bc70
  205abc:	00000000 	.word	0x00000000

00205ac0 <chThdCreateFromMemoryPool.constprop.31>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
  205ac0:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
  205ac2:	4d21      	ldr	r5, [pc, #132]	; (205b48 <chThdCreateFromMemoryPool.constprop.31+0x88>)
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
  205ac4:	b087      	sub	sp, #28
  205ac6:	4607      	mov	r7, r0
  205ac8:	460e      	mov	r6, r1
  wsp = chPoolAlloc(mp);
  205aca:	4628      	mov	r0, r5
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
  205acc:	4614      	mov	r4, r2
  wsp = chPoolAlloc(mp);
  205ace:	f7ff ffc7 	bl	205a60 <chPoolAlloc>
  if (wsp == NULL) {
  205ad2:	2800      	cmp	r0, #0
  205ad4:	d035      	beq.n	205b42 <chThdCreateFromMemoryPool.constprop.31+0x82>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
  205ad6:	686b      	ldr	r3, [r5, #4]
  thread_descriptor_t td = {
  205ad8:	4a1c      	ldr	r2, [pc, #112]	; (205b4c <chThdCreateFromMemoryPool.constprop.31+0x8c>)
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
  205ada:	4403      	add	r3, r0
  thread_descriptor_t td = {
  205adc:	9700      	str	r7, [sp, #0]
  205ade:	9001      	str	r0, [sp, #4]
  while (startp < endp) {
  205ae0:	4298      	cmp	r0, r3
  205ae2:	9603      	str	r6, [sp, #12]
  205ae4:	9405      	str	r4, [sp, #20]
  205ae6:	9302      	str	r3, [sp, #8]
  205ae8:	9204      	str	r2, [sp, #16]
  205aea:	d204      	bcs.n	205af6 <chThdCreateFromMemoryPool.constprop.31+0x36>
    *startp++ = v;
  205aec:	2255      	movs	r2, #85	; 0x55
  205aee:	f800 2b01 	strb.w	r2, [r0], #1
  while (startp < endp) {
  205af2:	4283      	cmp	r3, r0
  205af4:	d1fb      	bne.n	205aee <chThdCreateFromMemoryPool.constprop.31+0x2e>
  __ASM volatile ("cpsid i" : : : "memory");
  205af6:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205af8:	2320      	movs	r3, #32
  205afa:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205afe:	b662      	cpsie	i
  _dbg_check_lock();
  205b00:	f7fe f926 	bl	203d50 <_dbg_check_lock>
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
  205b04:	4668      	mov	r0, sp
  205b06:	f7fb f99b 	bl	200e40 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
  205b0a:	2302      	movs	r3, #2
  tp->mpool = mp;
  chSchWakeupS(tp, MSG_OK);
  205b0c:	2100      	movs	r1, #0
  tp->mpool = mp;
  205b0e:	6405      	str	r5, [r0, #64]	; 0x40
  tp->flags = CH_FLAG_MODE_MPOOL;
  205b10:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tp = chThdCreateSuspendedI(&td);
  205b14:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
  205b16:	f7fd fc8b 	bl	203430 <chSchWakeupS>
  _dbg_check_unlock();
  205b1a:	f7fe f8c9 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205b1e:	4b0c      	ldr	r3, [pc, #48]	; (205b50 <chThdCreateFromMemoryPool.constprop.31+0x90>)
  205b20:	681a      	ldr	r2, [r3, #0]
  205b22:	429a      	cmp	r2, r3
  205b24:	d004      	beq.n	205b30 <chThdCreateFromMemoryPool.constprop.31+0x70>
  205b26:	6999      	ldr	r1, [r3, #24]
  205b28:	6893      	ldr	r3, [r2, #8]
  205b2a:	688a      	ldr	r2, [r1, #8]
  205b2c:	429a      	cmp	r2, r3
  205b2e:	d305      	bcc.n	205b3c <chThdCreateFromMemoryPool.constprop.31+0x7c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205b30:	2300      	movs	r3, #0
  205b32:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
  205b36:	4620      	mov	r0, r4
  205b38:	b007      	add	sp, #28
  205b3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  205b3c:	4805      	ldr	r0, [pc, #20]	; (205b54 <chThdCreateFromMemoryPool.constprop.31+0x94>)
  205b3e:	f7fb f817 	bl	200b70 <chSysHalt>
    return NULL;
  205b42:	4604      	mov	r4, r0
  205b44:	e7f7      	b.n	205b36 <chThdCreateFromMemoryPool.constprop.31+0x76>
  205b46:	bf00      	nop
  205b48:	20001808 	.word	0x20001808
  205b4c:	002057f1 	.word	0x002057f1
  205b50:	20000dc8 	.word	0x20000dc8
  205b54:	0800bc4c 	.word	0x0800bc4c
	...

00205b60 <oslib_test_002_001_execute>:
static void oslib_test_002_001_execute(void) {
  205b60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  205b64:	4e39      	ldr	r6, [pc, #228]	; (205c4c <oslib_test_002_001_execute+0xec>)
  205b66:	2504      	movs	r5, #4
  205b68:	4c39      	ldr	r4, [pc, #228]	; (205c50 <oslib_test_002_001_execute+0xf0>)
  chPoolFree(mp, objp);
  205b6a:	4637      	mov	r7, r6
  205b6c:	4621      	mov	r1, r4
  205b6e:	4638      	mov	r0, r7
  205b70:	f7ff ff26 	bl	2059c0 <chPoolFree>
    p = (void *)(((uint8_t *)p) + mp->object_size);
  205b74:	6873      	ldr	r3, [r6, #4]
  while (n != 0U) {
  205b76:	3d01      	subs	r5, #1
    p = (void *)(((uint8_t *)p) + mp->object_size);
  205b78:	441c      	add	r4, r3
  while (n != 0U) {
  205b7a:	d1f7      	bne.n	205b6c <oslib_test_002_001_execute+0xc>
  test_set_step(2);
  205b7c:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 205c70 <oslib_test_002_001_execute+0x110>
  205b80:	2302      	movs	r3, #2
  205b82:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  205b84:	4f31      	ldr	r7, [pc, #196]	; (205c4c <oslib_test_002_001_execute+0xec>)
  205b86:	4d33      	ldr	r5, [pc, #204]	; (205c54 <oslib_test_002_001_execute+0xf4>)
  test_set_step(2);
  205b88:	f8c8 3000 	str.w	r3, [r8]
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  205b8c:	4638      	mov	r0, r7
  205b8e:	f7ff ff67 	bl	205a60 <chPoolAlloc>
  205b92:	3000      	adds	r0, #0
  205b94:	4629      	mov	r1, r5
  205b96:	bf18      	it	ne
  205b98:	2001      	movne	r0, #1
  205b9a:	f7fa fe11 	bl	2007c0 <_test_assert>
  205b9e:	2800      	cmp	r0, #0
  205ba0:	d13d      	bne.n	205c1e <oslib_test_002_001_execute+0xbe>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  205ba2:	3c01      	subs	r4, #1
  205ba4:	d1f2      	bne.n	205b8c <oslib_test_002_001_execute+0x2c>
  test_set_step(3);
  205ba6:	2303      	movs	r3, #3
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
  205ba8:	4828      	ldr	r0, [pc, #160]	; (205c4c <oslib_test_002_001_execute+0xec>)
  test_set_step(3);
  205baa:	f8c8 3000 	str.w	r3, [r8]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
  205bae:	f7ff ff57 	bl	205a60 <chPoolAlloc>
  205bb2:	fab0 f080 	clz	r0, r0
  205bb6:	4928      	ldr	r1, [pc, #160]	; (205c58 <oslib_test_002_001_execute+0xf8>)
  205bb8:	0940      	lsrs	r0, r0, #5
  205bba:	f7fa fe01 	bl	2007c0 <_test_assert>
  205bbe:	bb70      	cbnz	r0, 205c1e <oslib_test_002_001_execute+0xbe>
      chPoolFree(&mp1, &objects[i]);
  205bc0:	4923      	ldr	r1, [pc, #140]	; (205c50 <oslib_test_002_001_execute+0xf0>)
  test_set_step(5);
  205bc2:	2404      	movs	r4, #4
      chPoolFree(&mp1, &objects[i]);
  205bc4:	4821      	ldr	r0, [pc, #132]	; (205c4c <oslib_test_002_001_execute+0xec>)
  205bc6:	f7ff fefb 	bl	2059c0 <chPoolFree>
  205bca:	4924      	ldr	r1, [pc, #144]	; (205c5c <oslib_test_002_001_execute+0xfc>)
  205bcc:	481f      	ldr	r0, [pc, #124]	; (205c4c <oslib_test_002_001_execute+0xec>)
  205bce:	f7ff fef7 	bl	2059c0 <chPoolFree>
  205bd2:	4923      	ldr	r1, [pc, #140]	; (205c60 <oslib_test_002_001_execute+0x100>)
  205bd4:	481d      	ldr	r0, [pc, #116]	; (205c4c <oslib_test_002_001_execute+0xec>)
  205bd6:	f7ff fef3 	bl	2059c0 <chPoolFree>
  205bda:	4922      	ldr	r1, [pc, #136]	; (205c64 <oslib_test_002_001_execute+0x104>)
  205bdc:	481b      	ldr	r0, [pc, #108]	; (205c4c <oslib_test_002_001_execute+0xec>)
  205bde:	f7ff feef 	bl	2059c0 <chPoolFree>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  205be2:	4f1a      	ldr	r7, [pc, #104]	; (205c4c <oslib_test_002_001_execute+0xec>)
  test_set_step(5);
  205be4:	2305      	movs	r3, #5
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  205be6:	4d1b      	ldr	r5, [pc, #108]	; (205c54 <oslib_test_002_001_execute+0xf4>)
  test_set_step(5);
  205be8:	f8c8 3000 	str.w	r3, [r8]
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  205bec:	4638      	mov	r0, r7
  205bee:	f7ff ff37 	bl	205a60 <chPoolAlloc>
  205bf2:	3000      	adds	r0, #0
  205bf4:	4629      	mov	r1, r5
  205bf6:	bf18      	it	ne
  205bf8:	2001      	movne	r0, #1
  205bfa:	f7fa fde1 	bl	2007c0 <_test_assert>
  205bfe:	b970      	cbnz	r0, 205c1e <oslib_test_002_001_execute+0xbe>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
  205c00:	3c01      	subs	r4, #1
  205c02:	d1f3      	bne.n	205bec <oslib_test_002_001_execute+0x8c>
  test_set_step(6);
  205c04:	2306      	movs	r3, #6
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
  205c06:	4811      	ldr	r0, [pc, #68]	; (205c4c <oslib_test_002_001_execute+0xec>)
  test_set_step(6);
  205c08:	f8c8 3000 	str.w	r3, [r8]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
  205c0c:	f7ff ff28 	bl	205a60 <chPoolAlloc>
  205c10:	fab0 f080 	clz	r0, r0
  205c14:	4910      	ldr	r1, [pc, #64]	; (205c58 <oslib_test_002_001_execute+0xf8>)
  205c16:	0940      	lsrs	r0, r0, #5
  205c18:	f7fa fdd2 	bl	2007c0 <_test_assert>
  205c1c:	b108      	cbz	r0, 205c22 <oslib_test_002_001_execute+0xc2>
}
  205c1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(7);
  205c22:	2107      	movs	r1, #7
  mp->object_size = size;
  205c24:	2304      	movs	r3, #4
  mp->provider = provider;
  205c26:	4a10      	ldr	r2, [pc, #64]	; (205c68 <oslib_test_002_001_execute+0x108>)
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
  205c28:	4808      	ldr	r0, [pc, #32]	; (205c4c <oslib_test_002_001_execute+0xec>)
  test_set_step(7);
  205c2a:	f8c8 1000 	str.w	r1, [r8]
  mp->next = NULL;
  205c2e:	6034      	str	r4, [r6, #0]
  mp->provider = provider;
  205c30:	60f2      	str	r2, [r6, #12]
  mp->align = align;
  205c32:	e9c6 3301 	strd	r3, r3, [r6, #4]
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
  205c36:	f7ff ff13 	bl	205a60 <chPoolAlloc>
  205c3a:	fab0 f080 	clz	r0, r0
  205c3e:	490b      	ldr	r1, [pc, #44]	; (205c6c <oslib_test_002_001_execute+0x10c>)
  205c40:	0940      	lsrs	r0, r0, #5
}
  205c42:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
  205c46:	f7fa bdbb 	b.w	2007c0 <_test_assert>
  205c4a:	bf00      	nop
  205c4c:	20010480 	.word	0x20010480
  205c50:	20001828 	.word	0x20001828
  205c54:	0800c6f4 	.word	0x0800c6f4
  205c58:	0800c710 	.word	0x0800c710
  205c5c:	2000182c 	.word	0x2000182c
  205c60:	20001830 	.word	0x20001830
  205c64:	20001834 	.word	0x20001834
  205c68:	00200791 	.word	0x00200791
  205c6c:	0800c6c8 	.word	0x0800c6c8
  205c70:	20001f6c 	.word	0x20001f6c
	...

00205c80 <dyn_create_object_pool>:
                                             memory_pool_t *mp) {
  205c80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_element_t *p = dlp->next;
  205c82:	680c      	ldr	r4, [r1, #0]
                                             memory_pool_t *mp) {
  205c84:	460d      	mov	r5, r1
  205c86:	4606      	mov	r6, r0
  205c88:	4617      	mov	r7, r2
  while (p != (dyn_element_t *)dlp) {
  205c8a:	42a1      	cmp	r1, r4
  205c8c:	d103      	bne.n	205c96 <dyn_create_object_pool+0x16>
  205c8e:	e00d      	b.n	205cac <dyn_create_object_pool+0x2c>
    p = p->next;
  205c90:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
  205c92:	42a5      	cmp	r5, r4
  205c94:	d00a      	beq.n	205cac <dyn_create_object_pool+0x2c>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
  205c96:	2208      	movs	r2, #8
  205c98:	4631      	mov	r1, r6
  205c9a:	18a0      	adds	r0, r4, r2
  205c9c:	f005 fee8 	bl	20ba70 <strncmp>
  205ca0:	2800      	cmp	r0, #0
  205ca2:	d1f5      	bne.n	205c90 <dyn_create_object_pool+0x10>
  if (dep != NULL) {
  205ca4:	b114      	cbz	r4, 205cac <dyn_create_object_pool+0x2c>
    return NULL;
  205ca6:	4604      	mov	r4, r0
}
  205ca8:	4620      	mov	r0, r4
  205caa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  dep = (dyn_element_t *)chPoolAlloc(mp);
  205cac:	4638      	mov	r0, r7
  205cae:	f7ff fed7 	bl	205a60 <chPoolAlloc>
  if (dep == NULL) {
  205cb2:	4604      	mov	r4, r0
  205cb4:	b148      	cbz	r0, 205cca <dyn_create_object_pool+0x4a>
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
  205cb6:	2208      	movs	r2, #8
  205cb8:	4631      	mov	r1, r6
  205cba:	4410      	add	r0, r2
  205cbc:	f005 ff24 	bl	20bb08 <strncpy>
  dep->next = dlp->next;
  205cc0:	682b      	ldr	r3, [r5, #0]
  dep->refs = (ucnt_t)1;
  205cc2:	2201      	movs	r2, #1
  dep->next = dlp->next;
  205cc4:	e9c4 3200 	strd	r3, r2, [r4]
  dlp->next = (dyn_element_t *)dep;
  205cc8:	602c      	str	r4, [r5, #0]
}
  205cca:	4620      	mov	r0, r4
  205ccc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  205cce:	bf00      	nop

00205cd0 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
  205cd0:	b538      	push	{r3, r4, r5, lr}
  205cd2:	4604      	mov	r4, r0
  205cd4:	460d      	mov	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
  205cd6:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205cd8:	2320      	movs	r3, #32
  205cda:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205cde:	b662      	cpsie	i
  _dbg_check_lock();
  205ce0:	f7fe f836 	bl	203d50 <_dbg_check_lock>

  chSysLock();
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
  205ce4:	f894 3020 	ldrb.w	r3, [r4, #32]
  205ce8:	2b0d      	cmp	r3, #13
  205cea:	d002      	beq.n	205cf2 <chMsgRelease+0x22>
  205cec:	480d      	ldr	r0, [pc, #52]	; (205d24 <chMsgRelease+0x54>)
  205cee:	f7fa ff3f 	bl	200b70 <chSysHalt>
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();
  205cf2:	f7fb f83d 	bl	200d70 <chDbgCheckClassS>

  chSchWakeupS(tp, msg);
  205cf6:	4629      	mov	r1, r5
  205cf8:	4620      	mov	r0, r4
  205cfa:	f7fd fb99 	bl	203430 <chSchWakeupS>
  _dbg_check_unlock();
  205cfe:	f7fd ffd7 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205d02:	4b09      	ldr	r3, [pc, #36]	; (205d28 <chMsgRelease+0x58>)
  205d04:	681a      	ldr	r2, [r3, #0]
  205d06:	429a      	cmp	r2, r3
  205d08:	d004      	beq.n	205d14 <chMsgRelease+0x44>
  205d0a:	6999      	ldr	r1, [r3, #24]
  205d0c:	6893      	ldr	r3, [r2, #8]
  205d0e:	688a      	ldr	r2, [r1, #8]
  205d10:	429a      	cmp	r2, r3
  205d12:	d303      	bcc.n	205d1c <chMsgRelease+0x4c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205d14:	2300      	movs	r3, #0
  205d16:	f383 8811 	msr	BASEPRI, r3
  chMsgReleaseS(tp, msg);
  chSysUnlock();
}
  205d1a:	bd38      	pop	{r3, r4, r5, pc}
  205d1c:	4803      	ldr	r0, [pc, #12]	; (205d2c <chMsgRelease+0x5c>)
  205d1e:	f7fa ff27 	bl	200b70 <chSysHalt>
  205d22:	bf00      	nop
  205d24:	0800bd98 	.word	0x0800bd98
  205d28:	20000dc8 	.word	0x20000dc8
  205d2c:	0800bc40 	.word	0x0800bc40

00205d30 <chMsgWait>:
thread_t *chMsgWait(void) {
  205d30:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  205d32:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205d34:	2320      	movs	r3, #32
  205d36:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205d3a:	b662      	cpsie	i
  if (!chMsgIsPendingI(currp)) {
  205d3c:	4c15      	ldr	r4, [pc, #84]	; (205d94 <chMsgWait+0x64>)
  _dbg_check_lock();
  205d3e:	f7fe f807 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  205d42:	f7fb f825 	bl	200d90 <chDbgCheckClassI>
  205d46:	69a2      	ldr	r2, [r4, #24]
  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
  205d48:	4613      	mov	r3, r2
  205d4a:	f853 5f2c 	ldr.w	r5, [r3, #44]!
  205d4e:	429d      	cmp	r5, r3
  205d50:	d017      	beq.n	205d82 <chMsgWait+0x52>
  205d52:	6829      	ldr	r1, [r5, #0]
  tp->state = CH_STATE_SNDMSG;
  205d54:	200d      	movs	r0, #13
  205d56:	62d1      	str	r1, [r2, #44]	; 0x2c
  tqp->next->queue.prev = (thread_t *)tqp;
  205d58:	604b      	str	r3, [r1, #4]
  205d5a:	f885 0020 	strb.w	r0, [r5, #32]
  _dbg_check_unlock();
  205d5e:	f7fd ffa7 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205d62:	6823      	ldr	r3, [r4, #0]
  205d64:	42a3      	cmp	r3, r4
  205d66:	d004      	beq.n	205d72 <chMsgWait+0x42>
  205d68:	69a2      	ldr	r2, [r4, #24]
  205d6a:	689b      	ldr	r3, [r3, #8]
  205d6c:	6892      	ldr	r2, [r2, #8]
  205d6e:	429a      	cmp	r2, r3
  205d70:	d304      	bcc.n	205d7c <chMsgWait+0x4c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205d72:	2300      	movs	r3, #0
  205d74:	f383 8811 	msr	BASEPRI, r3
}
  205d78:	4628      	mov	r0, r5
  205d7a:	bd38      	pop	{r3, r4, r5, pc}
  205d7c:	4806      	ldr	r0, [pc, #24]	; (205d98 <chMsgWait+0x68>)
  205d7e:	f7fa fef7 	bl	200b70 <chSysHalt>
    chSchGoSleepS(CH_STATE_WTMSG);
  205d82:	200e      	movs	r0, #14
  205d84:	f7fd fb8c 	bl	2034a0 <chSchGoSleepS>
  205d88:	69a2      	ldr	r2, [r4, #24]
  205d8a:	f102 032c 	add.w	r3, r2, #44	; 0x2c
  205d8e:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
  205d90:	e7df      	b.n	205d52 <chMsgWait+0x22>
  205d92:	bf00      	nop
  205d94:	20000dc8 	.word	0x20000dc8
  205d98:	0800bc40 	.word	0x0800bc40
  205d9c:	00000000 	.word	0x00000000

00205da0 <bmk_thread1>:
static THD_FUNCTION(bmk_thread1, p) {
  205da0:	b510      	push	{r4, lr}
    tp = chMsgWait();
  205da2:	f7ff ffc5 	bl	205d30 <chMsgWait>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
  205da6:	f890 2020 	ldrb.w	r2, [r0, #32]
  205daa:	2a0d      	cmp	r2, #13
  205dac:	d002      	beq.n	205db4 <bmk_thread1+0x14>
  205dae:	4805      	ldr	r0, [pc, #20]	; (205dc4 <bmk_thread1+0x24>)
  205db0:	f7fa fede 	bl	200b70 <chSysHalt>
  return tp->u.sentmsg;
  205db4:	6a44      	ldr	r4, [r0, #36]	; 0x24
    chMsgRelease(tp, msg);
  205db6:	4621      	mov	r1, r4
  205db8:	f7ff ff8a 	bl	205cd0 <chMsgRelease>
  } while (msg);
  205dbc:	2c00      	cmp	r4, #0
  205dbe:	d1f0      	bne.n	205da2 <bmk_thread1+0x2>
}
  205dc0:	bd10      	pop	{r4, pc}
  205dc2:	bf00      	nop
  205dc4:	0800bd50 	.word	0x0800bd50
	...

00205dd0 <chMsgSend>:
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  205dd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
  205dd2:	4e1a      	ldr	r6, [pc, #104]	; (205e3c <chMsgSend+0x6c>)
  205dd4:	69b4      	ldr	r4, [r6, #24]
  chDbgCheck(tp != NULL);
  205dd6:	b370      	cbz	r0, 205e36 <chMsgSend+0x66>
  205dd8:	460f      	mov	r7, r1
  205dda:	4605      	mov	r5, r0
  __ASM volatile ("cpsid i" : : : "memory");
  205ddc:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205dde:	2320      	movs	r3, #32
  205de0:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205de4:	b662      	cpsie	i
  _dbg_check_lock();
  205de6:	f7fd ffb3 	bl	203d50 <_dbg_check_lock>
  ctp->u.sentmsg = msg;
  205dea:	6267      	str	r7, [r4, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
  205dec:	f105 022c 	add.w	r2, r5, #44	; 0x2c
  tp->queue.prev             = tqp->prev;
  205df0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  205df2:	e9c4 2300 	strd	r2, r3, [r4]
  tp->queue.prev->queue.next = tp;
  205df6:	601c      	str	r4, [r3, #0]
  if (tp->state == CH_STATE_WTMSG) {
  205df8:	f895 3020 	ldrb.w	r3, [r5, #32]
  tqp->prev                  = tp;
  205dfc:	632c      	str	r4, [r5, #48]	; 0x30
  205dfe:	2b0e      	cmp	r3, #14
  205e00:	d015      	beq.n	205e2e <chMsgSend+0x5e>
  chSchGoSleepS(CH_STATE_SNDMSGQ);
  205e02:	200c      	movs	r0, #12
  205e04:	f7fd fb4c 	bl	2034a0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
  205e08:	6a64      	ldr	r4, [r4, #36]	; 0x24
  _dbg_check_unlock();
  205e0a:	f7fd ff51 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205e0e:	6833      	ldr	r3, [r6, #0]
  205e10:	42b3      	cmp	r3, r6
  205e12:	d004      	beq.n	205e1e <chMsgSend+0x4e>
  205e14:	69b2      	ldr	r2, [r6, #24]
  205e16:	689b      	ldr	r3, [r3, #8]
  205e18:	6892      	ldr	r2, [r2, #8]
  205e1a:	429a      	cmp	r2, r3
  205e1c:	d304      	bcc.n	205e28 <chMsgSend+0x58>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205e1e:	2300      	movs	r3, #0
  205e20:	f383 8811 	msr	BASEPRI, r3
}
  205e24:	4620      	mov	r0, r4
  205e26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  205e28:	4805      	ldr	r0, [pc, #20]	; (205e40 <chMsgSend+0x70>)
  205e2a:	f7fa fea1 	bl	200b70 <chSysHalt>
    (void) chSchReadyI(tp);
  205e2e:	4628      	mov	r0, r5
  205e30:	f7fb f85e 	bl	200ef0 <chSchReadyI>
  205e34:	e7e5      	b.n	205e02 <chMsgSend+0x32>
  chDbgCheck(tp != NULL);
  205e36:	4803      	ldr	r0, [pc, #12]	; (205e44 <chMsgSend+0x74>)
  205e38:	f7fa fe9a 	bl	200b70 <chSysHalt>
  205e3c:	20000dc8 	.word	0x20000dc8
  205e40:	0800bc40 	.word	0x0800bc40
  205e44:	0800bd5c 	.word	0x0800bd5c
	...

00205e50 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
  205e50:	b510      	push	{r4, lr}
  205e52:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
  205e54:	2141      	movs	r1, #65	; 0x41
  205e56:	f7ff ffbb 	bl	205dd0 <chMsgSend>
  chMsgSend(p, 'B');
  205e5a:	2142      	movs	r1, #66	; 0x42
  205e5c:	4620      	mov	r0, r4
  205e5e:	f7ff ffb7 	bl	205dd0 <chMsgSend>
  chMsgSend(p, 'C');
  205e62:	4620      	mov	r0, r4
  205e64:	2143      	movs	r1, #67	; 0x43
  205e66:	f7ff ffb3 	bl	205dd0 <chMsgSend>
  chMsgSend(p, 'D');
  205e6a:	4620      	mov	r0, r4
  205e6c:	2144      	movs	r1, #68	; 0x44
}
  205e6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMsgSend(p, 'D');
  205e72:	f7ff bfad 	b.w	205dd0 <chMsgSend>
  205e76:	bf00      	nop
	...

00205e80 <chEvtAddEvents>:
eventmask_t chEvtAddEvents(eventmask_t events) {
  205e80:	b538      	push	{r3, r4, r5, lr}
  205e82:	4605      	mov	r5, r0
  __ASM volatile ("cpsid i" : : : "memory");
  205e84:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205e86:	2320      	movs	r3, #32
  205e88:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205e8c:	b662      	cpsie	i
 *
 * @iclass
 */
static inline eventmask_t chEvtAddEventsI(eventmask_t events) {

  return currp->epending |= events;
  205e8e:	4c0c      	ldr	r4, [pc, #48]	; (205ec0 <chEvtAddEvents+0x40>)
  _dbg_check_lock();
  205e90:	f7fd ff5e 	bl	203d50 <_dbg_check_lock>
  205e94:	69a3      	ldr	r3, [r4, #24]
  205e96:	6b58      	ldr	r0, [r3, #52]	; 0x34
  205e98:	4305      	orrs	r5, r0
  205e9a:	635d      	str	r5, [r3, #52]	; 0x34
  _dbg_check_unlock();
  205e9c:	f7fd ff08 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205ea0:	6823      	ldr	r3, [r4, #0]
  205ea2:	42a3      	cmp	r3, r4
  205ea4:	d004      	beq.n	205eb0 <chEvtAddEvents+0x30>
  205ea6:	69a2      	ldr	r2, [r4, #24]
  205ea8:	689b      	ldr	r3, [r3, #8]
  205eaa:	6892      	ldr	r2, [r2, #8]
  205eac:	429a      	cmp	r2, r3
  205eae:	d304      	bcc.n	205eba <chEvtAddEvents+0x3a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205eb0:	2300      	movs	r3, #0
  205eb2:	f383 8811 	msr	BASEPRI, r3
}
  205eb6:	4628      	mov	r0, r5
  205eb8:	bd38      	pop	{r3, r4, r5, pc}
  205eba:	4802      	ldr	r0, [pc, #8]	; (205ec4 <chEvtAddEvents+0x44>)
  205ebc:	f7fa fe58 	bl	200b70 <chSysHalt>
  205ec0:	20000dc8 	.word	0x20000dc8
  205ec4:	0800bc34 	.word	0x0800bc34
	...

00205ed0 <chEvtUnregister>:
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
  205ed0:	b538      	push	{r3, r4, r5, lr}
  205ed2:	4604      	mov	r4, r0
  205ed4:	460d      	mov	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
  205ed6:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205ed8:	2320      	movs	r3, #32
  205eda:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205ede:	b662      	cpsie	i
  _dbg_check_lock();
  205ee0:	f7fd ff36 	bl	203d50 <_dbg_check_lock>
  205ee4:	4622      	mov	r2, r4
  205ee6:	e002      	b.n	205eee <chEvtUnregister+0x1e>
    if (p->next == elp) {
  205ee8:	42ab      	cmp	r3, r5
  205eea:	d012      	beq.n	205f12 <chEvtUnregister+0x42>
  205eec:	461a      	mov	r2, r3
  while (p->next != (event_listener_t *)esp) {
  205eee:	6813      	ldr	r3, [r2, #0]
  205ef0:	42a3      	cmp	r3, r4
  205ef2:	d1f9      	bne.n	205ee8 <chEvtUnregister+0x18>
  _dbg_check_unlock();
  205ef4:	f7fd fedc 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205ef8:	4b0c      	ldr	r3, [pc, #48]	; (205f2c <chEvtUnregister+0x5c>)
  205efa:	681a      	ldr	r2, [r3, #0]
  205efc:	429a      	cmp	r2, r3
  205efe:	d004      	beq.n	205f0a <chEvtUnregister+0x3a>
  205f00:	6999      	ldr	r1, [r3, #24]
  205f02:	6893      	ldr	r3, [r2, #8]
  205f04:	688a      	ldr	r2, [r1, #8]
  205f06:	429a      	cmp	r2, r3
  205f08:	d30c      	bcc.n	205f24 <chEvtUnregister+0x54>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205f0a:	2300      	movs	r3, #0
  205f0c:	f383 8811 	msr	BASEPRI, r3
}
  205f10:	bd38      	pop	{r3, r4, r5, pc}
      p->next = elp->next;
  205f12:	682b      	ldr	r3, [r5, #0]
  205f14:	6013      	str	r3, [r2, #0]
  _dbg_check_unlock();
  205f16:	f7fd fecb 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205f1a:	4b04      	ldr	r3, [pc, #16]	; (205f2c <chEvtUnregister+0x5c>)
  205f1c:	681a      	ldr	r2, [r3, #0]
  205f1e:	429a      	cmp	r2, r3
  205f20:	d1ee      	bne.n	205f00 <chEvtUnregister+0x30>
  205f22:	e7f2      	b.n	205f0a <chEvtUnregister+0x3a>
  205f24:	4802      	ldr	r0, [pc, #8]	; (205f30 <chEvtUnregister+0x60>)
  205f26:	f7fa fe23 	bl	200b70 <chSysHalt>
  205f2a:	bf00      	nop
  205f2c:	20000dc8 	.word	0x20000dc8
  205f30:	0800bc34 	.word	0x0800bc34
	...

00205f40 <rt_test_008_001_execute>:
static void rt_test_008_001_execute(void) {
  205f40:	b570      	push	{r4, r5, r6, lr}
  esp->next = (event_listener_t *)esp;
  205f42:	4c40      	ldr	r4, [pc, #256]	; (206044 <rt_test_008_001_execute+0x104>)
  205f44:	b08a      	sub	sp, #40	; 0x28
  test_set_step(2);
  205f46:	2502      	movs	r5, #2
  205f48:	4e3f      	ldr	r6, [pc, #252]	; (206048 <rt_test_008_001_execute+0x108>)
  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
  205f4a:	4620      	mov	r0, r4
  205f4c:	a905      	add	r1, sp, #20
  205f4e:	2201      	movs	r2, #1
  esp->next = (event_listener_t *)esp;
  205f50:	6024      	str	r4, [r4, #0]
  205f52:	6035      	str	r5, [r6, #0]
  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
  205f54:	f7fd ffec 	bl	203f30 <chEvtRegisterMaskWithFlags.constprop.43>
  205f58:	462a      	mov	r2, r5
  205f5a:	4620      	mov	r0, r4
  205f5c:	4669      	mov	r1, sp
  205f5e:	f7fd ffe7 	bl	203f30 <chEvtRegisterMaskWithFlags.constprop.43>
  __ASM volatile ("cpsid i" : : : "memory");
  205f62:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205f64:	2320      	movs	r3, #32
  205f66:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205f6a:	b662      	cpsie	i
  _dbg_check_lock();
  205f6c:	f7fd fef0 	bl	203d50 <_dbg_check_lock>
  return (bool)(esp != (event_source_t *)esp->next);
  205f70:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  205f72:	4936      	ldr	r1, [pc, #216]	; (20604c <rt_test_008_001_execute+0x10c>)
  205f74:	1b00      	subs	r0, r0, r4
  205f76:	bf18      	it	ne
  205f78:	2001      	movne	r0, #1
  205f7a:	f7fa fc21 	bl	2007c0 <_test_assert>
  205f7e:	b178      	cbz	r0, 205fa0 <rt_test_008_001_execute+0x60>
  _dbg_check_unlock();
  205f80:	f7fd fe96 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205f84:	4b32      	ldr	r3, [pc, #200]	; (206050 <rt_test_008_001_execute+0x110>)
  205f86:	681a      	ldr	r2, [r3, #0]
  205f88:	429a      	cmp	r2, r3
  205f8a:	d004      	beq.n	205f96 <rt_test_008_001_execute+0x56>
  205f8c:	6999      	ldr	r1, [r3, #24]
  205f8e:	6893      	ldr	r3, [r2, #8]
  205f90:	688a      	ldr	r2, [r1, #8]
  205f92:	429a      	cmp	r2, r3
  205f94:	d353      	bcc.n	20603e <rt_test_008_001_execute+0xfe>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205f96:	2300      	movs	r3, #0
  205f98:	f383 8811 	msr	BASEPRI, r3
}
  205f9c:	b00a      	add	sp, #40	; 0x28
  205f9e:	bd70      	pop	{r4, r5, r6, pc}
  205fa0:	4d2b      	ldr	r5, [pc, #172]	; (206050 <rt_test_008_001_execute+0x110>)
  _dbg_check_unlock();
  205fa2:	f7fd fe85 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205fa6:	682b      	ldr	r3, [r5, #0]
  205fa8:	42ab      	cmp	r3, r5
  205faa:	d004      	beq.n	205fb6 <rt_test_008_001_execute+0x76>
  205fac:	69aa      	ldr	r2, [r5, #24]
  205fae:	689b      	ldr	r3, [r3, #8]
  205fb0:	6892      	ldr	r2, [r2, #8]
  205fb2:	429a      	cmp	r2, r3
  205fb4:	d343      	bcc.n	20603e <rt_test_008_001_execute+0xfe>
  205fb6:	2300      	movs	r3, #0
  205fb8:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
  205fbc:	2303      	movs	r3, #3
    chEvtUnregister(&es1, &el1);
  205fbe:	a905      	add	r1, sp, #20
  205fc0:	4820      	ldr	r0, [pc, #128]	; (206044 <rt_test_008_001_execute+0x104>)
  test_set_step(3);
  205fc2:	6033      	str	r3, [r6, #0]
    chEvtUnregister(&es1, &el1);
  205fc4:	f7ff ff84 	bl	205ed0 <chEvtUnregister>
  __ASM volatile ("cpsid i" : : : "memory");
  205fc8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205fca:	2320      	movs	r3, #32
  205fcc:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  205fd0:	b662      	cpsie	i
  _dbg_check_lock();
  205fd2:	f7fd febd 	bl	203d50 <_dbg_check_lock>
  205fd6:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  205fd8:	491c      	ldr	r1, [pc, #112]	; (20604c <rt_test_008_001_execute+0x10c>)
  205fda:	1b00      	subs	r0, r0, r4
  205fdc:	bf18      	it	ne
  205fde:	2001      	movne	r0, #1
  205fe0:	f7fa fbee 	bl	2007c0 <_test_assert>
  205fe4:	bb08      	cbnz	r0, 20602a <rt_test_008_001_execute+0xea>
  _dbg_check_unlock();
  205fe6:	f7fd fe63 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  205fea:	682b      	ldr	r3, [r5, #0]
  205fec:	42ab      	cmp	r3, r5
  205fee:	d004      	beq.n	205ffa <rt_test_008_001_execute+0xba>
  205ff0:	69aa      	ldr	r2, [r5, #24]
  205ff2:	689b      	ldr	r3, [r3, #8]
  205ff4:	6892      	ldr	r2, [r2, #8]
  205ff6:	429a      	cmp	r2, r3
  205ff8:	d321      	bcc.n	20603e <rt_test_008_001_execute+0xfe>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205ffa:	2300      	movs	r3, #0
  205ffc:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
  206000:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el2);
  206002:	4669      	mov	r1, sp
  206004:	480f      	ldr	r0, [pc, #60]	; (206044 <rt_test_008_001_execute+0x104>)
  test_set_step(4);
  206006:	6033      	str	r3, [r6, #0]
    chEvtUnregister(&es1, &el2);
  206008:	f7ff ff62 	bl	205ed0 <chEvtUnregister>
  __ASM volatile ("cpsid i" : : : "memory");
  20600c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20600e:	2320      	movs	r3, #32
  206010:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  206014:	b662      	cpsie	i
  _dbg_check_lock();
  206016:	f7fd fe9b 	bl	203d50 <_dbg_check_lock>
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  20601a:	6820      	ldr	r0, [r4, #0]
  20601c:	490d      	ldr	r1, [pc, #52]	; (206054 <rt_test_008_001_execute+0x114>)
  20601e:	1b00      	subs	r0, r0, r4
  206020:	fab0 f080 	clz	r0, r0
  206024:	0940      	lsrs	r0, r0, #5
  206026:	f7fa fbcb 	bl	2007c0 <_test_assert>
  _dbg_check_unlock();
  20602a:	f7fd fe41 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20602e:	682b      	ldr	r3, [r5, #0]
  206030:	42ab      	cmp	r3, r5
  206032:	d0b0      	beq.n	205f96 <rt_test_008_001_execute+0x56>
  206034:	69aa      	ldr	r2, [r5, #24]
  206036:	689b      	ldr	r3, [r3, #8]
  206038:	6892      	ldr	r2, [r2, #8]
  20603a:	429a      	cmp	r2, r3
  20603c:	d2ab      	bcs.n	205f96 <rt_test_008_001_execute+0x56>
  20603e:	4806      	ldr	r0, [pc, #24]	; (206058 <rt_test_008_001_execute+0x118>)
  206040:	f7fa fd96 	bl	200b70 <chSysHalt>
  206044:	2001040c 	.word	0x2001040c
  206048:	20001f6c 	.word	0x20001f6c
  20604c:	0800d7a8 	.word	0x0800d7a8
  206050:	20000dc8 	.word	0x20000dc8
  206054:	0800d7b4 	.word	0x0800d7b4
  206058:	0800bcd0 	.word	0x0800bcd0
  20605c:	00000000 	.word	0x00000000

00206060 <chMtxUnlock>:
void chMtxUnlock(mutex_t *mp) {
  206060:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  thread_t *ctp = currp;
  206064:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 206114 <chMtxUnlock+0xb4>
  206068:	f8d8 6018 	ldr.w	r6, [r8, #24]
  chDbgCheck(mp != NULL);
  20606c:	b160      	cbz	r0, 206088 <chMtxUnlock+0x28>
  20606e:	4605      	mov	r5, r0
  __ASM volatile ("cpsid i" : : : "memory");
  206070:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  206072:	2320      	movs	r3, #32
  206074:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  206078:	b662      	cpsie	i
  _dbg_check_lock();
  20607a:	f7fd fe69 	bl	203d50 <_dbg_check_lock>
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
  20607e:	6bb7      	ldr	r7, [r6, #56]	; 0x38
  206080:	b117      	cbz	r7, 206088 <chMtxUnlock+0x28>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
  206082:	68bb      	ldr	r3, [r7, #8]
  206084:	42b3      	cmp	r3, r6
  206086:	d002      	beq.n	20608e <chMtxUnlock+0x2e>
  chDbgCheck(mp != NULL);
  206088:	4820      	ldr	r0, [pc, #128]	; (20610c <chMtxUnlock+0xac>)
  20608a:	f7fa fd71 	bl	200b70 <chSysHalt>
    chDbgAssert(ctp->mtxlist == mp, "not next in list");
  20608e:	42af      	cmp	r7, r5
  206090:	d1fa      	bne.n	206088 <chMtxUnlock+0x28>
    ctp->mtxlist = mp->next;
  206092:	68ec      	ldr	r4, [r5, #12]
  206094:	63b4      	str	r4, [r6, #56]	; 0x38
  206096:	f7fa fe6b 	bl	200d70 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
  20609a:	f8d5 9000 	ldr.w	r9, [r5]
    if (chMtxQueueNotEmptyS(mp)) {
  20609e:	454d      	cmp	r5, r9
  2060a0:	d02e      	beq.n	206100 <chMtxUnlock+0xa0>
      tprio_t newprio = ctp->realprio;
  2060a2:	6bf7      	ldr	r7, [r6, #60]	; 0x3c
      while (lmp != NULL) {
  2060a4:	b15c      	cbz	r4, 2060be <chMtxUnlock+0x5e>
  2060a6:	f7fa fe63 	bl	200d70 <chDbgCheckClassS>
  2060aa:	6823      	ldr	r3, [r4, #0]
        if (chMtxQueueNotEmptyS(lmp) &&
  2060ac:	429c      	cmp	r4, r3
  2060ae:	d003      	beq.n	2060b8 <chMtxUnlock+0x58>
  2060b0:	689b      	ldr	r3, [r3, #8]
  2060b2:	429f      	cmp	r7, r3
  2060b4:	bf38      	it	cc
  2060b6:	461f      	movcc	r7, r3
        lmp = lmp->next;
  2060b8:	68e4      	ldr	r4, [r4, #12]
      while (lmp != NULL) {
  2060ba:	2c00      	cmp	r4, #0
  2060bc:	d1f3      	bne.n	2060a6 <chMtxUnlock+0x46>
  tqp->next             = tp->queue.next;
  2060be:	f8d9 3000 	ldr.w	r3, [r9]
      (void) chSchReadyI(tp);
  2060c2:	4648      	mov	r0, r9
      mp->next = tp->mtxlist;
  2060c4:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
      ctp->prio = newprio;
  2060c8:	60b7      	str	r7, [r6, #8]
  2060ca:	602b      	str	r3, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  2060cc:	605d      	str	r5, [r3, #4]
      mp->next = tp->mtxlist;
  2060ce:	e9c5 9202 	strd	r9, r2, [r5, #8]
      tp->mtxlist = mp;
  2060d2:	f8c9 5038 	str.w	r5, [r9, #56]	; 0x38
      (void) chSchReadyI(tp);
  2060d6:	f7fa ff0b 	bl	200ef0 <chSchReadyI>
      chSchRescheduleS();
  2060da:	f7fd fdd1 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  2060de:	f7fd fde7 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2060e2:	f8d8 3000 	ldr.w	r3, [r8]
  2060e6:	4543      	cmp	r3, r8
  2060e8:	d005      	beq.n	2060f6 <chMtxUnlock+0x96>
  2060ea:	f8d8 2018 	ldr.w	r2, [r8, #24]
  2060ee:	689b      	ldr	r3, [r3, #8]
  2060f0:	6892      	ldr	r2, [r2, #8]
  2060f2:	429a      	cmp	r2, r3
  2060f4:	d307      	bcc.n	206106 <chMtxUnlock+0xa6>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2060f6:	2300      	movs	r3, #0
  2060f8:	f383 8811 	msr	BASEPRI, r3
}
  2060fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      mp->owner = NULL;
  206100:	2300      	movs	r3, #0
  206102:	60bb      	str	r3, [r7, #8]
  206104:	e7eb      	b.n	2060de <chMtxUnlock+0x7e>
  206106:	4802      	ldr	r0, [pc, #8]	; (206110 <chMtxUnlock+0xb0>)
  206108:	f7fa fd32 	bl	200b70 <chSysHalt>
  20610c:	0800be6c 	.word	0x0800be6c
  206110:	0800bc1c 	.word	0x0800bc1c
  206114:	20000dc8 	.word	0x20000dc8
	...

00206120 <rt_test_006_005_execute>:
static void rt_test_006_005_execute(void) {
  206120:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  206124:	4d5b      	ldr	r5, [pc, #364]	; (206294 <rt_test_006_005_execute+0x174>)
  test_set_step(2);
  206126:	2202      	movs	r2, #2
  206128:	4c5b      	ldr	r4, [pc, #364]	; (206298 <rt_test_006_005_execute+0x178>)
  return chThdGetSelfX()->prio;
  20612a:	69ab      	ldr	r3, [r5, #24]
  20612c:	6022      	str	r2, [r4, #0]
  20612e:	689e      	ldr	r6, [r3, #8]
    b = chMtxTryLock(&m1);
  206130:	f7fd fe9e 	bl	203e70 <chMtxTryLock.constprop.53>
    test_assert(b, "already locked");
  206134:	4959      	ldr	r1, [pc, #356]	; (20629c <rt_test_006_005_execute+0x17c>)
  206136:	f7fa fb43 	bl	2007c0 <_test_assert>
  20613a:	b108      	cbz	r0, 206140 <rt_test_006_005_execute+0x20>
}
  20613c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  test_set_step(3);
  206140:	2303      	movs	r3, #3
  206142:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
  206144:	f7fd fe94 	bl	203e70 <chMtxTryLock.constprop.53>
    test_assert(!b, "not locked");
  206148:	f080 0001 	eor.w	r0, r0, #1
  20614c:	4954      	ldr	r1, [pc, #336]	; (2062a0 <rt_test_006_005_execute+0x180>)
  20614e:	b2c0      	uxtb	r0, r0
  206150:	f7fa fb36 	bl	2007c0 <_test_assert>
  206154:	2800      	cmp	r0, #0
  206156:	d1f1      	bne.n	20613c <rt_test_006_005_execute+0x1c>
    chMtxUnlock(&m1);
  206158:	4f52      	ldr	r7, [pc, #328]	; (2062a4 <rt_test_006_005_execute+0x184>)
  test_set_step(4);
  20615a:	2304      	movs	r3, #4
    chMtxUnlock(&m1);
  20615c:	4638      	mov	r0, r7
  test_set_step(4);
  20615e:	6023      	str	r3, [r4, #0]
    chMtxUnlock(&m1);
  206160:	f7ff ff7e 	bl	206060 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
  206164:	68b8      	ldr	r0, [r7, #8]
  206166:	4950      	ldr	r1, [pc, #320]	; (2062a8 <rt_test_006_005_execute+0x188>)
  206168:	fab0 f080 	clz	r0, r0
  20616c:	0940      	lsrs	r0, r0, #5
  20616e:	f7fa fb27 	bl	2007c0 <_test_assert>
  206172:	2800      	cmp	r0, #0
  206174:	d1e2      	bne.n	20613c <rt_test_006_005_execute+0x1c>
  return (bool)(tqp->next == (const thread_t *)tqp);
  206176:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  206178:	494c      	ldr	r1, [pc, #304]	; (2062ac <rt_test_006_005_execute+0x18c>)
  20617a:	1bc0      	subs	r0, r0, r7
  20617c:	fab0 f080 	clz	r0, r0
  206180:	0940      	lsrs	r0, r0, #5
  206182:	f7fa fb1d 	bl	2007c0 <_test_assert>
  206186:	2800      	cmp	r0, #0
  206188:	d1d8      	bne.n	20613c <rt_test_006_005_execute+0x1c>
  20618a:	69aa      	ldr	r2, [r5, #24]
  test_set_step(5);
  20618c:	2305      	movs	r3, #5
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  20618e:	4948      	ldr	r1, [pc, #288]	; (2062b0 <rt_test_006_005_execute+0x190>)
  206190:	6890      	ldr	r0, [r2, #8]
  test_set_step(5);
  206192:	6023      	str	r3, [r4, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  206194:	1b80      	subs	r0, r0, r6
  206196:	fab0 f080 	clz	r0, r0
  20619a:	0940      	lsrs	r0, r0, #5
  20619c:	f7fa fb10 	bl	2007c0 <_test_assert>
  2061a0:	2800      	cmp	r0, #0
  2061a2:	d1cb      	bne.n	20613c <rt_test_006_005_execute+0x1c>
  test_set_step(6);
  2061a4:	2306      	movs	r3, #6
  2061a6:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
  2061a8:	f7fd fe62 	bl	203e70 <chMtxTryLock.constprop.53>
    test_assert(b, "already locked");
  2061ac:	493b      	ldr	r1, [pc, #236]	; (20629c <rt_test_006_005_execute+0x17c>)
  2061ae:	f7fa fb07 	bl	2007c0 <_test_assert>
  2061b2:	2800      	cmp	r0, #0
  2061b4:	d1c2      	bne.n	20613c <rt_test_006_005_execute+0x1c>
    b = chMtxTryLock(&m1);
  2061b6:	f7fd fe5b 	bl	203e70 <chMtxTryLock.constprop.53>
    test_assert(!b, "not locked");
  2061ba:	f080 0001 	eor.w	r0, r0, #1
  2061be:	4938      	ldr	r1, [pc, #224]	; (2062a0 <rt_test_006_005_execute+0x180>)
  2061c0:	b2c0      	uxtb	r0, r0
  2061c2:	f7fa fafd 	bl	2007c0 <_test_assert>
  2061c6:	4682      	mov	sl, r0
  2061c8:	2800      	cmp	r0, #0
  2061ca:	d1b7      	bne.n	20613c <rt_test_006_005_execute+0x1c>
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
  2061cc:	f8d5 9018 	ldr.w	r9, [r5, #24]
  __ASM volatile ("cpsid i" : : : "memory");
  2061d0:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2061d2:	2320      	movs	r3, #32
  2061d4:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2061d8:	b662      	cpsie	i
  _dbg_check_lock();
  2061da:	f7fd fdb9 	bl	203d50 <_dbg_check_lock>

  chSysLock();
  if (ctp->mtxlist != NULL) {
  2061de:	f8d9 8038 	ldr.w	r8, [r9, #56]	; 0x38
  2061e2:	f1b8 0f00 	cmp.w	r8, #0
  2061e6:	d021      	beq.n	20622c <rt_test_006_005_execute+0x10c>
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
  2061e8:	f8d8 b00c 	ldr.w	fp, [r8, #12]
  2061ec:	f8c9 b038 	str.w	fp, [r9, #56]	; 0x38
  2061f0:	f7fa fdbe 	bl	200d70 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
  2061f4:	f8d8 3000 	ldr.w	r3, [r8]
      if (chMtxQueueNotEmptyS(mp)) {
  2061f8:	4598      	cmp	r8, r3
  2061fa:	d044      	beq.n	206286 <rt_test_006_005_execute+0x166>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
  2061fc:	6b99      	ldr	r1, [r3, #56]	; 0x38
        tp->mtxlist = mp;
        (void) chSchReadyI(tp);
  2061fe:	4618      	mov	r0, r3
  tqp->next             = tp->queue.next;
  206200:	681a      	ldr	r2, [r3, #0]
  206202:	f8c8 2000 	str.w	r2, [r8]
  tqp->next->queue.prev = (thread_t *)tqp;
  206206:	f8c2 8004 	str.w	r8, [r2, #4]
        mp->next = tp->mtxlist;
  20620a:	e9c8 3102 	strd	r3, r1, [r8, #8]
        tp->mtxlist = mp;
  20620e:	f8c3 8038 	str.w	r8, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
  206212:	f7fa fe6d 	bl	200ef0 <chSchReadyI>
  206216:	f8d9 8038 	ldr.w	r8, [r9, #56]	; 0x38
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
      }
    } while (ctp->mtxlist != NULL);
  20621a:	f1b8 0f00 	cmp.w	r8, #0
  20621e:	d1e3      	bne.n	2061e8 <rt_test_006_005_execute+0xc8>
    ctp->prio = ctp->realprio;
  206220:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
  206224:	f8c9 3008 	str.w	r3, [r9, #8]
    chSchRescheduleS();
  206228:	f7fd fd2a 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  20622c:	f7fd fd40 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  206230:	682b      	ldr	r3, [r5, #0]
  206232:	42ab      	cmp	r3, r5
  206234:	d004      	beq.n	206240 <rt_test_006_005_execute+0x120>
  206236:	69aa      	ldr	r2, [r5, #24]
  206238:	689b      	ldr	r3, [r3, #8]
  20623a:	6892      	ldr	r2, [r2, #8]
  20623c:	429a      	cmp	r2, r3
  20623e:	d326      	bcc.n	20628e <rt_test_006_005_execute+0x16e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  206240:	2300      	movs	r3, #0
  206242:	f383 8811 	msr	BASEPRI, r3
    test_assert(m1.owner == NULL, "still owned");
  206246:	68b8      	ldr	r0, [r7, #8]
  206248:	4917      	ldr	r1, [pc, #92]	; (2062a8 <rt_test_006_005_execute+0x188>)
  20624a:	fab0 f080 	clz	r0, r0
  20624e:	0940      	lsrs	r0, r0, #5
  206250:	f7fa fab6 	bl	2007c0 <_test_assert>
  206254:	2800      	cmp	r0, #0
  206256:	f47f af71 	bne.w	20613c <rt_test_006_005_execute+0x1c>
  return (bool)(tqp->next == (const thread_t *)tqp);
  20625a:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  20625c:	4913      	ldr	r1, [pc, #76]	; (2062ac <rt_test_006_005_execute+0x18c>)
  20625e:	1bc2      	subs	r2, r0, r7
  206260:	4250      	negs	r0, r2
  206262:	4150      	adcs	r0, r2
  206264:	f7fa faac 	bl	2007c0 <_test_assert>
  206268:	2800      	cmp	r0, #0
  20626a:	f47f af67 	bne.w	20613c <rt_test_006_005_execute+0x1c>
  20626e:	69aa      	ldr	r2, [r5, #24]
  test_set_step(7);
  206270:	2307      	movs	r3, #7
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  206272:	490f      	ldr	r1, [pc, #60]	; (2062b0 <rt_test_006_005_execute+0x190>)
  206274:	6890      	ldr	r0, [r2, #8]
  test_set_step(7);
  206276:	6023      	str	r3, [r4, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  206278:	1b83      	subs	r3, r0, r6
  20627a:	4258      	negs	r0, r3
  20627c:	4158      	adcs	r0, r3
}
  20627e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  206282:	f7fa ba9d 	b.w	2007c0 <_test_assert>
        mp->owner = NULL;
  206286:	f8c8 a008 	str.w	sl, [r8, #8]
  20628a:	46d8      	mov	r8, fp
  20628c:	e7c5      	b.n	20621a <rt_test_006_005_execute+0xfa>
  20628e:	4809      	ldr	r0, [pc, #36]	; (2062b4 <rt_test_006_005_execute+0x194>)
  206290:	f7fa fc6e 	bl	200b70 <chSysHalt>
  206294:	20000dc8 	.word	0x20000dc8
  206298:	20001f6c 	.word	0x20001f6c
  20629c:	0800d700 	.word	0x0800d700
  2062a0:	0800d710 	.word	0x0800d710
  2062a4:	20010438 	.word	0x20010438
  2062a8:	0800d71c 	.word	0x0800d71c
  2062ac:	0800d728 	.word	0x0800d728
  2062b0:	0800d738 	.word	0x0800d738
  2062b4:	0800bc1c 	.word	0x0800bc1c
	...

002062c0 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
  2062c0:	b510      	push	{r4, lr}
  2062c2:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  2062c4:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2062c6:	2320      	movs	r3, #32
  2062c8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2062cc:	b662      	cpsie	i
  _dbg_check_lock();
  2062ce:	f7fd fd3f 	bl	203d50 <_dbg_check_lock>
  chMtxLockS(mp);
  2062d2:	4620      	mov	r0, r4
  2062d4:	f7fd f90c 	bl	2034f0 <chMtxLockS>
  _dbg_check_unlock();
  2062d8:	f7fd fcea 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2062dc:	4b07      	ldr	r3, [pc, #28]	; (2062fc <chMtxLock+0x3c>)
  2062de:	681a      	ldr	r2, [r3, #0]
  2062e0:	429a      	cmp	r2, r3
  2062e2:	d004      	beq.n	2062ee <chMtxLock+0x2e>
  2062e4:	6999      	ldr	r1, [r3, #24]
  2062e6:	6893      	ldr	r3, [r2, #8]
  2062e8:	688a      	ldr	r2, [r1, #8]
  2062ea:	429a      	cmp	r2, r3
  2062ec:	d303      	bcc.n	2062f6 <chMtxLock+0x36>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2062ee:	2300      	movs	r3, #0
  2062f0:	f383 8811 	msr	BASEPRI, r3
}
  2062f4:	bd10      	pop	{r4, pc}
  2062f6:	4802      	ldr	r0, [pc, #8]	; (206300 <chMtxLock+0x40>)
  2062f8:	f7fa fc3a 	bl	200b70 <chSysHalt>
  2062fc:	20000dc8 	.word	0x20000dc8
  206300:	0800bc1c 	.word	0x0800bc1c
	...

00206310 <chHeapAllocAligned.constprop.32>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
  206310:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  heap_header_t *qp, *hp, *ahp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
  206314:	2900      	cmp	r1, #0
  206316:	d03c      	beq.n	206392 <chHeapAllocAligned.constprop.32+0x82>

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
  206318:	4b3b      	ldr	r3, [pc, #236]	; (206408 <chHeapAllocAligned.constprop.32+0xf8>)
  20631a:	4606      	mov	r6, r0
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
  20631c:	f101 0807 	add.w	r8, r1, #7
  206320:	460d      	mov	r5, r1
    heapp = &default_heap;
  206322:	2800      	cmp	r0, #0
  206324:	bf08      	it	eq
  206326:	461e      	moveq	r6, r3
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
  206328:	ea4f 08d8 	mov.w	r8, r8, lsr #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
  20632c:	f106 070c 	add.w	r7, r6, #12
  206330:	4638      	mov	r0, r7
  206332:	f7ff ffc5 	bl	2062c0 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  206336:	1d31      	adds	r1, r6, #4
  while (H_NEXT(qp) != NULL) {
  206338:	680b      	ldr	r3, [r1, #0]
  20633a:	b1c3      	cbz	r3, 20636e <chHeapAllocAligned.constprop.32+0x5e>

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
  20633c:	f103 000f 	add.w	r0, r3, #15

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
  206340:	f8d3 e004 	ldr.w	lr, [r3, #4]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
  206344:	f103 0908 	add.w	r9, r3, #8
  206348:	f020 0007 	bic.w	r0, r0, #7
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
  20634c:	f10e 0201 	add.w	r2, lr, #1
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
  206350:	f1a0 0c08 	sub.w	ip, r0, #8
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
  206354:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
  206358:	4594      	cmp	ip, r2
  20635a:	d204      	bcs.n	206366 <chHeapAllocAligned.constprop.32+0x56>
  20635c:	4604      	mov	r4, r0
  20635e:	1a10      	subs	r0, r2, r0
  206360:	10c0      	asrs	r0, r0, #3
  206362:	4580      	cmp	r8, r0
  206364:	d918      	bls.n	206398 <chHeapAllocAligned.constprop.32+0x88>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
  206366:	4619      	mov	r1, r3
  while (H_NEXT(qp) != NULL) {
  206368:	680b      	ldr	r3, [r1, #0]
  20636a:	2b00      	cmp	r3, #0
  20636c:	d1e6      	bne.n	20633c <chHeapAllocAligned.constprop.32+0x2c>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
  20636e:	4638      	mov	r0, r7
  206370:	f7ff fe76 	bl	206060 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
  206374:	6834      	ldr	r4, [r6, #0]
  206376:	b14c      	cbz	r4, 20638c <chHeapAllocAligned.constprop.32+0x7c>
    ahp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT,
  206378:	2208      	movs	r2, #8
  20637a:	f108 0001 	add.w	r0, r8, #1
  20637e:	4611      	mov	r1, r2
  206380:	00c0      	lsls	r0, r0, #3
  206382:	47a0      	blx	r4
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
  206384:	4604      	mov	r4, r0
  206386:	b108      	cbz	r0, 20638c <chHeapAllocAligned.constprop.32+0x7c>
      hp = ahp - 1U;
      H_HEAP(hp) = heapp;
      H_SIZE(hp) = size;
  206388:	e940 6502 	strd	r6, r5, [r0, #-8]
      /*lint -restore*/
    }
  }

  return NULL;
}
  20638c:	4620      	mov	r0, r4
  20638e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
  206392:	481e      	ldr	r0, [pc, #120]	; (20640c <chHeapAllocAligned.constprop.32+0xfc>)
  206394:	f7fa fbec 	bl	200b70 <chSysHalt>
      if (ahp > hp) {
  206398:	4563      	cmp	r3, ip
  20639a:	d31b      	bcc.n	2063d4 <chHeapAllocAligned.constprop.32+0xc4>
        if (H_PAGES(hp) == pages) {
  20639c:	45f0      	cmp	r8, lr
  20639e:	f8d3 a000 	ldr.w	sl, [r3]
  2063a2:	d02c      	beq.n	2063fe <chHeapAllocAligned.constprop.32+0xee>
          fp = H_BLOCK(hp) + pages;
  2063a4:	f108 0801 	add.w	r8, r8, #1
          H_NEXT(qp) = fp;
  2063a8:	469c      	mov	ip, r3
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
  2063aa:	464c      	mov	r4, r9
          fp = H_BLOCK(hp) + pages;
  2063ac:	eb03 00c8 	add.w	r0, r3, r8, lsl #3
          H_NEXT(fp) = H_NEXT(hp);
  2063b0:	f843 a038 	str.w	sl, [r3, r8, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
  2063b4:	f100 0308 	add.w	r3, r0, #8
  2063b8:	1ad3      	subs	r3, r2, r3
  2063ba:	10db      	asrs	r3, r3, #3
  2063bc:	6043      	str	r3, [r0, #4]
          H_NEXT(qp) = fp;
  2063be:	6008      	str	r0, [r1, #0]
      H_UNLOCK(heapp);
  2063c0:	4638      	mov	r0, r7
      H_SIZE(hp) = size;
  2063c2:	f8cc 5004 	str.w	r5, [ip, #4]
      H_HEAP(hp) = heapp;
  2063c6:	f8cc 6000 	str.w	r6, [ip]
      H_UNLOCK(heapp);
  2063ca:	f7ff fe49 	bl	206060 <chMtxUnlock>
}
  2063ce:	4620      	mov	r0, r4
  2063d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
  2063d4:	ebac 0909 	sub.w	r9, ip, r9
        if (bpages > pages) {
  2063d8:	4580      	cmp	r8, r0
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
  2063da:	ea4f 02e9 	mov.w	r2, r9, asr #3
  2063de:	605a      	str	r2, [r3, #4]
        if (bpages > pages) {
  2063e0:	d2ee      	bcs.n	2063c0 <chHeapAllocAligned.constprop.32+0xb0>
          fp = H_BLOCK(ahp) + pages;
  2063e2:	f108 0101 	add.w	r1, r8, #1
          H_PAGES(fp) = (bpages - pages) - 1U;
  2063e6:	ea6f 0808 	mvn.w	r8, r8
          H_NEXT(fp) = H_NEXT(hp);
  2063ea:	f8d3 e000 	ldr.w	lr, [r3]
          fp = H_BLOCK(ahp) + pages;
  2063ee:	eb0c 02c1 	add.w	r2, ip, r1, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
  2063f2:	4440      	add	r0, r8
  2063f4:	6050      	str	r0, [r2, #4]
          H_NEXT(fp) = H_NEXT(hp);
  2063f6:	f84c e031 	str.w	lr, [ip, r1, lsl #3]
          H_NEXT(hp) = fp;
  2063fa:	601a      	str	r2, [r3, #0]
  2063fc:	e7e0      	b.n	2063c0 <chHeapAllocAligned.constprop.32+0xb0>
          H_NEXT(qp) = H_NEXT(hp);
  2063fe:	f8c1 a000 	str.w	sl, [r1]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
  206402:	464c      	mov	r4, r9
          H_NEXT(qp) = H_NEXT(hp);
  206404:	469c      	mov	ip, r3
  206406:	e7db      	b.n	2063c0 <chHeapAllocAligned.constprop.32+0xb0>
  206408:	20001778 	.word	0x20001778
  20640c:	0800be04 	.word	0x0800be04

00206410 <dyn_create_object_heap>:
                                             size_t size) {
  206410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_element_t *p = dlp->next;
  206412:	680c      	ldr	r4, [r1, #0]
                                             size_t size) {
  206414:	460d      	mov	r5, r1
  206416:	4606      	mov	r6, r0
  206418:	4617      	mov	r7, r2
  while (p != (dyn_element_t *)dlp) {
  20641a:	42a1      	cmp	r1, r4
  20641c:	d103      	bne.n	206426 <dyn_create_object_heap+0x16>
  20641e:	e00d      	b.n	20643c <dyn_create_object_heap+0x2c>
    p = p->next;
  206420:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
  206422:	42a5      	cmp	r5, r4
  206424:	d00a      	beq.n	20643c <dyn_create_object_heap+0x2c>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
  206426:	2208      	movs	r2, #8
  206428:	4631      	mov	r1, r6
  20642a:	18a0      	adds	r0, r4, r2
  20642c:	f005 fb20 	bl	20ba70 <strncmp>
  206430:	2800      	cmp	r0, #0
  206432:	d1f5      	bne.n	206420 <dyn_create_object_heap+0x10>
  if (dep != NULL) {
  206434:	b114      	cbz	r4, 20643c <dyn_create_object_heap+0x2c>
    return NULL;
  206436:	4604      	mov	r4, r0
}
  206438:	4620      	mov	r0, r4
  20643a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
  20643c:	4639      	mov	r1, r7
  20643e:	2000      	movs	r0, #0
  206440:	f7ff ff66 	bl	206310 <chHeapAllocAligned.constprop.32>
  if (dep == NULL) {
  206444:	4604      	mov	r4, r0
  206446:	b148      	cbz	r0, 20645c <dyn_create_object_heap+0x4c>
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
  206448:	2208      	movs	r2, #8
  20644a:	4631      	mov	r1, r6
  20644c:	4410      	add	r0, r2
  20644e:	f005 fb5b 	bl	20bb08 <strncpy>
  dep->next = dlp->next;
  206452:	682b      	ldr	r3, [r5, #0]
  dep->refs = (ucnt_t)1;
  206454:	2201      	movs	r2, #1
  dep->next = dlp->next;
  206456:	e9c4 3200 	strd	r3, r2, [r4]
  dlp->next = dep;
  20645a:	602c      	str	r4, [r5, #0]
}
  20645c:	4620      	mov	r0, r4
  20645e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00206460 <chThdCreateFromHeap>:
                              tfunc_t pf, void *arg) {
  206460:	b570      	push	{r4, r5, r6, lr}
  206462:	b086      	sub	sp, #24
  206464:	4616      	mov	r6, r2
  206466:	461d      	mov	r5, r3
  206468:	460c      	mov	r4, r1
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  20646a:	f7ff ff51 	bl	206310 <chHeapAllocAligned.constprop.32>
  if (wsp == NULL) {
  20646e:	2800      	cmp	r0, #0
  206470:	d034      	beq.n	2064dc <chThdCreateFromHeap+0x7c>
    (stkalign_t *)((uint8_t *)wsp + size),
  206472:	4404      	add	r4, r0
  thread_descriptor_t td = {
  206474:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  206476:	4284      	cmp	r4, r0
  206478:	9304      	str	r3, [sp, #16]
  20647a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  20647c:	e9cd 6000 	strd	r6, r0, [sp]
  206480:	e9cd 4502 	strd	r4, r5, [sp, #8]
  206484:	9305      	str	r3, [sp, #20]
  206486:	d904      	bls.n	206492 <chThdCreateFromHeap+0x32>
    *startp++ = v;
  206488:	2355      	movs	r3, #85	; 0x55
  20648a:	f800 3b01 	strb.w	r3, [r0], #1
  while (startp < endp) {
  20648e:	4284      	cmp	r4, r0
  206490:	d1fb      	bne.n	20648a <chThdCreateFromHeap+0x2a>
  __ASM volatile ("cpsid i" : : : "memory");
  206492:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  206494:	2320      	movs	r3, #32
  206496:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20649a:	b662      	cpsie	i
  _dbg_check_lock();
  20649c:	f7fd fc58 	bl	203d50 <_dbg_check_lock>
  tp = chThdCreateSuspendedI(&td);
  2064a0:	4668      	mov	r0, sp
  2064a2:	f7fa fccd 	bl	200e40 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
  2064a6:	2301      	movs	r3, #1
  chSchWakeupS(tp, MSG_OK);
  2064a8:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(&td);
  2064aa:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_HEAP;
  2064ac:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
  2064b0:	f7fc ffbe 	bl	203430 <chSchWakeupS>
  _dbg_check_unlock();
  2064b4:	f7fd fbfc 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2064b8:	4b09      	ldr	r3, [pc, #36]	; (2064e0 <chThdCreateFromHeap+0x80>)
  2064ba:	681a      	ldr	r2, [r3, #0]
  2064bc:	429a      	cmp	r2, r3
  2064be:	d004      	beq.n	2064ca <chThdCreateFromHeap+0x6a>
  2064c0:	6999      	ldr	r1, [r3, #24]
  2064c2:	6893      	ldr	r3, [r2, #8]
  2064c4:	688a      	ldr	r2, [r1, #8]
  2064c6:	429a      	cmp	r2, r3
  2064c8:	d305      	bcc.n	2064d6 <chThdCreateFromHeap+0x76>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2064ca:	2300      	movs	r3, #0
  2064cc:	f383 8811 	msr	BASEPRI, r3
}
  2064d0:	4620      	mov	r0, r4
  2064d2:	b006      	add	sp, #24
  2064d4:	bd70      	pop	{r4, r5, r6, pc}
  2064d6:	4803      	ldr	r0, [pc, #12]	; (2064e4 <chThdCreateFromHeap+0x84>)
  2064d8:	f7fa fb4a 	bl	200b70 <chSysHalt>
    return NULL;
  2064dc:	4604      	mov	r4, r0
  2064de:	e7f7      	b.n	2064d0 <chThdCreateFromHeap+0x70>
  2064e0:	20000dc8 	.word	0x20000dc8
  2064e4:	0800bc4c 	.word	0x0800bc4c
	...

002064f0 <chFactoryRegisterObject.constprop.14>:
 * @retval NULL         if the object to be registered cannot be allocated or
 *                      a registered object with the same name exists.
 *
 * @api
 */
registered_object_t *chFactoryRegisterObject(const char *name,
  2064f0:	b538      	push	{r3, r4, r5, lr}
  2064f2:	4605      	mov	r5, r0
                                             void *objp) {
  registered_object_t *rop;

  F_LOCK();
  2064f4:	4807      	ldr	r0, [pc, #28]	; (206514 <chFactoryRegisterObject.constprop.14+0x24>)
  2064f6:	f7ff fee3 	bl	2062c0 <chMtxLock>

  rop = (registered_object_t *)dyn_create_object_pool(name,
  2064fa:	4a07      	ldr	r2, [pc, #28]	; (206518 <chFactoryRegisterObject.constprop.14+0x28>)
  2064fc:	4807      	ldr	r0, [pc, #28]	; (20651c <chFactoryRegisterObject.constprop.14+0x2c>)
  2064fe:	1f11      	subs	r1, r2, #4
  206500:	f7ff fbbe 	bl	205c80 <dyn_create_object_pool>
                                                      &ch_factory.obj_list,
                                                      &ch_factory.obj_pool);
  if (rop != NULL) {
  206504:	4604      	mov	r4, r0
  206506:	b100      	cbz	r0, 20650a <chFactoryRegisterObject.constprop.14+0x1a>
    /* Initializing registered object data.*/
    rop->objp = objp;
  206508:	6105      	str	r5, [r0, #16]
  }

  F_UNLOCK();
  20650a:	4802      	ldr	r0, [pc, #8]	; (206514 <chFactoryRegisterObject.constprop.14+0x24>)
  20650c:	f7ff fda8 	bl	206060 <chMtxUnlock>

  return rop;
}
  206510:	4620      	mov	r0, r4
  206512:	bd38      	pop	{r3, r4, r5, pc}
  206514:	20001650 	.word	0x20001650
  206518:	20001664 	.word	0x20001664
  20651c:	0800c220 	.word	0x0800c220

00206520 <chFactoryFindObject.constprop.13>:
 * @retval NULL         if a registered object with the specified name
 *                      does not exist.
 *
 * @api
 */
registered_object_t *chFactoryFindObject(const char *name) {
  206520:	b538      	push	{r3, r4, r5, lr}
  registered_object_t *rop;

  F_LOCK();
  206522:	4c07      	ldr	r4, [pc, #28]	; (206540 <chFactoryFindObject.constprop.13+0x20>)
  206524:	4620      	mov	r0, r4
  206526:	f7ff fecb 	bl	2062c0 <chMtxLock>

  rop = (registered_object_t *)dyn_find_object(name, &ch_factory.obj_list);
  20652a:	f104 0110 	add.w	r1, r4, #16
  20652e:	4805      	ldr	r0, [pc, #20]	; (206544 <chFactoryFindObject.constprop.13+0x24>)
  206530:	f7fc ff5e 	bl	2033f0 <dyn_find_object>
  206534:	4605      	mov	r5, r0

  F_UNLOCK();
  206536:	4620      	mov	r0, r4
  206538:	f7ff fd92 	bl	206060 <chMtxUnlock>

  return rop;
}
  20653c:	4628      	mov	r0, r5
  20653e:	bd38      	pop	{r3, r4, r5, pc}
  206540:	20001650 	.word	0x20001650
  206544:	0800c220 	.word	0x0800c220
	...

00206550 <chFactoryCreateBuffer.constprop.12>:
 * @retval NULL         if the dynamic buffer object cannot be allocated or
 *                      a dynamic buffer object with the same name exists.
 *
 * @api
 */
dyn_buffer_t *chFactoryCreateBuffer(const char *name, size_t size) {
  206550:	b510      	push	{r4, lr}
  dyn_buffer_t *dbp;

  F_LOCK();
  206552:	480a      	ldr	r0, [pc, #40]	; (20657c <chFactoryCreateBuffer.constprop.12+0x2c>)
  206554:	f7ff feb4 	bl	2062c0 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_create_object_heap(name,
  206558:	2280      	movs	r2, #128	; 0x80
  20655a:	4909      	ldr	r1, [pc, #36]	; (206580 <chFactoryCreateBuffer.constprop.12+0x30>)
  20655c:	4809      	ldr	r0, [pc, #36]	; (206584 <chFactoryCreateBuffer.constprop.12+0x34>)
  20655e:	f7ff ff57 	bl	206410 <dyn_create_object_heap>
                                               &ch_factory.buf_list,
                                               size);
  if (dbp != NULL) {
  206562:	4604      	mov	r4, r0
  206564:	b120      	cbz	r0, 206570 <chFactoryCreateBuffer.constprop.12+0x20>
    /* Initializing buffer object data.*/
    memset((void *)dbp->buffer, 0, size);
  206566:	2280      	movs	r2, #128	; 0x80
  206568:	2100      	movs	r1, #0
  20656a:	3010      	adds	r0, #16
  20656c:	f005 f9c2 	bl	20b8f4 <memset>
  }

  F_UNLOCK();
  206570:	4802      	ldr	r0, [pc, #8]	; (20657c <chFactoryCreateBuffer.constprop.12+0x2c>)
  206572:	f7ff fd75 	bl	206060 <chMtxUnlock>

  return dbp;
}
  206576:	4620      	mov	r0, r4
  206578:	bd10      	pop	{r4, pc}
  20657a:	bf00      	nop
  20657c:	20001650 	.word	0x20001650
  206580:	20001674 	.word	0x20001674
  206584:	0800c200 	.word	0x0800c200
	...

00206590 <chFactoryFindBuffer.constprop.11>:
 * @retval NULL         if a dynamic buffer object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
  206590:	b538      	push	{r3, r4, r5, lr}
  dyn_buffer_t *dbp;

  F_LOCK();
  206592:	4c07      	ldr	r4, [pc, #28]	; (2065b0 <chFactoryFindBuffer.constprop.11+0x20>)
  206594:	4620      	mov	r0, r4
  206596:	f7ff fe93 	bl	2062c0 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_find_object(name, &ch_factory.buf_list);
  20659a:	f104 0124 	add.w	r1, r4, #36	; 0x24
  20659e:	4805      	ldr	r0, [pc, #20]	; (2065b4 <chFactoryFindBuffer.constprop.11+0x24>)
  2065a0:	f7fc ff26 	bl	2033f0 <dyn_find_object>
  2065a4:	4605      	mov	r5, r0

  F_UNLOCK();
  2065a6:	4620      	mov	r0, r4
  2065a8:	f7ff fd5a 	bl	206060 <chMtxUnlock>

  return dbp;
}
  2065ac:	4628      	mov	r0, r5
  2065ae:	bd38      	pop	{r3, r4, r5, pc}
  2065b0:	20001650 	.word	0x20001650
  2065b4:	0800c200 	.word	0x0800c200
	...

002065c0 <chFactoryCreateSemaphore.constprop.10>:
 * @retval NULL         if the dynamic semaphore object cannot be allocated or
 *                      a dynamic semaphore with the same name exists.
 *
 * @api
 */
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
  2065c0:	b510      	push	{r4, lr}
  dyn_semaphore_t *dsp;

  F_LOCK();
  2065c2:	4809      	ldr	r0, [pc, #36]	; (2065e8 <chFactoryCreateSemaphore.constprop.10+0x28>)
  2065c4:	f7ff fe7c 	bl	2062c0 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_create_object_pool(name,
  2065c8:	4a08      	ldr	r2, [pc, #32]	; (2065ec <chFactoryCreateSemaphore.constprop.10+0x2c>)
  2065ca:	4809      	ldr	r0, [pc, #36]	; (2065f0 <chFactoryCreateSemaphore.constprop.10+0x30>)
  2065cc:	1f11      	subs	r1, r2, #4
  2065ce:	f7ff fb57 	bl	205c80 <dyn_create_object_pool>
                                                  &ch_factory.sem_list,
                                                  &ch_factory.sem_pool);
  if (dsp != NULL) {
  2065d2:	4604      	mov	r4, r0
  2065d4:	b118      	cbz	r0, 2065de <chFactoryCreateSemaphore.constprop.10+0x1e>
    /* Initializing semaphore object dataa.*/
    chSemObjectInit(&dsp->sem, n);
  2065d6:	2100      	movs	r1, #0
  2065d8:	3010      	adds	r0, #16
  2065da:	f7fa fb71 	bl	200cc0 <chSemObjectInit>
  }

  F_UNLOCK();
  2065de:	4802      	ldr	r0, [pc, #8]	; (2065e8 <chFactoryCreateSemaphore.constprop.10+0x28>)
  2065e0:	f7ff fd3e 	bl	206060 <chMtxUnlock>

  return dsp;
}
  2065e4:	4620      	mov	r0, r4
  2065e6:	bd10      	pop	{r4, pc}
  2065e8:	20001650 	.word	0x20001650
  2065ec:	2000167c 	.word	0x2000167c
  2065f0:	0800c218 	.word	0x0800c218
	...

00206600 <chFactoryFindSemaphore.constprop.9>:
 * @retval NULL         if a dynamic semaphore object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
  206600:	b538      	push	{r3, r4, r5, lr}
  dyn_semaphore_t *dsp;

  F_LOCK();
  206602:	4c07      	ldr	r4, [pc, #28]	; (206620 <chFactoryFindSemaphore.constprop.9+0x20>)
  206604:	4620      	mov	r0, r4
  206606:	f7ff fe5b 	bl	2062c0 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_find_object(name, &ch_factory.sem_list);
  20660a:	f104 0128 	add.w	r1, r4, #40	; 0x28
  20660e:	4805      	ldr	r0, [pc, #20]	; (206624 <chFactoryFindSemaphore.constprop.9+0x24>)
  206610:	f7fc feee 	bl	2033f0 <dyn_find_object>
  206614:	4605      	mov	r5, r0

  F_UNLOCK();
  206616:	4620      	mov	r0, r4
  206618:	f7ff fd22 	bl	206060 <chMtxUnlock>

  return dsp;
}
  20661c:	4628      	mov	r0, r5
  20661e:	bd38      	pop	{r3, r4, r5, pc}
  206620:	20001650 	.word	0x20001650
  206624:	0800c218 	.word	0x0800c218
	...

00206630 <chFactoryCreateMailbox.constprop.8>:
 * @retval NULL         if the dynamic mailbox object cannot be allocated or
 *                      a dynamic mailbox object with the same name exists.
 *
 * @api
 */
dyn_mailbox_t *chFactoryCreateMailbox(const char *name, size_t n) {
  206630:	b538      	push	{r3, r4, r5, lr}
  dyn_mailbox_t *dmp;

  F_LOCK();
  206632:	4811      	ldr	r0, [pc, #68]	; (206678 <chFactoryCreateMailbox.constprop.8+0x48>)
  206634:	f7ff fe44 	bl	2062c0 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
  206638:	2278      	movs	r2, #120	; 0x78
  20663a:	4910      	ldr	r1, [pc, #64]	; (20667c <chFactoryCreateMailbox.constprop.8+0x4c>)
  20663c:	4810      	ldr	r0, [pc, #64]	; (206680 <chFactoryCreateMailbox.constprop.8+0x50>)
  20663e:	f7ff fee7 	bl	206410 <dyn_create_object_heap>
                                                &ch_factory.mbx_list,
                                                sizeof (dyn_mailbox_t) +
                                                (n * sizeof (msg_t)));
  if (dmp != NULL) {
  206642:	4604      	mov	r4, r0
  206644:	b198      	cbz	r0, 20666e <chFactoryCreateMailbox.constprop.8+0x3e>
    /* Initializing mailbox object data.*/
    chMBObjectInit(&dmp->mbx, dmp->msgbuf, n);
  206646:	f100 0338 	add.w	r3, r0, #56	; 0x38
  mbp->top    = &buf[n];
  20664a:	f100 0578 	add.w	r5, r0, #120	; 0x78
  chThdQueueObjectInit(&mbp->qw);
  20664e:	f104 0128 	add.w	r1, r4, #40	; 0x28
  mbp->cnt    = (size_t)0;
  206652:	2000      	movs	r0, #0
  chThdQueueObjectInit(&mbp->qr);
  206654:	f104 0230 	add.w	r2, r4, #48	; 0x30
  mbp->buffer = buf;
  206658:	6123      	str	r3, [r4, #16]
  mbp->top    = &buf[n];
  20665a:	6165      	str	r5, [r4, #20]
  mbp->cnt    = (size_t)0;
  20665c:	6220      	str	r0, [r4, #32]
  mbp->reset  = false;
  20665e:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
  mbp->wrptr  = buf;
  206662:	e9c4 3306 	strd	r3, r3, [r4, #24]
  tqp->prev = (thread_t *)tqp;
  206666:	e9c4 110a 	strd	r1, r1, [r4, #40]	; 0x28
  20666a:	e9c4 220c 	strd	r2, r2, [r4, #48]	; 0x30
  }

  F_UNLOCK();
  20666e:	4802      	ldr	r0, [pc, #8]	; (206678 <chFactoryCreateMailbox.constprop.8+0x48>)
  206670:	f7ff fcf6 	bl	206060 <chMtxUnlock>

  return dmp;
}
  206674:	4620      	mov	r0, r4
  206676:	bd38      	pop	{r3, r4, r5, pc}
  206678:	20001650 	.word	0x20001650
  20667c:	2000168c 	.word	0x2000168c
  206680:	0800c208 	.word	0x0800c208
	...

00206690 <chFactoryFindMailbox.constprop.7>:
 * @retval NULL         if a dynamic mailbox object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
  206690:	b538      	push	{r3, r4, r5, lr}
  dyn_mailbox_t *dmp;

  F_LOCK();
  206692:	4c07      	ldr	r4, [pc, #28]	; (2066b0 <chFactoryFindMailbox.constprop.7+0x20>)
  206694:	4620      	mov	r0, r4
  206696:	f7ff fe13 	bl	2062c0 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_find_object(name, &ch_factory.mbx_list);
  20669a:	f104 013c 	add.w	r1, r4, #60	; 0x3c
  20669e:	4805      	ldr	r0, [pc, #20]	; (2066b4 <chFactoryFindMailbox.constprop.7+0x24>)
  2066a0:	f7fc fea6 	bl	2033f0 <dyn_find_object>
  2066a4:	4605      	mov	r5, r0

  F_UNLOCK();
  2066a6:	4620      	mov	r0, r4
  2066a8:	f7ff fcda 	bl	206060 <chMtxUnlock>

  return dmp;
}
  2066ac:	4628      	mov	r0, r5
  2066ae:	bd38      	pop	{r3, r4, r5, pc}
  2066b0:	20001650 	.word	0x20001650
  2066b4:	0800c208 	.word	0x0800c208
	...

002066c0 <chFactoryCreateObjectsFIFO.constprop.6>:
 *                      allocated or a dynamic "objects FIFO" object with
 *                      the same name exists.
 *
 * @api
 */
dyn_objects_fifo_t *chFactoryCreateObjectsFIFO(const char *name,
  2066c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                                               size_t objsize,
                                               size_t objn,
                                               unsigned objalign) {
  dyn_objects_fifo_t *dofp;

  F_LOCK();
  2066c4:	481c      	ldr	r0, [pc, #112]	; (206738 <chFactoryCreateObjectsFIFO.constprop.6+0x78>)
  2066c6:	f7ff fdfb 	bl	2062c0 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_create_object_heap(name,
  2066ca:	f44f 72ca 	mov.w	r2, #404	; 0x194
  2066ce:	491b      	ldr	r1, [pc, #108]	; (20673c <chFactoryCreateObjectsFIFO.constprop.6+0x7c>)
  2066d0:	481b      	ldr	r0, [pc, #108]	; (206740 <chFactoryCreateObjectsFIFO.constprop.6+0x80>)
  2066d2:	f7ff fe9d 	bl	206410 <dyn_create_object_heap>
                                                      &ch_factory.fifo_list,
                                                      sizeof (dyn_objects_fifo_t) +
                                                      (objn * sizeof (msg_t)) +
                                                      (objn * objsize));
  if (dofp != NULL) {
  2066d6:	4604      	mov	r4, r0
  2066d8:	b340      	cbz	r0, 20672c <chFactoryCreateObjectsFIFO.constprop.6+0x6c>
  mp->object_size = size;
  2066da:	2310      	movs	r3, #16
  mp->next = NULL;
  2066dc:	2100      	movs	r1, #0
  mp->align = align;
  2066de:	2204      	movs	r2, #4
    /* Initializing mailbox object data.*/
    chFifoObjectInit(&dofp->fifo, objsize, objn, objalign,
                     (void *)&dofp->msgbuf[objn], dofp->msgbuf);
  2066e0:	f100 0894 	add.w	r8, r0, #148	; 0x94
 */
static inline void chFifoObjectInit(objects_fifo_t *ofp, size_t objsize,
                                    size_t objn, unsigned objalign,
                                    void *objbuf, msg_t *msgbuf) {

  chGuardedPoolObjectInitAligned(&ofp->free, objsize, objalign);
  2066e4:	18c7      	adds	r7, r0, r3
  mp->object_size = size;
  2066e6:	6203      	str	r3, [r0, #32]
  mp->next = NULL;
  2066e8:	61e1      	str	r1, [r4, #28]
  chSemObjectInit(&gmp->sem, (cnt_t)0);
  2066ea:	461d      	mov	r5, r3
  2066ec:	4638      	mov	r0, r7
  2066ee:	4646      	mov	r6, r8
  mp->align = align;
  2066f0:	e9c4 2109 	strd	r2, r1, [r4, #36]	; 0x24
  chSemObjectInit(&gmp->sem, (cnt_t)0);
  2066f4:	f7fa fae4 	bl	200cc0 <chSemObjectInit>
  chGuardedPoolFree(gmp, objp);
  2066f8:	4631      	mov	r1, r6
  2066fa:	4638      	mov	r0, r7
  2066fc:	f7ff f8b8 	bl	205870 <chGuardedPoolFree>
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
  206700:	6a23      	ldr	r3, [r4, #32]
  while (n != 0U) {
  206702:	3d01      	subs	r5, #1
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
  206704:	441e      	add	r6, r3
  while (n != 0U) {
  206706:	d1f7      	bne.n	2066f8 <chFactoryCreateObjectsFIFO.constprop.6+0x38>
  206708:	f104 0354 	add.w	r3, r4, #84	; 0x54
  chThdQueueObjectInit(&mbp->qw);
  20670c:	f104 0144 	add.w	r1, r4, #68	; 0x44
  chThdQueueObjectInit(&mbp->qr);
  206710:	f104 024c 	add.w	r2, r4, #76	; 0x4c
  mbp->top    = &buf[n];
  206714:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
  mbp->cnt    = (size_t)0;
  206718:	63e5      	str	r5, [r4, #60]	; 0x3c
  mbp->reset  = false;
  20671a:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
  mbp->buffer = buf;
  20671e:	62e3      	str	r3, [r4, #44]	; 0x2c
  mbp->wrptr  = buf;
  206720:	e9c4 330d 	strd	r3, r3, [r4, #52]	; 0x34
  206724:	e9c4 1111 	strd	r1, r1, [r4, #68]	; 0x44
  206728:	e9c4 2213 	strd	r2, r2, [r4, #76]	; 0x4c
  }

  F_UNLOCK();
  20672c:	4802      	ldr	r0, [pc, #8]	; (206738 <chFactoryCreateObjectsFIFO.constprop.6+0x78>)
  20672e:	f7ff fc97 	bl	206060 <chMtxUnlock>

  return dofp;
}
  206732:	4620      	mov	r0, r4
  206734:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  206738:	20001650 	.word	0x20001650
  20673c:	20001690 	.word	0x20001690
  206740:	0800c210 	.word	0x0800c210
	...

00206750 <chFactoryFindObjectsFIFO.constprop.5>:
 * @retval NULL         if a dynamic "objects FIFO" object with the specified
 *                      name does not exist.
 *
 * @api
 */
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
  206750:	b538      	push	{r3, r4, r5, lr}
  dyn_objects_fifo_t *dofp;

  F_LOCK();
  206752:	4c07      	ldr	r4, [pc, #28]	; (206770 <chFactoryFindObjectsFIFO.constprop.5+0x20>)
  206754:	4620      	mov	r0, r4
  206756:	f7ff fdb3 	bl	2062c0 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_find_object(name, &ch_factory.fifo_list);
  20675a:	f104 0140 	add.w	r1, r4, #64	; 0x40
  20675e:	4805      	ldr	r0, [pc, #20]	; (206774 <chFactoryFindObjectsFIFO.constprop.5+0x24>)
  206760:	f7fc fe46 	bl	2033f0 <dyn_find_object>
  206764:	4605      	mov	r5, r0

  F_UNLOCK();
  206766:	4620      	mov	r0, r4
  206768:	f7ff fc7a 	bl	206060 <chMtxUnlock>

  return dofp;
}
  20676c:	4628      	mov	r0, r5
  20676e:	bd38      	pop	{r3, r4, r5, pc}
  206770:	20001650 	.word	0x20001650
  206774:	0800c210 	.word	0x0800c210
	...

00206780 <thread8>:
static THD_FUNCTION(thread8, p) {
  206780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  206782:	4607      	mov	r7, r0
  chMtxLock(&m2);
  206784:	4827      	ldr	r0, [pc, #156]	; (206824 <thread8+0xa4>)
  206786:	f7ff fd9b 	bl	2062c0 <chMtxLock>
  chMtxLock(&m1);
  20678a:	4827      	ldr	r0, [pc, #156]	; (206828 <thread8+0xa8>)
  20678c:	f7ff fd98 	bl	2062c0 <chMtxLock>
  __ASM volatile ("cpsid i" : : : "memory");
  206790:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  206792:	2320      	movs	r3, #32
  206794:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  206798:	b662      	cpsie	i
  return ch.rlist.current;
  20679a:	4d24      	ldr	r5, [pc, #144]	; (20682c <thread8+0xac>)
  _dbg_check_lock();
  20679c:	f7fd fad8 	bl	203d50 <_dbg_check_lock>
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
  2067a0:	69ab      	ldr	r3, [r5, #24]
  2067a2:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, sysinterval_t timeout) {
  mutex_t *mp = chMtxGetNextMutexX();
  msg_t msg;

  chDbgCheckClassS();
  2067a4:	f7fa fae4 	bl	200d70 <chDbgCheckClassS>
  chDbgCheck((cp != NULL) && (timeout != TIME_IMMEDIATE));
  chDbgAssert(mp != NULL, "not owning a mutex");
  2067a8:	2e00      	cmp	r6, #0
  2067aa:	d038      	beq.n	20681e <thread8+0x9e>

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
  2067ac:	4630      	mov	r0, r6
  2067ae:	f7fa fc77 	bl	2010a0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
  2067b2:	4b1f      	ldr	r3, [pc, #124]	; (206830 <thread8+0xb0>)
  2067b4:	69ac      	ldr	r4, [r5, #24]
  thread_t *cp = (thread_t *)tqp;
  2067b6:	4618      	mov	r0, r3
  2067b8:	6263      	str	r3, [r4, #36]	; 0x24
  2067ba:	e003      	b.n	2067c4 <thread8+0x44>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  2067bc:	6899      	ldr	r1, [r3, #8]
  2067be:	68a2      	ldr	r2, [r4, #8]
  2067c0:	4291      	cmp	r1, r2
  2067c2:	d302      	bcc.n	2067ca <thread8+0x4a>
    cp = cp->queue.next;
  2067c4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  2067c6:	4283      	cmp	r3, r0
  2067c8:	d1f8      	bne.n	2067bc <thread8+0x3c>
  tp->queue.prev             = cp->queue.prev;
  2067ca:	685a      	ldr	r2, [r3, #4]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
  2067cc:	f04f 31ff 	mov.w	r1, #4294967295
  tp->queue.next             = cp;
  2067d0:	6023      	str	r3, [r4, #0]
  2067d2:	2007      	movs	r0, #7
  tp->queue.prev             = cp->queue.prev;
  2067d4:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  2067d6:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  2067d8:	605c      	str	r4, [r3, #4]
  2067da:	f7fc ff39 	bl	203650 <chSchGoSleepTimeoutS>
  if (msg != MSG_TIMEOUT) {
  2067de:	3001      	adds	r0, #1
  2067e0:	d002      	beq.n	2067e8 <thread8+0x68>
    chMtxLockS(mp);
  2067e2:	4630      	mov	r0, r6
  2067e4:	f7fc fe84 	bl	2034f0 <chMtxLockS>
  _dbg_check_unlock();
  2067e8:	f7fd fa62 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2067ec:	682b      	ldr	r3, [r5, #0]
  2067ee:	42ab      	cmp	r3, r5
  2067f0:	d004      	beq.n	2067fc <thread8+0x7c>
  2067f2:	69aa      	ldr	r2, [r5, #24]
  2067f4:	689b      	ldr	r3, [r3, #8]
  2067f6:	6892      	ldr	r2, [r2, #8]
  2067f8:	429a      	cmp	r2, r3
  2067fa:	d30d      	bcc.n	206818 <thread8+0x98>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2067fc:	2300      	movs	r3, #0
  2067fe:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
  206802:	7838      	ldrb	r0, [r7, #0]
  206804:	f7fe fac4 	bl	204d90 <test_emit_token>
  chMtxUnlock(&m1);
  206808:	4807      	ldr	r0, [pc, #28]	; (206828 <thread8+0xa8>)
  20680a:	f7ff fc29 	bl	206060 <chMtxUnlock>
  chMtxUnlock(&m2);
  20680e:	4805      	ldr	r0, [pc, #20]	; (206824 <thread8+0xa4>)
}
  206810:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chMtxUnlock(&m2);
  206814:	f7ff bc24 	b.w	206060 <chMtxUnlock>
  206818:	4806      	ldr	r0, [pc, #24]	; (206834 <thread8+0xb4>)
  20681a:	f7fa f9a9 	bl	200b70 <chSysHalt>
  chDbgAssert(mp != NULL, "not owning a mutex");
  20681e:	4806      	ldr	r0, [pc, #24]	; (206838 <thread8+0xb8>)
  206820:	f7fa f9a6 	bl	200b70 <chSysHalt>
  206824:	20010448 	.word	0x20010448
  206828:	20010438 	.word	0x20010438
  20682c:	20000dc8 	.word	0x20000dc8
  206830:	20010404 	.word	0x20010404
  206834:	0800bc28 	.word	0x0800bc28
  206838:	0800bedc 	.word	0x0800bedc
  20683c:	00000000 	.word	0x00000000

00206840 <thread6>:
static THD_FUNCTION(thread6, p) {
  206840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  206842:	4607      	mov	r7, r0
  chMtxLock(&m1);
  206844:	4821      	ldr	r0, [pc, #132]	; (2068cc <thread6+0x8c>)
  206846:	f7ff fd3b 	bl	2062c0 <chMtxLock>
  __ASM volatile ("cpsid i" : : : "memory");
  20684a:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20684c:	2320      	movs	r3, #32
  20684e:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  206852:	b662      	cpsie	i
  thread_t *ctp = currp;
  206854:	4d1e      	ldr	r5, [pc, #120]	; (2068d0 <thread6+0x90>)
  _dbg_check_lock();
  206856:	f7fd fa7b 	bl	203d50 <_dbg_check_lock>
  20685a:	69ac      	ldr	r4, [r5, #24]
  20685c:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  chDbgCheckClassS();
  20685e:	f7fa fa87 	bl	200d70 <chDbgCheckClassS>
  chDbgAssert(mp != NULL, "not owning a mutex");
  206862:	b386      	cbz	r6, 2068c6 <thread6+0x86>
  chMtxUnlockS(mp);
  206864:	4630      	mov	r0, r6
  206866:	f7fa fc1b 	bl	2010a0 <chMtxUnlockS>
  ctp->u.wtobjp = cp;
  20686a:	4b1a      	ldr	r3, [pc, #104]	; (2068d4 <thread6+0x94>)
  thread_t *cp = (thread_t *)tqp;
  20686c:	4618      	mov	r0, r3
  20686e:	6263      	str	r3, [r4, #36]	; 0x24
  206870:	e003      	b.n	20687a <thread6+0x3a>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  206872:	6899      	ldr	r1, [r3, #8]
  206874:	68a2      	ldr	r2, [r4, #8]
  206876:	4291      	cmp	r1, r2
  206878:	d302      	bcc.n	206880 <thread6+0x40>
    cp = cp->queue.next;
  20687a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  20687c:	4283      	cmp	r3, r0
  20687e:	d1f8      	bne.n	206872 <thread6+0x32>
  tp->queue.prev             = cp->queue.prev;
  206880:	685a      	ldr	r2, [r3, #4]
  chSchGoSleepS(CH_STATE_WTCOND);
  206882:	2007      	movs	r0, #7
  206884:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
  206888:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  20688a:	605c      	str	r4, [r3, #4]
  20688c:	f7fc fe08 	bl	2034a0 <chSchGoSleepS>
  chMtxLockS(mp);
  206890:	4630      	mov	r0, r6
  206892:	f7fc fe2d 	bl	2034f0 <chMtxLockS>
  _dbg_check_unlock();
  206896:	f7fd fa0b 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20689a:	682b      	ldr	r3, [r5, #0]
  20689c:	42ab      	cmp	r3, r5
  20689e:	d004      	beq.n	2068aa <thread6+0x6a>
  2068a0:	69aa      	ldr	r2, [r5, #24]
  2068a2:	689b      	ldr	r3, [r3, #8]
  2068a4:	6892      	ldr	r2, [r2, #8]
  2068a6:	429a      	cmp	r2, r3
  2068a8:	d30a      	bcc.n	2068c0 <thread6+0x80>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2068aa:	2300      	movs	r3, #0
  2068ac:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
  2068b0:	7838      	ldrb	r0, [r7, #0]
  2068b2:	f7fe fa6d 	bl	204d90 <test_emit_token>
  chMtxUnlock(&m1);
  2068b6:	4805      	ldr	r0, [pc, #20]	; (2068cc <thread6+0x8c>)
}
  2068b8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chMtxUnlock(&m1);
  2068bc:	f7ff bbd0 	b.w	206060 <chMtxUnlock>
  2068c0:	4805      	ldr	r0, [pc, #20]	; (2068d8 <thread6+0x98>)
  2068c2:	f7fa f955 	bl	200b70 <chSysHalt>
  chDbgAssert(mp != NULL, "not owning a mutex");
  2068c6:	4805      	ldr	r0, [pc, #20]	; (2068dc <thread6+0x9c>)
  2068c8:	f7fa f952 	bl	200b70 <chSysHalt>
  2068cc:	20010438 	.word	0x20010438
  2068d0:	20000dc8 	.word	0x20000dc8
  2068d4:	20010404 	.word	0x20010404
  2068d8:	0800bc28 	.word	0x0800bc28
  2068dc:	0800be3c 	.word	0x0800be3c

002068e0 <thread9>:
static THD_FUNCTION(thread9, p) {
  2068e0:	b538      	push	{r3, r4, r5, lr}
  chMtxLock(&m2);
  2068e2:	4c06      	ldr	r4, [pc, #24]	; (2068fc <thread9+0x1c>)
static THD_FUNCTION(thread9, p) {
  2068e4:	4605      	mov	r5, r0
  chMtxLock(&m2);
  2068e6:	4620      	mov	r0, r4
  2068e8:	f7ff fcea 	bl	2062c0 <chMtxLock>
  test_emit_token(*(char *)p);
  2068ec:	7828      	ldrb	r0, [r5, #0]
  2068ee:	f7fe fa4f 	bl	204d90 <test_emit_token>
  chMtxUnlock(&m2);
  2068f2:	4620      	mov	r0, r4
}
  2068f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m2);
  2068f8:	f7ff bbb2 	b.w	206060 <chMtxUnlock>
  2068fc:	20010448 	.word	0x20010448

00206900 <thread1.lto_priv.171>:
static THD_FUNCTION(thread1, p) {
  206900:	b538      	push	{r3, r4, r5, lr}
  chMtxLock(&m1);
  206902:	4c06      	ldr	r4, [pc, #24]	; (20691c <thread1.lto_priv.171+0x1c>)
static THD_FUNCTION(thread1, p) {
  206904:	4605      	mov	r5, r0
  chMtxLock(&m1);
  206906:	4620      	mov	r0, r4
  206908:	f7ff fcda 	bl	2062c0 <chMtxLock>
  test_emit_token(*(char *)p);
  20690c:	7828      	ldrb	r0, [r5, #0]
  20690e:	f7fe fa3f 	bl	204d90 <test_emit_token>
  chMtxUnlock(&m1);
  206912:	4620      	mov	r0, r4
}
  206914:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m1);
  206918:	f7ff bba2 	b.w	206060 <chMtxUnlock>
  20691c:	20010438 	.word	0x20010438

00206920 <chFactoryReleaseSemaphore>:
void chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
  206920:	b538      	push	{r3, r4, r5, lr}
  F_LOCK();
  206922:	4c08      	ldr	r4, [pc, #32]	; (206944 <chFactoryReleaseSemaphore+0x24>)
void chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
  206924:	4605      	mov	r5, r0
  F_LOCK();
  206926:	4620      	mov	r0, r4
  206928:	f7ff fcca 	bl	2062c0 <chMtxLock>
  dyn_release_object_pool(&dsp->element,
  20692c:	4628      	mov	r0, r5
  20692e:	f104 022c 	add.w	r2, r4, #44	; 0x2c
  206932:	f104 0128 	add.w	r1, r4, #40	; 0x28
  206936:	f7ff f86b 	bl	205a10 <dyn_release_object_pool>
  F_UNLOCK();
  20693a:	4620      	mov	r0, r4
}
  20693c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
  206940:	f7ff bb8e 	b.w	206060 <chMtxUnlock>
  206944:	20001650 	.word	0x20001650
	...

00206950 <oslib_test_004_003_execute>:
      chFactoryReleaseSemaphore(dsp);
    }
  }
}

static void oslib_test_004_003_execute(void) {
  206950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_semaphore_t *dsp;

  /* [4.3.1] Retrieving a dynamic semaphore by name, must not exist.*/
  test_set_step(1);
  206952:	4c42      	ldr	r4, [pc, #264]	; (206a5c <oslib_test_004_003_execute+0x10c>)
  206954:	2501      	movs	r5, #1
  206956:	6025      	str	r5, [r4, #0]
  {
    dsp = chFactoryFindSemaphore("mysem");
  206958:	f7ff fe52 	bl	206600 <chFactoryFindSemaphore.constprop.9>
    test_assert(dsp == NULL, "found");
  20695c:	fab0 f080 	clz	r0, r0
  206960:	493f      	ldr	r1, [pc, #252]	; (206a60 <oslib_test_004_003_execute+0x110>)
  206962:	0940      	lsrs	r0, r0, #5
  206964:	f7f9 ff2c 	bl	2007c0 <_test_assert>
  206968:	b100      	cbz	r0, 20696c <oslib_test_004_003_execute+0x1c>
  test_set_step(6);
  {
    dsp = chFactoryFindSemaphore("mysem");
    test_assert(dsp == NULL, "found");
  }
}
  20696a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
  20696c:	2302      	movs	r3, #2
  20696e:	6023      	str	r3, [r4, #0]
    dsp = chFactoryCreateSemaphore("mysem", 0);
  206970:	f7ff fe26 	bl	2065c0 <chFactoryCreateSemaphore.constprop.10>
    test_assert(dsp != NULL, "cannot create");
  206974:	4606      	mov	r6, r0
  206976:	3000      	adds	r0, #0
  206978:	493a      	ldr	r1, [pc, #232]	; (206a64 <oslib_test_004_003_execute+0x114>)
  20697a:	bf18      	it	ne
  20697c:	2001      	movne	r0, #1
  20697e:	f7f9 ff1f 	bl	2007c0 <_test_assert>
  206982:	2800      	cmp	r0, #0
  206984:	d1f1      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
  test_set_step(3);
  206986:	2303      	movs	r3, #3
  206988:	6023      	str	r3, [r4, #0]
    dsp1 = chFactoryCreateSemaphore("mysem", 0);
  20698a:	f7ff fe19 	bl	2065c0 <chFactoryCreateSemaphore.constprop.10>
    test_assert(dsp1 == NULL, "can create");
  20698e:	fab0 f080 	clz	r0, r0
  206992:	4935      	ldr	r1, [pc, #212]	; (206a68 <oslib_test_004_003_execute+0x118>)
  206994:	0940      	lsrs	r0, r0, #5
  206996:	f7f9 ff13 	bl	2007c0 <_test_assert>
  20699a:	2800      	cmp	r0, #0
  20699c:	d1e5      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
  test_set_step(4);
  20699e:	2304      	movs	r3, #4
  2069a0:	6023      	str	r3, [r4, #0]
    dsp1 = chFactoryFindSemaphore("mysem");
  2069a2:	f7ff fe2d 	bl	206600 <chFactoryFindSemaphore.constprop.9>
    test_assert(dsp1 != NULL, "not found");
  2069a6:	4607      	mov	r7, r0
  2069a8:	3000      	adds	r0, #0
  2069aa:	4930      	ldr	r1, [pc, #192]	; (206a6c <oslib_test_004_003_execute+0x11c>)
  2069ac:	bf18      	it	ne
  2069ae:	2001      	movne	r0, #1
  2069b0:	f7f9 ff06 	bl	2007c0 <_test_assert>
  2069b4:	2800      	cmp	r0, #0
  2069b6:	d1d8      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
    test_assert(dsp == dsp1, "object reference mismatch");
  2069b8:	1bf0      	subs	r0, r6, r7
  2069ba:	492d      	ldr	r1, [pc, #180]	; (206a70 <oslib_test_004_003_execute+0x120>)
  2069bc:	fab0 f080 	clz	r0, r0
  2069c0:	0940      	lsrs	r0, r0, #5
  2069c2:	f7f9 fefd 	bl	2007c0 <_test_assert>
  2069c6:	2800      	cmp	r0, #0
  2069c8:	d1cf      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
    test_assert(dsp1->element.refs == 2, "object reference mismatch");
  2069ca:	6878      	ldr	r0, [r7, #4]
  2069cc:	4928      	ldr	r1, [pc, #160]	; (206a70 <oslib_test_004_003_execute+0x120>)
  2069ce:	f1a0 0002 	sub.w	r0, r0, #2
  2069d2:	fab0 f080 	clz	r0, r0
  2069d6:	0940      	lsrs	r0, r0, #5
  2069d8:	f7f9 fef2 	bl	2007c0 <_test_assert>
  2069dc:	2800      	cmp	r0, #0
  2069de:	d1c4      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
 *
 * @api
 */
static inline dyn_element_t *chFactoryDuplicateReference(dyn_element_t *dep) {

  dep->refs++;
  2069e0:	687b      	ldr	r3, [r7, #4]
    test_assert(dsp1 == dsp2, "object reference mismatch");
  2069e2:	4628      	mov	r0, r5
  2069e4:	4922      	ldr	r1, [pc, #136]	; (206a70 <oslib_test_004_003_execute+0x120>)
  2069e6:	442b      	add	r3, r5
  2069e8:	607b      	str	r3, [r7, #4]
  2069ea:	f7f9 fee9 	bl	2007c0 <_test_assert>
  2069ee:	2800      	cmp	r0, #0
  2069f0:	d1bb      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
    test_assert(dsp2->element.refs == 3, "object reference mismatch");
  2069f2:	6878      	ldr	r0, [r7, #4]
  2069f4:	491e      	ldr	r1, [pc, #120]	; (206a70 <oslib_test_004_003_execute+0x120>)
  2069f6:	f1a0 0c03 	sub.w	ip, r0, #3
  2069fa:	f1dc 0000 	rsbs	r0, ip, #0
  2069fe:	eb40 000c 	adc.w	r0, r0, ip
  206a02:	f7f9 fedd 	bl	2007c0 <_test_assert>
  206a06:	2800      	cmp	r0, #0
  206a08:	d1af      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
    chFactoryReleaseSemaphore(dsp2);
  206a0a:	4638      	mov	r0, r7
  206a0c:	f7ff ff88 	bl	206920 <chFactoryReleaseSemaphore>
    test_assert(dsp1->element.refs == 2, "references mismatch");
  206a10:	6878      	ldr	r0, [r7, #4]
  206a12:	4918      	ldr	r1, [pc, #96]	; (206a74 <oslib_test_004_003_execute+0x124>)
  206a14:	1e82      	subs	r2, r0, #2
  206a16:	4250      	negs	r0, r2
  206a18:	4150      	adcs	r0, r2
  206a1a:	f7f9 fed1 	bl	2007c0 <_test_assert>
  206a1e:	2800      	cmp	r0, #0
  206a20:	d1a3      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
    chFactoryReleaseSemaphore(dsp1);
  206a22:	4638      	mov	r0, r7
  206a24:	f7ff ff7c 	bl	206920 <chFactoryReleaseSemaphore>
    test_assert(dsp->element.refs == 1, "references mismatch");
  206a28:	6870      	ldr	r0, [r6, #4]
  206a2a:	4912      	ldr	r1, [pc, #72]	; (206a74 <oslib_test_004_003_execute+0x124>)
  206a2c:	1b43      	subs	r3, r0, r5
  206a2e:	4258      	negs	r0, r3
  206a30:	4158      	adcs	r0, r3
  206a32:	f7f9 fec5 	bl	2007c0 <_test_assert>
  206a36:	2800      	cmp	r0, #0
  206a38:	d197      	bne.n	20696a <oslib_test_004_003_execute+0x1a>
  test_set_step(5);
  206a3a:	2305      	movs	r3, #5
    chFactoryReleaseSemaphore(dsp);
  206a3c:	4630      	mov	r0, r6
  test_set_step(5);
  206a3e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseSemaphore(dsp);
  206a40:	f7ff ff6e 	bl	206920 <chFactoryReleaseSemaphore>
  test_set_step(6);
  206a44:	2306      	movs	r3, #6
  206a46:	6023      	str	r3, [r4, #0]
    dsp = chFactoryFindSemaphore("mysem");
  206a48:	f7ff fdda 	bl	206600 <chFactoryFindSemaphore.constprop.9>
    test_assert(dsp == NULL, "found");
  206a4c:	fab0 f080 	clz	r0, r0
  206a50:	4903      	ldr	r1, [pc, #12]	; (206a60 <oslib_test_004_003_execute+0x110>)
  206a52:	0940      	lsrs	r0, r0, #5
}
  206a54:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dsp == NULL, "found");
  206a58:	f7f9 beb2 	b.w	2007c0 <_test_assert>
  206a5c:	20001f6c 	.word	0x20001f6c
  206a60:	0800c848 	.word	0x0800c848
  206a64:	0800c828 	.word	0x0800c828
  206a68:	0800c838 	.word	0x0800c838
  206a6c:	0800c844 	.word	0x0800c844
  206a70:	0800c850 	.word	0x0800c850
  206a74:	0800c86c 	.word	0x0800c86c
	...

00206a80 <oslib_test_004_003_teardown>:
static void oslib_test_004_003_teardown(void) {
  206a80:	b510      	push	{r4, lr}
  dsp = chFactoryFindSemaphore("mysem");
  206a82:	f7ff fdbd 	bl	206600 <chFactoryFindSemaphore.constprop.9>
  if (dsp != NULL) {
  206a86:	b140      	cbz	r0, 206a9a <oslib_test_004_003_teardown+0x1a>
    while (dsp->element.refs > 0U) {
  206a88:	6843      	ldr	r3, [r0, #4]
  206a8a:	4604      	mov	r4, r0
  206a8c:	b12b      	cbz	r3, 206a9a <oslib_test_004_003_teardown+0x1a>
      chFactoryReleaseSemaphore(dsp);
  206a8e:	4620      	mov	r0, r4
  206a90:	f7ff ff46 	bl	206920 <chFactoryReleaseSemaphore>
    while (dsp->element.refs > 0U) {
  206a94:	6863      	ldr	r3, [r4, #4]
  206a96:	2b00      	cmp	r3, #0
  206a98:	d1f9      	bne.n	206a8e <oslib_test_004_003_teardown+0xe>
}
  206a9a:	bd10      	pop	{r4, pc}
  206a9c:	0000      	movs	r0, r0
	...

00206aa0 <chFactoryReleaseObject>:
void chFactoryReleaseObject(registered_object_t *rop){
  206aa0:	b538      	push	{r3, r4, r5, lr}
  F_LOCK();
  206aa2:	4c08      	ldr	r4, [pc, #32]	; (206ac4 <chFactoryReleaseObject+0x24>)
void chFactoryReleaseObject(registered_object_t *rop){
  206aa4:	4605      	mov	r5, r0
  F_LOCK();
  206aa6:	4620      	mov	r0, r4
  206aa8:	f7ff fc0a 	bl	2062c0 <chMtxLock>
  dyn_release_object_pool(&rop->element,
  206aac:	4628      	mov	r0, r5
  206aae:	f104 0214 	add.w	r2, r4, #20
  206ab2:	f104 0110 	add.w	r1, r4, #16
  206ab6:	f7fe ffab 	bl	205a10 <dyn_release_object_pool>
  F_UNLOCK();
  206aba:	4620      	mov	r0, r4
}
  206abc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
  206ac0:	f7ff bace 	b.w	206060 <chMtxUnlock>
  206ac4:	20001650 	.word	0x20001650
	...

00206ad0 <oslib_test_004_001_execute>:
static void oslib_test_004_001_execute(void) {
  206ad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
  206ad4:	4c51      	ldr	r4, [pc, #324]	; (206c1c <oslib_test_004_001_execute+0x14c>)
  206ad6:	2501      	movs	r5, #1
  206ad8:	6025      	str	r5, [r4, #0]
    rop = chFactoryFindObject("myobj");
  206ada:	f7ff fd21 	bl	206520 <chFactoryFindObject.constprop.13>
    test_assert(rop == NULL, "found");
  206ade:	fab0 f080 	clz	r0, r0
  206ae2:	494f      	ldr	r1, [pc, #316]	; (206c20 <oslib_test_004_001_execute+0x150>)
  206ae4:	0940      	lsrs	r0, r0, #5
  206ae6:	f7f9 fe6b 	bl	2007c0 <_test_assert>
  206aea:	b108      	cbz	r0, 206af0 <oslib_test_004_001_execute+0x20>
}
  206aec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(2);
  206af0:	2302      	movs	r3, #2
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
  206af2:	484c      	ldr	r0, [pc, #304]	; (206c24 <oslib_test_004_001_execute+0x154>)
  test_set_step(2);
  206af4:	6023      	str	r3, [r4, #0]
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
  206af6:	f7ff fcfb 	bl	2064f0 <chFactoryRegisterObject.constprop.14>
    test_assert(rop != NULL, "cannot register");
  206afa:	4606      	mov	r6, r0
  206afc:	3000      	adds	r0, #0
  206afe:	494a      	ldr	r1, [pc, #296]	; (206c28 <oslib_test_004_001_execute+0x158>)
  206b00:	bf18      	it	ne
  206b02:	2001      	movne	r0, #1
  206b04:	f7f9 fe5c 	bl	2007c0 <_test_assert>
  206b08:	2800      	cmp	r0, #0
  206b0a:	d1ef      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
  test_set_step(3);
  206b0c:	2303      	movs	r3, #3
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
  206b0e:	4847      	ldr	r0, [pc, #284]	; (206c2c <oslib_test_004_001_execute+0x15c>)
  test_set_step(3);
  206b10:	6023      	str	r3, [r4, #0]
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
  206b12:	f7ff fced 	bl	2064f0 <chFactoryRegisterObject.constprop.14>
    test_assert(rop1 == NULL, "can register");
  206b16:	fab0 f080 	clz	r0, r0
  206b1a:	4945      	ldr	r1, [pc, #276]	; (206c30 <oslib_test_004_001_execute+0x160>)
  206b1c:	0940      	lsrs	r0, r0, #5
  206b1e:	f7f9 fe4f 	bl	2007c0 <_test_assert>
  206b22:	2800      	cmp	r0, #0
  206b24:	d1e2      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
  test_set_step(4);
  206b26:	2304      	movs	r3, #4
  206b28:	6023      	str	r3, [r4, #0]
    rop1 = chFactoryFindObject("myobj");
  206b2a:	f7ff fcf9 	bl	206520 <chFactoryFindObject.constprop.13>
    test_assert(rop1 != NULL, "not found");
  206b2e:	4607      	mov	r7, r0
  206b30:	3000      	adds	r0, #0
  206b32:	4940      	ldr	r1, [pc, #256]	; (206c34 <oslib_test_004_001_execute+0x164>)
  206b34:	bf18      	it	ne
  206b36:	2001      	movne	r0, #1
  206b38:	f7f9 fe42 	bl	2007c0 <_test_assert>
  206b3c:	2800      	cmp	r0, #0
  206b3e:	d1d5      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
    test_assert(*(uint32_t *)(rop1->objp) == 0x55aa, "object mismatch");
  206b40:	693b      	ldr	r3, [r7, #16]
  206b42:	f245 58aa 	movw	r8, #21930	; 0x55aa
  206b46:	493c      	ldr	r1, [pc, #240]	; (206c38 <oslib_test_004_001_execute+0x168>)
  206b48:	6818      	ldr	r0, [r3, #0]
  206b4a:	eba0 0008 	sub.w	r0, r0, r8
  206b4e:	fab0 f080 	clz	r0, r0
  206b52:	0940      	lsrs	r0, r0, #5
  206b54:	f7f9 fe34 	bl	2007c0 <_test_assert>
  206b58:	2800      	cmp	r0, #0
  206b5a:	d1c7      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
    test_assert(rop == rop1, "object reference mismatch");
  206b5c:	1bf0      	subs	r0, r6, r7
  206b5e:	4937      	ldr	r1, [pc, #220]	; (206c3c <oslib_test_004_001_execute+0x16c>)
  206b60:	fab0 f080 	clz	r0, r0
  206b64:	0940      	lsrs	r0, r0, #5
  206b66:	f7f9 fe2b 	bl	2007c0 <_test_assert>
  206b6a:	2800      	cmp	r0, #0
  206b6c:	d1be      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
    test_assert(rop1->element.refs == 2, "object reference mismatch");
  206b6e:	6878      	ldr	r0, [r7, #4]
  206b70:	4932      	ldr	r1, [pc, #200]	; (206c3c <oslib_test_004_001_execute+0x16c>)
  206b72:	f1a0 0002 	sub.w	r0, r0, #2
  206b76:	fab0 f080 	clz	r0, r0
  206b7a:	0940      	lsrs	r0, r0, #5
  206b7c:	f7f9 fe20 	bl	2007c0 <_test_assert>
  206b80:	2800      	cmp	r0, #0
  206b82:	d1b3      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
  206b84:	687b      	ldr	r3, [r7, #4]
    test_assert(rop1 == rop2, "object reference mismatch");
  206b86:	4628      	mov	r0, r5
  206b88:	492c      	ldr	r1, [pc, #176]	; (206c3c <oslib_test_004_001_execute+0x16c>)
  206b8a:	442b      	add	r3, r5
  206b8c:	607b      	str	r3, [r7, #4]
  206b8e:	f7f9 fe17 	bl	2007c0 <_test_assert>
  206b92:	2800      	cmp	r0, #0
  206b94:	d1aa      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
    test_assert(*(uint32_t *)(rop2->objp) == 0x55aa, "object mismatch");
  206b96:	693b      	ldr	r3, [r7, #16]
  206b98:	4927      	ldr	r1, [pc, #156]	; (206c38 <oslib_test_004_001_execute+0x168>)
  206b9a:	6818      	ldr	r0, [r3, #0]
  206b9c:	eba0 0e08 	sub.w	lr, r0, r8
  206ba0:	f1de 0000 	rsbs	r0, lr, #0
  206ba4:	eb40 000e 	adc.w	r0, r0, lr
  206ba8:	f7f9 fe0a 	bl	2007c0 <_test_assert>
  206bac:	2800      	cmp	r0, #0
  206bae:	d19d      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
    test_assert(rop2->element.refs == 3, "object reference mismatch");
  206bb0:	6878      	ldr	r0, [r7, #4]
  206bb2:	4922      	ldr	r1, [pc, #136]	; (206c3c <oslib_test_004_001_execute+0x16c>)
  206bb4:	f1a0 0c03 	sub.w	ip, r0, #3
  206bb8:	f1dc 0000 	rsbs	r0, ip, #0
  206bbc:	eb40 000c 	adc.w	r0, r0, ip
  206bc0:	f7f9 fdfe 	bl	2007c0 <_test_assert>
  206bc4:	2800      	cmp	r0, #0
  206bc6:	d191      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
    chFactoryReleaseObject(rop2);
  206bc8:	4638      	mov	r0, r7
  206bca:	f7ff ff69 	bl	206aa0 <chFactoryReleaseObject>
    test_assert(rop1->element.refs == 2, "references mismatch");
  206bce:	6878      	ldr	r0, [r7, #4]
  206bd0:	491b      	ldr	r1, [pc, #108]	; (206c40 <oslib_test_004_001_execute+0x170>)
  206bd2:	1e82      	subs	r2, r0, #2
  206bd4:	4250      	negs	r0, r2
  206bd6:	4150      	adcs	r0, r2
  206bd8:	f7f9 fdf2 	bl	2007c0 <_test_assert>
  206bdc:	2800      	cmp	r0, #0
  206bde:	d185      	bne.n	206aec <oslib_test_004_001_execute+0x1c>
    chFactoryReleaseObject(rop1);
  206be0:	4638      	mov	r0, r7
  206be2:	f7ff ff5d 	bl	206aa0 <chFactoryReleaseObject>
    test_assert(rop->element.refs == 1, "references mismatch");
  206be6:	6870      	ldr	r0, [r6, #4]
  206be8:	4915      	ldr	r1, [pc, #84]	; (206c40 <oslib_test_004_001_execute+0x170>)
  206bea:	1b43      	subs	r3, r0, r5
  206bec:	4258      	negs	r0, r3
  206bee:	4158      	adcs	r0, r3
  206bf0:	f7f9 fde6 	bl	2007c0 <_test_assert>
  206bf4:	2800      	cmp	r0, #0
  206bf6:	f47f af79 	bne.w	206aec <oslib_test_004_001_execute+0x1c>
  test_set_step(5);
  206bfa:	2305      	movs	r3, #5
    chFactoryReleaseObject(rop);
  206bfc:	4630      	mov	r0, r6
  test_set_step(5);
  206bfe:	6023      	str	r3, [r4, #0]
    chFactoryReleaseObject(rop);
  206c00:	f7ff ff4e 	bl	206aa0 <chFactoryReleaseObject>
  test_set_step(6);
  206c04:	2306      	movs	r3, #6
  206c06:	6023      	str	r3, [r4, #0]
    rop = chFactoryFindObject("myobj");
  206c08:	f7ff fc8a 	bl	206520 <chFactoryFindObject.constprop.13>
    test_assert(rop == NULL, "found");
  206c0c:	fab0 f080 	clz	r0, r0
  206c10:	4903      	ldr	r1, [pc, #12]	; (206c20 <oslib_test_004_001_execute+0x150>)
  206c12:	0940      	lsrs	r0, r0, #5
}
  206c14:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(rop == NULL, "found");
  206c18:	f7f9 bdd2 	b.w	2007c0 <_test_assert>
  206c1c:	20001f6c 	.word	0x20001f6c
  206c20:	0800c848 	.word	0x0800c848
  206c24:	20010490 	.word	0x20010490
  206c28:	0800c7d8 	.word	0x0800c7d8
  206c2c:	20010494 	.word	0x20010494
  206c30:	0800c7e8 	.word	0x0800c7e8
  206c34:	0800c844 	.word	0x0800c844
  206c38:	0800c7f8 	.word	0x0800c7f8
  206c3c:	0800c850 	.word	0x0800c850
  206c40:	0800c86c 	.word	0x0800c86c
	...

00206c50 <oslib_test_004_001_teardown>:
static void oslib_test_004_001_teardown(void) {
  206c50:	b510      	push	{r4, lr}
  rop = chFactoryFindObject("myobj");
  206c52:	f7ff fc65 	bl	206520 <chFactoryFindObject.constprop.13>
  if (rop != NULL) {
  206c56:	b140      	cbz	r0, 206c6a <oslib_test_004_001_teardown+0x1a>
    while (rop->element.refs > 0U) {
  206c58:	6843      	ldr	r3, [r0, #4]
  206c5a:	4604      	mov	r4, r0
  206c5c:	b12b      	cbz	r3, 206c6a <oslib_test_004_001_teardown+0x1a>
      chFactoryReleaseObject(rop);
  206c5e:	4620      	mov	r0, r4
  206c60:	f7ff ff1e 	bl	206aa0 <chFactoryReleaseObject>
    while (rop->element.refs > 0U) {
  206c64:	6863      	ldr	r3, [r4, #4]
  206c66:	2b00      	cmp	r3, #0
  206c68:	d1f9      	bne.n	206c5e <oslib_test_004_001_teardown+0xe>
}
  206c6a:	bd10      	pop	{r4, pc}
  206c6c:	0000      	movs	r0, r0
	...

00206c70 <chHeapStatus>:
 *                      free free block found space or @p NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
  206c70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
  206c74:	4c15      	ldr	r4, [pc, #84]	; (206ccc <chHeapStatus+0x5c>)
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
  206c76:	4688      	mov	r8, r1
  206c78:	4617      	mov	r7, r2
    heapp = &default_heap;
  206c7a:	2800      	cmp	r0, #0
  206c7c:	bf18      	it	ne
  206c7e:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
  206c80:	f104 090c 	add.w	r9, r4, #12
  206c84:	4648      	mov	r0, r9
  206c86:	f7ff fb1b 	bl	2062c0 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
  206c8a:	6863      	ldr	r3, [r4, #4]
  206c8c:	b1d3      	cbz	r3, 206cc4 <chHeapStatus+0x54>
  lpages = 0U;
  206c8e:	2400      	movs	r4, #0
  tpages = 0U;
  206c90:	4625      	mov	r5, r4
  n = 0U;
  206c92:	4626      	mov	r6, r4
    size_t pages = H_PAGES(H_NEXT(qp));
  206c94:	6858      	ldr	r0, [r3, #4]

    /* Updating counters.*/
    n++;
  206c96:	3601      	adds	r6, #1
  while (H_NEXT(qp) != NULL) {
  206c98:	681b      	ldr	r3, [r3, #0]
  206c9a:	4284      	cmp	r4, r0
    tpages += pages;
  206c9c:	4405      	add	r5, r0
  206c9e:	bf38      	it	cc
  206ca0:	4604      	movcc	r4, r0
  while (H_NEXT(qp) != NULL) {
  206ca2:	2b00      	cmp	r3, #0
  206ca4:	d1f6      	bne.n	206c94 <chHeapStatus+0x24>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
  206ca6:	f1b8 0f00 	cmp.w	r8, #0
  206caa:	d002      	beq.n	206cb2 <chHeapStatus+0x42>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
  206cac:	00ed      	lsls	r5, r5, #3
  206cae:	f8c8 5000 	str.w	r5, [r8]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
  206cb2:	b10f      	cbz	r7, 206cb8 <chHeapStatus+0x48>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
  206cb4:	00e4      	lsls	r4, r4, #3
  206cb6:	603c      	str	r4, [r7, #0]
  }
  H_UNLOCK(heapp);
  206cb8:	4648      	mov	r0, r9
  206cba:	f7ff f9d1 	bl	206060 <chMtxUnlock>

  return n;
}
  206cbe:	4630      	mov	r0, r6
  206cc0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  lpages = 0U;
  206cc4:	461c      	mov	r4, r3
  tpages = 0U;
  206cc6:	461d      	mov	r5, r3
  n = 0U;
  206cc8:	461e      	mov	r6, r3
  206cca:	e7ec      	b.n	206ca6 <chHeapStatus+0x36>
  206ccc:	20001778 	.word	0x20001778

00206cd0 <cmd_mem>:
#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
  size_t n, total, largest;

  (void)argv;
  if (argc > 0) {
  206cd0:	2900      	cmp	r1, #0
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
  206cd2:	b530      	push	{r4, r5, lr}
  206cd4:	b083      	sub	sp, #12
  if (argc > 0) {
  206cd6:	dd05      	ble.n	206ce4 <cmd_mem+0x14>
    shellUsage(chp, "mem");
  206cd8:	4a12      	ldr	r2, [pc, #72]	; (206d24 <cmd_mem+0x54>)
  206cda:	4913      	ldr	r1, [pc, #76]	; (206d28 <cmd_mem+0x58>)
  206cdc:	f7fc f8d8 	bl	202e90 <chprintf>
  n = chHeapStatus(NULL, &total, &largest);
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
}
  206ce0:	b003      	add	sp, #12
  206ce2:	bd30      	pop	{r4, r5, pc}
  206ce4:	4604      	mov	r4, r0
  n = chHeapStatus(NULL, &total, &largest);
  206ce6:	aa01      	add	r2, sp, #4
  206ce8:	4669      	mov	r1, sp
  206cea:	2000      	movs	r0, #0
  206cec:	f7ff ffc0 	bl	206c70 <chHeapStatus>
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
  206cf0:	4b0e      	ldr	r3, [pc, #56]	; (206d2c <cmd_mem+0x5c>)
  206cf2:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
  206cf4:	490e      	ldr	r1, [pc, #56]	; (206d30 <cmd_mem+0x60>)
  206cf6:	4620      	mov	r0, r4
  206cf8:	e9d3 3200 	ldrd	r3, r2, [r3]
  206cfc:	1ad2      	subs	r2, r2, r3
  206cfe:	f7fc f8c7 	bl	202e90 <chprintf>
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
  206d02:	462a      	mov	r2, r5
  206d04:	490b      	ldr	r1, [pc, #44]	; (206d34 <cmd_mem+0x64>)
  206d06:	4620      	mov	r0, r4
  206d08:	f7fc f8c2 	bl	202e90 <chprintf>
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
  206d0c:	9a00      	ldr	r2, [sp, #0]
  206d0e:	490a      	ldr	r1, [pc, #40]	; (206d38 <cmd_mem+0x68>)
  206d10:	4620      	mov	r0, r4
  206d12:	f7fc f8bd 	bl	202e90 <chprintf>
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
  206d16:	9a01      	ldr	r2, [sp, #4]
  206d18:	4908      	ldr	r1, [pc, #32]	; (206d3c <cmd_mem+0x6c>)
  206d1a:	4620      	mov	r0, r4
  206d1c:	f7fc f8b8 	bl	202e90 <chprintf>
}
  206d20:	b003      	add	sp, #12
  206d22:	bd30      	pop	{r4, r5, pc}
  206d24:	0800c3a8 	.word	0x0800c3a8
  206d28:	0800c270 	.word	0x0800c270
  206d2c:	20001770 	.word	0x20001770
  206d30:	0800c3ac 	.word	0x0800c3ac
  206d34:	0800c3cc 	.word	0x0800c3cc
  206d38:	0800c3e4 	.word	0x0800c3e4
  206d3c:	0800c404 	.word	0x0800c404

00206d40 <chHeapFree>:
void chHeapFree(void *p) {
  206d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
  206d42:	b310      	cbz	r0, 206d8a <chHeapFree+0x4a>
  206d44:	0743      	lsls	r3, r0, #29
  206d46:	4606      	mov	r6, r0
  206d48:	d11f      	bne.n	206d8a <chHeapFree+0x4a>
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
  206d4a:	f850 3c04 	ldr.w	r3, [r0, #-4]
  hp = (heap_header_t *)p - 1U;
  206d4e:	f1a0 0408 	sub.w	r4, r0, #8
  heapp = H_HEAP(hp);
  206d52:	f850 5c08 	ldr.w	r5, [r0, #-8]
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
  206d56:	3307      	adds	r3, #7
  H_LOCK(heapp);
  206d58:	f105 070c 	add.w	r7, r5, #12
  qp = &heapp->header;
  206d5c:	3504      	adds	r5, #4
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
  206d5e:	08db      	lsrs	r3, r3, #3
  H_LOCK(heapp);
  206d60:	4638      	mov	r0, r7
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
  206d62:	f846 3c04 	str.w	r3, [r6, #-4]
  H_LOCK(heapp);
  206d66:	f7ff faab 	bl	2062c0 <chMtxLock>
  qp = &heapp->header;
  206d6a:	462b      	mov	r3, r5
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
  206d6c:	42a3      	cmp	r3, r4
  206d6e:	d805      	bhi.n	206d7c <chHeapFree+0x3c>
  206d70:	685a      	ldr	r2, [r3, #4]
  206d72:	3201      	adds	r2, #1
  206d74:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
  206d78:	4294      	cmp	r4, r2
  206d7a:	d306      	bcc.n	206d8a <chHeapFree+0x4a>
    if (((qp == &heapp->header) || (hp > qp)) &&
  206d7c:	42a3      	cmp	r3, r4
  206d7e:	681a      	ldr	r2, [r3, #0]
  206d80:	d306      	bcc.n	206d90 <chHeapFree+0x50>
  206d82:	42ab      	cmp	r3, r5
  206d84:	d004      	beq.n	206d90 <chHeapFree+0x50>
void chHeapFree(void *p) {
  206d86:	4613      	mov	r3, r2
  206d88:	e7f0      	b.n	206d6c <chHeapFree+0x2c>
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
  206d8a:	481a      	ldr	r0, [pc, #104]	; (206df4 <chHeapFree+0xb4>)
  206d8c:	f7f9 fef0 	bl	200b70 <chSysHalt>
    if (((qp == &heapp->header) || (hp > qp)) &&
  206d90:	b10a      	cbz	r2, 206d96 <chHeapFree+0x56>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
  206d92:	4294      	cmp	r4, r2
  206d94:	d2f7      	bcs.n	206d86 <chHeapFree+0x46>
      if (H_LIMIT(hp) == H_NEXT(hp)) {
  206d96:	f856 1c04 	ldr.w	r1, [r6, #-4]
      H_NEXT(hp) = H_NEXT(qp);
  206d9a:	f846 2c08 	str.w	r2, [r6, #-8]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
  206d9e:	1c4a      	adds	r2, r1, #1
      H_NEXT(qp) = hp;
  206da0:	601c      	str	r4, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
  206da2:	f856 0c08 	ldr.w	r0, [r6, #-8]
  206da6:	eb04 01c2 	add.w	r1, r4, r2, lsl #3
  206daa:	4281      	cmp	r1, r0
  206dac:	d00a      	beq.n	206dc4 <chHeapFree+0x84>
      if ((H_LIMIT(qp) == hp)) {
  206dae:	6859      	ldr	r1, [r3, #4]
  206db0:	1c4a      	adds	r2, r1, #1
  206db2:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
  206db6:	4294      	cmp	r4, r2
  206db8:	d010      	beq.n	206ddc <chHeapFree+0x9c>
  H_UNLOCK(heapp);
  206dba:	4638      	mov	r0, r7
}
  206dbc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  H_UNLOCK(heapp);
  206dc0:	f7ff b94e 	b.w	206060 <chMtxUnlock>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
  206dc4:	6849      	ldr	r1, [r1, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
  206dc6:	f854 0032 	ldr.w	r0, [r4, r2, lsl #3]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
  206dca:	440a      	add	r2, r1
  206dcc:	e946 0202 	strd	r0, r2, [r6, #-8]
      if ((H_LIMIT(qp) == hp)) {
  206dd0:	6859      	ldr	r1, [r3, #4]
  206dd2:	1c4a      	adds	r2, r1, #1
  206dd4:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
  206dd8:	4294      	cmp	r4, r2
  206dda:	d1ee      	bne.n	206dba <chHeapFree+0x7a>
        H_NEXT(qp) = H_NEXT(hp);
  206ddc:	e956 0202 	ldrd	r0, r2, [r6, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
  206de0:	3201      	adds	r2, #1
        H_NEXT(qp) = H_NEXT(hp);
  206de2:	6018      	str	r0, [r3, #0]
  H_UNLOCK(heapp);
  206de4:	4638      	mov	r0, r7
        H_PAGES(qp) += H_PAGES(hp) + 1U;
  206de6:	4411      	add	r1, r2
  206de8:	6059      	str	r1, [r3, #4]
}
  206dea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  H_UNLOCK(heapp);
  206dee:	f7ff b937 	b.w	206060 <chMtxUnlock>
  206df2:	bf00      	nop
  206df4:	0800be60 	.word	0x0800be60
	...

00206e00 <oslib_test_003_002_execute>:
 *   is freed using chHeapFree(), must not fail.
 * - [3.2.2] Testing allocation failure.
 * .
 */

static void oslib_test_003_002_execute(void) {
  206e00:	b570      	push	{r4, r5, r6, lr}
  206e02:	b082      	sub	sp, #8
  void *p1;
  size_t total_size, largest_size;

  /* [3.2.1] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
  206e04:	2301      	movs	r3, #1
  206e06:	4c13      	ldr	r4, [pc, #76]	; (206e54 <oslib_test_003_002_execute+0x54>)
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
  206e08:	2000      	movs	r0, #0
  206e0a:	466a      	mov	r2, sp
  206e0c:	a901      	add	r1, sp, #4
  test_set_step(1);
  206e0e:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(NULL, &total_size, &largest_size);
  206e10:	f7ff ff2e 	bl	206c70 <chHeapStatus>
  206e14:	2110      	movs	r1, #16
  206e16:	4810      	ldr	r0, [pc, #64]	; (206e58 <oslib_test_003_002_execute+0x58>)
  206e18:	f7ff fa7a 	bl	206310 <chHeapAllocAligned.constprop.32>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
  206e1c:	4606      	mov	r6, r0
  206e1e:	3000      	adds	r0, #0
  206e20:	490e      	ldr	r1, [pc, #56]	; (206e5c <oslib_test_003_002_execute+0x5c>)
  206e22:	bf18      	it	ne
  206e24:	2001      	movne	r0, #1
  206e26:	f7f9 fccb 	bl	2007c0 <_test_assert>
  206e2a:	b980      	cbnz	r0, 206e4e <oslib_test_003_002_execute+0x4e>
  206e2c:	4605      	mov	r5, r0
    chHeapFree(p1);
  206e2e:	4630      	mov	r0, r6
  206e30:	f7ff ff86 	bl	206d40 <chHeapFree>
  }

  /* [3.2.2] Testing allocation failure.*/
  test_set_step(2);
  206e34:	2302      	movs	r3, #2
  206e36:	f06f 01ff 	mvn.w	r1, #255	; 0xff
  206e3a:	4628      	mov	r0, r5
  206e3c:	6023      	str	r3, [r4, #0]
  206e3e:	f7ff fa67 	bl	206310 <chHeapAllocAligned.constprop.32>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
  206e42:	fab0 f080 	clz	r0, r0
  206e46:	4906      	ldr	r1, [pc, #24]	; (206e60 <oslib_test_003_002_execute+0x60>)
  206e48:	0940      	lsrs	r0, r0, #5
  206e4a:	f7f9 fcb9 	bl	2007c0 <_test_assert>
  }
}
  206e4e:	b002      	add	sp, #8
  206e50:	bd70      	pop	{r4, r5, r6, pc}
  206e52:	bf00      	nop
  206e54:	20001f6c 	.word	0x20001f6c
  206e58:	20001ecc 	.word	0x20001ecc
  206e5c:	0800c79c 	.word	0x0800c79c
  206e60:	0800c7b0 	.word	0x0800c7b0
	...

00206e70 <oslib_test_003_001_execute>:
static void oslib_test_003_001_execute(void) {
  206e70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  206e74:	b084      	sub	sp, #16
  test_set_step(1);
  206e76:	2301      	movs	r3, #1
  206e78:	4cbe      	ldr	r4, [pc, #760]	; (207174 <oslib_test_003_001_execute+0x304>)
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
  206e7a:	2200      	movs	r2, #0
  206e7c:	4669      	mov	r1, sp
  206e7e:	48be      	ldr	r0, [pc, #760]	; (207178 <oslib_test_003_001_execute+0x308>)
  test_set_step(1);
  206e80:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
  206e82:	f7ff fef5 	bl	206c70 <chHeapStatus>
  206e86:	f1a0 0001 	sub.w	r0, r0, #1
  206e8a:	49bc      	ldr	r1, [pc, #752]	; (20717c <oslib_test_003_001_execute+0x30c>)
  206e8c:	fab0 f080 	clz	r0, r0
  206e90:	0940      	lsrs	r0, r0, #5
  206e92:	f7f9 fc95 	bl	2007c0 <_test_assert>
  206e96:	b110      	cbz	r0, 206e9e <oslib_test_003_001_execute+0x2e>
}
  206e98:	b004      	add	sp, #16
  206e9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(2);
  206e9e:	2302      	movs	r3, #2
  206ea0:	f44f 7180 	mov.w	r1, #256	; 0x100
  206ea4:	48b4      	ldr	r0, [pc, #720]	; (207178 <oslib_test_003_001_execute+0x308>)
  206ea6:	6023      	str	r3, [r4, #0]
  206ea8:	f7ff fa32 	bl	206310 <chHeapAllocAligned.constprop.32>
    test_assert(p1 == NULL, "allocation not failed");
  206eac:	fab0 f080 	clz	r0, r0
  206eb0:	49b3      	ldr	r1, [pc, #716]	; (207180 <oslib_test_003_001_execute+0x310>)
  206eb2:	0940      	lsrs	r0, r0, #5
  206eb4:	f7f9 fc84 	bl	2007c0 <_test_assert>
  206eb8:	2800      	cmp	r0, #0
  206eba:	d1ed      	bne.n	206e98 <oslib_test_003_001_execute+0x28>
  test_set_step(3);
  206ebc:	2303      	movs	r3, #3
  206ebe:	2110      	movs	r1, #16
  206ec0:	48ad      	ldr	r0, [pc, #692]	; (207178 <oslib_test_003_001_execute+0x308>)
  206ec2:	6023      	str	r3, [r4, #0]
  206ec4:	f7ff fa24 	bl	206310 <chHeapAllocAligned.constprop.32>
    test_assert(p1 != NULL, "allocation failed");
  206ec8:	4605      	mov	r5, r0
  206eca:	3000      	adds	r0, #0
  206ecc:	49ad      	ldr	r1, [pc, #692]	; (207184 <oslib_test_003_001_execute+0x314>)
  206ece:	bf18      	it	ne
  206ed0:	2001      	movne	r0, #1
  206ed2:	f7f9 fc75 	bl	2007c0 <_test_assert>
  206ed6:	2800      	cmp	r0, #0
  206ed8:	d1de      	bne.n	206e98 <oslib_test_003_001_execute+0x28>
    chHeapFree(p1);
  206eda:	4628      	mov	r0, r5
  206edc:	f7ff ff30 	bl	206d40 <chHeapFree>
  test_set_step(4);
  206ee0:	2304      	movs	r3, #4
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
  206ee2:	a903      	add	r1, sp, #12
  206ee4:	aa02      	add	r2, sp, #8
  206ee6:	48a4      	ldr	r0, [pc, #656]	; (207178 <oslib_test_003_001_execute+0x308>)
  test_set_step(4);
  206ee8:	6023      	str	r3, [r4, #0]
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
  206eea:	f7ff fec1 	bl	206c70 <chHeapStatus>
  206eee:	4603      	mov	r3, r0
    test_assert(n == 1, "missing free block");
  206ef0:	f1a0 0001 	sub.w	r0, r0, #1
  206ef4:	49a4      	ldr	r1, [pc, #656]	; (207188 <oslib_test_003_001_execute+0x318>)
  206ef6:	fab0 f080 	clz	r0, r0
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
  206efa:	9301      	str	r3, [sp, #4]
    test_assert(n == 1, "missing free block");
  206efc:	0940      	lsrs	r0, r0, #5
  206efe:	f7f9 fc5f 	bl	2007c0 <_test_assert>
  206f02:	2800      	cmp	r0, #0
  206f04:	d1c8      	bne.n	206e98 <oslib_test_003_001_execute+0x28>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
  206f06:	9803      	ldr	r0, [sp, #12]
  206f08:	49a0      	ldr	r1, [pc, #640]	; (20718c <oslib_test_003_001_execute+0x31c>)
  206f0a:	280f      	cmp	r0, #15
  206f0c:	bf94      	ite	ls
  206f0e:	2000      	movls	r0, #0
  206f10:	2001      	movhi	r0, #1
  206f12:	f7f9 fc55 	bl	2007c0 <_test_assert>
  206f16:	2800      	cmp	r0, #0
  206f18:	d1be      	bne.n	206e98 <oslib_test_003_001_execute+0x28>
    test_assert(total_size == largest_size, "unexpected heap state");
  206f1a:	499c      	ldr	r1, [pc, #624]	; (20718c <oslib_test_003_001_execute+0x31c>)
  206f1c:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
  206f20:	1ac0      	subs	r0, r0, r3
  206f22:	fab0 f080 	clz	r0, r0
  206f26:	0940      	lsrs	r0, r0, #5
  206f28:	f7f9 fc4a 	bl	2007c0 <_test_assert>
  206f2c:	4605      	mov	r5, r0
  206f2e:	2800      	cmp	r0, #0
  206f30:	d1b2      	bne.n	206e98 <oslib_test_003_001_execute+0x28>
  test_set_step(5);
  206f32:	2305      	movs	r3, #5
  206f34:	2110      	movs	r1, #16
  206f36:	4890      	ldr	r0, [pc, #576]	; (207178 <oslib_test_003_001_execute+0x308>)
  206f38:	6023      	str	r3, [r4, #0]
  206f3a:	f7ff f9e9 	bl	206310 <chHeapAllocAligned.constprop.32>
  206f3e:	2110      	movs	r1, #16
  206f40:	4680      	mov	r8, r0
  206f42:	488d      	ldr	r0, [pc, #564]	; (207178 <oslib_test_003_001_execute+0x308>)
  206f44:	f7ff f9e4 	bl	206310 <chHeapAllocAligned.constprop.32>
  206f48:	2110      	movs	r1, #16
  206f4a:	4607      	mov	r7, r0
  206f4c:	488a      	ldr	r0, [pc, #552]	; (207178 <oslib_test_003_001_execute+0x308>)
  206f4e:	f7ff f9df 	bl	206310 <chHeapAllocAligned.constprop.32>
  206f52:	4606      	mov	r6, r0
    chHeapFree(p1);                                 /* Does not merge.*/
  206f54:	4640      	mov	r0, r8
  206f56:	f7ff fef3 	bl	206d40 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
  206f5a:	4638      	mov	r0, r7
  206f5c:	f7ff fef0 	bl	206d40 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
  206f60:	4630      	mov	r0, r6
  206f62:	f7ff feed 	bl	206d40 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  206f66:	462a      	mov	r2, r5
  206f68:	a901      	add	r1, sp, #4
  206f6a:	4883      	ldr	r0, [pc, #524]	; (207178 <oslib_test_003_001_execute+0x308>)
  206f6c:	f7ff fe80 	bl	206c70 <chHeapStatus>
  206f70:	f1a0 0001 	sub.w	r0, r0, #1
  206f74:	4981      	ldr	r1, [pc, #516]	; (20717c <oslib_test_003_001_execute+0x30c>)
  206f76:	fab0 f080 	clz	r0, r0
  206f7a:	0940      	lsrs	r0, r0, #5
  206f7c:	f7f9 fc20 	bl	2007c0 <_test_assert>
  206f80:	4605      	mov	r5, r0
  206f82:	2800      	cmp	r0, #0
  206f84:	d188      	bne.n	206e98 <oslib_test_003_001_execute+0x28>
  test_set_step(6);
  206f86:	2306      	movs	r3, #6
  206f88:	2110      	movs	r1, #16
  206f8a:	487b      	ldr	r0, [pc, #492]	; (207178 <oslib_test_003_001_execute+0x308>)
  206f8c:	6023      	str	r3, [r4, #0]
  206f8e:	f7ff f9bf 	bl	206310 <chHeapAllocAligned.constprop.32>
  206f92:	2110      	movs	r1, #16
  206f94:	4606      	mov	r6, r0
  206f96:	4878      	ldr	r0, [pc, #480]	; (207178 <oslib_test_003_001_execute+0x308>)
  206f98:	f7ff f9ba 	bl	206310 <chHeapAllocAligned.constprop.32>
  206f9c:	2110      	movs	r1, #16
  206f9e:	4607      	mov	r7, r0
  206fa0:	4875      	ldr	r0, [pc, #468]	; (207178 <oslib_test_003_001_execute+0x308>)
  206fa2:	f7ff f9b5 	bl	206310 <chHeapAllocAligned.constprop.32>
    chHeapFree(p3);                                 /* Merges forward.*/
  206fa6:	f7ff fecb 	bl	206d40 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
  206faa:	4638      	mov	r0, r7
  206fac:	f7ff fec8 	bl	206d40 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
  206fb0:	4630      	mov	r0, r6
  206fb2:	f7ff fec5 	bl	206d40 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  206fb6:	462a      	mov	r2, r5
  206fb8:	a901      	add	r1, sp, #4
  206fba:	486f      	ldr	r0, [pc, #444]	; (207178 <oslib_test_003_001_execute+0x308>)
  206fbc:	f7ff fe58 	bl	206c70 <chHeapStatus>
  206fc0:	1e43      	subs	r3, r0, #1
  206fc2:	496e      	ldr	r1, [pc, #440]	; (20717c <oslib_test_003_001_execute+0x30c>)
  206fc4:	4258      	negs	r0, r3
  206fc6:	4158      	adcs	r0, r3
  206fc8:	f7f9 fbfa 	bl	2007c0 <_test_assert>
  206fcc:	4605      	mov	r5, r0
  206fce:	2800      	cmp	r0, #0
  206fd0:	f47f af62 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
  test_set_step(7);
  206fd4:	2307      	movs	r3, #7
  206fd6:	2111      	movs	r1, #17
  206fd8:	4867      	ldr	r0, [pc, #412]	; (207178 <oslib_test_003_001_execute+0x308>)
  206fda:	6023      	str	r3, [r4, #0]
  206fdc:	f7ff f998 	bl	206310 <chHeapAllocAligned.constprop.32>
  206fe0:	4606      	mov	r6, r0
  206fe2:	2110      	movs	r1, #16
  206fe4:	4864      	ldr	r0, [pc, #400]	; (207178 <oslib_test_003_001_execute+0x308>)
  206fe6:	f7ff f993 	bl	206310 <chHeapAllocAligned.constprop.32>
  206fea:	4607      	mov	r7, r0
    chHeapFree(p1);
  206fec:	4630      	mov	r0, r6
  206fee:	f7ff fea7 	bl	206d40 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
  206ff2:	462a      	mov	r2, r5
  206ff4:	a901      	add	r1, sp, #4
  206ff6:	4860      	ldr	r0, [pc, #384]	; (207178 <oslib_test_003_001_execute+0x308>)
  206ff8:	f7ff fe3a 	bl	206c70 <chHeapStatus>
  206ffc:	f1a0 0802 	sub.w	r8, r0, #2
  207000:	4963      	ldr	r1, [pc, #396]	; (207190 <oslib_test_003_001_execute+0x320>)
  207002:	f1d8 0000 	rsbs	r0, r8, #0
  207006:	eb40 0008 	adc.w	r0, r0, r8
  20700a:	f7f9 fbd9 	bl	2007c0 <_test_assert>
  20700e:	4605      	mov	r5, r0
  207010:	2800      	cmp	r0, #0
  207012:	f47f af41 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
  207016:	2110      	movs	r1, #16
  207018:	4857      	ldr	r0, [pc, #348]	; (207178 <oslib_test_003_001_execute+0x308>)
  20701a:	f7ff f979 	bl	206310 <chHeapAllocAligned.constprop.32>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
  20701e:	462a      	mov	r2, r5
  207020:	4606      	mov	r6, r0
  207022:	a901      	add	r1, sp, #4
  207024:	4854      	ldr	r0, [pc, #336]	; (207178 <oslib_test_003_001_execute+0x308>)
  207026:	f7ff fe23 	bl	206c70 <chHeapStatus>
  20702a:	2801      	cmp	r0, #1
  20702c:	f000 809f 	beq.w	20716e <oslib_test_003_001_execute+0x2fe>
  207030:	2200      	movs	r2, #0
  207032:	a901      	add	r1, sp, #4
  207034:	4850      	ldr	r0, [pc, #320]	; (207178 <oslib_test_003_001_execute+0x308>)
  207036:	f7ff fe1b 	bl	206c70 <chHeapStatus>
  20703a:	f1a0 0e02 	sub.w	lr, r0, #2
  20703e:	f1de 0000 	rsbs	r0, lr, #0
  207042:	eb40 000e 	adc.w	r0, r0, lr
  207046:	494d      	ldr	r1, [pc, #308]	; (20717c <oslib_test_003_001_execute+0x30c>)
  207048:	f7f9 fbba 	bl	2007c0 <_test_assert>
  20704c:	4605      	mov	r5, r0
  20704e:	2800      	cmp	r0, #0
  207050:	f47f af22 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
    chHeapFree(p2);
  207054:	4638      	mov	r0, r7
  207056:	f7ff fe73 	bl	206d40 <chHeapFree>
    chHeapFree(p1);
  20705a:	4630      	mov	r0, r6
  20705c:	f7ff fe70 	bl	206d40 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  207060:	462a      	mov	r2, r5
  207062:	a901      	add	r1, sp, #4
  207064:	4844      	ldr	r0, [pc, #272]	; (207178 <oslib_test_003_001_execute+0x308>)
  207066:	f7ff fe03 	bl	206c70 <chHeapStatus>
  20706a:	f100 3cff 	add.w	ip, r0, #4294967295
  20706e:	4943      	ldr	r1, [pc, #268]	; (20717c <oslib_test_003_001_execute+0x30c>)
  207070:	f1dc 0000 	rsbs	r0, ip, #0
  207074:	eb40 000c 	adc.w	r0, r0, ip
  207078:	f7f9 fba2 	bl	2007c0 <_test_assert>
  20707c:	4605      	mov	r5, r0
  20707e:	2800      	cmp	r0, #0
  207080:	f47f af0a 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
  test_set_step(8);
  207084:	2308      	movs	r3, #8
  207086:	2110      	movs	r1, #16
  207088:	483b      	ldr	r0, [pc, #236]	; (207178 <oslib_test_003_001_execute+0x308>)
  20708a:	6023      	str	r3, [r4, #0]
  20708c:	f7ff f940 	bl	206310 <chHeapAllocAligned.constprop.32>
  207090:	4607      	mov	r7, r0
  207092:	2110      	movs	r1, #16
  207094:	4838      	ldr	r0, [pc, #224]	; (207178 <oslib_test_003_001_execute+0x308>)
  207096:	f7ff f93b 	bl	206310 <chHeapAllocAligned.constprop.32>
  20709a:	4606      	mov	r6, r0
    chHeapFree(p1);
  20709c:	4638      	mov	r0, r7
  20709e:	f7ff fe4f 	bl	206d40 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
  2070a2:	462a      	mov	r2, r5
  2070a4:	a901      	add	r1, sp, #4
  2070a6:	4834      	ldr	r0, [pc, #208]	; (207178 <oslib_test_003_001_execute+0x308>)
  2070a8:	f7ff fde2 	bl	206c70 <chHeapStatus>
  2070ac:	1e87      	subs	r7, r0, #2
  2070ae:	4938      	ldr	r1, [pc, #224]	; (207190 <oslib_test_003_001_execute+0x320>)
  2070b0:	4278      	negs	r0, r7
  2070b2:	4178      	adcs	r0, r7
  2070b4:	f7f9 fb84 	bl	2007c0 <_test_assert>
  2070b8:	4605      	mov	r5, r0
  2070ba:	2800      	cmp	r0, #0
  2070bc:	f47f aeec 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
  2070c0:	2120      	movs	r1, #32
  2070c2:	482d      	ldr	r0, [pc, #180]	; (207178 <oslib_test_003_001_execute+0x308>)
  2070c4:	f7ff f924 	bl	206310 <chHeapAllocAligned.constprop.32>
    chHeapFree(p1);
  2070c8:	f7ff fe3a 	bl	206d40 <chHeapFree>
    chHeapFree(p2);
  2070cc:	4630      	mov	r0, r6
  2070ce:	f7ff fe37 	bl	206d40 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  2070d2:	462a      	mov	r2, r5
  2070d4:	a901      	add	r1, sp, #4
  2070d6:	4828      	ldr	r0, [pc, #160]	; (207178 <oslib_test_003_001_execute+0x308>)
  2070d8:	f7ff fdca 	bl	206c70 <chHeapStatus>
  2070dc:	1e45      	subs	r5, r0, #1
  2070de:	4927      	ldr	r1, [pc, #156]	; (20717c <oslib_test_003_001_execute+0x30c>)
  2070e0:	4268      	negs	r0, r5
  2070e2:	4168      	adcs	r0, r5
  2070e4:	f7f9 fb6c 	bl	2007c0 <_test_assert>
  2070e8:	4602      	mov	r2, r0
  2070ea:	2800      	cmp	r0, #0
  2070ec:	f47f aed4 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
  test_set_step(9);
  2070f0:	2309      	movs	r3, #9
    (void)chHeapStatus(&test_heap, &n, NULL);
  2070f2:	a901      	add	r1, sp, #4
  2070f4:	4820      	ldr	r0, [pc, #128]	; (207178 <oslib_test_003_001_execute+0x308>)
  test_set_step(9);
  2070f6:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(&test_heap, &n, NULL);
  2070f8:	f7ff fdba 	bl	206c70 <chHeapStatus>
  2070fc:	9901      	ldr	r1, [sp, #4]
  2070fe:	481e      	ldr	r0, [pc, #120]	; (207178 <oslib_test_003_001_execute+0x308>)
  207100:	f7ff f906 	bl	206310 <chHeapAllocAligned.constprop.32>
    test_assert(p1 != NULL, "allocation failed");
  207104:	4606      	mov	r6, r0
  207106:	3000      	adds	r0, #0
  207108:	491e      	ldr	r1, [pc, #120]	; (207184 <oslib_test_003_001_execute+0x314>)
  20710a:	bf18      	it	ne
  20710c:	2001      	movne	r0, #1
  20710e:	f7f9 fb57 	bl	2007c0 <_test_assert>
  207112:	4602      	mov	r2, r0
  207114:	2800      	cmp	r0, #0
  207116:	f47f aebf 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
  20711a:	4601      	mov	r1, r0
  20711c:	4816      	ldr	r0, [pc, #88]	; (207178 <oslib_test_003_001_execute+0x308>)
  20711e:	f7ff fda7 	bl	206c70 <chHeapStatus>
  207122:	fab0 f080 	clz	r0, r0
  207126:	491b      	ldr	r1, [pc, #108]	; (207194 <oslib_test_003_001_execute+0x324>)
  207128:	0940      	lsrs	r0, r0, #5
  20712a:	f7f9 fb49 	bl	2007c0 <_test_assert>
  20712e:	4605      	mov	r5, r0
  207130:	2800      	cmp	r0, #0
  207132:	f47f aeb1 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
    chHeapFree(p1);
  207136:	4630      	mov	r0, r6
  207138:	f7ff fe02 	bl	206d40 <chHeapFree>
  test_set_step(10);
  20713c:	230a      	movs	r3, #10
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  20713e:	462a      	mov	r2, r5
  207140:	a901      	add	r1, sp, #4
  207142:	480d      	ldr	r0, [pc, #52]	; (207178 <oslib_test_003_001_execute+0x308>)
  test_set_step(10);
  207144:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  207146:	f7ff fd93 	bl	206c70 <chHeapStatus>
  20714a:	1e42      	subs	r2, r0, #1
  20714c:	490b      	ldr	r1, [pc, #44]	; (20717c <oslib_test_003_001_execute+0x30c>)
  20714e:	4250      	negs	r0, r2
  207150:	4150      	adcs	r0, r2
  207152:	f7f9 fb35 	bl	2007c0 <_test_assert>
  207156:	2800      	cmp	r0, #0
  207158:	f47f ae9e 	bne.w	206e98 <oslib_test_003_001_execute+0x28>
    test_assert(n == sz, "size changed");
  20715c:	490e      	ldr	r1, [pc, #56]	; (207198 <oslib_test_003_001_execute+0x328>)
  20715e:	e9dd 3000 	ldrd	r3, r0, [sp]
  207162:	1ac3      	subs	r3, r0, r3
  207164:	4258      	negs	r0, r3
  207166:	4158      	adcs	r0, r3
  207168:	f7f9 fb2a 	bl	2007c0 <_test_assert>
  20716c:	e694      	b.n	206e98 <oslib_test_003_001_execute+0x28>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
  20716e:	2001      	movs	r0, #1
  207170:	e769      	b.n	207046 <oslib_test_003_001_execute+0x1d6>
  207172:	bf00      	nop
  207174:	20001f6c 	.word	0x20001f6c
  207178:	20001ecc 	.word	0x20001ecc
  20717c:	0800c730 	.word	0x0800c730
  207180:	0800c7b0 	.word	0x0800c7b0
  207184:	0800c79c 	.word	0x0800c79c
  207188:	0800c740 	.word	0x0800c740
  20718c:	0800c754 	.word	0x0800c754
  207190:	0800c76c 	.word	0x0800c76c
  207194:	0800c5e4 	.word	0x0800c5e4
  207198:	0800c77c 	.word	0x0800c77c
  20719c:	00000000 	.word	0x00000000

002071a0 <dyn_release_object_heap>:
                                    dyn_list_t *dlp) {
  2071a0:	b508      	push	{r3, lr}
  chDbgCheck(dep != NULL);
  2071a2:	b190      	cbz	r0, 2071ca <dyn_release_object_heap+0x2a>
  chDbgAssert(dep->refs > (ucnt_t)0, "invalid references number");
  2071a4:	6843      	ldr	r3, [r0, #4]
  2071a6:	b183      	cbz	r3, 2071ca <dyn_release_object_heap+0x2a>
  dep->refs--;
  2071a8:	3b01      	subs	r3, #1
  2071aa:	6043      	str	r3, [r0, #4]
  if (dep->refs == (ucnt_t)0) {
  2071ac:	b963      	cbnz	r3, 2071c8 <dyn_release_object_heap+0x28>
  dyn_element_t *prev = (dyn_element_t *)dlp;
  2071ae:	460a      	mov	r2, r1
  2071b0:	e002      	b.n	2071b8 <dyn_release_object_heap+0x18>
    if (prev->next == element) {
  2071b2:	4298      	cmp	r0, r3
  2071b4:	d00c      	beq.n	2071d0 <dyn_release_object_heap+0x30>
  2071b6:	461a      	mov	r2, r3
  while (prev->next != (dyn_element_t *)dlp) {
  2071b8:	6813      	ldr	r3, [r2, #0]
  2071ba:	4299      	cmp	r1, r3
  2071bc:	d1f9      	bne.n	2071b2 <dyn_release_object_heap+0x12>
  return NULL;
  2071be:	2000      	movs	r0, #0
}
  2071c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    chHeapFree((void *)dep);
  2071c4:	f7ff bdbc 	b.w	206d40 <chHeapFree>
}
  2071c8:	bd08      	pop	{r3, pc}
  chDbgCheck(dep != NULL);
  2071ca:	4804      	ldr	r0, [pc, #16]	; (2071dc <dyn_release_object_heap+0x3c>)
  2071cc:	f7f9 fcd0 	bl	200b70 <chSysHalt>
      prev->next = element->next;
  2071d0:	6803      	ldr	r3, [r0, #0]
  2071d2:	6013      	str	r3, [r2, #0]
}
  2071d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    chHeapFree((void *)dep);
  2071d8:	f7ff bdb2 	b.w	206d40 <chHeapFree>
  2071dc:	0800bfb4 	.word	0x0800bfb4

002071e0 <chFactoryReleaseObjectsFIFO>:
 *
 * @param[in] dofp      dynamic "objects FIFO" object reference
 *
 * @api
 */
void chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
  2071e0:	b538      	push	{r3, r4, r5, lr}

  F_LOCK();
  2071e2:	4c07      	ldr	r4, [pc, #28]	; (207200 <chFactoryReleaseObjectsFIFO+0x20>)
void chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
  2071e4:	4605      	mov	r5, r0
  F_LOCK();
  2071e6:	4620      	mov	r0, r4
  2071e8:	f7ff f86a 	bl	2062c0 <chMtxLock>

  dyn_release_object_heap(&dofp->element, &ch_factory.fifo_list);
  2071ec:	4628      	mov	r0, r5
  2071ee:	f104 0140 	add.w	r1, r4, #64	; 0x40
  2071f2:	f7ff ffd5 	bl	2071a0 <dyn_release_object_heap>

  F_UNLOCK();
  2071f6:	4620      	mov	r0, r4
}
  2071f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
  2071fc:	f7fe bf30 	b.w	206060 <chMtxUnlock>
  207200:	20001650 	.word	0x20001650
	...

00207210 <oslib_test_004_005_execute>:
      chFactoryReleaseObjectsFIFO(dofp);
    }
  }
}

static void oslib_test_004_005_execute(void) {
  207210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_objects_fifo_t *dofp;

  /* [4.5.1] Retrieving a dynamic objects FIFO by name, must not
     exist.*/
  test_set_step(1);
  207212:	4c42      	ldr	r4, [pc, #264]	; (20731c <oslib_test_004_005_execute+0x10c>)
  207214:	2501      	movs	r5, #1
  207216:	6025      	str	r5, [r4, #0]
  {
    dofp = chFactoryFindObjectsFIFO("myfifo");
  207218:	f7ff fa9a 	bl	206750 <chFactoryFindObjectsFIFO.constprop.5>
    test_assert(dofp == NULL, "found");
  20721c:	fab0 f080 	clz	r0, r0
  207220:	493f      	ldr	r1, [pc, #252]	; (207320 <oslib_test_004_005_execute+0x110>)
  207222:	0940      	lsrs	r0, r0, #5
  207224:	f7f9 facc 	bl	2007c0 <_test_assert>
  207228:	b100      	cbz	r0, 20722c <oslib_test_004_005_execute+0x1c>
  test_set_step(6);
  {
    dofp = chFactoryFindObjectsFIFO("myfifo");
    test_assert(dofp == NULL, "found");
  }
}
  20722a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
  20722c:	2302      	movs	r3, #2
  20722e:	6023      	str	r3, [r4, #0]
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
  207230:	f7ff fa46 	bl	2066c0 <chFactoryCreateObjectsFIFO.constprop.6>
    test_assert(dofp != NULL, "cannot create");
  207234:	4606      	mov	r6, r0
  207236:	3000      	adds	r0, #0
  207238:	493a      	ldr	r1, [pc, #232]	; (207324 <oslib_test_004_005_execute+0x114>)
  20723a:	bf18      	it	ne
  20723c:	2001      	movne	r0, #1
  20723e:	f7f9 fabf 	bl	2007c0 <_test_assert>
  207242:	2800      	cmp	r0, #0
  207244:	d1f1      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
  test_set_step(3);
  207246:	2303      	movs	r3, #3
  207248:	6023      	str	r3, [r4, #0]
    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
  20724a:	f7ff fa39 	bl	2066c0 <chFactoryCreateObjectsFIFO.constprop.6>
    test_assert(dofp1 == NULL, "can create");
  20724e:	fab0 f080 	clz	r0, r0
  207252:	4935      	ldr	r1, [pc, #212]	; (207328 <oslib_test_004_005_execute+0x118>)
  207254:	0940      	lsrs	r0, r0, #5
  207256:	f7f9 fab3 	bl	2007c0 <_test_assert>
  20725a:	2800      	cmp	r0, #0
  20725c:	d1e5      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
  test_set_step(4);
  20725e:	2304      	movs	r3, #4
  207260:	6023      	str	r3, [r4, #0]
    dofp1 = chFactoryFindObjectsFIFO("myfifo");
  207262:	f7ff fa75 	bl	206750 <chFactoryFindObjectsFIFO.constprop.5>
    test_assert(dofp1 != NULL, "not found");
  207266:	4607      	mov	r7, r0
  207268:	3000      	adds	r0, #0
  20726a:	4930      	ldr	r1, [pc, #192]	; (20732c <oslib_test_004_005_execute+0x11c>)
  20726c:	bf18      	it	ne
  20726e:	2001      	movne	r0, #1
  207270:	f7f9 faa6 	bl	2007c0 <_test_assert>
  207274:	2800      	cmp	r0, #0
  207276:	d1d8      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
    test_assert(dofp == dofp1, "object reference mismatch");
  207278:	1bf0      	subs	r0, r6, r7
  20727a:	492d      	ldr	r1, [pc, #180]	; (207330 <oslib_test_004_005_execute+0x120>)
  20727c:	fab0 f080 	clz	r0, r0
  207280:	0940      	lsrs	r0, r0, #5
  207282:	f7f9 fa9d 	bl	2007c0 <_test_assert>
  207286:	2800      	cmp	r0, #0
  207288:	d1cf      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
    test_assert(dofp1->element.refs == 2, "object reference mismatch");
  20728a:	6878      	ldr	r0, [r7, #4]
  20728c:	4928      	ldr	r1, [pc, #160]	; (207330 <oslib_test_004_005_execute+0x120>)
  20728e:	f1a0 0002 	sub.w	r0, r0, #2
  207292:	fab0 f080 	clz	r0, r0
  207296:	0940      	lsrs	r0, r0, #5
  207298:	f7f9 fa92 	bl	2007c0 <_test_assert>
  20729c:	2800      	cmp	r0, #0
  20729e:	d1c4      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
  2072a0:	687b      	ldr	r3, [r7, #4]
    test_assert(dofp1 == dofp2, "object reference mismatch");
  2072a2:	4628      	mov	r0, r5
  2072a4:	4922      	ldr	r1, [pc, #136]	; (207330 <oslib_test_004_005_execute+0x120>)
  2072a6:	442b      	add	r3, r5
  2072a8:	607b      	str	r3, [r7, #4]
  2072aa:	f7f9 fa89 	bl	2007c0 <_test_assert>
  2072ae:	2800      	cmp	r0, #0
  2072b0:	d1bb      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
    test_assert(dofp2->element.refs == 3, "object reference mismatch");
  2072b2:	6878      	ldr	r0, [r7, #4]
  2072b4:	491e      	ldr	r1, [pc, #120]	; (207330 <oslib_test_004_005_execute+0x120>)
  2072b6:	f1a0 0c03 	sub.w	ip, r0, #3
  2072ba:	f1dc 0000 	rsbs	r0, ip, #0
  2072be:	eb40 000c 	adc.w	r0, r0, ip
  2072c2:	f7f9 fa7d 	bl	2007c0 <_test_assert>
  2072c6:	2800      	cmp	r0, #0
  2072c8:	d1af      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
    chFactoryReleaseObjectsFIFO(dofp2);
  2072ca:	4638      	mov	r0, r7
  2072cc:	f7ff ff88 	bl	2071e0 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp1->element.refs == 2, "references mismatch");
  2072d0:	6878      	ldr	r0, [r7, #4]
  2072d2:	4918      	ldr	r1, [pc, #96]	; (207334 <oslib_test_004_005_execute+0x124>)
  2072d4:	1e82      	subs	r2, r0, #2
  2072d6:	4250      	negs	r0, r2
  2072d8:	4150      	adcs	r0, r2
  2072da:	f7f9 fa71 	bl	2007c0 <_test_assert>
  2072de:	2800      	cmp	r0, #0
  2072e0:	d1a3      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
    chFactoryReleaseObjectsFIFO(dofp1);
  2072e2:	4638      	mov	r0, r7
  2072e4:	f7ff ff7c 	bl	2071e0 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp->element.refs == 1, "references mismatch");
  2072e8:	6870      	ldr	r0, [r6, #4]
  2072ea:	4912      	ldr	r1, [pc, #72]	; (207334 <oslib_test_004_005_execute+0x124>)
  2072ec:	1b43      	subs	r3, r0, r5
  2072ee:	4258      	negs	r0, r3
  2072f0:	4158      	adcs	r0, r3
  2072f2:	f7f9 fa65 	bl	2007c0 <_test_assert>
  2072f6:	2800      	cmp	r0, #0
  2072f8:	d197      	bne.n	20722a <oslib_test_004_005_execute+0x1a>
  test_set_step(5);
  2072fa:	2305      	movs	r3, #5
    chFactoryReleaseObjectsFIFO(dofp);
  2072fc:	4630      	mov	r0, r6
  test_set_step(5);
  2072fe:	6023      	str	r3, [r4, #0]
    chFactoryReleaseObjectsFIFO(dofp);
  207300:	f7ff ff6e 	bl	2071e0 <chFactoryReleaseObjectsFIFO>
  test_set_step(6);
  207304:	2306      	movs	r3, #6
  207306:	6023      	str	r3, [r4, #0]
    dofp = chFactoryFindObjectsFIFO("myfifo");
  207308:	f7ff fa22 	bl	206750 <chFactoryFindObjectsFIFO.constprop.5>
    test_assert(dofp == NULL, "found");
  20730c:	fab0 f080 	clz	r0, r0
  207310:	4903      	ldr	r1, [pc, #12]	; (207320 <oslib_test_004_005_execute+0x110>)
  207312:	0940      	lsrs	r0, r0, #5
}
  207314:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dofp == NULL, "found");
  207318:	f7f9 ba52 	b.w	2007c0 <_test_assert>
  20731c:	20001f6c 	.word	0x20001f6c
  207320:	0800c848 	.word	0x0800c848
  207324:	0800c828 	.word	0x0800c828
  207328:	0800c838 	.word	0x0800c838
  20732c:	0800c844 	.word	0x0800c844
  207330:	0800c850 	.word	0x0800c850
  207334:	0800c86c 	.word	0x0800c86c
	...

00207340 <oslib_test_004_005_teardown>:
static void oslib_test_004_005_teardown(void) {
  207340:	b510      	push	{r4, lr}
  dofp = chFactoryFindObjectsFIFO("myfifo");
  207342:	f7ff fa05 	bl	206750 <chFactoryFindObjectsFIFO.constprop.5>
  if (dofp != NULL) {
  207346:	b140      	cbz	r0, 20735a <oslib_test_004_005_teardown+0x1a>
    while (dofp->element.refs > 0U) {
  207348:	6843      	ldr	r3, [r0, #4]
  20734a:	4604      	mov	r4, r0
  20734c:	b12b      	cbz	r3, 20735a <oslib_test_004_005_teardown+0x1a>
      chFactoryReleaseObjectsFIFO(dofp);
  20734e:	4620      	mov	r0, r4
  207350:	f7ff ff46 	bl	2071e0 <chFactoryReleaseObjectsFIFO>
    while (dofp->element.refs > 0U) {
  207354:	6863      	ldr	r3, [r4, #4]
  207356:	2b00      	cmp	r3, #0
  207358:	d1f9      	bne.n	20734e <oslib_test_004_005_teardown+0xe>
}
  20735a:	bd10      	pop	{r4, pc}
  20735c:	0000      	movs	r0, r0
	...

00207360 <chFactoryReleaseMailbox>:
void chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
  207360:	b538      	push	{r3, r4, r5, lr}
  F_LOCK();
  207362:	4c07      	ldr	r4, [pc, #28]	; (207380 <chFactoryReleaseMailbox+0x20>)
void chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
  207364:	4605      	mov	r5, r0
  F_LOCK();
  207366:	4620      	mov	r0, r4
  207368:	f7fe ffaa 	bl	2062c0 <chMtxLock>
  dyn_release_object_heap(&dmp->element, &ch_factory.mbx_list);
  20736c:	4628      	mov	r0, r5
  20736e:	f104 013c 	add.w	r1, r4, #60	; 0x3c
  207372:	f7ff ff15 	bl	2071a0 <dyn_release_object_heap>
  F_UNLOCK();
  207376:	4620      	mov	r0, r4
}
  207378:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
  20737c:	f7fe be70 	b.w	206060 <chMtxUnlock>
  207380:	20001650 	.word	0x20001650
	...

00207390 <oslib_test_004_004_execute>:
static void oslib_test_004_004_execute(void) {
  207390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
  207392:	4c42      	ldr	r4, [pc, #264]	; (20749c <oslib_test_004_004_execute+0x10c>)
  207394:	2501      	movs	r5, #1
  207396:	6025      	str	r5, [r4, #0]
    dmp = chFactoryFindMailbox("mymbx");
  207398:	f7ff f97a 	bl	206690 <chFactoryFindMailbox.constprop.7>
    test_assert(dmp == NULL, "found");
  20739c:	fab0 f080 	clz	r0, r0
  2073a0:	493f      	ldr	r1, [pc, #252]	; (2074a0 <oslib_test_004_004_execute+0x110>)
  2073a2:	0940      	lsrs	r0, r0, #5
  2073a4:	f7f9 fa0c 	bl	2007c0 <_test_assert>
  2073a8:	b100      	cbz	r0, 2073ac <oslib_test_004_004_execute+0x1c>
}
  2073aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
  2073ac:	2302      	movs	r3, #2
  2073ae:	6023      	str	r3, [r4, #0]
    dmp = chFactoryCreateMailbox("mymbx", 16U);
  2073b0:	f7ff f93e 	bl	206630 <chFactoryCreateMailbox.constprop.8>
    test_assert(dmp != NULL, "cannot create");
  2073b4:	4606      	mov	r6, r0
  2073b6:	3000      	adds	r0, #0
  2073b8:	493a      	ldr	r1, [pc, #232]	; (2074a4 <oslib_test_004_004_execute+0x114>)
  2073ba:	bf18      	it	ne
  2073bc:	2001      	movne	r0, #1
  2073be:	f7f9 f9ff 	bl	2007c0 <_test_assert>
  2073c2:	2800      	cmp	r0, #0
  2073c4:	d1f1      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
  test_set_step(3);
  2073c6:	2303      	movs	r3, #3
  2073c8:	6023      	str	r3, [r4, #0]
    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
  2073ca:	f7ff f931 	bl	206630 <chFactoryCreateMailbox.constprop.8>
    test_assert(dmp1 == NULL, "can create");
  2073ce:	fab0 f080 	clz	r0, r0
  2073d2:	4935      	ldr	r1, [pc, #212]	; (2074a8 <oslib_test_004_004_execute+0x118>)
  2073d4:	0940      	lsrs	r0, r0, #5
  2073d6:	f7f9 f9f3 	bl	2007c0 <_test_assert>
  2073da:	2800      	cmp	r0, #0
  2073dc:	d1e5      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
  test_set_step(4);
  2073de:	2304      	movs	r3, #4
  2073e0:	6023      	str	r3, [r4, #0]
    dmp1 = chFactoryFindMailbox("mymbx");
  2073e2:	f7ff f955 	bl	206690 <chFactoryFindMailbox.constprop.7>
    test_assert(dmp1 != NULL, "not found");
  2073e6:	4607      	mov	r7, r0
  2073e8:	3000      	adds	r0, #0
  2073ea:	4930      	ldr	r1, [pc, #192]	; (2074ac <oslib_test_004_004_execute+0x11c>)
  2073ec:	bf18      	it	ne
  2073ee:	2001      	movne	r0, #1
  2073f0:	f7f9 f9e6 	bl	2007c0 <_test_assert>
  2073f4:	2800      	cmp	r0, #0
  2073f6:	d1d8      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
    test_assert(dmp == dmp1, "object reference mismatch");
  2073f8:	1bf0      	subs	r0, r6, r7
  2073fa:	492d      	ldr	r1, [pc, #180]	; (2074b0 <oslib_test_004_004_execute+0x120>)
  2073fc:	fab0 f080 	clz	r0, r0
  207400:	0940      	lsrs	r0, r0, #5
  207402:	f7f9 f9dd 	bl	2007c0 <_test_assert>
  207406:	2800      	cmp	r0, #0
  207408:	d1cf      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
    test_assert(dmp1->element.refs == 2, "object reference mismatch");
  20740a:	6878      	ldr	r0, [r7, #4]
  20740c:	4928      	ldr	r1, [pc, #160]	; (2074b0 <oslib_test_004_004_execute+0x120>)
  20740e:	f1a0 0002 	sub.w	r0, r0, #2
  207412:	fab0 f080 	clz	r0, r0
  207416:	0940      	lsrs	r0, r0, #5
  207418:	f7f9 f9d2 	bl	2007c0 <_test_assert>
  20741c:	2800      	cmp	r0, #0
  20741e:	d1c4      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
  207420:	687b      	ldr	r3, [r7, #4]
    test_assert(dmp1 == dmp2, "object reference mismatch");
  207422:	4628      	mov	r0, r5
  207424:	4922      	ldr	r1, [pc, #136]	; (2074b0 <oslib_test_004_004_execute+0x120>)
  207426:	442b      	add	r3, r5
  207428:	607b      	str	r3, [r7, #4]
  20742a:	f7f9 f9c9 	bl	2007c0 <_test_assert>
  20742e:	2800      	cmp	r0, #0
  207430:	d1bb      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
    test_assert(dmp2->element.refs == 3, "object reference mismatch");
  207432:	6878      	ldr	r0, [r7, #4]
  207434:	491e      	ldr	r1, [pc, #120]	; (2074b0 <oslib_test_004_004_execute+0x120>)
  207436:	f1a0 0c03 	sub.w	ip, r0, #3
  20743a:	f1dc 0000 	rsbs	r0, ip, #0
  20743e:	eb40 000c 	adc.w	r0, r0, ip
  207442:	f7f9 f9bd 	bl	2007c0 <_test_assert>
  207446:	2800      	cmp	r0, #0
  207448:	d1af      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
    chFactoryReleaseMailbox(dmp2);
  20744a:	4638      	mov	r0, r7
  20744c:	f7ff ff88 	bl	207360 <chFactoryReleaseMailbox>
    test_assert(dmp1->element.refs == 2, "references mismatch");
  207450:	6878      	ldr	r0, [r7, #4]
  207452:	4918      	ldr	r1, [pc, #96]	; (2074b4 <oslib_test_004_004_execute+0x124>)
  207454:	1e82      	subs	r2, r0, #2
  207456:	4250      	negs	r0, r2
  207458:	4150      	adcs	r0, r2
  20745a:	f7f9 f9b1 	bl	2007c0 <_test_assert>
  20745e:	2800      	cmp	r0, #0
  207460:	d1a3      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
    chFactoryReleaseMailbox(dmp1);
  207462:	4638      	mov	r0, r7
  207464:	f7ff ff7c 	bl	207360 <chFactoryReleaseMailbox>
    test_assert(dmp->element.refs == 1, "references mismatch");
  207468:	6870      	ldr	r0, [r6, #4]
  20746a:	4912      	ldr	r1, [pc, #72]	; (2074b4 <oslib_test_004_004_execute+0x124>)
  20746c:	1b43      	subs	r3, r0, r5
  20746e:	4258      	negs	r0, r3
  207470:	4158      	adcs	r0, r3
  207472:	f7f9 f9a5 	bl	2007c0 <_test_assert>
  207476:	2800      	cmp	r0, #0
  207478:	d197      	bne.n	2073aa <oslib_test_004_004_execute+0x1a>
  test_set_step(5);
  20747a:	2305      	movs	r3, #5
    chFactoryReleaseMailbox(dmp);
  20747c:	4630      	mov	r0, r6
  test_set_step(5);
  20747e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseMailbox(dmp);
  207480:	f7ff ff6e 	bl	207360 <chFactoryReleaseMailbox>
  test_set_step(6);
  207484:	2306      	movs	r3, #6
  207486:	6023      	str	r3, [r4, #0]
    dmp = chFactoryFindMailbox("mymbx");
  207488:	f7ff f902 	bl	206690 <chFactoryFindMailbox.constprop.7>
    test_assert(dmp == NULL, "found");
  20748c:	fab0 f080 	clz	r0, r0
  207490:	4903      	ldr	r1, [pc, #12]	; (2074a0 <oslib_test_004_004_execute+0x110>)
  207492:	0940      	lsrs	r0, r0, #5
}
  207494:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dmp == NULL, "found");
  207498:	f7f9 b992 	b.w	2007c0 <_test_assert>
  20749c:	20001f6c 	.word	0x20001f6c
  2074a0:	0800c848 	.word	0x0800c848
  2074a4:	0800c828 	.word	0x0800c828
  2074a8:	0800c838 	.word	0x0800c838
  2074ac:	0800c844 	.word	0x0800c844
  2074b0:	0800c850 	.word	0x0800c850
  2074b4:	0800c86c 	.word	0x0800c86c
	...

002074c0 <oslib_test_004_004_teardown>:
static void oslib_test_004_004_teardown(void) {
  2074c0:	b510      	push	{r4, lr}
  dmp = chFactoryFindMailbox("mymbx");
  2074c2:	f7ff f8e5 	bl	206690 <chFactoryFindMailbox.constprop.7>
  if (dmp != NULL) {
  2074c6:	b140      	cbz	r0, 2074da <oslib_test_004_004_teardown+0x1a>
    while (dmp->element.refs > 0U) {
  2074c8:	6843      	ldr	r3, [r0, #4]
  2074ca:	4604      	mov	r4, r0
  2074cc:	b12b      	cbz	r3, 2074da <oslib_test_004_004_teardown+0x1a>
      chFactoryReleaseMailbox(dmp);
  2074ce:	4620      	mov	r0, r4
  2074d0:	f7ff ff46 	bl	207360 <chFactoryReleaseMailbox>
    while (dmp->element.refs > 0U) {
  2074d4:	6863      	ldr	r3, [r4, #4]
  2074d6:	2b00      	cmp	r3, #0
  2074d8:	d1f9      	bne.n	2074ce <oslib_test_004_004_teardown+0xe>
}
  2074da:	bd10      	pop	{r4, pc}
  2074dc:	0000      	movs	r0, r0
	...

002074e0 <chFactoryReleaseBuffer>:
void chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
  2074e0:	b538      	push	{r3, r4, r5, lr}
  F_LOCK();
  2074e2:	4c07      	ldr	r4, [pc, #28]	; (207500 <chFactoryReleaseBuffer+0x20>)
void chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
  2074e4:	4605      	mov	r5, r0
  F_LOCK();
  2074e6:	4620      	mov	r0, r4
  2074e8:	f7fe feea 	bl	2062c0 <chMtxLock>
  dyn_release_object_heap(&dbp->element, &ch_factory.buf_list);
  2074ec:	4628      	mov	r0, r5
  2074ee:	f104 0124 	add.w	r1, r4, #36	; 0x24
  2074f2:	f7ff fe55 	bl	2071a0 <dyn_release_object_heap>
  F_UNLOCK();
  2074f6:	4620      	mov	r0, r4
}
  2074f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
  2074fc:	f7fe bdb0 	b.w	206060 <chMtxUnlock>
  207500:	20001650 	.word	0x20001650
	...

00207510 <oslib_test_004_002_execute>:
static void oslib_test_004_002_execute(void) {
  207510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
  207512:	4c42      	ldr	r4, [pc, #264]	; (20761c <oslib_test_004_002_execute+0x10c>)
  207514:	2501      	movs	r5, #1
  207516:	6025      	str	r5, [r4, #0]
    dbp = chFactoryFindBuffer("mybuf");
  207518:	f7ff f83a 	bl	206590 <chFactoryFindBuffer.constprop.11>
    test_assert(dbp == NULL, "found");
  20751c:	fab0 f080 	clz	r0, r0
  207520:	493f      	ldr	r1, [pc, #252]	; (207620 <oslib_test_004_002_execute+0x110>)
  207522:	0940      	lsrs	r0, r0, #5
  207524:	f7f9 f94c 	bl	2007c0 <_test_assert>
  207528:	b100      	cbz	r0, 20752c <oslib_test_004_002_execute+0x1c>
}
  20752a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
  20752c:	2302      	movs	r3, #2
  20752e:	6023      	str	r3, [r4, #0]
    dbp = chFactoryCreateBuffer("mybuf", 128U);
  207530:	f7ff f80e 	bl	206550 <chFactoryCreateBuffer.constprop.12>
    test_assert(dbp != NULL, "cannot create");
  207534:	4606      	mov	r6, r0
  207536:	3000      	adds	r0, #0
  207538:	493a      	ldr	r1, [pc, #232]	; (207624 <oslib_test_004_002_execute+0x114>)
  20753a:	bf18      	it	ne
  20753c:	2001      	movne	r0, #1
  20753e:	f7f9 f93f 	bl	2007c0 <_test_assert>
  207542:	2800      	cmp	r0, #0
  207544:	d1f1      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
  test_set_step(3);
  207546:	2303      	movs	r3, #3
  207548:	6023      	str	r3, [r4, #0]
    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
  20754a:	f7ff f801 	bl	206550 <chFactoryCreateBuffer.constprop.12>
    test_assert(dbp1 == NULL, "can create");
  20754e:	fab0 f080 	clz	r0, r0
  207552:	4935      	ldr	r1, [pc, #212]	; (207628 <oslib_test_004_002_execute+0x118>)
  207554:	0940      	lsrs	r0, r0, #5
  207556:	f7f9 f933 	bl	2007c0 <_test_assert>
  20755a:	2800      	cmp	r0, #0
  20755c:	d1e5      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
  test_set_step(4);
  20755e:	2304      	movs	r3, #4
  207560:	6023      	str	r3, [r4, #0]
    dbp1 = chFactoryFindBuffer("mybuf");
  207562:	f7ff f815 	bl	206590 <chFactoryFindBuffer.constprop.11>
    test_assert(dbp1 != NULL, "not found");
  207566:	4607      	mov	r7, r0
  207568:	3000      	adds	r0, #0
  20756a:	4930      	ldr	r1, [pc, #192]	; (20762c <oslib_test_004_002_execute+0x11c>)
  20756c:	bf18      	it	ne
  20756e:	2001      	movne	r0, #1
  207570:	f7f9 f926 	bl	2007c0 <_test_assert>
  207574:	2800      	cmp	r0, #0
  207576:	d1d8      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
    test_assert(dbp == dbp1, "object reference mismatch");
  207578:	1bf0      	subs	r0, r6, r7
  20757a:	492d      	ldr	r1, [pc, #180]	; (207630 <oslib_test_004_002_execute+0x120>)
  20757c:	fab0 f080 	clz	r0, r0
  207580:	0940      	lsrs	r0, r0, #5
  207582:	f7f9 f91d 	bl	2007c0 <_test_assert>
  207586:	2800      	cmp	r0, #0
  207588:	d1cf      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
    test_assert(dbp1->element.refs == 2, "object reference mismatch");
  20758a:	6878      	ldr	r0, [r7, #4]
  20758c:	4928      	ldr	r1, [pc, #160]	; (207630 <oslib_test_004_002_execute+0x120>)
  20758e:	f1a0 0002 	sub.w	r0, r0, #2
  207592:	fab0 f080 	clz	r0, r0
  207596:	0940      	lsrs	r0, r0, #5
  207598:	f7f9 f912 	bl	2007c0 <_test_assert>
  20759c:	2800      	cmp	r0, #0
  20759e:	d1c4      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
  2075a0:	687b      	ldr	r3, [r7, #4]
    test_assert(dbp1 == dbp2, "object reference mismatch");
  2075a2:	4628      	mov	r0, r5
  2075a4:	4922      	ldr	r1, [pc, #136]	; (207630 <oslib_test_004_002_execute+0x120>)
  2075a6:	442b      	add	r3, r5
  2075a8:	607b      	str	r3, [r7, #4]
  2075aa:	f7f9 f909 	bl	2007c0 <_test_assert>
  2075ae:	2800      	cmp	r0, #0
  2075b0:	d1bb      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
    test_assert(dbp2->element.refs == 3, "object reference mismatch");
  2075b2:	6878      	ldr	r0, [r7, #4]
  2075b4:	491e      	ldr	r1, [pc, #120]	; (207630 <oslib_test_004_002_execute+0x120>)
  2075b6:	f1a0 0c03 	sub.w	ip, r0, #3
  2075ba:	f1dc 0000 	rsbs	r0, ip, #0
  2075be:	eb40 000c 	adc.w	r0, r0, ip
  2075c2:	f7f9 f8fd 	bl	2007c0 <_test_assert>
  2075c6:	2800      	cmp	r0, #0
  2075c8:	d1af      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
    chFactoryReleaseBuffer(dbp2);
  2075ca:	4638      	mov	r0, r7
  2075cc:	f7ff ff88 	bl	2074e0 <chFactoryReleaseBuffer>
    test_assert(dbp1->element.refs == 2, "references mismatch");
  2075d0:	6878      	ldr	r0, [r7, #4]
  2075d2:	4918      	ldr	r1, [pc, #96]	; (207634 <oslib_test_004_002_execute+0x124>)
  2075d4:	1e82      	subs	r2, r0, #2
  2075d6:	4250      	negs	r0, r2
  2075d8:	4150      	adcs	r0, r2
  2075da:	f7f9 f8f1 	bl	2007c0 <_test_assert>
  2075de:	2800      	cmp	r0, #0
  2075e0:	d1a3      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
    chFactoryReleaseBuffer(dbp1);
  2075e2:	4638      	mov	r0, r7
  2075e4:	f7ff ff7c 	bl	2074e0 <chFactoryReleaseBuffer>
    test_assert(dbp->element.refs == 1, "references mismatch");
  2075e8:	6870      	ldr	r0, [r6, #4]
  2075ea:	4912      	ldr	r1, [pc, #72]	; (207634 <oslib_test_004_002_execute+0x124>)
  2075ec:	1b43      	subs	r3, r0, r5
  2075ee:	4258      	negs	r0, r3
  2075f0:	4158      	adcs	r0, r3
  2075f2:	f7f9 f8e5 	bl	2007c0 <_test_assert>
  2075f6:	2800      	cmp	r0, #0
  2075f8:	d197      	bne.n	20752a <oslib_test_004_002_execute+0x1a>
  test_set_step(5);
  2075fa:	2305      	movs	r3, #5
    chFactoryReleaseBuffer(dbp);
  2075fc:	4630      	mov	r0, r6
  test_set_step(5);
  2075fe:	6023      	str	r3, [r4, #0]
    chFactoryReleaseBuffer(dbp);
  207600:	f7ff ff6e 	bl	2074e0 <chFactoryReleaseBuffer>
  test_set_step(6);
  207604:	2306      	movs	r3, #6
  207606:	6023      	str	r3, [r4, #0]
    dbp = chFactoryFindBuffer("mybuf");
  207608:	f7fe ffc2 	bl	206590 <chFactoryFindBuffer.constprop.11>
    test_assert(dbp == NULL, "found");
  20760c:	fab0 f080 	clz	r0, r0
  207610:	4903      	ldr	r1, [pc, #12]	; (207620 <oslib_test_004_002_execute+0x110>)
  207612:	0940      	lsrs	r0, r0, #5
}
  207614:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dbp == NULL, "found");
  207618:	f7f9 b8d2 	b.w	2007c0 <_test_assert>
  20761c:	20001f6c 	.word	0x20001f6c
  207620:	0800c848 	.word	0x0800c848
  207624:	0800c828 	.word	0x0800c828
  207628:	0800c838 	.word	0x0800c838
  20762c:	0800c844 	.word	0x0800c844
  207630:	0800c850 	.word	0x0800c850
  207634:	0800c86c 	.word	0x0800c86c
	...

00207640 <oslib_test_004_002_teardown>:
static void oslib_test_004_002_teardown(void) {
  207640:	b510      	push	{r4, lr}
  dbp = chFactoryFindBuffer("mybuf");
  207642:	f7fe ffa5 	bl	206590 <chFactoryFindBuffer.constprop.11>
  if (dbp != NULL) {
  207646:	b140      	cbz	r0, 20765a <oslib_test_004_002_teardown+0x1a>
    while (dbp->element.refs > 0U) {
  207648:	6843      	ldr	r3, [r0, #4]
  20764a:	4604      	mov	r4, r0
  20764c:	b12b      	cbz	r3, 20765a <oslib_test_004_002_teardown+0x1a>
      chFactoryReleaseBuffer(dbp);
  20764e:	4620      	mov	r0, r4
  207650:	f7ff ff46 	bl	2074e0 <chFactoryReleaseBuffer>
    while (dbp->element.refs > 0U) {
  207654:	6863      	ldr	r3, [r4, #4]
  207656:	2b00      	cmp	r3, #0
  207658:	d1f9      	bne.n	20764e <oslib_test_004_002_teardown+0xe>
}
  20765a:	bd10      	pop	{r4, pc}
  20765c:	0000      	movs	r0, r0
	...

00207660 <chSemSignal>:
void chSemSignal(semaphore_t *sp) {
  207660:	b510      	push	{r4, lr}
  207662:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  207664:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207666:	2320      	movs	r3, #32
  207668:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20766c:	b662      	cpsie	i
  _dbg_check_lock();
  20766e:	f7fc fb6f 	bl	203d50 <_dbg_check_lock>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  207672:	68a3      	ldr	r3, [r4, #8]
  207674:	6820      	ldr	r0, [r4, #0]
  207676:	2b00      	cmp	r3, #0
  207678:	db04      	blt.n	207684 <chSemSignal+0x24>
  20767a:	42a0      	cmp	r0, r4
  20767c:	d004      	beq.n	207688 <chSemSignal+0x28>
  20767e:	4811      	ldr	r0, [pc, #68]	; (2076c4 <chSemSignal+0x64>)
  207680:	f7f9 fa76 	bl	200b70 <chSysHalt>
  207684:	42a0      	cmp	r0, r4
  207686:	d0fa      	beq.n	20767e <chSemSignal+0x1e>
  if (++sp->cnt <= (cnt_t)0) {
  207688:	3301      	adds	r3, #1
  20768a:	2b00      	cmp	r3, #0
  20768c:	60a3      	str	r3, [r4, #8]
  20768e:	dd11      	ble.n	2076b4 <chSemSignal+0x54>
  _dbg_check_unlock();
  207690:	f7fc fb0e 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207694:	4b0c      	ldr	r3, [pc, #48]	; (2076c8 <chSemSignal+0x68>)
  207696:	681a      	ldr	r2, [r3, #0]
  207698:	429a      	cmp	r2, r3
  20769a:	d004      	beq.n	2076a6 <chSemSignal+0x46>
  20769c:	6999      	ldr	r1, [r3, #24]
  20769e:	6893      	ldr	r3, [r2, #8]
  2076a0:	688a      	ldr	r2, [r1, #8]
  2076a2:	429a      	cmp	r2, r3
  2076a4:	d303      	bcc.n	2076ae <chSemSignal+0x4e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2076a6:	2300      	movs	r3, #0
  2076a8:	f383 8811 	msr	BASEPRI, r3
}
  2076ac:	bd10      	pop	{r4, pc}
  2076ae:	4807      	ldr	r0, [pc, #28]	; (2076cc <chSemSignal+0x6c>)
  2076b0:	f7f9 fa5e 	bl	200b70 <chSysHalt>
  tqp->next             = tp->queue.next;
  2076b4:	6803      	ldr	r3, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
  2076b6:	2100      	movs	r1, #0
  2076b8:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  2076ba:	605c      	str	r4, [r3, #4]
  2076bc:	f7fb feb8 	bl	203430 <chSchWakeupS>
  2076c0:	e7e6      	b.n	207690 <chSemSignal+0x30>
  2076c2:	bf00      	nop
  2076c4:	0800bea0 	.word	0x0800bea0
  2076c8:	20000dc8 	.word	0x20000dc8
  2076cc:	0800bc10 	.word	0x0800bc10

002076d0 <chSemWait>:
msg_t chSemWait(semaphore_t *sp) {
  2076d0:	b538      	push	{r3, r4, r5, lr}
  2076d2:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  2076d4:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2076d6:	2320      	movs	r3, #32
  2076d8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2076dc:	b662      	cpsie	i
  _dbg_check_lock();
  2076de:	f7fc fb37 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassS();
  2076e2:	f7f9 fb45 	bl	200d70 <chDbgCheckClassS>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  2076e6:	68a3      	ldr	r3, [r4, #8]
  2076e8:	6822      	ldr	r2, [r4, #0]
  2076ea:	2b00      	cmp	r3, #0
  2076ec:	db04      	blt.n	2076f8 <chSemWait+0x28>
  2076ee:	42a2      	cmp	r2, r4
  2076f0:	d004      	beq.n	2076fc <chSemWait+0x2c>
  2076f2:	4815      	ldr	r0, [pc, #84]	; (207748 <chSemWait+0x78>)
  2076f4:	f7f9 fa3c 	bl	200b70 <chSysHalt>
  2076f8:	42a2      	cmp	r2, r4
  2076fa:	d0fa      	beq.n	2076f2 <chSemWait+0x22>
  if (--sp->cnt < (cnt_t)0) {
  2076fc:	3b01      	subs	r3, #1
  2076fe:	2b00      	cmp	r3, #0
  207700:	60a3      	str	r3, [r4, #8]
  207702:	db13      	blt.n	20772c <chSemWait+0x5c>
  return MSG_OK;
  207704:	2400      	movs	r4, #0
  207706:	4d11      	ldr	r5, [pc, #68]	; (20774c <chSemWait+0x7c>)
  _dbg_check_unlock();
  207708:	f7fc fad2 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20770c:	682b      	ldr	r3, [r5, #0]
  20770e:	42ab      	cmp	r3, r5
  207710:	d004      	beq.n	20771c <chSemWait+0x4c>
  207712:	69aa      	ldr	r2, [r5, #24]
  207714:	689b      	ldr	r3, [r3, #8]
  207716:	6892      	ldr	r2, [r2, #8]
  207718:	429a      	cmp	r2, r3
  20771a:	d304      	bcc.n	207726 <chSemWait+0x56>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20771c:	2300      	movs	r3, #0
  20771e:	f383 8811 	msr	BASEPRI, r3
}
  207722:	4620      	mov	r0, r4
  207724:	bd38      	pop	{r3, r4, r5, pc}
  207726:	480a      	ldr	r0, [pc, #40]	; (207750 <chSemWait+0x80>)
  207728:	f7f9 fa22 	bl	200b70 <chSysHalt>
    currp->u.wtsemp = sp;
  20772c:	4d07      	ldr	r5, [pc, #28]	; (20774c <chSemWait+0x7c>)
    chSchGoSleepS(CH_STATE_WTSEM);
  20772e:	2005      	movs	r0, #5
    currp->u.wtsemp = sp;
  207730:	69ab      	ldr	r3, [r5, #24]
  207732:	625c      	str	r4, [r3, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
  207734:	6862      	ldr	r2, [r4, #4]
  207736:	e9c3 4200 	strd	r4, r2, [r3]
  tp->queue.prev->queue.next = tp;
  20773a:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
  20773c:	6063      	str	r3, [r4, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
  20773e:	f7fb feaf 	bl	2034a0 <chSchGoSleepS>
    return currp->u.rdymsg;
  207742:	69ab      	ldr	r3, [r5, #24]
  207744:	6a5c      	ldr	r4, [r3, #36]	; 0x24
  207746:	e7df      	b.n	207708 <chSemWait+0x38>
  207748:	0800be18 	.word	0x0800be18
  20774c:	20000dc8 	.word	0x20000dc8
  207750:	0800bc10 	.word	0x0800bc10
	...

00207760 <bmk_thread7>:
static THD_FUNCTION(bmk_thread7, p) {
  207760:	b538      	push	{r3, r4, r5, lr}
  207762:	4c08      	ldr	r4, [pc, #32]	; (207784 <bmk_thread7+0x24>)
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
  207764:	69a3      	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
  207766:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  20776a:	075a      	lsls	r2, r3, #29
  20776c:	d408      	bmi.n	207780 <bmk_thread7+0x20>
    chSemWait(&sem1);
  20776e:	4d06      	ldr	r5, [pc, #24]	; (207788 <bmk_thread7+0x28>)
  207770:	4628      	mov	r0, r5
  207772:	f7ff ffad 	bl	2076d0 <chSemWait>
  207776:	69a3      	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
  207778:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  20777c:	075b      	lsls	r3, r3, #29
  20777e:	d5f7      	bpl.n	207770 <bmk_thread7+0x10>
}
  207780:	bd38      	pop	{r3, r4, r5, pc}
  207782:	bf00      	nop
  207784:	20000dc8 	.word	0x20000dc8
  207788:	20001844 	.word	0x20001844
  20778c:	00000000 	.word	0x00000000

00207790 <thread3>:
static THD_FUNCTION(thread3, p) {
  207790:	b510      	push	{r4, lr}
  chSemWait(&sem1);
  207792:	4c04      	ldr	r4, [pc, #16]	; (2077a4 <thread3+0x14>)
  207794:	4620      	mov	r0, r4
  207796:	f7ff ff9b 	bl	2076d0 <chSemWait>
  chSemSignal(&sem1);
  20779a:	4620      	mov	r0, r4
}
  20779c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chSemSignal(&sem1);
  2077a0:	f7ff bf5e 	b.w	207660 <chSemSignal>
  2077a4:	20001838 	.word	0x20001838
	...

002077b0 <thread1.lto_priv.170>:
static THD_FUNCTION(thread1, p) {
  2077b0:	b510      	push	{r4, lr}
  2077b2:	4604      	mov	r4, r0
  chSemWait(&sem1);
  2077b4:	4803      	ldr	r0, [pc, #12]	; (2077c4 <thread1.lto_priv.170+0x14>)
  2077b6:	f7ff ff8b 	bl	2076d0 <chSemWait>
  test_emit_token(*(char *)p);
  2077ba:	7820      	ldrb	r0, [r4, #0]
}
  2077bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
  2077c0:	f7fd bae6 	b.w	204d90 <test_emit_token>
  2077c4:	20001838 	.word	0x20001838
	...

002077d0 <chSemReset>:
void chSemReset(semaphore_t *sp, cnt_t n) {
  2077d0:	b570      	push	{r4, r5, r6, lr}
  2077d2:	4604      	mov	r4, r0
  2077d4:	460e      	mov	r6, r1
  __ASM volatile ("cpsid i" : : : "memory");
  2077d6:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2077d8:	2320      	movs	r3, #32
  2077da:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2077de:	b662      	cpsie	i
  _dbg_check_lock();
  2077e0:	f7fc fab6 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  2077e4:	f7f9 fad4 	bl	200d90 <chDbgCheckClassI>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  2077e8:	68a5      	ldr	r5, [r4, #8]
  2077ea:	6823      	ldr	r3, [r4, #0]
  2077ec:	2d00      	cmp	r5, #0
  2077ee:	db04      	blt.n	2077fa <chSemReset+0x2a>
  2077f0:	42a3      	cmp	r3, r4
  2077f2:	d004      	beq.n	2077fe <chSemReset+0x2e>
  2077f4:	4814      	ldr	r0, [pc, #80]	; (207848 <chSemReset+0x78>)
  2077f6:	f7f9 f9bb 	bl	200b70 <chSysHalt>
  2077fa:	42a3      	cmp	r3, r4
  2077fc:	d0fa      	beq.n	2077f4 <chSemReset+0x24>
  while (++cnt <= (cnt_t)0) {
  2077fe:	3501      	adds	r5, #1
  sp->cnt = n;
  207800:	60a6      	str	r6, [r4, #8]
  while (++cnt <= (cnt_t)0) {
  207802:	2d00      	cmp	r5, #0
  207804:	dc0b      	bgt.n	20781e <chSemReset+0x4e>
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
  207806:	f06f 0601 	mvn.w	r6, #1
  thread_t *tp = tqp->prev;
  20780a:	6860      	ldr	r0, [r4, #4]
  while (++cnt <= (cnt_t)0) {
  20780c:	3501      	adds	r5, #1
  tqp->prev             = tp->queue.prev;
  20780e:	6843      	ldr	r3, [r0, #4]
  207810:	6063      	str	r3, [r4, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
  207812:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
  207814:	f7f9 fb6c 	bl	200ef0 <chSchReadyI>
  while (++cnt <= (cnt_t)0) {
  207818:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
  20781a:	6246      	str	r6, [r0, #36]	; 0x24
  while (++cnt <= (cnt_t)0) {
  20781c:	d1f5      	bne.n	20780a <chSemReset+0x3a>
  chSchRescheduleS();
  20781e:	f7fc fa2f 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  207822:	f7fc fa45 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207826:	4b09      	ldr	r3, [pc, #36]	; (20784c <chSemReset+0x7c>)
  207828:	681a      	ldr	r2, [r3, #0]
  20782a:	429a      	cmp	r2, r3
  20782c:	d004      	beq.n	207838 <chSemReset+0x68>
  20782e:	6999      	ldr	r1, [r3, #24]
  207830:	6893      	ldr	r3, [r2, #8]
  207832:	688a      	ldr	r2, [r1, #8]
  207834:	429a      	cmp	r2, r3
  207836:	d303      	bcc.n	207840 <chSemReset+0x70>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207838:	2300      	movs	r3, #0
  20783a:	f383 8811 	msr	BASEPRI, r3
}
  20783e:	bd70      	pop	{r4, r5, r6, pc}
  207840:	4803      	ldr	r0, [pc, #12]	; (207850 <chSemReset+0x80>)
  207842:	f7f9 f995 	bl	200b70 <chSysHalt>
  207846:	bf00      	nop
  207848:	0800bd8c 	.word	0x0800bd8c
  20784c:	20000dc8 	.word	0x20000dc8
  207850:	0800bc10 	.word	0x0800bc10
	...

00207860 <rt_test_005_001_execute>:
static void rt_test_005_001_execute(void) {
  207860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    msg = chSemWait(&sem1);
  207862:	4c44      	ldr	r4, [pc, #272]	; (207974 <rt_test_005_001_execute+0x114>)
  test_set_step(1);
  207864:	2301      	movs	r3, #1
  207866:	4e44      	ldr	r6, [pc, #272]	; (207978 <rt_test_005_001_execute+0x118>)
    msg = chSemWait(&sem1);
  207868:	4620      	mov	r0, r4
  test_set_step(1);
  20786a:	6033      	str	r3, [r6, #0]
    msg = chSemWait(&sem1);
  20786c:	f7ff ff30 	bl	2076d0 <chSemWait>
  207870:	4607      	mov	r7, r0
  __ASM volatile ("cpsid i" : : : "memory");
  207872:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207874:	2320      	movs	r3, #32
  207876:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20787a:	b662      	cpsie	i
  _dbg_check_lock();
  20787c:	f7fc fa68 	bl	203d50 <_dbg_check_lock>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(const semaphore_t *sp) {

  chDbgCheckClassI();
  207880:	f7f9 fa86 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
  207884:	68a0      	ldr	r0, [r4, #8]
  207886:	493d      	ldr	r1, [pc, #244]	; (20797c <rt_test_005_001_execute+0x11c>)
  207888:	fab0 f080 	clz	r0, r0
  20788c:	0940      	lsrs	r0, r0, #5
  20788e:	f7f8 ff97 	bl	2007c0 <_test_assert>
  207892:	b9a8      	cbnz	r0, 2078c0 <rt_test_005_001_execute+0x60>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207894:	4d3a      	ldr	r5, [pc, #232]	; (207980 <rt_test_005_001_execute+0x120>)
  _dbg_check_unlock();
  207896:	f7fc fa0b 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20789a:	682b      	ldr	r3, [r5, #0]
  20789c:	42ab      	cmp	r3, r5
  20789e:	d004      	beq.n	2078aa <rt_test_005_001_execute+0x4a>
  2078a0:	69aa      	ldr	r2, [r5, #24]
  2078a2:	689b      	ldr	r3, [r3, #8]
  2078a4:	6892      	ldr	r2, [r2, #8]
  2078a6:	429a      	cmp	r2, r3
  2078a8:	d360      	bcc.n	20796c <rt_test_005_001_execute+0x10c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2078aa:	2300      	movs	r3, #0
  2078ac:	f383 8811 	msr	BASEPRI, r3
    test_assert(MSG_OK == msg, "wrong returned message");
  2078b0:	fab7 f087 	clz	r0, r7
  2078b4:	4933      	ldr	r1, [pc, #204]	; (207984 <rt_test_005_001_execute+0x124>)
  2078b6:	0940      	lsrs	r0, r0, #5
  2078b8:	f7f8 ff82 	bl	2007c0 <_test_assert>
  2078bc:	b178      	cbz	r0, 2078de <rt_test_005_001_execute+0x7e>
}
  2078be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  _dbg_check_unlock();
  2078c0:	f7fc f9f6 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2078c4:	4b2e      	ldr	r3, [pc, #184]	; (207980 <rt_test_005_001_execute+0x120>)
  2078c6:	681a      	ldr	r2, [r3, #0]
  2078c8:	429a      	cmp	r2, r3
  2078ca:	d004      	beq.n	2078d6 <rt_test_005_001_execute+0x76>
  2078cc:	6999      	ldr	r1, [r3, #24]
  2078ce:	6893      	ldr	r3, [r2, #8]
  2078d0:	688a      	ldr	r2, [r1, #8]
  2078d2:	429a      	cmp	r2, r3
  2078d4:	d34a      	bcc.n	20796c <rt_test_005_001_execute+0x10c>
  2078d6:	2300      	movs	r3, #0
  2078d8:	f383 8811 	msr	BASEPRI, r3
  2078dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
  2078de:	2302      	movs	r3, #2
    chSemSignal(&sem1);
  2078e0:	4824      	ldr	r0, [pc, #144]	; (207974 <rt_test_005_001_execute+0x114>)
  test_set_step(2);
  2078e2:	6033      	str	r3, [r6, #0]
    chSemSignal(&sem1);
  2078e4:	f7ff febc 	bl	207660 <chSemSignal>
  __ASM volatile ("cpsid i" : : : "memory");
  2078e8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2078ea:	2320      	movs	r3, #32
  2078ec:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2078f0:	b662      	cpsie	i
  _dbg_check_lock();
  2078f2:	f7fc fa2d 	bl	203d50 <_dbg_check_lock>
  2078f6:	f7f9 fa4b 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
  2078fa:	68a0      	ldr	r0, [r4, #8]
  2078fc:	491f      	ldr	r1, [pc, #124]	; (20797c <rt_test_005_001_execute+0x11c>)
  2078fe:	f1a0 0001 	sub.w	r0, r0, #1
  207902:	fab0 f080 	clz	r0, r0
  207906:	0940      	lsrs	r0, r0, #5
  207908:	f7f8 ff5a 	bl	2007c0 <_test_assert>
  20790c:	bb20      	cbnz	r0, 207958 <rt_test_005_001_execute+0xf8>
  _dbg_check_unlock();
  20790e:	f7fc f9cf 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207912:	682b      	ldr	r3, [r5, #0]
  207914:	42ab      	cmp	r3, r5
  207916:	d004      	beq.n	207922 <rt_test_005_001_execute+0xc2>
  207918:	69aa      	ldr	r2, [r5, #24]
  20791a:	689b      	ldr	r3, [r3, #8]
  20791c:	6892      	ldr	r2, [r2, #8]
  20791e:	429a      	cmp	r2, r3
  207920:	d324      	bcc.n	20796c <rt_test_005_001_execute+0x10c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207922:	2300      	movs	r3, #0
  207924:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
  207928:	2303      	movs	r3, #3
    chSemReset(&sem1, 2);
  20792a:	2102      	movs	r1, #2
  20792c:	4811      	ldr	r0, [pc, #68]	; (207974 <rt_test_005_001_execute+0x114>)
  test_set_step(3);
  20792e:	6033      	str	r3, [r6, #0]
    chSemReset(&sem1, 2);
  207930:	f7ff ff4e 	bl	2077d0 <chSemReset>
  __ASM volatile ("cpsid i" : : : "memory");
  207934:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207936:	2320      	movs	r3, #32
  207938:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20793c:	b662      	cpsie	i
  _dbg_check_lock();
  20793e:	f7fc fa07 	bl	203d50 <_dbg_check_lock>
  207942:	f7f9 fa25 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
  207946:	68a0      	ldr	r0, [r4, #8]
  207948:	490c      	ldr	r1, [pc, #48]	; (20797c <rt_test_005_001_execute+0x11c>)
  20794a:	f1a0 0002 	sub.w	r0, r0, #2
  20794e:	fab0 f080 	clz	r0, r0
  207952:	0940      	lsrs	r0, r0, #5
  207954:	f7f8 ff34 	bl	2007c0 <_test_assert>
  _dbg_check_unlock();
  207958:	f7fc f9aa 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20795c:	682b      	ldr	r3, [r5, #0]
  20795e:	42ab      	cmp	r3, r5
  207960:	d0b9      	beq.n	2078d6 <rt_test_005_001_execute+0x76>
  207962:	69aa      	ldr	r2, [r5, #24]
  207964:	689b      	ldr	r3, [r3, #8]
  207966:	6892      	ldr	r2, [r2, #8]
  207968:	429a      	cmp	r2, r3
  20796a:	d2b4      	bcs.n	2078d6 <rt_test_005_001_execute+0x76>
  20796c:	4806      	ldr	r0, [pc, #24]	; (207988 <rt_test_005_001_execute+0x128>)
  20796e:	f7f9 f8ff 	bl	200b70 <chSysHalt>
  207972:	bf00      	nop
  207974:	20001838 	.word	0x20001838
  207978:	20001f6c 	.word	0x20001f6c
  20797c:	0800d5e8 	.word	0x0800d5e8
  207980:	20000dc8 	.word	0x20000dc8
  207984:	0800d5fc 	.word	0x0800d5fc
  207988:	0800bcb8 	.word	0x0800bcb8
  20798c:	00000000 	.word	0x00000000

00207990 <rt_test_005_001_teardown>:
  chSemReset(&sem1, 0);
  207990:	2100      	movs	r1, #0
  207992:	4801      	ldr	r0, [pc, #4]	; (207998 <rt_test_005_001_teardown+0x8>)
  207994:	f7ff bf1c 	b.w	2077d0 <chSemReset>
  207998:	20001838 	.word	0x20001838
  20799c:	00000000 	.word	0x00000000

002079a0 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
  2079a0:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  2079a2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2079a4:	2320      	movs	r3, #32
  2079a6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2079aa:	b662      	cpsie	i
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
  2079ac:	4c0d      	ldr	r4, [pc, #52]	; (2079e4 <chRegFirstThread+0x44>)
  _dbg_check_lock();
  2079ae:	f7fc f9cf 	bl	203d50 <_dbg_check_lock>
  2079b2:	6925      	ldr	r5, [r4, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
  2079b4:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
  2079b8:	3301      	adds	r3, #1
  2079ba:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
  _dbg_check_unlock();
  2079be:	f7fc f977 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2079c2:	6823      	ldr	r3, [r4, #0]
  2079c4:	42a3      	cmp	r3, r4
  2079c6:	d004      	beq.n	2079d2 <chRegFirstThread+0x32>
  2079c8:	69a2      	ldr	r2, [r4, #24]
  2079ca:	689b      	ldr	r3, [r3, #8]
  2079cc:	6892      	ldr	r2, [r2, #8]
  2079ce:	429a      	cmp	r2, r3
  2079d0:	d304      	bcc.n	2079dc <chRegFirstThread+0x3c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2079d2:	2300      	movs	r3, #0
  2079d4:	f383 8811 	msr	BASEPRI, r3
#endif
  chSysUnlock();

  return tp;
}
  2079d8:	4628      	mov	r0, r5
  2079da:	bd38      	pop	{r3, r4, r5, pc}
  2079dc:	4802      	ldr	r0, [pc, #8]	; (2079e8 <chRegFirstThread+0x48>)
  2079de:	f7f9 f8c7 	bl	200b70 <chSysHalt>
  2079e2:	bf00      	nop
  2079e4:	20000dc8 	.word	0x20000dc8
  2079e8:	0800bd2c 	.word	0x0800bd2c
  2079ec:	00000000 	.word	0x00000000

002079f0 <chThdYield>:
void chThdYield(void) {
  2079f0:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  2079f2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2079f4:	2320      	movs	r3, #32
  2079f6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2079fa:	b662      	cpsie	i
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
  2079fc:	4c1b      	ldr	r4, [pc, #108]	; (207a6c <chThdYield+0x7c>)
  _dbg_check_lock();
  2079fe:	f7fc f9a7 	bl	203d50 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();
  207a02:	f7f9 f9b5 	bl	200d70 <chDbgCheckClassS>
  chDbgCheckClassS();
  207a06:	f7f9 f9b3 	bl	200d70 <chDbgCheckClassS>
  return firstprio(&ch.rlist.queue) >= currp->prio;
  207a0a:	6823      	ldr	r3, [r4, #0]
  207a0c:	69a0      	ldr	r0, [r4, #24]

  if (chSchCanYieldS()) {
  207a0e:	6899      	ldr	r1, [r3, #8]
  207a10:	6882      	ldr	r2, [r0, #8]
  207a12:	4291      	cmp	r1, r2
  207a14:	d210      	bcs.n	207a38 <chThdYield+0x48>
  _dbg_check_unlock();
  207a16:	f7fc f94b 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207a1a:	6823      	ldr	r3, [r4, #0]
  207a1c:	42a3      	cmp	r3, r4
  207a1e:	d004      	beq.n	207a2a <chThdYield+0x3a>
  207a20:	69a2      	ldr	r2, [r4, #24]
  207a22:	689b      	ldr	r3, [r3, #8]
  207a24:	6892      	ldr	r2, [r2, #8]
  207a26:	429a      	cmp	r2, r3
  207a28:	d303      	bcc.n	207a32 <chThdYield+0x42>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207a2a:	2300      	movs	r3, #0
  207a2c:	f383 8811 	msr	BASEPRI, r3
}
  207a30:	bd38      	pop	{r3, r4, r5, pc}
  207a32:	480f      	ldr	r0, [pc, #60]	; (207a70 <chThdYield+0x80>)
  207a34:	f7f9 f89c 	bl	200b70 <chSysHalt>
  tqp->next             = tp->queue.next;
  207a38:	681a      	ldr	r2, [r3, #0]
  currp->state = CH_STATE_CURRENT;
  207a3a:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
  207a3c:	6054      	str	r4, [r2, #4]
  207a3e:	f883 1020 	strb.w	r1, [r3, #32]
  tqp->next             = tp->queue.next;
  207a42:	6022      	str	r2, [r4, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
  207a44:	61a3      	str	r3, [r4, #24]
  otp = chSchReadyI(otp);
  207a46:	f7f9 fa53 	bl	200ef0 <chSchReadyI>
  207a4a:	4605      	mov	r5, r0
  chSysSwitch(currp, otp);
  207a4c:	f7f9 f830 	bl	200ab0 <_trace_switch.constprop.79>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  207a50:	f3ef 8309 	mrs	r3, PSP
  207a54:	3b24      	subs	r3, #36	; 0x24
  207a56:	69ea      	ldr	r2, [r5, #28]
  207a58:	429a      	cmp	r2, r3
  207a5a:	d804      	bhi.n	207a66 <chThdYield+0x76>
  207a5c:	4629      	mov	r1, r5
  207a5e:	69a0      	ldr	r0, [r4, #24]
  207a60:	f7f8 fc3e 	bl	2002e0 <_port_switch>
  207a64:	e7d7      	b.n	207a16 <chThdYield+0x26>
  207a66:	4803      	ldr	r0, [pc, #12]	; (207a74 <chThdYield+0x84>)
  207a68:	f7f9 f882 	bl	200b70 <chSysHalt>
  207a6c:	20000dc8 	.word	0x20000dc8
  207a70:	0800bc04 	.word	0x0800bc04
  207a74:	0800c228 	.word	0x0800c228
	...

00207a80 <bmk_thread8>:
static THD_FUNCTION(bmk_thread8, p) {
  207a80:	b538      	push	{r3, r4, r5, lr}
  207a82:	4604      	mov	r4, r0
  207a84:	4d08      	ldr	r5, [pc, #32]	; (207aa8 <bmk_thread8+0x28>)
    chThdYield();
  207a86:	f7ff ffb3 	bl	2079f0 <chThdYield>
    chThdYield();
  207a8a:	f7ff ffb1 	bl	2079f0 <chThdYield>
    chThdYield();
  207a8e:	f7ff ffaf 	bl	2079f0 <chThdYield>
    chThdYield();
  207a92:	f7ff ffad 	bl	2079f0 <chThdYield>
    (*(uint32_t *)p) += 4;
  207a96:	6823      	ldr	r3, [r4, #0]
  207a98:	69aa      	ldr	r2, [r5, #24]
  207a9a:	3304      	adds	r3, #4
  207a9c:	6023      	str	r3, [r4, #0]
  } while(!chThdShouldTerminateX());
  207a9e:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
  207aa2:	075b      	lsls	r3, r3, #29
  207aa4:	d5ef      	bpl.n	207a86 <bmk_thread8+0x6>
}
  207aa6:	bd38      	pop	{r3, r4, r5, pc}
  207aa8:	20000dc8 	.word	0x20000dc8
  207aac:	00000000 	.word	0x00000000

00207ab0 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
  207ab0:	b510      	push	{r4, lr}
  207ab2:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  207ab4:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207ab6:	2320      	movs	r3, #32
  207ab8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207abc:	b662      	cpsie	i
  _dbg_check_lock();
  207abe:	f7fc f947 	bl	203d50 <_dbg_check_lock>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
  207ac2:	4621      	mov	r1, r4
  207ac4:	2008      	movs	r0, #8
  207ac6:	f7fb fdc3 	bl	203650 <chSchGoSleepTimeoutS>
  _dbg_check_unlock();
  207aca:	f7fc f8f1 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207ace:	4b08      	ldr	r3, [pc, #32]	; (207af0 <chThdSleep+0x40>)
  207ad0:	681a      	ldr	r2, [r3, #0]
  207ad2:	429a      	cmp	r2, r3
  207ad4:	d004      	beq.n	207ae0 <chThdSleep+0x30>
  207ad6:	6999      	ldr	r1, [r3, #24]
  207ad8:	6893      	ldr	r3, [r2, #8]
  207ada:	688a      	ldr	r2, [r1, #8]
  207adc:	429a      	cmp	r2, r3
  207ade:	d303      	bcc.n	207ae8 <chThdSleep+0x38>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207ae0:	2300      	movs	r3, #0
  207ae2:	f383 8811 	msr	BASEPRI, r3
}
  207ae6:	bd10      	pop	{r4, pc}
  207ae8:	4802      	ldr	r0, [pc, #8]	; (207af4 <chThdSleep+0x44>)
  207aea:	f7f9 f841 	bl	200b70 <chSysHalt>
  207aee:	bf00      	nop
  207af0:	20000dc8 	.word	0x20000dc8
  207af4:	0800bc04 	.word	0x0800bc04
	...

00207b00 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
  207b00:	4b0c      	ldr	r3, [pc, #48]	; (207b34 <Thread1+0x34>)
  chRegSetThreadName("blinker");
  while (true) {
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 50 : 5000;
    palClearLine(PORTAB_BLINK_LED1);
  207b02:	2602      	movs	r6, #2
  207b04:	4a0c      	ldr	r2, [pc, #48]	; (207b38 <Thread1+0x38>)
  207b06:	699b      	ldr	r3, [r3, #24]
  207b08:	46b0      	mov	r8, r6
  207b0a:	4d0c      	ldr	r5, [pc, #48]	; (207b3c <Thread1+0x3c>)
static THD_FUNCTION(Thread1, arg) {
  207b0c:	b580      	push	{r7, lr}
  207b0e:	4f0c      	ldr	r7, [pc, #48]	; (207b40 <Thread1+0x40>)
  207b10:	619a      	str	r2, [r3, #24]
    time = serusbcfg.usbp->state == USB_ACTIVE ? 50 : 5000;
  207b12:	783b      	ldrb	r3, [r7, #0]
  207b14:	f24c 3450 	movw	r4, #50000	; 0xc350
    palClearLine(PORTAB_BLINK_LED1);
  207b18:	f8a5 801a 	strh.w	r8, [r5, #26]
    time = serusbcfg.usbp->state == USB_ACTIVE ? 50 : 5000;
  207b1c:	2b04      	cmp	r3, #4
  207b1e:	bf08      	it	eq
  207b20:	f44f 74fa 	moveq.w	r4, #500	; 0x1f4
    chThdSleepMilliseconds(time);
  207b24:	4620      	mov	r0, r4
  207b26:	f7ff ffc3 	bl	207ab0 <chThdSleep>
    palSetLine(PORTAB_BLINK_LED1);
    chThdSleepMilliseconds(time);
  207b2a:	4620      	mov	r0, r4
    palSetLine(PORTAB_BLINK_LED1);
  207b2c:	832e      	strh	r6, [r5, #24]
    chThdSleepMilliseconds(time);
  207b2e:	f7ff ffbf 	bl	207ab0 <chThdSleep>
  207b32:	e7ee      	b.n	207b12 <Thread1+0x12>
  207b34:	20000dc8 	.word	0x20000dc8
  207b38:	0800bbe4 	.word	0x0800bbe4
  207b3c:	40022000 	.word	0x40022000
  207b40:	20000d2c 	.word	0x20000d2c
	...

00207b50 <evt_thread7>:
static THD_FUNCTION(evt_thread7, p) {
  207b50:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  207b52:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207b54:	2320      	movs	r3, #32
  207b56:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207b5a:	b662      	cpsie	i
  207b5c:	4c1b      	ldr	r4, [pc, #108]	; (207bcc <evt_thread7+0x7c>)
  _dbg_check_lock();
  207b5e:	f7fc f8f7 	bl	203d50 <_dbg_check_lock>
  chEvtBroadcastFlagsI(esp, flags);
  207b62:	2100      	movs	r1, #0
  207b64:	481a      	ldr	r0, [pc, #104]	; (207bd0 <evt_thread7+0x80>)
  207b66:	f7f9 fa7b 	bl	201060 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
  207b6a:	f7fc f889 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  207b6e:	f7fc f89f 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207b72:	6823      	ldr	r3, [r4, #0]
  207b74:	42a3      	cmp	r3, r4
  207b76:	d004      	beq.n	207b82 <evt_thread7+0x32>
  207b78:	69a2      	ldr	r2, [r4, #24]
  207b7a:	689b      	ldr	r3, [r3, #8]
  207b7c:	6892      	ldr	r2, [r2, #8]
  207b7e:	429a      	cmp	r2, r3
  207b80:	d321      	bcc.n	207bc6 <evt_thread7+0x76>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207b82:	2500      	movs	r5, #0
  207b84:	f385 8811 	msr	BASEPRI, r5
  chThdSleepMilliseconds(50);
  207b88:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  207b8c:	f7ff ff90 	bl	207ab0 <chThdSleep>
  __ASM volatile ("cpsid i" : : : "memory");
  207b90:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207b92:	2320      	movs	r3, #32
  207b94:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207b98:	b662      	cpsie	i
  _dbg_check_lock();
  207b9a:	f7fc f8d9 	bl	203d50 <_dbg_check_lock>
  chEvtBroadcastFlagsI(esp, flags);
  207b9e:	4629      	mov	r1, r5
  207ba0:	480c      	ldr	r0, [pc, #48]	; (207bd4 <evt_thread7+0x84>)
  207ba2:	f7f9 fa5d 	bl	201060 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
  207ba6:	f7fc f86b 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  207baa:	f7fc f881 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207bae:	6823      	ldr	r3, [r4, #0]
  207bb0:	42a3      	cmp	r3, r4
  207bb2:	d004      	beq.n	207bbe <evt_thread7+0x6e>
  207bb4:	69a2      	ldr	r2, [r4, #24]
  207bb6:	689b      	ldr	r3, [r3, #8]
  207bb8:	6892      	ldr	r2, [r2, #8]
  207bba:	429a      	cmp	r2, r3
  207bbc:	d303      	bcc.n	207bc6 <evt_thread7+0x76>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207bbe:	2300      	movs	r3, #0
  207bc0:	f383 8811 	msr	BASEPRI, r3
}
  207bc4:	bd38      	pop	{r3, r4, r5, pc}
  207bc6:	4804      	ldr	r0, [pc, #16]	; (207bd8 <evt_thread7+0x88>)
  207bc8:	f7f8 ffd2 	bl	200b70 <chSysHalt>
  207bcc:	20000dc8 	.word	0x20000dc8
  207bd0:	2001040c 	.word	0x2001040c
  207bd4:	20010410 	.word	0x20010410
  207bd8:	0800bc34 	.word	0x0800bc34
  207bdc:	00000000 	.word	0x00000000

00207be0 <evt_thread3>:
static THD_FUNCTION(evt_thread3, p) {
  207be0:	b510      	push	{r4, lr}
  207be2:	4604      	mov	r4, r0
  chThdSleepMilliseconds(50);
  207be4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  207be8:	f7ff ff62 	bl	207ab0 <chThdSleep>
  chDbgCheck(tp != NULL);
  207bec:	b1f4      	cbz	r4, 207c2c <evt_thread3+0x4c>
  __ASM volatile ("cpsid i" : : : "memory");
  207bee:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207bf0:	2320      	movs	r3, #32
  207bf2:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207bf6:	b662      	cpsie	i
  _dbg_check_lock();
  207bf8:	f7fc f8aa 	bl	203d50 <_dbg_check_lock>
  chEvtSignalI(tp, events);
  207bfc:	4620      	mov	r0, r4
  207bfe:	2101      	movs	r1, #1
  207c00:	f7f9 fa06 	bl	201010 <chEvtSignalI>
  chSchRescheduleS();
  207c04:	f7fc f83c 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  207c08:	f7fc f852 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207c0c:	4b09      	ldr	r3, [pc, #36]	; (207c34 <evt_thread3+0x54>)
  207c0e:	681a      	ldr	r2, [r3, #0]
  207c10:	429a      	cmp	r2, r3
  207c12:	d004      	beq.n	207c1e <evt_thread3+0x3e>
  207c14:	6999      	ldr	r1, [r3, #24]
  207c16:	6893      	ldr	r3, [r2, #8]
  207c18:	688a      	ldr	r2, [r1, #8]
  207c1a:	429a      	cmp	r2, r3
  207c1c:	d303      	bcc.n	207c26 <evt_thread3+0x46>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207c1e:	2300      	movs	r3, #0
  207c20:	f383 8811 	msr	BASEPRI, r3
}
  207c24:	bd10      	pop	{r4, pc}
  207c26:	4804      	ldr	r0, [pc, #16]	; (207c38 <evt_thread3+0x58>)
  207c28:	f7f8 ffa2 	bl	200b70 <chSysHalt>
  chDbgCheck(tp != NULL);
  207c2c:	4803      	ldr	r0, [pc, #12]	; (207c3c <evt_thread3+0x5c>)
  207c2e:	f7f8 ff9f 	bl	200b70 <chSysHalt>
  207c32:	bf00      	nop
  207c34:	20000dc8 	.word	0x20000dc8
  207c38:	0800bc34 	.word	0x0800bc34
  207c3c:	0800bef0 	.word	0x0800bef0

00207c40 <thread4A>:
static THD_FUNCTION(thread4A, p) {
  207c40:	b510      	push	{r4, lr}
  chMtxLock(&m1);
  207c42:	4c06      	ldr	r4, [pc, #24]	; (207c5c <thread4A+0x1c>)
  chThdSleepMilliseconds(50);
  207c44:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  207c48:	f7ff ff32 	bl	207ab0 <chThdSleep>
  chMtxLock(&m1);
  207c4c:	4620      	mov	r0, r4
  207c4e:	f7fe fb37 	bl	2062c0 <chMtxLock>
  chMtxUnlock(&m1);
  207c52:	4620      	mov	r0, r4
}
  207c54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMtxUnlock(&m1);
  207c58:	f7fe ba02 	b.w	206060 <chMtxUnlock>
  207c5c:	20010438 	.word	0x20010438

00207c60 <thread4B>:
static THD_FUNCTION(thread4B, p) {
  207c60:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(150);
  207c62:	f240 50dc 	movw	r0, #1500	; 0x5dc
  207c66:	f7ff ff23 	bl	207ab0 <chThdSleep>
  __ASM volatile ("cpsid i" : : : "memory");
  207c6a:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207c6c:	2320      	movs	r3, #32
  207c6e:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207c72:	b662      	cpsie	i
  _dbg_check_lock();
  207c74:	f7fc f86c 	bl	203d50 <_dbg_check_lock>
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
  207c78:	480c      	ldr	r0, [pc, #48]	; (207cac <thread4B+0x4c>)
  207c7a:	f7fb fc39 	bl	2034f0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
  207c7e:	480b      	ldr	r0, [pc, #44]	; (207cac <thread4B+0x4c>)
  207c80:	f7f9 fa0e 	bl	2010a0 <chMtxUnlockS>
  chSchRescheduleS();
  207c84:	f7fb fffc 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  207c88:	f7fc f812 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207c8c:	4b08      	ldr	r3, [pc, #32]	; (207cb0 <thread4B+0x50>)
  207c8e:	681a      	ldr	r2, [r3, #0]
  207c90:	429a      	cmp	r2, r3
  207c92:	d004      	beq.n	207c9e <thread4B+0x3e>
  207c94:	6999      	ldr	r1, [r3, #24]
  207c96:	6893      	ldr	r3, [r2, #8]
  207c98:	688a      	ldr	r2, [r1, #8]
  207c9a:	429a      	cmp	r2, r3
  207c9c:	d303      	bcc.n	207ca6 <thread4B+0x46>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207c9e:	2300      	movs	r3, #0
  207ca0:	f383 8811 	msr	BASEPRI, r3
}
  207ca4:	bd08      	pop	{r3, pc}
  207ca6:	4803      	ldr	r0, [pc, #12]	; (207cb4 <thread4B+0x54>)
  207ca8:	f7f8 ff62 	bl	200b70 <chSysHalt>
  207cac:	20010448 	.word	0x20010448
  207cb0:	20000dc8 	.word	0x20000dc8
  207cb4:	0800bcc4 	.word	0x0800bcc4
	...

00207cc0 <thread2>:
static THD_FUNCTION(thread2, p) {
  207cc0:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(50);
  207cc2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  207cc6:	f7ff fef3 	bl	207ab0 <chThdSleep>
  __ASM volatile ("cpsid i" : : : "memory");
  207cca:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207ccc:	2320      	movs	r3, #32
  207cce:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207cd2:	b662      	cpsie	i
  _dbg_check_lock();
  207cd4:	f7fc f83c 	bl	203d50 <_dbg_check_lock>
  chSemSignalI(&sem1); /* For coverage reasons */
  207cd8:	480b      	ldr	r0, [pc, #44]	; (207d08 <thread2+0x48>)
  207cda:	f7f9 fa29 	bl	201130 <chSemSignalI>
  chSchRescheduleS();
  207cde:	f7fb ffcf 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  207ce2:	f7fb ffe5 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207ce6:	4b09      	ldr	r3, [pc, #36]	; (207d0c <thread2+0x4c>)
  207ce8:	681a      	ldr	r2, [r3, #0]
  207cea:	429a      	cmp	r2, r3
  207cec:	d004      	beq.n	207cf8 <thread2+0x38>
  207cee:	6999      	ldr	r1, [r3, #24]
  207cf0:	6893      	ldr	r3, [r2, #8]
  207cf2:	688a      	ldr	r2, [r1, #8]
  207cf4:	429a      	cmp	r2, r3
  207cf6:	d303      	bcc.n	207d00 <thread2+0x40>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207cf8:	2300      	movs	r3, #0
  207cfa:	f383 8811 	msr	BASEPRI, r3
}
  207cfe:	bd08      	pop	{r3, pc}
  207d00:	4803      	ldr	r0, [pc, #12]	; (207d10 <thread2+0x50>)
  207d02:	f7f8 ff35 	bl	200b70 <chSysHalt>
  207d06:	bf00      	nop
  207d08:	20001838 	.word	0x20001838
  207d0c:	20000dc8 	.word	0x20000dc8
  207d10:	0800bcb8 	.word	0x0800bcb8
	...

00207d20 <rt_test_003_001_execute>:
 * - [3.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void rt_test_003_001_execute(void) {
  207d20:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  /* [3.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
  207d22:	2301      	movs	r3, #1
  207d24:	4e34      	ldr	r6, [pc, #208]	; (207df8 <rt_test_003_001_execute+0xd8>)
  207d26:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
  {
    time = chVTGetSystemTimeX();
    chThdSleep(100);
  207d2a:	2064      	movs	r0, #100	; 0x64
  test_set_step(1);
  207d2c:	6033      	str	r3, [r6, #0]
  207d2e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleep(100);
  207d30:	f7ff febe 	bl	207ab0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, 100),
  207d34:	f104 0167 	add.w	r1, r4, #103	; 0x67
  207d38:	f104 0064 	add.w	r0, r4, #100	; 0x64
  207d3c:	f7f8 fd08 	bl	200750 <_test_assert_time_window.constprop.2>
  207d40:	b100      	cbz	r0, 207d44 <rt_test_003_001_execute+0x24>
    chThdSleepUntil(chTimeAddX(time, 100));
    test_assert_time_window(chTimeAddX(time, 100),
                            chTimeAddX(time, 100 + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
  }
}
  207d42:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(2);
  207d44:	2302      	movs	r3, #2
    chThdSleepMicroseconds(100000);
  207d46:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(2);
  207d4a:	6033      	str	r3, [r6, #0]
  207d4c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepMicroseconds(100000);
  207d4e:	f7ff feaf 	bl	207ab0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_US2I(100000)),
  207d52:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
  207d56:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
  207d5a:	f7f8 fcf9 	bl	200750 <_test_assert_time_window.constprop.2>
  207d5e:	2800      	cmp	r0, #0
  207d60:	d1ef      	bne.n	207d42 <rt_test_003_001_execute+0x22>
  test_set_step(3);
  207d62:	2303      	movs	r3, #3
    chThdSleepMilliseconds(100);
  207d64:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(3);
  207d68:	6033      	str	r3, [r6, #0]
  207d6a:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepMilliseconds(100);
  207d6c:	f7ff fea0 	bl	207ab0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(100)),
  207d70:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
  207d74:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
  207d78:	f7f8 fcea 	bl	200750 <_test_assert_time_window.constprop.2>
  207d7c:	2800      	cmp	r0, #0
  207d7e:	d1e0      	bne.n	207d42 <rt_test_003_001_execute+0x22>
  test_set_step(4);
  207d80:	2304      	movs	r3, #4
    chThdSleepSeconds(1);
  207d82:	f242 7010 	movw	r0, #10000	; 0x2710
  test_set_step(4);
  207d86:	6033      	str	r3, [r6, #0]
  207d88:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepSeconds(1);
  207d8a:	f7ff fe91 	bl	207ab0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_S2I(1)),
  207d8e:	f242 7113 	movw	r1, #10003	; 0x2713
  207d92:	f242 7010 	movw	r0, #10000	; 0x2710
  207d96:	4421      	add	r1, r4
  207d98:	4420      	add	r0, r4
  207d9a:	f7f8 fcd9 	bl	200750 <_test_assert_time_window.constprop.2>
  207d9e:	2800      	cmp	r0, #0
  207da0:	d1cf      	bne.n	207d42 <rt_test_003_001_execute+0x22>
  test_set_step(5);
  207da2:	2305      	movs	r3, #5
  207da4:	6033      	str	r3, [r6, #0]
  207da6:	6a6e      	ldr	r6, [r5, #36]	; 0x24
  207da8:	f106 0464 	add.w	r4, r6, #100	; 0x64
  __ASM volatile ("cpsid i" : : : "memory");
  207dac:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207dae:	2320      	movs	r3, #32
  207db0:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207db4:	b662      	cpsie	i
  _dbg_check_lock();
  207db6:	f7fb ffcb 	bl	203d50 <_dbg_check_lock>
  207dba:	6a69      	ldr	r1, [r5, #36]	; 0x24
  if (interval > (sysinterval_t)0) {
  207dbc:	1a61      	subs	r1, r4, r1
  207dbe:	d114      	bne.n	207dea <rt_test_003_001_execute+0xca>
  _dbg_check_unlock();
  207dc0:	f7fb ff76 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207dc4:	4b0d      	ldr	r3, [pc, #52]	; (207dfc <rt_test_003_001_execute+0xdc>)
  207dc6:	681a      	ldr	r2, [r3, #0]
  207dc8:	429a      	cmp	r2, r3
  207dca:	d004      	beq.n	207dd6 <rt_test_003_001_execute+0xb6>
  207dcc:	6999      	ldr	r1, [r3, #24]
  207dce:	6893      	ldr	r3, [r2, #8]
  207dd0:	688a      	ldr	r2, [r1, #8]
  207dd2:	429a      	cmp	r2, r3
  207dd4:	d30d      	bcc.n	207df2 <rt_test_003_001_execute+0xd2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207dd6:	2300      	movs	r3, #0
  207dd8:	f383 8811 	msr	BASEPRI, r3
    test_assert_time_window(chTimeAddX(time, 100),
  207ddc:	f106 0167 	add.w	r1, r6, #103	; 0x67
  207de0:	4620      	mov	r0, r4
}
  207de2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_time_window(chTimeAddX(time, 100),
  207de6:	f7f8 bcb3 	b.w	200750 <_test_assert_time_window.constprop.2>
  207dea:	2008      	movs	r0, #8
  207dec:	f7fb fc30 	bl	203650 <chSchGoSleepTimeoutS>
  207df0:	e7e6      	b.n	207dc0 <rt_test_003_001_execute+0xa0>
  207df2:	4803      	ldr	r0, [pc, #12]	; (207e00 <rt_test_003_001_execute+0xe0>)
  207df4:	f7f8 febc 	bl	200b70 <chSysHalt>
  207df8:	20001f6c 	.word	0x20001f6c
  207dfc:	20000dc8 	.word	0x20000dc8
  207e00:	0800bc04 	.word	0x0800bc04
	...

00207e10 <test_wait_tick>:
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
  207e10:	b510      	push	{r4, lr}

  chThdSleep(1);
  207e12:	2001      	movs	r0, #1
  207e14:	f7ff fe4c 	bl	207ab0 <chThdSleep>
  __ASM volatile ("cpsid i" : : : "memory");
  207e18:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207e1a:	2320      	movs	r3, #32
  207e1c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207e20:	b662      	cpsie	i
  _dbg_check_lock();
  207e22:	f7fb ff95 	bl	203d50 <_dbg_check_lock>
  207e26:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  207e2a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
  _dbg_check_unlock();
  207e2c:	f7fb ff40 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207e30:	4b08      	ldr	r3, [pc, #32]	; (207e54 <test_wait_tick+0x44>)
  207e32:	681a      	ldr	r2, [r3, #0]
  207e34:	429a      	cmp	r2, r3
  207e36:	d004      	beq.n	207e42 <test_wait_tick+0x32>
  207e38:	6999      	ldr	r1, [r3, #24]
  207e3a:	6893      	ldr	r3, [r2, #8]
  207e3c:	688a      	ldr	r2, [r1, #8]
  207e3e:	429a      	cmp	r2, r3
  207e40:	d304      	bcc.n	207e4c <test_wait_tick+0x3c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207e42:	2300      	movs	r3, #0
  207e44:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
  207e48:	4620      	mov	r0, r4
  207e4a:	bd10      	pop	{r4, pc}
  207e4c:	4802      	ldr	r0, [pc, #8]	; (207e58 <test_wait_tick+0x48>)
  207e4e:	f7f8 fe8f 	bl	200b70 <chSysHalt>
  207e52:	bf00      	nop
  207e54:	20000dc8 	.word	0x20000dc8
  207e58:	0800bc88 	.word	0x0800bc88
  207e5c:	00000000 	.word	0x00000000

00207e60 <rt_test_010_011_execute>:
static void rt_test_010_011_execute(void) {
  207e60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
  207e64:	2301      	movs	r3, #1
  207e66:	f8df 907c 	ldr.w	r9, [pc, #124]	; 207ee4 <rt_test_010_011_execute+0x84>
    n = 0;
  207e6a:	2500      	movs	r5, #0
      chMtxLock(&mtx1);
  207e6c:	4c1a      	ldr	r4, [pc, #104]	; (207ed8 <rt_test_010_011_execute+0x78>)
  test_set_step(1);
  207e6e:	f8c9 3000 	str.w	r3, [r9]
  207e72:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
    start = test_wait_tick();
  207e76:	f7ff ffcb 	bl	207e10 <test_wait_tick>
    } while (chVTIsSystemTimeWithinX(start, end));
  207e7a:	f242 760f 	movw	r6, #9999	; 0x270f
    start = test_wait_tick();
  207e7e:	4607      	mov	r7, r0
      chMtxLock(&mtx1);
  207e80:	4620      	mov	r0, r4
      n++;
  207e82:	3501      	adds	r5, #1
      chMtxLock(&mtx1);
  207e84:	f7fe fa1c 	bl	2062c0 <chMtxLock>
      chMtxUnlock(&mtx1);
  207e88:	4620      	mov	r0, r4
  207e8a:	f7fe f8e9 	bl	206060 <chMtxUnlock>
      chMtxLock(&mtx1);
  207e8e:	4620      	mov	r0, r4
  207e90:	f7fe fa16 	bl	2062c0 <chMtxLock>
      chMtxUnlock(&mtx1);
  207e94:	4620      	mov	r0, r4
  207e96:	f7fe f8e3 	bl	206060 <chMtxUnlock>
      chMtxLock(&mtx1);
  207e9a:	4620      	mov	r0, r4
  207e9c:	f7fe fa10 	bl	2062c0 <chMtxLock>
      chMtxUnlock(&mtx1);
  207ea0:	4620      	mov	r0, r4
  207ea2:	f7fe f8dd 	bl	206060 <chMtxUnlock>
      chMtxLock(&mtx1);
  207ea6:	4620      	mov	r0, r4
  207ea8:	f7fe fa0a 	bl	2062c0 <chMtxLock>
      chMtxUnlock(&mtx1);
  207eac:	4620      	mov	r0, r4
  207eae:	f7fe f8d7 	bl	206060 <chMtxUnlock>
  207eb2:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
  return (bool)((time - start) < (end - start));
  207eb6:	1bdb      	subs	r3, r3, r7
    } while (chVTIsSystemTimeWithinX(start, end));
  207eb8:	42b3      	cmp	r3, r6
  207eba:	d9e1      	bls.n	207e80 <rt_test_010_011_execute+0x20>
  test_set_step(2);
  207ebc:	2302      	movs	r3, #2
    test_print("--- Score : ");
  207ebe:	4807      	ldr	r0, [pc, #28]	; (207edc <rt_test_010_011_execute+0x7c>)
  test_set_step(2);
  207ec0:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
  207ec4:	f7f8 fd04 	bl	2008d0 <test_print>
    test_printn(n * 4);
  207ec8:	00a8      	lsls	r0, r5, #2
  207eca:	f7f8 fcd1 	bl	200870 <test_printn>
    test_println(" lock+unlock/S");
  207ece:	4804      	ldr	r0, [pc, #16]	; (207ee0 <rt_test_010_011_execute+0x80>)
}
  207ed0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" lock+unlock/S");
  207ed4:	f7f8 bcdc 	b.w	200890 <test_println>
  207ed8:	20001818 	.word	0x20001818
  207edc:	0800daac 	.word	0x0800daac
  207ee0:	0800dabc 	.word	0x0800dabc
  207ee4:	20001f6c 	.word	0x20001f6c
	...

00207ef0 <rt_test_010_010_execute>:
static void rt_test_010_010_execute(void) {
  207ef0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
  207ef4:	2301      	movs	r3, #1
  207ef6:	f8df 907c 	ldr.w	r9, [pc, #124]	; 207f74 <rt_test_010_010_execute+0x84>
    n = 0;
  207efa:	2500      	movs	r5, #0
      chSemWait(&sem1);
  207efc:	4c1a      	ldr	r4, [pc, #104]	; (207f68 <rt_test_010_010_execute+0x78>)
  test_set_step(1);
  207efe:	f8c9 3000 	str.w	r3, [r9]
  207f02:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
    start = test_wait_tick();
  207f06:	f7ff ff83 	bl	207e10 <test_wait_tick>
    } while (chVTIsSystemTimeWithinX(start, end));
  207f0a:	f242 760f 	movw	r6, #9999	; 0x270f
    start = test_wait_tick();
  207f0e:	4607      	mov	r7, r0
      chSemWait(&sem1);
  207f10:	4620      	mov	r0, r4
      n++;
  207f12:	3501      	adds	r5, #1
      chSemWait(&sem1);
  207f14:	f7ff fbdc 	bl	2076d0 <chSemWait>
      chSemSignal(&sem1);
  207f18:	4620      	mov	r0, r4
  207f1a:	f7ff fba1 	bl	207660 <chSemSignal>
      chSemWait(&sem1);
  207f1e:	4620      	mov	r0, r4
  207f20:	f7ff fbd6 	bl	2076d0 <chSemWait>
      chSemSignal(&sem1);
  207f24:	4620      	mov	r0, r4
  207f26:	f7ff fb9b 	bl	207660 <chSemSignal>
      chSemWait(&sem1);
  207f2a:	4620      	mov	r0, r4
  207f2c:	f7ff fbd0 	bl	2076d0 <chSemWait>
      chSemSignal(&sem1);
  207f30:	4620      	mov	r0, r4
  207f32:	f7ff fb95 	bl	207660 <chSemSignal>
      chSemWait(&sem1);
  207f36:	4620      	mov	r0, r4
  207f38:	f7ff fbca 	bl	2076d0 <chSemWait>
      chSemSignal(&sem1);
  207f3c:	4620      	mov	r0, r4
  207f3e:	f7ff fb8f 	bl	207660 <chSemSignal>
  207f42:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
  207f46:	1bdb      	subs	r3, r3, r7
    } while (chVTIsSystemTimeWithinX(start, end));
  207f48:	42b3      	cmp	r3, r6
  207f4a:	d9e1      	bls.n	207f10 <rt_test_010_010_execute+0x20>
  test_set_step(2);
  207f4c:	2302      	movs	r3, #2
    test_print("--- Score : ");
  207f4e:	4807      	ldr	r0, [pc, #28]	; (207f6c <rt_test_010_010_execute+0x7c>)
  test_set_step(2);
  207f50:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
  207f54:	f7f8 fcbc 	bl	2008d0 <test_print>
    test_printn(n * 4);
  207f58:	00a8      	lsls	r0, r5, #2
  207f5a:	f7f8 fc89 	bl	200870 <test_printn>
    test_println(" wait+signal/S");
  207f5e:	4804      	ldr	r0, [pc, #16]	; (207f70 <rt_test_010_010_execute+0x80>)
}
  207f60:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" wait+signal/S");
  207f64:	f7f8 bc94 	b.w	200890 <test_println>
  207f68:	20001844 	.word	0x20001844
  207f6c:	0800daac 	.word	0x0800daac
  207f70:	0800da8c 	.word	0x0800da8c
  207f74:	20001f6c 	.word	0x20001f6c
	...

00207f80 <rt_test_010_009_execute>:
static void rt_test_010_009_execute(void) {
  207f80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(1);
  207f84:	2301      	movs	r3, #1
  207f86:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 208044 <rt_test_010_009_execute+0xc4>
    n = 0;
  207f8a:	f04f 0800 	mov.w	r8, #0
  207f8e:	4c26      	ldr	r4, [pc, #152]	; (208028 <rt_test_010_009_execute+0xa8>)
  test_set_step(1);
  207f90:	f8ca 3000 	str.w	r3, [sl]
    start = test_wait_tick();
  207f94:	f7ff ff3c 	bl	207e10 <test_wait_tick>
      chVTDoSetI(&vt1, 1, tmo, NULL);
  207f98:	4f24      	ldr	r7, [pc, #144]	; (20802c <rt_test_010_009_execute+0xac>)
    start = test_wait_tick();
  207f9a:	4681      	mov	r9, r0
      chVTDoSetI(&vt1, 1, tmo, NULL);
  207f9c:	4e24      	ldr	r6, [pc, #144]	; (208030 <rt_test_010_009_execute+0xb0>)
      chVTDoSetI(&vt2, 10000, tmo, NULL);
  207f9e:	4d25      	ldr	r5, [pc, #148]	; (208034 <rt_test_010_009_execute+0xb4>)
  __ASM volatile ("cpsid i" : : : "memory");
  207fa0:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207fa2:	2320      	movs	r3, #32
  207fa4:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  207fa8:	b662      	cpsie	i
  _dbg_check_lock();
  207faa:	f7fb fed1 	bl	203d50 <_dbg_check_lock>
      chVTDoSetI(&vt1, 1, tmo, NULL);
  207fae:	463a      	mov	r2, r7
  207fb0:	4630      	mov	r0, r6
  207fb2:	2300      	movs	r3, #0
  207fb4:	2101      	movs	r1, #1
  207fb6:	f7fa f95b 	bl	202270 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
  207fba:	2300      	movs	r3, #0
  207fbc:	463a      	mov	r2, r7
  207fbe:	f242 7110 	movw	r1, #10000	; 0x2710
  207fc2:	4628      	mov	r0, r5
  207fc4:	f7fa f954 	bl	202270 <chVTDoSetI>
      chVTDoResetI(&vt1);
  207fc8:	4630      	mov	r0, r6
  207fca:	f7fa f909 	bl	2021e0 <chVTDoResetI>
      chVTDoResetI(&vt2);
  207fce:	4628      	mov	r0, r5
  207fd0:	f7fa f906 	bl	2021e0 <chVTDoResetI>
  _dbg_check_unlock();
  207fd4:	f7fb fe6c 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  207fd8:	6823      	ldr	r3, [r4, #0]
  207fda:	42a3      	cmp	r3, r4
  207fdc:	d004      	beq.n	207fe8 <rt_test_010_009_execute+0x68>
  207fde:	69a2      	ldr	r2, [r4, #24]
  207fe0:	689b      	ldr	r3, [r3, #8]
  207fe2:	6892      	ldr	r2, [r2, #8]
  207fe4:	429a      	cmp	r2, r3
  207fe6:	d31c      	bcc.n	208022 <rt_test_010_009_execute+0xa2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  207fe8:	2300      	movs	r3, #0
  207fea:	f383 8811 	msr	BASEPRI, r3
  207fee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
  207ff2:	f242 720f 	movw	r2, #9999	; 0x270f
      n++;
  207ff6:	f108 0801 	add.w	r8, r8, #1
  207ffa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  207ffc:	eba3 0309 	sub.w	r3, r3, r9
    } while (chVTIsSystemTimeWithinX(start, end));
  208000:	4293      	cmp	r3, r2
  208002:	d9cd      	bls.n	207fa0 <rt_test_010_009_execute+0x20>
  test_set_step(2);
  208004:	2302      	movs	r3, #2
    test_print("--- Score : ");
  208006:	480c      	ldr	r0, [pc, #48]	; (208038 <rt_test_010_009_execute+0xb8>)
  test_set_step(2);
  208008:	f8ca 3000 	str.w	r3, [sl]
    test_print("--- Score : ");
  20800c:	f7f8 fc60 	bl	2008d0 <test_print>
    test_printn(n * 2);
  208010:	ea4f 0048 	mov.w	r0, r8, lsl #1
  208014:	f7f8 fc2c 	bl	200870 <test_printn>
    test_println(" timers/S");
  208018:	4808      	ldr	r0, [pc, #32]	; (20803c <rt_test_010_009_execute+0xbc>)
}
  20801a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_println(" timers/S");
  20801e:	f7f8 bc37 	b.w	200890 <test_println>
  208022:	4807      	ldr	r0, [pc, #28]	; (208040 <rt_test_010_009_execute+0xc0>)
  208024:	f7f8 fda4 	bl	200b70 <chSysHalt>
  208028:	20000dc8 	.word	0x20000dc8
  20802c:	002007a1 	.word	0x002007a1
  208030:	20001f9c 	.word	0x20001f9c
  208034:	20001fb0 	.word	0x20001fb0
  208038:	0800daac 	.word	0x0800daac
  20803c:	0800da70 	.word	0x0800da70
  208040:	0800bcdc 	.word	0x0800bcdc
  208044:	20001f6c 	.word	0x20001f6c
	...

00208050 <msg_loop_test>:
NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
  208050:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  208054:	4605      	mov	r5, r0
  uint32_t n = 0;
  208056:	2400      	movs	r4, #0
  start = test_wait_tick();
  208058:	f7ff feda 	bl	207e10 <test_wait_tick>
  20805c:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
  208060:	4680      	mov	r8, r0
  } while (chVTIsSystemTimeWithinX(start, end));
  208062:	f242 760f 	movw	r6, #9999	; 0x270f
    (void)chMsgSend(tp, 1);
  208066:	2101      	movs	r1, #1
  208068:	4628      	mov	r0, r5
  20806a:	f7fd feb1 	bl	205dd0 <chMsgSend>
  20806e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    n++;
  208070:	3401      	adds	r4, #1
  208072:	eba3 0308 	sub.w	r3, r3, r8
  } while (chVTIsSystemTimeWithinX(start, end));
  208076:	42b3      	cmp	r3, r6
  208078:	d9f5      	bls.n	208066 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
  20807a:	4628      	mov	r0, r5
  20807c:	2100      	movs	r1, #0
  20807e:	f7fd fea7 	bl	205dd0 <chMsgSend>
}
  208082:	4620      	mov	r0, r4
  208084:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

00208090 <test_execute>:
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
  208090:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int tseq, tcase;

  test_chp = stream;
  208094:	4c9d      	ldr	r4, [pc, #628]	; (20830c <test_execute+0x27c>)
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
  208096:	4689      	mov	r9, r1
  test_chp = stream;
  208098:	6020      	str	r0, [r4, #0]
  test_println("");
  20809a:	489d      	ldr	r0, [pc, #628]	; (208310 <test_execute+0x280>)
  20809c:	f7f8 fbf8 	bl	200890 <test_println>
  if (tsp->name != NULL) {
  2080a0:	f8d9 3000 	ldr.w	r3, [r9]
  2080a4:	2b00      	cmp	r3, #0
  2080a6:	f000 8185 	beq.w	2083b4 <test_execute+0x324>
  while (*msgp)
  2080aa:	212a      	movs	r1, #42	; 0x2a
  if (tsp->name != NULL) {
  2080ac:	4d99      	ldr	r5, [pc, #612]	; (208314 <test_execute+0x284>)
    streamPut(test_chp, *msgp++);
  2080ae:	6820      	ldr	r0, [r4, #0]
  2080b0:	6803      	ldr	r3, [r0, #0]
  2080b2:	68db      	ldr	r3, [r3, #12]
  2080b4:	4798      	blx	r3
  while (*msgp)
  2080b6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
  2080ba:	2900      	cmp	r1, #0
  2080bc:	d1f7      	bne.n	2080ae <test_execute+0x1e>
    test_print("*** ");
    test_println(tsp->name);
  2080be:	f8d9 0000 	ldr.w	r0, [r9]
  2080c2:	f7f8 fbe5 	bl	200890 <test_println>
  }
  else {
    test_println("*** Test Suite");
  }
  test_println("***");
  2080c6:	4894      	ldr	r0, [pc, #592]	; (208318 <test_execute+0x288>)
  2080c8:	f7f8 fbe2 	bl	200890 <test_println>
  2080cc:	4d93      	ldr	r5, [pc, #588]	; (20831c <test_execute+0x28c>)
  while (*msgp)
  2080ce:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
  2080d0:	6820      	ldr	r0, [r4, #0]
  2080d2:	6803      	ldr	r3, [r0, #0]
  2080d4:	68db      	ldr	r3, [r3, #12]
  2080d6:	4798      	blx	r3
  while (*msgp)
  2080d8:	f815 1f01 	ldrb.w	r1, [r5, #1]!
  2080dc:	2900      	cmp	r1, #0
  2080de:	d1f7      	bne.n	2080d0 <test_execute+0x40>
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
  2080e0:	488f      	ldr	r0, [pc, #572]	; (208320 <test_execute+0x290>)
  2080e2:	f7f8 fbd5 	bl	200890 <test_println>
  2080e6:	4d8f      	ldr	r5, [pc, #572]	; (208324 <test_execute+0x294>)
  while (*msgp)
  2080e8:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
  2080ea:	6820      	ldr	r0, [r4, #0]
  2080ec:	6803      	ldr	r3, [r0, #0]
  2080ee:	68db      	ldr	r3, [r3, #12]
  2080f0:	4798      	blx	r3
  while (*msgp)
  2080f2:	f815 1f01 	ldrb.w	r1, [r5, #1]!
  2080f6:	2900      	cmp	r1, #0
  2080f8:	d1f7      	bne.n	2080ea <test_execute+0x5a>
  2080fa:	252a      	movs	r5, #42	; 0x2a
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
  2080fc:	488a      	ldr	r0, [pc, #552]	; (208328 <test_execute+0x298>)
  2080fe:	f7f8 fbc7 	bl	200890 <test_println>
  208102:	4e8a      	ldr	r6, [pc, #552]	; (20832c <test_execute+0x29c>)
  208104:	4629      	mov	r1, r5
    streamPut(test_chp, *msgp++);
  208106:	6820      	ldr	r0, [r4, #0]
  208108:	6803      	ldr	r3, [r0, #0]
  20810a:	68db      	ldr	r3, [r3, #12]
  20810c:	4798      	blx	r3
  while (*msgp)
  20810e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
  208112:	2900      	cmp	r1, #0
  208114:	d1f7      	bne.n	208106 <test_execute+0x76>
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
  208116:	4886      	ldr	r0, [pc, #536]	; (208330 <test_execute+0x2a0>)
  208118:	460d      	mov	r5, r1
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
  tseq = 0;
  20811a:	468b      	mov	fp, r1
  test_println(BOARD_NAME);
  20811c:	f7f8 fbb8 	bl	200890 <test_println>
  test_println("");
  208120:	487b      	ldr	r0, [pc, #492]	; (208310 <test_execute+0x280>)
  208122:	f7f8 fbb5 	bl	200890 <test_println>
  test_global_fail = false;
  208126:	4b83      	ldr	r3, [pc, #524]	; (208334 <test_execute+0x2a4>)
  test_tokp = test_tokens_buffer;
  208128:	4f83      	ldr	r7, [pc, #524]	; (208338 <test_execute+0x2a8>)
  test_global_fail = false;
  20812a:	701d      	strb	r5, [r3, #0]
  20812c:	f8d9 3004 	ldr.w	r3, [r9, #4]
  while (tsp->sequences[tseq] != NULL) {
  208130:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
  208134:	ea4f 068b 	mov.w	r6, fp, lsl #2
  208138:	2b00      	cmp	r3, #0
  20813a:	f000 811b 	beq.w	208374 <test_execute+0x2e4>
  20813e:	254c      	movs	r5, #76	; 0x4c
    streamPut(test_chp, '=');
  208140:	6820      	ldr	r0, [r4, #0]
  208142:	213d      	movs	r1, #61	; 0x3d
  208144:	6803      	ldr	r3, [r0, #0]
  208146:	68db      	ldr	r3, [r3, #12]
  208148:	4798      	blx	r3
  for (i = 0; i < 76; i++)
  20814a:	3d01      	subs	r5, #1
  20814c:	d1f8      	bne.n	208140 <test_execute+0xb0>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
  20814e:	6820      	ldr	r0, [r4, #0]
  208150:	2202      	movs	r2, #2
  208152:	497a      	ldr	r1, [pc, #488]	; (20833c <test_execute+0x2ac>)
  208154:	6803      	ldr	r3, [r0, #0]
  208156:	4d7a      	ldr	r5, [pc, #488]	; (208340 <test_execute+0x2b0>)
  208158:	685b      	ldr	r3, [r3, #4]
  20815a:	4798      	blx	r3
  while (*msgp)
  20815c:	213d      	movs	r1, #61	; 0x3d
    streamPut(test_chp, *msgp++);
  20815e:	6820      	ldr	r0, [r4, #0]
  208160:	6803      	ldr	r3, [r0, #0]
  208162:	68db      	ldr	r3, [r3, #12]
  208164:	4798      	blx	r3
  while (*msgp)
  208166:	f815 1f01 	ldrb.w	r1, [r5, #1]!
  20816a:	2900      	cmp	r1, #0
  20816c:	d1f7      	bne.n	20815e <test_execute+0xce>
#if TEST_SHOW_SEQUENCES == TRUE
    print_fat_line();
    test_print("=== Test Sequence ");
    test_printn(tseq + 1);
  20816e:	f10b 0b01 	add.w	fp, fp, #1
  208172:	4d74      	ldr	r5, [pc, #464]	; (208344 <test_execute+0x2b4>)
  208174:	4658      	mov	r0, fp
  208176:	f7f8 fb7b 	bl	200870 <test_printn>
  while (*msgp)
  20817a:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
  20817c:	6820      	ldr	r0, [r4, #0]
  20817e:	6803      	ldr	r3, [r0, #0]
  208180:	68db      	ldr	r3, [r3, #12]
  208182:	4798      	blx	r3
  while (*msgp)
  208184:	f815 1f01 	ldrb.w	r1, [r5, #1]!
  208188:	2900      	cmp	r1, #0
  20818a:	d1f7      	bne.n	20817c <test_execute+0xec>
    test_print(" (");
    test_print(tsp->sequences[tseq]->name);
  20818c:	f8d9 3004 	ldr.w	r3, [r9, #4]
  208190:	599b      	ldr	r3, [r3, r6]
  208192:	681d      	ldr	r5, [r3, #0]
  while (*msgp)
  208194:	7829      	ldrb	r1, [r5, #0]
  208196:	b139      	cbz	r1, 2081a8 <test_execute+0x118>
    streamPut(test_chp, *msgp++);
  208198:	6820      	ldr	r0, [r4, #0]
  20819a:	6803      	ldr	r3, [r0, #0]
  20819c:	68db      	ldr	r3, [r3, #12]
  20819e:	4798      	blx	r3
  while (*msgp)
  2081a0:	f815 1f01 	ldrb.w	r1, [r5, #1]!
  2081a4:	2900      	cmp	r1, #0
  2081a6:	d1f7      	bne.n	208198 <test_execute+0x108>
    test_println(")");
  2081a8:	4867      	ldr	r0, [pc, #412]	; (208348 <test_execute+0x2b8>)
#endif
    tcase = 0;
  2081aa:	2500      	movs	r5, #0
    test_println(")");
  2081ac:	f7f8 fb70 	bl	200890 <test_println>
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
  2081b0:	f8d9 3004 	ldr.w	r3, [r9, #4]
  2081b4:	ea4f 0885 	mov.w	r8, r5, lsl #2
  2081b8:	599a      	ldr	r2, [r3, r6]
  2081ba:	6852      	ldr	r2, [r2, #4]
  2081bc:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
  2081c0:	2a00      	cmp	r2, #0
  2081c2:	d0b5      	beq.n	208130 <test_execute+0xa0>
      print_line();
  2081c4:	f7f8 fbc4 	bl	200950 <print_line>
  2081c8:	f8df a194 	ldr.w	sl, [pc, #404]	; 208360 <test_execute+0x2d0>
  while (*msgp)
  2081cc:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
  2081ce:	6820      	ldr	r0, [r4, #0]
  2081d0:	6803      	ldr	r3, [r0, #0]
  2081d2:	68db      	ldr	r3, [r3, #12]
  2081d4:	4798      	blx	r3
  while (*msgp)
  2081d6:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
  2081da:	2900      	cmp	r1, #0
  2081dc:	d1f7      	bne.n	2081ce <test_execute+0x13e>
      test_print("--- Test Case ");
      test_printn(tseq + 1);
  2081de:	4658      	mov	r0, fp
      test_print(".");
      test_printn(tcase + 1);
  2081e0:	3501      	adds	r5, #1
      test_printn(tseq + 1);
  2081e2:	f7f8 fb45 	bl	200870 <test_printn>
    streamPut(test_chp, *msgp++);
  2081e6:	6820      	ldr	r0, [r4, #0]
  2081e8:	212e      	movs	r1, #46	; 0x2e
      test_printn(tcase + 1);
  2081ea:	f8df a158 	ldr.w	sl, [pc, #344]	; 208344 <test_execute+0x2b4>
    streamPut(test_chp, *msgp++);
  2081ee:	6803      	ldr	r3, [r0, #0]
  2081f0:	68db      	ldr	r3, [r3, #12]
  2081f2:	4798      	blx	r3
      test_printn(tcase + 1);
  2081f4:	4628      	mov	r0, r5
  2081f6:	f7f8 fb3b 	bl	200870 <test_printn>
  while (*msgp)
  2081fa:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
  2081fc:	6820      	ldr	r0, [r4, #0]
  2081fe:	6803      	ldr	r3, [r0, #0]
  208200:	68db      	ldr	r3, [r3, #12]
  208202:	4798      	blx	r3
  while (*msgp)
  208204:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
  208208:	2900      	cmp	r1, #0
  20820a:	d1f7      	bne.n	2081fc <test_execute+0x16c>
      test_print(" (");
      test_print(tsp->sequences[tseq]->cases[tcase]->name);
  20820c:	f8d9 3004 	ldr.w	r3, [r9, #4]
  208210:	599b      	ldr	r3, [r3, r6]
  208212:	685b      	ldr	r3, [r3, #4]
  208214:	f853 3008 	ldr.w	r3, [r3, r8]
  208218:	f8d3 a000 	ldr.w	sl, [r3]
  while (*msgp)
  20821c:	f89a 1000 	ldrb.w	r1, [sl]
  208220:	b139      	cbz	r1, 208232 <test_execute+0x1a2>
    streamPut(test_chp, *msgp++);
  208222:	6820      	ldr	r0, [r4, #0]
  208224:	6803      	ldr	r3, [r0, #0]
  208226:	68db      	ldr	r3, [r3, #12]
  208228:	4798      	blx	r3
  while (*msgp)
  20822a:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
  20822e:	2900      	cmp	r1, #0
  208230:	d1f7      	bne.n	208222 <test_execute+0x192>
      test_println(")");
  208232:	4845      	ldr	r0, [pc, #276]	; (208348 <test_execute+0x2b8>)
  208234:	f7f8 fb2c 	bl	200890 <test_println>
  chThdSleep(delay);
  208238:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
  20823c:	f7ff fc38 	bl	207ab0 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
  208240:	f8d9 3004 	ldr.w	r3, [r9, #4]
  test_local_fail = false;
  208244:	f8df a11c 	ldr.w	sl, [pc, #284]	; 208364 <test_execute+0x2d4>
  208248:	2200      	movs	r2, #0
      execute_test(tsp->sequences[tseq]->cases[tcase]);
  20824a:	599b      	ldr	r3, [r3, r6]
  test_tokp = test_tokens_buffer;
  20824c:	493f      	ldr	r1, [pc, #252]	; (20834c <test_execute+0x2bc>)
      execute_test(tsp->sequences[tseq]->cases[tcase]);
  20824e:	685b      	ldr	r3, [r3, #4]
  test_tokp = test_tokens_buffer;
  208250:	6039      	str	r1, [r7, #0]
      execute_test(tsp->sequences[tseq]->cases[tcase]);
  208252:	f853 8008 	ldr.w	r8, [r3, r8]
  test_local_fail = false;
  208256:	f88a 2000 	strb.w	r2, [sl]
  if (tcp->setup != NULL)
  20825a:	f8d8 3004 	ldr.w	r3, [r8, #4]
  20825e:	b103      	cbz	r3, 208262 <test_execute+0x1d2>
    tcp->setup();
  208260:	4798      	blx	r3
  tcp->execute();
  208262:	f8d8 300c 	ldr.w	r3, [r8, #12]
  208266:	4798      	blx	r3
  if (tcp->teardown != NULL)
  208268:	f8d8 3008 	ldr.w	r3, [r8, #8]
  20826c:	b103      	cbz	r3, 208270 <test_execute+0x1e0>
    tcp->teardown();
  20826e:	4798      	blx	r3
      if (test_local_fail) {
  208270:	f89a 3000 	ldrb.w	r3, [sl]
  208274:	2b00      	cmp	r3, #0
  208276:	d044      	beq.n	208302 <test_execute+0x272>
  while (*msgp)
  208278:	212d      	movs	r1, #45	; 0x2d
      if (test_local_fail) {
  20827a:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 208368 <test_execute+0x2d8>
    streamPut(test_chp, *msgp++);
  20827e:	6820      	ldr	r0, [r4, #0]
  208280:	6803      	ldr	r3, [r0, #0]
  208282:	68db      	ldr	r3, [r3, #12]
  208284:	4798      	blx	r3
  while (*msgp)
  208286:	f818 1f01 	ldrb.w	r1, [r8, #1]!
  20828a:	2900      	cmp	r1, #0
  20828c:	d1f7      	bne.n	20827e <test_execute+0x1ee>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
  20828e:	4b30      	ldr	r3, [pc, #192]	; (208350 <test_execute+0x2c0>)
  208290:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 20836c <test_execute+0x2dc>
  208294:	6818      	ldr	r0, [r3, #0]
  208296:	f7f8 faeb 	bl	200870 <test_printn>
  while (*msgp)
  20829a:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
  20829c:	6820      	ldr	r0, [r4, #0]
  20829e:	6803      	ldr	r3, [r0, #0]
  2082a0:	68db      	ldr	r3, [r3, #12]
  2082a2:	4798      	blx	r3
  while (*msgp)
  2082a4:	f818 1f01 	ldrb.w	r1, [r8, #1]!
  2082a8:	2900      	cmp	r1, #0
  2082aa:	d1f7      	bne.n	20829c <test_execute+0x20c>
  while (cp < test_tokp)
  2082ac:	683b      	ldr	r3, [r7, #0]
  2082ae:	4a27      	ldr	r2, [pc, #156]	; (20834c <test_execute+0x2bc>)
  2082b0:	4293      	cmp	r3, r2
  2082b2:	d909      	bls.n	2082c8 <test_execute+0x238>
  char *cp = test_tokens_buffer;
  2082b4:	4690      	mov	r8, r2
    streamPut(test_chp, *cp++);
  2082b6:	6820      	ldr	r0, [r4, #0]
  2082b8:	f818 1b01 	ldrb.w	r1, [r8], #1
  2082bc:	6803      	ldr	r3, [r0, #0]
  2082be:	68db      	ldr	r3, [r3, #12]
  2082c0:	4798      	blx	r3
  while (cp < test_tokp)
  2082c2:	683b      	ldr	r3, [r7, #0]
  2082c4:	4598      	cmp	r8, r3
  2082c6:	d3f6      	bcc.n	2082b6 <test_execute+0x226>
  while (*msgp)
  2082c8:	215d      	movs	r1, #93	; 0x5d
  2082ca:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 208370 <test_execute+0x2e0>
    streamPut(test_chp, *msgp++);
  2082ce:	6820      	ldr	r0, [r4, #0]
  2082d0:	6803      	ldr	r3, [r0, #0]
  2082d2:	68db      	ldr	r3, [r3, #12]
  2082d4:	4798      	blx	r3
  while (*msgp)
  2082d6:	f818 1f01 	ldrb.w	r1, [r8, #1]!
  2082da:	2900      	cmp	r1, #0
  2082dc:	d1f7      	bne.n	2082ce <test_execute+0x23e>
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
  2082de:	4b1d      	ldr	r3, [pc, #116]	; (208354 <test_execute+0x2c4>)
  2082e0:	f8d3 8000 	ldr.w	r8, [r3]
  while (*msgp)
  2082e4:	f898 1000 	ldrb.w	r1, [r8]
  2082e8:	b139      	cbz	r1, 2082fa <test_execute+0x26a>
    streamPut(test_chp, *msgp++);
  2082ea:	6820      	ldr	r0, [r4, #0]
  2082ec:	6803      	ldr	r3, [r0, #0]
  2082ee:	68db      	ldr	r3, [r3, #12]
  2082f0:	4798      	blx	r3
  while (*msgp)
  2082f2:	f818 1f01 	ldrb.w	r1, [r8, #1]!
  2082f6:	2900      	cmp	r1, #0
  2082f8:	d1f7      	bne.n	2082ea <test_execute+0x25a>
        test_println("\")");
  2082fa:	4817      	ldr	r0, [pc, #92]	; (208358 <test_execute+0x2c8>)
  2082fc:	f7f8 fac8 	bl	200890 <test_println>
  208300:	e756      	b.n	2081b0 <test_execute+0x120>
      }
      else {
        test_println("--- Result: SUCCESS");
  208302:	4816      	ldr	r0, [pc, #88]	; (20835c <test_execute+0x2cc>)
  208304:	f7f8 fac4 	bl	200890 <test_println>
  208308:	e752      	b.n	2081b0 <test_execute+0x120>
  20830a:	bf00      	nop
  20830c:	20001ec0 	.word	0x20001ec0
  208310:	0800dd4c 	.word	0x0800dd4c
  208314:	0800e738 	.word	0x0800e738
  208318:	0800e7e4 	.word	0x0800e7e4
  20831c:	0800e740 	.word	0x0800e740
  208320:	0800e7e8 	.word	0x0800e7e8
  208324:	0800e754 	.word	0x0800e754
  208328:	0800c2f0 	.word	0x0800c2f0
  20832c:	0800e768 	.word	0x0800e768
  208330:	0800c338 	.word	0x0800c338
  208334:	20001ec8 	.word	0x20001ec8
  208338:	20001f80 	.word	0x20001f80
  20833c:	0800c4dc 	.word	0x0800c4dc
  208340:	0800e77c 	.word	0x0800e77c
  208344:	0800e790 	.word	0x0800e790
  208348:	0800e800 	.word	0x0800e800
  20834c:	20001f70 	.word	0x20001f70
  208350:	20001f6c 	.word	0x20001f6c
  208354:	20001ec4 	.word	0x20001ec4
  208358:	0800e804 	.word	0x0800e804
  20835c:	0800e808 	.word	0x0800e808
  208360:	0800e794 	.word	0x0800e794
  208364:	20001f68 	.word	0x20001f68
  208368:	0800e7a4 	.word	0x0800e7a4
  20836c:	0800e7bc 	.word	0x0800e7bc
  208370:	0800e7c0 	.word	0x0800e7c0
      }
      tcase++;
    }
    tseq++;
  }
  print_line();
  208374:	f7f8 faec 	bl	200950 <print_line>
  test_println("");
  208378:	4810      	ldr	r0, [pc, #64]	; (2083bc <test_execute+0x32c>)
  20837a:	f7f8 fa89 	bl	200890 <test_println>
  20837e:	4d10      	ldr	r5, [pc, #64]	; (2083c0 <test_execute+0x330>)
  while (*msgp)
  208380:	2146      	movs	r1, #70	; 0x46
    streamPut(test_chp, *msgp++);
  208382:	6820      	ldr	r0, [r4, #0]
  208384:	6803      	ldr	r3, [r0, #0]
  208386:	68db      	ldr	r3, [r3, #12]
  208388:	4798      	blx	r3
  while (*msgp)
  20838a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
  20838e:	2900      	cmp	r1, #0
  208390:	d1f7      	bne.n	208382 <test_execute+0x2f2>
  test_print("Final result: ");
  if (test_global_fail)
  208392:	4b0c      	ldr	r3, [pc, #48]	; (2083c4 <test_execute+0x334>)
  208394:	781b      	ldrb	r3, [r3, #0]
  208396:	b933      	cbnz	r3, 2083a6 <test_execute+0x316>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
  208398:	480b      	ldr	r0, [pc, #44]	; (2083c8 <test_execute+0x338>)
  20839a:	f7f8 fa79 	bl	200890 <test_println>
#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
}
  20839e:	4b09      	ldr	r3, [pc, #36]	; (2083c4 <test_execute+0x334>)
  2083a0:	7818      	ldrb	r0, [r3, #0]
  2083a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    test_println("FAILURE");
  2083a6:	4809      	ldr	r0, [pc, #36]	; (2083cc <test_execute+0x33c>)
  2083a8:	f7f8 fa72 	bl	200890 <test_println>
}
  2083ac:	4b05      	ldr	r3, [pc, #20]	; (2083c4 <test_execute+0x334>)
  2083ae:	7818      	ldrb	r0, [r3, #0]
  2083b0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    test_println("*** Test Suite");
  2083b4:	4806      	ldr	r0, [pc, #24]	; (2083d0 <test_execute+0x340>)
  2083b6:	f7f8 fa6b 	bl	200890 <test_println>
  2083ba:	e684      	b.n	2080c6 <test_execute+0x36>
  2083bc:	0800dd4c 	.word	0x0800dd4c
  2083c0:	0800e7c4 	.word	0x0800e7c4
  2083c4:	20001ec8 	.word	0x20001ec8
  2083c8:	0800e814 	.word	0x0800e814
  2083cc:	0800e81c 	.word	0x0800e81c
  2083d0:	0800e7d4 	.word	0x0800e7d4
	...

002083e0 <test_rt>:
#endif

#if (SHELL_CMD_TEST_ENABLED == TRUE) || defined(__DOXYGEN__)
static THD_FUNCTION(test_rt, arg) {
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
  test_execute(chp, &rt_test_suite);
  2083e0:	4901      	ldr	r1, [pc, #4]	; (2083e8 <test_rt+0x8>)
  2083e2:	f7ff be55 	b.w	208090 <test_execute>
  2083e6:	bf00      	nop
  2083e8:	0800dca4 	.word	0x0800dca4
  2083ec:	00000000 	.word	0x00000000

002083f0 <test_oslib>:
}

static THD_FUNCTION(test_oslib, arg) {
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
  test_execute(chp, &oslib_test_suite);
  2083f0:	4901      	ldr	r1, [pc, #4]	; (2083f8 <test_oslib+0x8>)
  2083f2:	f7ff be4d 	b.w	208090 <test_execute>
  2083f6:	bf00      	nop
  2083f8:	0800c904 	.word	0x0800c904
  2083fc:	00000000 	.word	0x00000000

00208400 <chThdSetPriority>:
  chDbgCheck(newprio <= HIGHPRIO);
  208400:	28ff      	cmp	r0, #255	; 0xff
tprio_t chThdSetPriority(tprio_t newprio) {
  208402:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck(newprio <= HIGHPRIO);
  208404:	d822      	bhi.n	20844c <chThdSetPriority+0x4c>
  208406:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  208408:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20840a:	2320      	movs	r3, #32
  20840c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208410:	b662      	cpsie	i
  oldprio = currp->realprio;
  208412:	4d11      	ldr	r5, [pc, #68]	; (208458 <chThdSetPriority+0x58>)
  _dbg_check_lock();
  208414:	f7fb fc9c 	bl	203d50 <_dbg_check_lock>
  208418:	69ab      	ldr	r3, [r5, #24]
  20841a:	6bde      	ldr	r6, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
  20841c:	689a      	ldr	r2, [r3, #8]
  20841e:	42b2      	cmp	r2, r6
  208420:	d001      	beq.n	208426 <chThdSetPriority+0x26>
  208422:	42a2      	cmp	r2, r4
  208424:	d200      	bcs.n	208428 <chThdSetPriority+0x28>
    currp->prio = newprio;
  208426:	609c      	str	r4, [r3, #8]
  currp->realprio = newprio;
  208428:	63dc      	str	r4, [r3, #60]	; 0x3c
  chSchRescheduleS();
  20842a:	f7fb fc29 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  20842e:	f7fb fc3f 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208432:	682b      	ldr	r3, [r5, #0]
  208434:	42ab      	cmp	r3, r5
  208436:	d004      	beq.n	208442 <chThdSetPriority+0x42>
  208438:	69aa      	ldr	r2, [r5, #24]
  20843a:	689b      	ldr	r3, [r3, #8]
  20843c:	6892      	ldr	r2, [r2, #8]
  20843e:	429a      	cmp	r2, r3
  208440:	d307      	bcc.n	208452 <chThdSetPriority+0x52>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208442:	2300      	movs	r3, #0
  208444:	f383 8811 	msr	BASEPRI, r3
}
  208448:	4630      	mov	r0, r6
  20844a:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(newprio <= HIGHPRIO);
  20844c:	4803      	ldr	r0, [pc, #12]	; (20845c <chThdSetPriority+0x5c>)
  20844e:	f7f8 fb8f 	bl	200b70 <chSysHalt>
  208452:	4803      	ldr	r0, [pc, #12]	; (208460 <chThdSetPriority+0x60>)
  208454:	f7f8 fb8c 	bl	200b70 <chSysHalt>
  208458:	20000dc8 	.word	0x20000dc8
  20845c:	0800bf68 	.word	0x0800bf68
  208460:	0800bc04 	.word	0x0800bc04
	...

00208470 <rt_test_003_004_execute>:
 * - [3.4.3] Raising thread priority above the boosted level.
 * - [3.4.4] Restoring original conditions.
 * .
 */

static void rt_test_003_004_execute(void) {
  208470:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
  208474:	4d38      	ldr	r5, [pc, #224]	; (208558 <rt_test_003_004_execute+0xe8>)
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  208476:	2202      	movs	r2, #2
  208478:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 208570 <rt_test_003_004_execute+0x100>
  20847c:	69ab      	ldr	r3, [r5, #24]
  20847e:	f8c8 2000 	str.w	r2, [r8]
  return chThdGetSelfX()->prio;
  208482:	689c      	ldr	r4, [r3, #8]
    chThdGetSelfX()->prio += 2;
  208484:	18a6      	adds	r6, r4, r2
  {
    p1 = chThdSetPriority(prio + 1);
  208486:	1c67      	adds	r7, r4, #1
    chThdGetSelfX()->prio += 2;
  208488:	609e      	str	r6, [r3, #8]
    p1 = chThdSetPriority(prio + 1);
  20848a:	4638      	mov	r0, r7
  20848c:	f7ff ffb8 	bl	208400 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
  208490:	1b00      	subs	r0, r0, r4
  208492:	4932      	ldr	r1, [pc, #200]	; (20855c <rt_test_003_004_execute+0xec>)
  208494:	fab0 f080 	clz	r0, r0
  208498:	0940      	lsrs	r0, r0, #5
  20849a:	f7f8 f991 	bl	2007c0 <_test_assert>
  20849e:	b108      	cbz	r0, 2084a4 <rt_test_003_004_execute+0x34>
    chSysLock();
    chThdGetSelfX()->prio = prio;
    chThdGetSelfX()->realprio = prio;
    chSysUnlock();
  }
}
  2084a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
  2084a4:	69ab      	ldr	r3, [r5, #24]
  2084a6:	492e      	ldr	r1, [pc, #184]	; (208560 <rt_test_003_004_execute+0xf0>)
  2084a8:	6898      	ldr	r0, [r3, #8]
  2084aa:	1b80      	subs	r0, r0, r6
  2084ac:	fab0 f080 	clz	r0, r0
  2084b0:	0940      	lsrs	r0, r0, #5
  2084b2:	f7f8 f985 	bl	2007c0 <_test_assert>
  2084b6:	2800      	cmp	r0, #0
  2084b8:	d1f2      	bne.n	2084a0 <rt_test_003_004_execute+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
  2084ba:	69ab      	ldr	r3, [r5, #24]
  2084bc:	4929      	ldr	r1, [pc, #164]	; (208564 <rt_test_003_004_execute+0xf4>)
  2084be:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
  2084c0:	1bc0      	subs	r0, r0, r7
  2084c2:	fab0 f080 	clz	r0, r0
  2084c6:	0940      	lsrs	r0, r0, #5
  2084c8:	f7f8 f97a 	bl	2007c0 <_test_assert>
  2084cc:	2800      	cmp	r0, #0
  2084ce:	d1e7      	bne.n	2084a0 <rt_test_003_004_execute+0x30>
    p1 = chThdSetPriority(prio + 3);
  2084d0:	1ce6      	adds	r6, r4, #3
  test_set_step(3);
  2084d2:	2303      	movs	r3, #3
    p1 = chThdSetPriority(prio + 3);
  2084d4:	4630      	mov	r0, r6
  test_set_step(3);
  2084d6:	f8c8 3000 	str.w	r3, [r8]
    p1 = chThdSetPriority(prio + 3);
  2084da:	f7ff ff91 	bl	208400 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
  2084de:	1a38      	subs	r0, r7, r0
  2084e0:	491e      	ldr	r1, [pc, #120]	; (20855c <rt_test_003_004_execute+0xec>)
  2084e2:	fab0 f080 	clz	r0, r0
  2084e6:	0940      	lsrs	r0, r0, #5
  2084e8:	f7f8 f96a 	bl	2007c0 <_test_assert>
  2084ec:	2800      	cmp	r0, #0
  2084ee:	d1d7      	bne.n	2084a0 <rt_test_003_004_execute+0x30>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
  2084f0:	69ab      	ldr	r3, [r5, #24]
  2084f2:	491b      	ldr	r1, [pc, #108]	; (208560 <rt_test_003_004_execute+0xf0>)
  2084f4:	6898      	ldr	r0, [r3, #8]
  2084f6:	1b80      	subs	r0, r0, r6
  2084f8:	fab0 f080 	clz	r0, r0
  2084fc:	0940      	lsrs	r0, r0, #5
  2084fe:	f7f8 f95f 	bl	2007c0 <_test_assert>
  208502:	2800      	cmp	r0, #0
  208504:	d1cc      	bne.n	2084a0 <rt_test_003_004_execute+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
  208506:	69ab      	ldr	r3, [r5, #24]
  208508:	4917      	ldr	r1, [pc, #92]	; (208568 <rt_test_003_004_execute+0xf8>)
  20850a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
  20850c:	1b80      	subs	r0, r0, r6
  20850e:	fab0 f080 	clz	r0, r0
  208512:	0940      	lsrs	r0, r0, #5
  208514:	f7f8 f954 	bl	2007c0 <_test_assert>
  208518:	2800      	cmp	r0, #0
  20851a:	d1c1      	bne.n	2084a0 <rt_test_003_004_execute+0x30>
  test_set_step(4);
  20851c:	2304      	movs	r3, #4
  20851e:	f8c8 3000 	str.w	r3, [r8]
  __ASM volatile ("cpsid i" : : : "memory");
  208522:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208524:	2320      	movs	r3, #32
  208526:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20852a:	b662      	cpsie	i
  _dbg_check_lock();
  20852c:	f7fb fc10 	bl	203d50 <_dbg_check_lock>
  return ch.rlist.current;
  208530:	69ab      	ldr	r3, [r5, #24]
    chThdGetSelfX()->prio = prio;
  208532:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
  208534:	63dc      	str	r4, [r3, #60]	; 0x3c
  _dbg_check_unlock();
  208536:	f7fb fbbb 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20853a:	682b      	ldr	r3, [r5, #0]
  20853c:	42ab      	cmp	r3, r5
  20853e:	d004      	beq.n	20854a <rt_test_003_004_execute+0xda>
  208540:	69aa      	ldr	r2, [r5, #24]
  208542:	689b      	ldr	r3, [r3, #8]
  208544:	6892      	ldr	r2, [r2, #8]
  208546:	429a      	cmp	r2, r3
  208548:	d303      	bcc.n	208552 <rt_test_003_004_execute+0xe2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20854a:	2300      	movs	r3, #0
  20854c:	f383 8811 	msr	BASEPRI, r3
  208550:	e7a6      	b.n	2084a0 <rt_test_003_004_execute+0x30>
  208552:	4806      	ldr	r0, [pc, #24]	; (20856c <rt_test_003_004_execute+0xfc>)
  208554:	f7f8 fb0c 	bl	200b70 <chSysHalt>
  208558:	20000dc8 	.word	0x20000dc8
  20855c:	0800d534 	.word	0x0800d534
  208560:	0800d558 	.word	0x0800d558
  208564:	0800d574 	.word	0x0800d574
  208568:	0800d59c 	.word	0x0800d59c
  20856c:	0800bca0 	.word	0x0800bca0
  208570:	20001f6c 	.word	0x20001f6c
	...

00208580 <rt_test_003_003_execute>:
static void rt_test_003_003_execute(void) {
  208580:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  208584:	4e1c      	ldr	r6, [pc, #112]	; (2085f8 <rt_test_003_003_execute+0x78>)
  test_set_step(1);
  208586:	2201      	movs	r2, #1
  208588:	4f1c      	ldr	r7, [pc, #112]	; (2085fc <rt_test_003_003_execute+0x7c>)
  return chThdGetSelfX()->prio;
  20858a:	69b3      	ldr	r3, [r6, #24]
  20858c:	603a      	str	r2, [r7, #0]
  20858e:	689c      	ldr	r4, [r3, #8]
    p1 = chThdSetPriority(prio + 1);
  208590:	18a5      	adds	r5, r4, r2
  208592:	4628      	mov	r0, r5
  208594:	f7ff ff34 	bl	208400 <chThdSetPriority>
  208598:	4680      	mov	r8, r0
    test_assert(p1 == prio, "unexpected returned priority level");
  20859a:	1b00      	subs	r0, r0, r4
  20859c:	4918      	ldr	r1, [pc, #96]	; (208600 <rt_test_003_003_execute+0x80>)
  20859e:	fab0 f080 	clz	r0, r0
  2085a2:	0940      	lsrs	r0, r0, #5
  2085a4:	f7f8 f90c 	bl	2007c0 <_test_assert>
  2085a8:	b108      	cbz	r0, 2085ae <rt_test_003_003_execute+0x2e>
}
  2085aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  2085ae:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
  2085b0:	4914      	ldr	r1, [pc, #80]	; (208604 <rt_test_003_003_execute+0x84>)
  2085b2:	6898      	ldr	r0, [r3, #8]
  2085b4:	1b40      	subs	r0, r0, r5
  2085b6:	fab0 f080 	clz	r0, r0
  2085ba:	0940      	lsrs	r0, r0, #5
  2085bc:	f7f8 f900 	bl	2007c0 <_test_assert>
  2085c0:	2800      	cmp	r0, #0
  2085c2:	d1f2      	bne.n	2085aa <rt_test_003_003_execute+0x2a>
  test_set_step(2);
  2085c4:	2302      	movs	r3, #2
    p1 = chThdSetPriority(p1);
  2085c6:	4640      	mov	r0, r8
  test_set_step(2);
  2085c8:	603b      	str	r3, [r7, #0]
    p1 = chThdSetPriority(p1);
  2085ca:	f7ff ff19 	bl	208400 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
  2085ce:	1a28      	subs	r0, r5, r0
  2085d0:	490b      	ldr	r1, [pc, #44]	; (208600 <rt_test_003_003_execute+0x80>)
  2085d2:	fab0 f080 	clz	r0, r0
  2085d6:	0940      	lsrs	r0, r0, #5
  2085d8:	f7f8 f8f2 	bl	2007c0 <_test_assert>
  2085dc:	2800      	cmp	r0, #0
  2085de:	d1e4      	bne.n	2085aa <rt_test_003_003_execute+0x2a>
  2085e0:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
  2085e2:	4908      	ldr	r1, [pc, #32]	; (208604 <rt_test_003_003_execute+0x84>)
  2085e4:	6898      	ldr	r0, [r3, #8]
  2085e6:	1b00      	subs	r0, r0, r4
  2085e8:	fab0 f080 	clz	r0, r0
}
  2085ec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
  2085f0:	0940      	lsrs	r0, r0, #5
  2085f2:	f7f8 b8e5 	b.w	2007c0 <_test_assert>
  2085f6:	bf00      	nop
  2085f8:	20000dc8 	.word	0x20000dc8
  2085fc:	20001f6c 	.word	0x20001f6c
  208600:	0800d534 	.word	0x0800d534
  208604:	0800d558 	.word	0x0800d558
	...

00208610 <chThdExit>:
void chThdExit(msg_t msg) {
  208610:	b508      	push	{r3, lr}
  208612:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  208614:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208616:	2320      	movs	r3, #32
  208618:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20861c:	b662      	cpsie	i
  _dbg_check_lock();
  20861e:	f7fb fb97 	bl	203d50 <_dbg_check_lock>
  chThdExitS(msg);
  208622:	4620      	mov	r0, r4
  208624:	f7fa ffec 	bl	203600 <chThdExitS>
	...

00208630 <bmk_thread3>:
static THD_FUNCTION(bmk_thread3, p) {
  208630:	b508      	push	{r3, lr}
  chThdExit((msg_t)p);
  208632:	f7ff ffed 	bl	208610 <chThdExit>
  208636:	bf00      	nop
	...

00208640 <chThdRelease>:
void chThdRelease(thread_t *tp) {
  208640:	b510      	push	{r4, lr}
  208642:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  208644:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208646:	2320      	movs	r3, #32
  208648:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20864c:	b662      	cpsie	i
  20864e:	f7fb fb7f 	bl	203d50 <_dbg_check_lock>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  208652:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
  208656:	2b00      	cmp	r3, #0
  208658:	d037      	beq.n	2086ca <chThdRelease+0x8a>
  tp->refs--;
  20865a:	3b01      	subs	r3, #1
  20865c:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
  208660:	6a23      	ldr	r3, [r4, #32]
  208662:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
  208666:	2b0f      	cmp	r3, #15
  208668:	d00e      	beq.n	208688 <chThdRelease+0x48>
  _dbg_check_unlock();
  20866a:	f7fb fb21 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20866e:	4b1c      	ldr	r3, [pc, #112]	; (2086e0 <chThdRelease+0xa0>)
  208670:	681a      	ldr	r2, [r3, #0]
  208672:	429a      	cmp	r2, r3
  208674:	d004      	beq.n	208680 <chThdRelease+0x40>
  208676:	6999      	ldr	r1, [r3, #24]
  208678:	6893      	ldr	r3, [r2, #8]
  20867a:	688a      	ldr	r2, [r1, #8]
  20867c:	429a      	cmp	r2, r3
  20867e:	d327      	bcc.n	2086d0 <chThdRelease+0x90>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208680:	2300      	movs	r3, #0
  208682:	f383 8811 	msr	BASEPRI, r3
}
  208686:	bd10      	pop	{r4, pc}
    REG_REMOVE(tp);
  208688:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
  20868c:	611a      	str	r2, [r3, #16]
  20868e:	6922      	ldr	r2, [r4, #16]
  208690:	6153      	str	r3, [r2, #20]
  _dbg_check_unlock();
  208692:	f7fb fb0d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208696:	4b12      	ldr	r3, [pc, #72]	; (2086e0 <chThdRelease+0xa0>)
  208698:	681a      	ldr	r2, [r3, #0]
  20869a:	429a      	cmp	r2, r3
  20869c:	d004      	beq.n	2086a8 <chThdRelease+0x68>
  20869e:	6999      	ldr	r1, [r3, #24]
  2086a0:	6893      	ldr	r3, [r2, #8]
  2086a2:	688a      	ldr	r2, [r1, #8]
  2086a4:	429a      	cmp	r2, r3
  2086a6:	d313      	bcc.n	2086d0 <chThdRelease+0x90>
  2086a8:	2300      	movs	r3, #0
  2086aa:	f383 8811 	msr	BASEPRI, r3
    switch (tp->flags & CH_FLAG_MODE_MASK) {
  2086ae:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
  2086b2:	f003 0303 	and.w	r3, r3, #3
  2086b6:	2b01      	cmp	r3, #1
  2086b8:	d00d      	beq.n	2086d6 <chThdRelease+0x96>
  2086ba:	2b02      	cmp	r3, #2
  2086bc:	d1e3      	bne.n	208686 <chThdRelease+0x46>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
  2086be:	69e1      	ldr	r1, [r4, #28]
  2086c0:	6c20      	ldr	r0, [r4, #64]	; 0x40
}
  2086c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
  2086c6:	f7fd b97b 	b.w	2059c0 <chPoolFree>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  2086ca:	4806      	ldr	r0, [pc, #24]	; (2086e4 <chThdRelease+0xa4>)
  2086cc:	f7f8 fa50 	bl	200b70 <chSysHalt>
  2086d0:	4805      	ldr	r0, [pc, #20]	; (2086e8 <chThdRelease+0xa8>)
  2086d2:	f7f8 fa4d 	bl	200b70 <chSysHalt>
      chHeapFree(chThdGetWorkingAreaX(tp));
  2086d6:	69e0      	ldr	r0, [r4, #28]
}
  2086d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      chHeapFree(chThdGetWorkingAreaX(tp));
  2086dc:	f7fe bb30 	b.w	206d40 <chHeapFree>
  2086e0:	20000dc8 	.word	0x20000dc8
  2086e4:	0800bf20 	.word	0x0800bf20
  2086e8:	0800bc04 	.word	0x0800bc04
  2086ec:	00000000 	.word	0x00000000

002086f0 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
  2086f0:	b570      	push	{r4, r5, r6, lr}
  2086f2:	4606      	mov	r6, r0
  __ASM volatile ("cpsid i" : : : "memory");
  2086f4:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2086f6:	2320      	movs	r3, #32
  2086f8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2086fc:	b662      	cpsie	i
  _dbg_check_lock();
  2086fe:	f7fb fb27 	bl	203d50 <_dbg_check_lock>
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  208702:	4d12      	ldr	r5, [pc, #72]	; (20874c <chRegNextThread+0x5c>)
  ntp = tp->newer;
  208704:	6934      	ldr	r4, [r6, #16]
  if (ntp == (thread_t *)&ch.rlist) {
  208706:	42ac      	cmp	r4, r5
  208708:	d01e      	beq.n	208748 <chRegNextThread+0x58>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
  20870a:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
  20870e:	2bff      	cmp	r3, #255	; 0xff
  208710:	d017      	beq.n	208742 <chRegNextThread+0x52>
    ntp->refs++;
  208712:	3301      	adds	r3, #1
  208714:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  _dbg_check_unlock();
  208718:	f7fb faca 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20871c:	682b      	ldr	r3, [r5, #0]
  20871e:	42ab      	cmp	r3, r5
  208720:	d004      	beq.n	20872c <chRegNextThread+0x3c>
  208722:	69aa      	ldr	r2, [r5, #24]
  208724:	689b      	ldr	r3, [r3, #8]
  208726:	6892      	ldr	r2, [r2, #8]
  208728:	429a      	cmp	r2, r3
  20872a:	d307      	bcc.n	20873c <chRegNextThread+0x4c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20872c:	2300      	movs	r3, #0
  20872e:	f383 8811 	msr	BASEPRI, r3
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
  208732:	4630      	mov	r0, r6
  208734:	f7ff ff84 	bl	208640 <chThdRelease>
#endif

  return ntp;
}
  208738:	4620      	mov	r0, r4
  20873a:	bd70      	pop	{r4, r5, r6, pc}
  20873c:	4804      	ldr	r0, [pc, #16]	; (208750 <chRegNextThread+0x60>)
  20873e:	f7f8 fa17 	bl	200b70 <chSysHalt>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
  208742:	4804      	ldr	r0, [pc, #16]	; (208754 <chRegNextThread+0x64>)
  208744:	f7f8 fa14 	bl	200b70 <chSysHalt>
    ntp = NULL;
  208748:	2400      	movs	r4, #0
  20874a:	e7e5      	b.n	208718 <chRegNextThread+0x28>
  20874c:	20000dc8 	.word	0x20000dc8
  208750:	0800bd2c 	.word	0x0800bd2c
  208754:	0800bfa4 	.word	0x0800bfa4
	...

00208760 <cmd_threads>:
  if (argc > 0) {
  208760:	2900      	cmp	r1, #0
  208762:	dd03      	ble.n	20876c <cmd_threads+0xc>
    shellUsage(chp, "threads");
  208764:	4a19      	ldr	r2, [pc, #100]	; (2087cc <cmd_threads+0x6c>)
  208766:	491a      	ldr	r1, [pc, #104]	; (2087d0 <cmd_threads+0x70>)
  208768:	f7fa bb92 	b.w	202e90 <chprintf>
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  20876c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
  208770:	4918      	ldr	r1, [pc, #96]	; (2087d4 <cmd_threads+0x74>)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  208772:	b087      	sub	sp, #28
  208774:	4680      	mov	r8, r0
  208776:	f8df b060 	ldr.w	fp, [pc, #96]	; 2087d8 <cmd_threads+0x78>
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
  20877a:	f7fa fb89 	bl	202e90 <chprintf>
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  20877e:	f8df a05c 	ldr.w	sl, [pc, #92]	; 2087dc <cmd_threads+0x7c>
  tp = chRegFirstThread();
  208782:	f7ff f90d 	bl	2079a0 <chRegFirstThread>
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  208786:	f8df 9058 	ldr.w	r9, [pc, #88]	; 2087e0 <cmd_threads+0x80>
  tp = chRegFirstThread();
  20878a:	4604      	mov	r4, r0
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
  20878c:	f894 3020 	ldrb.w	r3, [r4, #32]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  208790:	4649      	mov	r1, r9
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
  208792:	f894 6022 	ldrb.w	r6, [r4, #34]	; 0x22
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  208796:	4640      	mov	r0, r8
             tp->name == NULL ? "" : tp->name);
  208798:	69a5      	ldr	r5, [r4, #24]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  20879a:	f85b c023 	ldr.w	ip, [fp, r3, lsl #2]
  20879e:	3e01      	subs	r6, #1
  2087a0:	2d00      	cmp	r5, #0
  2087a2:	bf08      	it	eq
  2087a4:	4655      	moveq	r5, sl
    uint32_t stklimit = (uint32_t)tp->wabase;
  2087a6:	69e2      	ldr	r2, [r4, #28]
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
  2087a8:	e9d4 7302 	ldrd	r7, r3, [r4, #8]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  2087ac:	9400      	str	r4, [sp, #0]
  2087ae:	9601      	str	r6, [sp, #4]
  2087b0:	9504      	str	r5, [sp, #16]
  2087b2:	e9cd 7c02 	strd	r7, ip, [sp, #8]
  2087b6:	f7fa fb6b 	bl	202e90 <chprintf>
    tp = chRegNextThread(tp);
  2087ba:	4620      	mov	r0, r4
  2087bc:	f7ff ff98 	bl	2086f0 <chRegNextThread>
  } while (tp != NULL);
  2087c0:	4604      	mov	r4, r0
  2087c2:	2800      	cmp	r0, #0
  2087c4:	d1e2      	bne.n	20878c <cmd_threads+0x2c>
}
  2087c6:	b007      	add	sp, #28
  2087c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  2087cc:	0800e3a8 	.word	0x0800e3a8
  2087d0:	0800c270 	.word	0x0800c270
  2087d4:	0800c458 	.word	0x0800c458
  2087d8:	0800dd98 	.word	0x0800dd98
  2087dc:	0800dd4c 	.word	0x0800dd4c
  2087e0:	0800c498 	.word	0x0800c498
	...

002087f0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
  2087f0:	b510      	push	{r4, lr}
  2087f2:	4604      	mov	r4, r0
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  2087f4:	f7ff f8d4 	bl	2079a0 <chRegFirstThread>
  2087f8:	4603      	mov	r3, r0
  2087fa:	e003      	b.n	208804 <chRegFindThreadByWorkingArea+0x14>
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  2087fc:	f7ff ff78 	bl	2086f0 <chRegNextThread>
  } while (ctp != NULL);
  208800:	4603      	mov	r3, r0
  208802:	b118      	cbz	r0, 20880c <chRegFindThreadByWorkingArea+0x1c>
    if (chThdGetWorkingAreaX(ctp) == wa) {
  208804:	69da      	ldr	r2, [r3, #28]
    ctp = chRegNextThread(ctp);
  208806:	4618      	mov	r0, r3
    if (chThdGetWorkingAreaX(ctp) == wa) {
  208808:	4294      	cmp	r4, r2
  20880a:	d1f7      	bne.n	2087fc <chRegFindThreadByWorkingArea+0xc>

  return NULL;
}
  20880c:	4618      	mov	r0, r3
  20880e:	bd10      	pop	{r4, pc}

00208810 <chThdCreateStatic.constprop.61>:
thread_t *chThdCreateStatic(void *wsp, size_t size,
  208810:	b5f0      	push	{r4, r5, r6, r7, lr}
  208812:	b085      	sub	sp, #20
  chDbgCheck((wsp != NULL) &&
  208814:	b110      	cbz	r0, 20881c <chThdCreateStatic.constprop.61+0xc>
  208816:	0745      	lsls	r5, r0, #29
  208818:	4604      	mov	r4, r0
  20881a:	d002      	beq.n	208822 <chThdCreateStatic.constprop.61+0x12>
  20881c:	4837      	ldr	r0, [pc, #220]	; (2088fc <chThdCreateStatic.constprop.61+0xec>)
  20881e:	f7f8 f9a7 	bl	200b70 <chSysHalt>
  208822:	29ff      	cmp	r1, #255	; 0xff
  208824:	d8fa      	bhi.n	20881c <chThdCreateStatic.constprop.61+0xc>
  208826:	9101      	str	r1, [sp, #4]
  208828:	e9cd 2302 	strd	r2, r3, [sp, #8]
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
  20882c:	f7ff ffe0 	bl	2087f0 <chRegFindThreadByWorkingArea>
  208830:	2800      	cmp	r0, #0
  208832:	d1f3      	bne.n	20881c <chThdCreateStatic.constprop.61+0xc>
  _thread_memfill((uint8_t *)wsp,
  208834:	f504 76a4 	add.w	r6, r4, #328	; 0x148
  208838:	4620      	mov	r0, r4
    *startp++ = v;
  20883a:	2555      	movs	r5, #85	; 0x55
  20883c:	9901      	ldr	r1, [sp, #4]
  20883e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  208842:	f800 5b01 	strb.w	r5, [r0], #1
  while (startp < endp) {
  208846:	4286      	cmp	r6, r0
  208848:	d1fb      	bne.n	208842 <chThdCreateStatic.constprop.61+0x32>
  20884a:	9101      	str	r1, [sp, #4]
  20884c:	e9cd 2302 	strd	r2, r3, [sp, #8]
  __ASM volatile ("cpsid i" : : : "memory");
  208850:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208852:	2020      	movs	r0, #32
  208854:	f380 8811 	msr	BASEPRI, r0
  __ASM volatile ("cpsie i" : : : "memory");
  208858:	b662      	cpsie	i
  _dbg_check_lock();
  20885a:	f7fb fa79 	bl	203d50 <_dbg_check_lock>
  tp->prio      = prio;
  20885e:	9901      	ldr	r1, [sp, #4]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  208860:	9b03      	ldr	r3, [sp, #12]
  tp->flags     = CH_FLAG_MODE_STATIC;
  208862:	2001      	movs	r0, #1
  REG_INSERT(tp);
  208864:	4d26      	ldr	r5, [pc, #152]	; (208900 <chThdCreateStatic.constprop.61+0xf0>)
  tp = (thread_t *)((uint8_t *)wsp + size -
  208866:	f504 7680 	add.w	r6, r4, #256	; 0x100
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  20886a:	9a02      	ldr	r2, [sp, #8]
  20886c:	f104 0edc 	add.w	lr, r4, #220	; 0xdc
  208870:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
  tp->mtxlist   = NULL;
  208874:	2300      	movs	r3, #0
  tp->prio      = prio;
  208876:	f8c4 1108 	str.w	r1, [r4, #264]	; 0x108
  tp->state     = CH_STATE_WTSTART;
  20887a:	f04f 0c02 	mov.w	ip, #2
  tp->realprio  = prio;
  20887e:	f8c4 113c 	str.w	r1, [r4, #316]	; 0x13c
  list_init(&tp->waiting);
  208882:	f504 7794 	add.w	r7, r4, #296	; 0x128
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  208886:	491f      	ldr	r1, [pc, #124]	; (208904 <chThdCreateStatic.constprop.61+0xf4>)
  208888:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
  queue_init(&tp->msgqueue);
  20888c:	f504 7296 	add.w	r2, r4, #300	; 0x12c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  208890:	f8c4 10fc 	str.w	r1, [r4, #252]	; 0xfc
  chSchWakeupS(tp, MSG_OK);
  208894:	4619      	mov	r1, r3
  tp->flags     = CH_FLAG_MODE_STATIC;
  208896:	f884 0122 	strb.w	r0, [r4, #290]	; 0x122
  tp->mtxlist   = NULL;
  20889a:	f8c4 3138 	str.w	r3, [r4, #312]	; 0x138
  tp->epending  = (eventmask_t)0;
  20889e:	f8c4 3134 	str.w	r3, [r4, #308]	; 0x134
  tp->name      = name;
  2088a2:	4819      	ldr	r0, [pc, #100]	; (208908 <chThdCreateStatic.constprop.61+0xf8>)
  REG_INSERT(tp);
  2088a4:	696b      	ldr	r3, [r5, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  2088a6:	f8c4 e10c 	str.w	lr, [r4, #268]	; 0x10c
  REG_INSERT(tp);
  2088aa:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
  tp->state     = CH_STATE_WTSTART;
  2088ae:	f8a4 c120 	strh.w	ip, [r4, #288]	; 0x120
  tp->name      = name;
  2088b2:	f8c4 0118 	str.w	r0, [r4, #280]	; 0x118
  chSchWakeupS(tp, MSG_OK);
  2088b6:	4630      	mov	r0, r6
  tp->wabase = (stkalign_t *)wsp;
  2088b8:	f8c4 411c 	str.w	r4, [r4, #284]	; 0x11c
  REG_INSERT(tp);
  2088bc:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  2088c0:	611e      	str	r6, [r3, #16]
  tqp->next = (thread_t *)tqp;
  2088c2:	f8c4 212c 	str.w	r2, [r4, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
  2088c6:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
  tlp->next = (thread_t *)tlp;
  2088ca:	f8c4 7128 	str.w	r7, [r4, #296]	; 0x128
  2088ce:	616e      	str	r6, [r5, #20]
  chSchWakeupS(tp, MSG_OK);
  2088d0:	f7fa fdae 	bl	203430 <chSchWakeupS>
  _dbg_check_unlock();
  2088d4:	f7fb f9ec 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2088d8:	682b      	ldr	r3, [r5, #0]
  2088da:	42ab      	cmp	r3, r5
  2088dc:	d004      	beq.n	2088e8 <chThdCreateStatic.constprop.61+0xd8>
  2088de:	69aa      	ldr	r2, [r5, #24]
  2088e0:	689b      	ldr	r3, [r3, #8]
  2088e2:	6892      	ldr	r2, [r2, #8]
  2088e4:	429a      	cmp	r2, r3
  2088e6:	d305      	bcc.n	2088f4 <chThdCreateStatic.constprop.61+0xe4>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2088e8:	2300      	movs	r3, #0
  2088ea:	f383 8811 	msr	BASEPRI, r3
}
  2088ee:	4630      	mov	r0, r6
  2088f0:	b005      	add	sp, #20
  2088f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  2088f4:	4805      	ldr	r0, [pc, #20]	; (20890c <chThdCreateStatic.constprop.61+0xfc>)
  2088f6:	f7f8 f93b 	bl	200b70 <chSysHalt>
  2088fa:	bf00      	nop
  2088fc:	0800be8c 	.word	0x0800be8c
  208900:	20000dc8 	.word	0x20000dc8
  208904:	002002f1 	.word	0x002002f1
  208908:	0800c238 	.word	0x0800c238
  20890c:	0800bc04 	.word	0x0800bc04

00208910 <rt_test_010_006_execute>:
static void rt_test_010_006_execute(void) {
  208910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
  208914:	4b17      	ldr	r3, [pc, #92]	; (208974 <rt_test_010_006_execute+0x64>)
  test_set_step(1);
  208916:	2201      	movs	r2, #1
  208918:	f8df 9068 	ldr.w	r9, [pc, #104]	; 208984 <rt_test_010_006_execute+0x74>
    n = 0;
  20891c:	2400      	movs	r4, #0
  return chThdGetSelfX()->prio;
  20891e:	699b      	ldr	r3, [r3, #24]
  test_set_step(1);
  208920:	f8c9 2000 	str.w	r2, [r9]
  tprio_t prio = chThdGetPriorityX() + 1;
  208924:	689d      	ldr	r5, [r3, #8]
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  208926:	f8df 8060 	ldr.w	r8, [pc, #96]	; 208988 <rt_test_010_006_execute+0x78>
  tprio_t prio = chThdGetPriorityX() + 1;
  20892a:	4415      	add	r5, r2
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  20892c:	4f12      	ldr	r7, [pc, #72]	; (208978 <rt_test_010_006_execute+0x68>)
    start = test_wait_tick();
  20892e:	f7ff fa6f 	bl	207e10 <test_wait_tick>
  208932:	4606      	mov	r6, r0
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  208934:	2300      	movs	r3, #0
  208936:	4642      	mov	r2, r8
  208938:	4629      	mov	r1, r5
  20893a:	4638      	mov	r0, r7
  20893c:	f7ff ff68 	bl	208810 <chThdCreateStatic.constprop.61>
      n++;
  208940:	3401      	adds	r4, #1
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  208942:	f7ff fe7d 	bl	208640 <chThdRelease>
  208946:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
  20894a:	f242 720f 	movw	r2, #9999	; 0x270f
  20894e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  208950:	1b9b      	subs	r3, r3, r6
  208952:	4293      	cmp	r3, r2
  208954:	d9ee      	bls.n	208934 <rt_test_010_006_execute+0x24>
  test_set_step(2);
  208956:	2302      	movs	r3, #2
    test_print("--- Score : ");
  208958:	4808      	ldr	r0, [pc, #32]	; (20897c <rt_test_010_006_execute+0x6c>)
  test_set_step(2);
  20895a:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
  20895e:	f7f7 ffb7 	bl	2008d0 <test_print>
    test_printn(n);
  208962:	4620      	mov	r0, r4
  208964:	f7f7 ff84 	bl	200870 <test_printn>
    test_println(" threads/S");
  208968:	4805      	ldr	r0, [pc, #20]	; (208980 <rt_test_010_006_execute+0x70>)
}
  20896a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" threads/S");
  20896e:	f7f7 bf8f 	b.w	200890 <test_println>
  208972:	bf00      	nop
  208974:	20000dc8 	.word	0x20000dc8
  208978:	20001858 	.word	0x20001858
  20897c:	0800daac 	.word	0x0800daac
  208980:	0800da14 	.word	0x0800da14
  208984:	20001f6c 	.word	0x20001f6c
  208988:	00208631 	.word	0x00208631
  20898c:	00000000 	.word	0x00000000

00208990 <rt_test_006_004_execute>:
static void rt_test_006_004_execute(void) {
  208990:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
  208994:	4d40      	ldr	r5, [pc, #256]	; (208a98 <rt_test_006_004_execute+0x108>)
  test_set_step(2);
  208996:	f04f 0c02 	mov.w	ip, #2
  20899a:	4e40      	ldr	r6, [pc, #256]	; (208a9c <rt_test_006_004_execute+0x10c>)
  return chThdGetSelfX()->prio;
  20899c:	69ab      	ldr	r3, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
  20899e:	4f40      	ldr	r7, [pc, #256]	; (208aa0 <rt_test_006_004_execute+0x110>)
  2089a0:	689c      	ldr	r4, [r3, #8]
  2089a2:	4a40      	ldr	r2, [pc, #256]	; (208aa4 <rt_test_006_004_execute+0x114>)
    pa = p + 1;
  2089a4:	f104 0801 	add.w	r8, r4, #1
    pb = p + 2;
  2089a8:	eb04 090c 	add.w	r9, r4, ip
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
  2089ac:	4b3e      	ldr	r3, [pc, #248]	; (208aa8 <rt_test_006_004_execute+0x118>)
  2089ae:	4641      	mov	r1, r8
  2089b0:	483e      	ldr	r0, [pc, #248]	; (208aac <rt_test_006_004_execute+0x11c>)
  test_set_step(2);
  2089b2:	f8c6 c000 	str.w	ip, [r6]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
  2089b6:	f7ff ff2b 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
  2089ba:	4649      	mov	r1, r9
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
  2089bc:	6038      	str	r0, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
  2089be:	4b3c      	ldr	r3, [pc, #240]	; (208ab0 <rt_test_006_004_execute+0x120>)
  2089c0:	4a3c      	ldr	r2, [pc, #240]	; (208ab4 <rt_test_006_004_execute+0x124>)
  2089c2:	483d      	ldr	r0, [pc, #244]	; (208ab8 <rt_test_006_004_execute+0x128>)
  2089c4:	f7ff ff24 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(3);
  2089c8:	2303      	movs	r3, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
  2089ca:	6078      	str	r0, [r7, #4]
    chMtxLock(&m1);
  2089cc:	483b      	ldr	r0, [pc, #236]	; (208abc <rt_test_006_004_execute+0x12c>)
  test_set_step(3);
  2089ce:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
  2089d0:	f7fd fc76 	bl	2062c0 <chMtxLock>
  2089d4:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
  2089d6:	493a      	ldr	r1, [pc, #232]	; (208ac0 <rt_test_006_004_execute+0x130>)
  2089d8:	6898      	ldr	r0, [r3, #8]
  2089da:	1b00      	subs	r0, r0, r4
  2089dc:	fab0 f080 	clz	r0, r0
  2089e0:	0940      	lsrs	r0, r0, #5
  2089e2:	f7f7 feed 	bl	2007c0 <_test_assert>
  2089e6:	b108      	cbz	r0, 2089ec <rt_test_006_004_execute+0x5c>
}
  2089e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  test_set_step(4);
  2089ec:	2304      	movs	r3, #4
    chThdSleepMilliseconds(100);
  2089ee:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(4);
  2089f2:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
  2089f4:	f7ff f85c 	bl	207ab0 <chThdSleep>
  2089f8:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  2089fa:	4931      	ldr	r1, [pc, #196]	; (208ac0 <rt_test_006_004_execute+0x130>)
  2089fc:	6898      	ldr	r0, [r3, #8]
  2089fe:	eba0 0008 	sub.w	r0, r0, r8
  208a02:	fab0 f080 	clz	r0, r0
  208a06:	0940      	lsrs	r0, r0, #5
  208a08:	f7f7 feda 	bl	2007c0 <_test_assert>
  208a0c:	2800      	cmp	r0, #0
  208a0e:	d1eb      	bne.n	2089e8 <rt_test_006_004_execute+0x58>
  test_set_step(5);
  208a10:	2305      	movs	r3, #5
    chMtxLock(&m2);
  208a12:	482c      	ldr	r0, [pc, #176]	; (208ac4 <rt_test_006_004_execute+0x134>)
  test_set_step(5);
  208a14:	6033      	str	r3, [r6, #0]
    chMtxLock(&m2);
  208a16:	f7fd fc53 	bl	2062c0 <chMtxLock>
  208a1a:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  208a1c:	4928      	ldr	r1, [pc, #160]	; (208ac0 <rt_test_006_004_execute+0x130>)
  208a1e:	6898      	ldr	r0, [r3, #8]
  208a20:	eba0 0008 	sub.w	r0, r0, r8
  208a24:	fab0 f080 	clz	r0, r0
  208a28:	0940      	lsrs	r0, r0, #5
  208a2a:	f7f7 fec9 	bl	2007c0 <_test_assert>
  208a2e:	2800      	cmp	r0, #0
  208a30:	d1da      	bne.n	2089e8 <rt_test_006_004_execute+0x58>
  test_set_step(6);
  208a32:	2306      	movs	r3, #6
    chThdSleepMilliseconds(100);
  208a34:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(6);
  208a38:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
  208a3a:	f7ff f839 	bl	207ab0 <chThdSleep>
  208a3e:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
  208a40:	491f      	ldr	r1, [pc, #124]	; (208ac0 <rt_test_006_004_execute+0x130>)
  208a42:	6898      	ldr	r0, [r3, #8]
  208a44:	eba0 0009 	sub.w	r0, r0, r9
  208a48:	fab0 f080 	clz	r0, r0
  208a4c:	0940      	lsrs	r0, r0, #5
  208a4e:	f7f7 feb7 	bl	2007c0 <_test_assert>
  208a52:	2800      	cmp	r0, #0
  208a54:	d1c8      	bne.n	2089e8 <rt_test_006_004_execute+0x58>
  test_set_step(7);
  208a56:	2307      	movs	r3, #7
    chMtxUnlock(&m2);
  208a58:	481a      	ldr	r0, [pc, #104]	; (208ac4 <rt_test_006_004_execute+0x134>)
  test_set_step(7);
  208a5a:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m2);
  208a5c:	f7fd fb00 	bl	206060 <chMtxUnlock>
  208a60:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  208a62:	4917      	ldr	r1, [pc, #92]	; (208ac0 <rt_test_006_004_execute+0x130>)
  208a64:	6898      	ldr	r0, [r3, #8]
  208a66:	eba0 0008 	sub.w	r0, r0, r8
  208a6a:	fab0 f080 	clz	r0, r0
  208a6e:	0940      	lsrs	r0, r0, #5
  208a70:	f7f7 fea6 	bl	2007c0 <_test_assert>
  208a74:	2800      	cmp	r0, #0
  208a76:	d1b7      	bne.n	2089e8 <rt_test_006_004_execute+0x58>
  test_set_step(8);
  208a78:	2308      	movs	r3, #8
    chMtxUnlock(&m1);
  208a7a:	4810      	ldr	r0, [pc, #64]	; (208abc <rt_test_006_004_execute+0x12c>)
  test_set_step(8);
  208a7c:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
  208a7e:	f7fd faef 	bl	206060 <chMtxUnlock>
  208a82:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
  208a84:	490e      	ldr	r1, [pc, #56]	; (208ac0 <rt_test_006_004_execute+0x130>)
  208a86:	6898      	ldr	r0, [r3, #8]
  208a88:	1b00      	subs	r0, r0, r4
  208a8a:	fab0 f080 	clz	r0, r0
}
  208a8e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
  208a92:	0940      	lsrs	r0, r0, #5
  208a94:	f7f7 be94 	b.w	2007c0 <_test_assert>
  208a98:	20000dc8 	.word	0x20000dc8
  208a9c:	20001f6c 	.word	0x20001f6c
  208aa0:	20001f84 	.word	0x20001f84
  208aa4:	00207c41 	.word	0x00207c41
  208aa8:	0800d6e8 	.word	0x0800d6e8
  208aac:	20001858 	.word	0x20001858
  208ab0:	0800d6ec 	.word	0x0800d6ec
  208ab4:	00207c61 	.word	0x00207c61
  208ab8:	200019a0 	.word	0x200019a0
  208abc:	20010438 	.word	0x20010438
  208ac0:	0800d738 	.word	0x0800d738
  208ac4:	20010448 	.word	0x20010448
	...

00208ad0 <rt_test_005_006_execute>:

static void rt_test_005_006_teardown(void) {
  test_wait_threads();
}

static void rt_test_005_006_execute(void) {
  208ad0:	b570      	push	{r4, r5, r6, lr}
  208ad2:	b084      	sub	sp, #16
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
  208ad4:	2301      	movs	r3, #1
  208ad6:	4daf      	ldr	r5, [pc, #700]	; (208d94 <rt_test_005_006_execute+0x2c4>)
  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
  208ad8:	2100      	movs	r1, #0
  208ada:	a801      	add	r0, sp, #4
  208adc:	602b      	str	r3, [r5, #0]
  208ade:	f7f8 f8ef 	bl	200cc0 <chSemObjectInit>
  __ASM volatile ("cpsid i" : : : "memory");
  208ae2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208ae4:	2320      	movs	r3, #32
  208ae6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208aea:	b662      	cpsie	i
  _dbg_check_lock();
  208aec:	f7fb f930 	bl	203d50 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {

  chDbgCheckClassI();
  208af0:	f7f8 f94e 	bl	200d90 <chDbgCheckClassI>

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
  208af4:	9803      	ldr	r0, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  208af6:	49a8      	ldr	r1, [pc, #672]	; (208d98 <rt_test_005_006_execute+0x2c8>)
  208af8:	2800      	cmp	r0, #0
  208afa:	bfcc      	ite	gt
  208afc:	2000      	movgt	r0, #0
  208afe:	2001      	movle	r0, #1
  208b00:	f7f7 fe5e 	bl	2007c0 <_test_assert>
  208b04:	b180      	cbz	r0, 208b28 <rt_test_005_006_execute+0x58>
  _dbg_check_unlock();
  208b06:	f7fb f8d3 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208b0a:	4ba4      	ldr	r3, [pc, #656]	; (208d9c <rt_test_005_006_execute+0x2cc>)
  208b0c:	681a      	ldr	r2, [r3, #0]
  208b0e:	429a      	cmp	r2, r3
  208b10:	d005      	beq.n	208b1e <rt_test_005_006_execute+0x4e>
  208b12:	6999      	ldr	r1, [r3, #24]
  208b14:	6893      	ldr	r3, [r2, #8]
  208b16:	688a      	ldr	r2, [r1, #8]
  208b18:	429a      	cmp	r2, r3
  208b1a:	f0c0 8130 	bcc.w	208d7e <rt_test_005_006_execute+0x2ae>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208b1e:	2300      	movs	r3, #0
  208b20:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
  208b24:	b004      	add	sp, #16
  208b26:	bd70      	pop	{r4, r5, r6, pc}
  208b28:	4c9c      	ldr	r4, [pc, #624]	; (208d9c <rt_test_005_006_execute+0x2cc>)
  _dbg_check_unlock();
  208b2a:	f7fb f8c1 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208b2e:	6823      	ldr	r3, [r4, #0]
  208b30:	42a3      	cmp	r3, r4
  208b32:	d005      	beq.n	208b40 <rt_test_005_006_execute+0x70>
  208b34:	69a2      	ldr	r2, [r4, #24]
  208b36:	689b      	ldr	r3, [r3, #8]
  208b38:	6892      	ldr	r2, [r2, #8]
  208b3a:	429a      	cmp	r2, r3
  208b3c:	f0c0 811f 	bcc.w	208d7e <rt_test_005_006_execute+0x2ae>
  208b40:	2100      	movs	r1, #0
  208b42:	f381 8811 	msr	BASEPRI, r1
  test_set_step(2);
  208b46:	2302      	movs	r3, #2
  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
  208b48:	a801      	add	r0, sp, #4
  208b4a:	602b      	str	r3, [r5, #0]
  208b4c:	f7fe fe40 	bl	2077d0 <chSemReset>
  __ASM volatile ("cpsid i" : : : "memory");
  208b50:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208b52:	2320      	movs	r3, #32
  208b54:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208b58:	b662      	cpsie	i
  _dbg_check_lock();
  208b5a:	f7fb f8f9 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  208b5e:	f7f8 f917 	bl	200d90 <chDbgCheckClassI>
  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
  208b62:	9803      	ldr	r0, [sp, #12]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  208b64:	498c      	ldr	r1, [pc, #560]	; (208d98 <rt_test_005_006_execute+0x2c8>)
  208b66:	2800      	cmp	r0, #0
  208b68:	bfcc      	ite	gt
  208b6a:	2000      	movgt	r0, #0
  208b6c:	2001      	movle	r0, #1
  208b6e:	f7f7 fe27 	bl	2007c0 <_test_assert>
  208b72:	2800      	cmp	r0, #0
  208b74:	f040 80f7 	bne.w	208d66 <rt_test_005_006_execute+0x296>
  _dbg_check_unlock();
  208b78:	f7fb f89a 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208b7c:	6823      	ldr	r3, [r4, #0]
  208b7e:	42a3      	cmp	r3, r4
  208b80:	d005      	beq.n	208b8e <rt_test_005_006_execute+0xbe>
  208b82:	69a2      	ldr	r2, [r4, #24]
  208b84:	689b      	ldr	r3, [r3, #8]
  208b86:	6892      	ldr	r2, [r2, #8]
  208b88:	429a      	cmp	r2, r3
  208b8a:	f0c0 80f8 	bcc.w	208d7e <rt_test_005_006_execute+0x2ae>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208b8e:	2300      	movs	r3, #0
  208b90:	f383 8811 	msr	BASEPRI, r3
  208b94:	69a1      	ldr	r1, [r4, #24]
  test_set_step(3);
  208b96:	2603      	movs	r6, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
  208b98:	ab01      	add	r3, sp, #4
  208b9a:	4a81      	ldr	r2, [pc, #516]	; (208da0 <rt_test_005_006_execute+0x2d0>)
  208b9c:	6889      	ldr	r1, [r1, #8]
  208b9e:	4881      	ldr	r0, [pc, #516]	; (208da4 <rt_test_005_006_execute+0x2d4>)
  208ba0:	3901      	subs	r1, #1
  test_set_step(3);
  208ba2:	602e      	str	r6, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
  208ba4:	f7ff fe34 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(4);
  208ba8:	2304      	movs	r3, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
  208baa:	4a7f      	ldr	r2, [pc, #508]	; (208da8 <rt_test_005_006_execute+0x2d8>)
  test_set_step(4);
  208bac:	602b      	str	r3, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
  208bae:	6010      	str	r0, [r2, #0]
  return chSemWait(&bsp->sem);
  208bb0:	eb0d 0003 	add.w	r0, sp, r3
  208bb4:	f7fe fd8c 	bl	2076d0 <chSemWait>
  208bb8:	4606      	mov	r6, r0
  __ASM volatile ("cpsid i" : : : "memory");
  208bba:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208bbc:	2320      	movs	r3, #32
  208bbe:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208bc2:	b662      	cpsie	i
  _dbg_check_lock();
  208bc4:	f7fb f8c4 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  208bc8:	f7f8 f8e2 	bl	200d90 <chDbgCheckClassI>
  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
  208bcc:	9803      	ldr	r0, [sp, #12]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  208bce:	4972      	ldr	r1, [pc, #456]	; (208d98 <rt_test_005_006_execute+0x2c8>)
  208bd0:	2800      	cmp	r0, #0
  208bd2:	bfcc      	ite	gt
  208bd4:	2000      	movgt	r0, #0
  208bd6:	2001      	movle	r0, #1
  208bd8:	f7f7 fdf2 	bl	2007c0 <_test_assert>
  208bdc:	2800      	cmp	r0, #0
  208bde:	f040 80c2 	bne.w	208d66 <rt_test_005_006_execute+0x296>
  _dbg_check_unlock();
  208be2:	f7fb f865 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208be6:	6823      	ldr	r3, [r4, #0]
  208be8:	42a3      	cmp	r3, r4
  208bea:	d005      	beq.n	208bf8 <rt_test_005_006_execute+0x128>
  208bec:	69a2      	ldr	r2, [r4, #24]
  208bee:	689b      	ldr	r3, [r3, #8]
  208bf0:	6892      	ldr	r2, [r2, #8]
  208bf2:	429a      	cmp	r2, r3
  208bf4:	f0c0 80c3 	bcc.w	208d7e <rt_test_005_006_execute+0x2ae>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208bf8:	2300      	movs	r3, #0
  208bfa:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg == MSG_OK, "unexpected message");
  208bfe:	fab6 f086 	clz	r0, r6
  208c02:	496a      	ldr	r1, [pc, #424]	; (208dac <rt_test_005_006_execute+0x2dc>)
  208c04:	0940      	lsrs	r0, r0, #5
  208c06:	f7f7 fddb 	bl	2007c0 <_test_assert>
  208c0a:	2800      	cmp	r0, #0
  208c0c:	d18a      	bne.n	208b24 <rt_test_005_006_execute+0x54>
  test_set_step(5);
  208c0e:	2305      	movs	r3, #5
  208c10:	602b      	str	r3, [r5, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  208c12:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208c14:	2320      	movs	r3, #32
  208c16:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208c1a:	b662      	cpsie	i
  _dbg_check_lock();
  208c1c:	f7fb f898 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  208c20:	f7f8 f8b6 	bl	200d90 <chDbgCheckClassI>
  if (bsp->sem.cnt < (cnt_t)1) {
  208c24:	9b03      	ldr	r3, [sp, #12]
  208c26:	2b00      	cmp	r3, #0
  208c28:	f340 80ac 	ble.w	208d84 <rt_test_005_006_execute+0x2b4>
  chSchRescheduleS();
  208c2c:	f7fb f828 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  208c30:	f7fb f83e 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208c34:	6823      	ldr	r3, [r4, #0]
  208c36:	42a3      	cmp	r3, r4
  208c38:	d005      	beq.n	208c46 <rt_test_005_006_execute+0x176>
  208c3a:	69a2      	ldr	r2, [r4, #24]
  208c3c:	689b      	ldr	r3, [r3, #8]
  208c3e:	6892      	ldr	r2, [r2, #8]
  208c40:	429a      	cmp	r2, r3
  208c42:	f0c0 809c 	bcc.w	208d7e <rt_test_005_006_execute+0x2ae>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208c46:	2300      	movs	r3, #0
  208c48:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  208c4c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208c4e:	2320      	movs	r3, #32
  208c50:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208c54:	b662      	cpsie	i
  _dbg_check_lock();
  208c56:	f7fb f87b 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  208c5a:	f7f8 f899 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
  208c5e:	9803      	ldr	r0, [sp, #12]
  208c60:	4953      	ldr	r1, [pc, #332]	; (208db0 <rt_test_005_006_execute+0x2e0>)
  208c62:	2800      	cmp	r0, #0
  208c64:	bfd4      	ite	le
  208c66:	2000      	movle	r0, #0
  208c68:	2001      	movgt	r0, #1
  208c6a:	f7f7 fda9 	bl	2007c0 <_test_assert>
  208c6e:	2800      	cmp	r0, #0
  208c70:	d179      	bne.n	208d66 <rt_test_005_006_execute+0x296>
  _dbg_check_unlock();
  208c72:	f7fb f81d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208c76:	6823      	ldr	r3, [r4, #0]
  208c78:	42a3      	cmp	r3, r4
  208c7a:	d004      	beq.n	208c86 <rt_test_005_006_execute+0x1b6>
  208c7c:	69a2      	ldr	r2, [r4, #24]
  208c7e:	689b      	ldr	r3, [r3, #8]
  208c80:	6892      	ldr	r2, [r2, #8]
  208c82:	429a      	cmp	r2, r3
  208c84:	d37b      	bcc.n	208d7e <rt_test_005_006_execute+0x2ae>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208c86:	2300      	movs	r3, #0
  208c88:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  208c8c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208c8e:	2320      	movs	r3, #32
  208c90:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208c94:	b662      	cpsie	i
  _dbg_check_lock();
  208c96:	f7fb f85b 	bl	203d50 <_dbg_check_lock>
  208c9a:	f7f8 f879 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  208c9e:	9803      	ldr	r0, [sp, #12]
  208ca0:	4944      	ldr	r1, [pc, #272]	; (208db4 <rt_test_005_006_execute+0x2e4>)
  208ca2:	f1a0 0001 	sub.w	r0, r0, #1
  208ca6:	fab0 f080 	clz	r0, r0
  208caa:	0940      	lsrs	r0, r0, #5
  208cac:	f7f7 fd88 	bl	2007c0 <_test_assert>
  208cb0:	2800      	cmp	r0, #0
  208cb2:	d158      	bne.n	208d66 <rt_test_005_006_execute+0x296>
  _dbg_check_unlock();
  208cb4:	f7fa fffc 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208cb8:	6823      	ldr	r3, [r4, #0]
  208cba:	42a3      	cmp	r3, r4
  208cbc:	d004      	beq.n	208cc8 <rt_test_005_006_execute+0x1f8>
  208cbe:	69a2      	ldr	r2, [r4, #24]
  208cc0:	689b      	ldr	r3, [r3, #8]
  208cc2:	6892      	ldr	r2, [r2, #8]
  208cc4:	429a      	cmp	r2, r3
  208cc6:	d35a      	bcc.n	208d7e <rt_test_005_006_execute+0x2ae>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208cc8:	2300      	movs	r3, #0
  208cca:	f383 8811 	msr	BASEPRI, r3
  test_set_step(6);
  208cce:	2306      	movs	r3, #6
  208cd0:	602b      	str	r3, [r5, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  208cd2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208cd4:	2320      	movs	r3, #32
  208cd6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208cda:	b662      	cpsie	i
  _dbg_check_lock();
  208cdc:	f7fb f838 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  208ce0:	f7f8 f856 	bl	200d90 <chDbgCheckClassI>
  if (bsp->sem.cnt < (cnt_t)1) {
  208ce4:	9b03      	ldr	r3, [sp, #12]
  208ce6:	2b00      	cmp	r3, #0
  208ce8:	dd50      	ble.n	208d8c <rt_test_005_006_execute+0x2bc>
  chSchRescheduleS();
  208cea:	f7fa ffc9 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  208cee:	f7fa ffdf 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208cf2:	6823      	ldr	r3, [r4, #0]
  208cf4:	42a3      	cmp	r3, r4
  208cf6:	d004      	beq.n	208d02 <rt_test_005_006_execute+0x232>
  208cf8:	69a2      	ldr	r2, [r4, #24]
  208cfa:	689b      	ldr	r3, [r3, #8]
  208cfc:	6892      	ldr	r2, [r2, #8]
  208cfe:	429a      	cmp	r2, r3
  208d00:	d33d      	bcc.n	208d7e <rt_test_005_006_execute+0x2ae>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208d02:	2300      	movs	r3, #0
  208d04:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  208d08:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208d0a:	2320      	movs	r3, #32
  208d0c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208d10:	b662      	cpsie	i
  _dbg_check_lock();
  208d12:	f7fb f81d 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  208d16:	f7f8 f83b 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
  208d1a:	9803      	ldr	r0, [sp, #12]
  208d1c:	4926      	ldr	r1, [pc, #152]	; (208db8 <rt_test_005_006_execute+0x2e8>)
  208d1e:	2800      	cmp	r0, #0
  208d20:	bfd4      	ite	le
  208d22:	2000      	movle	r0, #0
  208d24:	2001      	movgt	r0, #1
  208d26:	f7f7 fd4b 	bl	2007c0 <_test_assert>
  208d2a:	b9e0      	cbnz	r0, 208d66 <rt_test_005_006_execute+0x296>
  _dbg_check_unlock();
  208d2c:	f7fa ffc0 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208d30:	6823      	ldr	r3, [r4, #0]
  208d32:	42a3      	cmp	r3, r4
  208d34:	d004      	beq.n	208d40 <rt_test_005_006_execute+0x270>
  208d36:	69a2      	ldr	r2, [r4, #24]
  208d38:	689b      	ldr	r3, [r3, #8]
  208d3a:	6892      	ldr	r2, [r2, #8]
  208d3c:	429a      	cmp	r2, r3
  208d3e:	d31e      	bcc.n	208d7e <rt_test_005_006_execute+0x2ae>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208d40:	2300      	movs	r3, #0
  208d42:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  208d46:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208d48:	2320      	movs	r3, #32
  208d4a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208d4e:	b662      	cpsie	i
  _dbg_check_lock();
  208d50:	f7fa fffe 	bl	203d50 <_dbg_check_lock>
  208d54:	f7f8 f81c 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  208d58:	9803      	ldr	r0, [sp, #12]
  208d5a:	4916      	ldr	r1, [pc, #88]	; (208db4 <rt_test_005_006_execute+0x2e4>)
  208d5c:	1e43      	subs	r3, r0, #1
  208d5e:	4258      	negs	r0, r3
  208d60:	4158      	adcs	r0, r3
  208d62:	f7f7 fd2d 	bl	2007c0 <_test_assert>
  _dbg_check_unlock();
  208d66:	f7fa ffa3 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208d6a:	6823      	ldr	r3, [r4, #0]
  208d6c:	42a3      	cmp	r3, r4
  208d6e:	f43f aed6 	beq.w	208b1e <rt_test_005_006_execute+0x4e>
  208d72:	69a2      	ldr	r2, [r4, #24]
  208d74:	689b      	ldr	r3, [r3, #8]
  208d76:	6892      	ldr	r2, [r2, #8]
  208d78:	429a      	cmp	r2, r3
  208d7a:	f4bf aed0 	bcs.w	208b1e <rt_test_005_006_execute+0x4e>
  208d7e:	480f      	ldr	r0, [pc, #60]	; (208dbc <rt_test_005_006_execute+0x2ec>)
  208d80:	f7f7 fef6 	bl	200b70 <chSysHalt>
    chSemSignalI(&bsp->sem);
  208d84:	a801      	add	r0, sp, #4
  208d86:	f7f8 f9d3 	bl	201130 <chSemSignalI>
  208d8a:	e74f      	b.n	208c2c <rt_test_005_006_execute+0x15c>
  208d8c:	a801      	add	r0, sp, #4
  208d8e:	f7f8 f9cf 	bl	201130 <chSemSignalI>
  208d92:	e7aa      	b.n	208cea <rt_test_005_006_execute+0x21a>
  208d94:	20001f6c 	.word	0x20001f6c
  208d98:	0800d688 	.word	0x0800d688
  208d9c:	20000dc8 	.word	0x20000dc8
  208da0:	00204b81 	.word	0x00204b81
  208da4:	20001858 	.word	0x20001858
  208da8:	20001f84 	.word	0x20001f84
  208dac:	0800d694 	.word	0x0800d694
  208db0:	0800d6a8 	.word	0x0800d6a8
  208db4:	0800d6b4 	.word	0x0800d6b4
  208db8:	0800d68c 	.word	0x0800d68c
  208dbc:	0800bcb8 	.word	0x0800bcb8

00208dc0 <rt_test_005_005_execute>:
  return ch.rlist.current;
  208dc0:	4a1e      	ldr	r2, [pc, #120]	; (208e3c <rt_test_005_005_execute+0x7c>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  208dc2:	481f      	ldr	r0, [pc, #124]	; (208e40 <rt_test_005_005_execute+0x80>)
  return chThdGetSelfX()->prio;
  208dc4:	6991      	ldr	r1, [r2, #24]
  208dc6:	4a1f      	ldr	r2, [pc, #124]	; (208e44 <rt_test_005_005_execute+0x84>)
  208dc8:	6889      	ldr	r1, [r1, #8]
static void rt_test_005_005_execute(void) {
  208dca:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
  208dcc:	2401      	movs	r4, #1
  208dce:	4d1e      	ldr	r5, [pc, #120]	; (208e48 <rt_test_005_005_execute+0x88>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  208dd0:	2300      	movs	r3, #0
  208dd2:	4421      	add	r1, r4
  test_set_step(1);
  208dd4:	602c      	str	r4, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  208dd6:	f7ff fd1b 	bl	208810 <chThdCreateStatic.constprop.61>
  return (bool)(tqp->next == (const thread_t *)tqp);
  208dda:	4c1c      	ldr	r4, [pc, #112]	; (208e4c <rt_test_005_005_execute+0x8c>)
  208ddc:	4a1c      	ldr	r2, [pc, #112]	; (208e50 <rt_test_005_005_execute+0x90>)
  test_set_step(2);
  208dde:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  208de0:	6010      	str	r0, [r2, #0]
  test_set_step(2);
  208de2:	602b      	str	r3, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
  208de4:	f7fa ffec 	bl	203dc0 <chSemSignalWait.constprop.56>
  208de8:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
  208dea:	491a      	ldr	r1, [pc, #104]	; (208e54 <rt_test_005_005_execute+0x94>)
  208dec:	1b00      	subs	r0, r0, r4
  208dee:	fab0 f080 	clz	r0, r0
  208df2:	0940      	lsrs	r0, r0, #5
  208df4:	f7f7 fce4 	bl	2007c0 <_test_assert>
  208df8:	b100      	cbz	r0, 208dfc <rt_test_005_005_execute+0x3c>
}
  208dfa:	bd38      	pop	{r3, r4, r5, pc}
    test_assert(sem1.cnt == 0, "counter not zero");
  208dfc:	68a0      	ldr	r0, [r4, #8]
  208dfe:	4916      	ldr	r1, [pc, #88]	; (208e58 <rt_test_005_005_execute+0x98>)
  208e00:	fab0 f080 	clz	r0, r0
  208e04:	0940      	lsrs	r0, r0, #5
  208e06:	f7f7 fcdb 	bl	2007c0 <_test_assert>
  208e0a:	2800      	cmp	r0, #0
  208e0c:	d1f5      	bne.n	208dfa <rt_test_005_005_execute+0x3a>
  test_set_step(3);
  208e0e:	2303      	movs	r3, #3
  208e10:	602b      	str	r3, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
  208e12:	f7fa ffd5 	bl	203dc0 <chSemSignalWait.constprop.56>
  208e16:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
  208e18:	490e      	ldr	r1, [pc, #56]	; (208e54 <rt_test_005_005_execute+0x94>)
  208e1a:	1b00      	subs	r0, r0, r4
  208e1c:	fab0 f080 	clz	r0, r0
  208e20:	0940      	lsrs	r0, r0, #5
  208e22:	f7f7 fccd 	bl	2007c0 <_test_assert>
  208e26:	2800      	cmp	r0, #0
  208e28:	d1e7      	bne.n	208dfa <rt_test_005_005_execute+0x3a>
    test_assert(sem1.cnt == 0, "counter not zero");
  208e2a:	68a0      	ldr	r0, [r4, #8]
  208e2c:	490a      	ldr	r1, [pc, #40]	; (208e58 <rt_test_005_005_execute+0x98>)
  208e2e:	fab0 f080 	clz	r0, r0
}
  208e32:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert(sem1.cnt == 0, "counter not zero");
  208e36:	0940      	lsrs	r0, r0, #5
  208e38:	f7f7 bcc2 	b.w	2007c0 <_test_assert>
  208e3c:	20000dc8 	.word	0x20000dc8
  208e40:	20001858 	.word	0x20001858
  208e44:	00207791 	.word	0x00207791
  208e48:	20001f6c 	.word	0x20001f6c
  208e4c:	20001838 	.word	0x20001838
  208e50:	20001f84 	.word	0x20001f84
  208e54:	0800d728 	.word	0x0800d728
  208e58:	0800d664 	.word	0x0800d664
  208e5c:	00000000 	.word	0x00000000

00208e60 <chThdWait>:
msg_t chThdWait(thread_t *tp) {
  208e60:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck(tp != NULL);
  208e62:	b358      	cbz	r0, 208ebc <chThdWait+0x5c>
  208e64:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
  208e66:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208e68:	2320      	movs	r3, #32
  208e6a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  208e6e:	b662      	cpsie	i
  chDbgAssert(tp != currp, "waiting self");
  208e70:	4d15      	ldr	r5, [pc, #84]	; (208ec8 <chThdWait+0x68>)
  _dbg_check_lock();
  208e72:	f7fa ff6d 	bl	203d50 <_dbg_check_lock>
  208e76:	69ab      	ldr	r3, [r5, #24]
  208e78:	42a3      	cmp	r3, r4
  208e7a:	d01f      	beq.n	208ebc <chThdWait+0x5c>
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
  208e7c:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
  208e80:	b1e2      	cbz	r2, 208ebc <chThdWait+0x5c>
  if (tp->state != CH_STATE_FINAL) {
  208e82:	f894 2020 	ldrb.w	r2, [r4, #32]
  208e86:	2a0f      	cmp	r2, #15
  208e88:	d005      	beq.n	208e96 <chThdWait+0x36>
  tp->queue.next = tlp->next;
  208e8a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTEXIT);
  208e8c:	2009      	movs	r0, #9
  208e8e:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
  208e90:	62a3      	str	r3, [r4, #40]	; 0x28
  208e92:	f7fa fb05 	bl	2034a0 <chSchGoSleepS>
  msg = tp->u.exitcode;
  208e96:	6a66      	ldr	r6, [r4, #36]	; 0x24
  _dbg_check_unlock();
  208e98:	f7fa ff0a 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  208e9c:	682b      	ldr	r3, [r5, #0]
  208e9e:	42ab      	cmp	r3, r5
  208ea0:	d004      	beq.n	208eac <chThdWait+0x4c>
  208ea2:	69aa      	ldr	r2, [r5, #24]
  208ea4:	689b      	ldr	r3, [r3, #8]
  208ea6:	6892      	ldr	r2, [r2, #8]
  208ea8:	429a      	cmp	r2, r3
  208eaa:	d30a      	bcc.n	208ec2 <chThdWait+0x62>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208eac:	2300      	movs	r3, #0
  208eae:	f383 8811 	msr	BASEPRI, r3
  chThdRelease(tp);
  208eb2:	4620      	mov	r0, r4
  208eb4:	f7ff fbc4 	bl	208640 <chThdRelease>
}
  208eb8:	4630      	mov	r0, r6
  208eba:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(tp != NULL);
  208ebc:	4803      	ldr	r0, [pc, #12]	; (208ecc <chThdWait+0x6c>)
  208ebe:	f7f7 fe57 	bl	200b70 <chSysHalt>
  208ec2:	4803      	ldr	r0, [pc, #12]	; (208ed0 <chThdWait+0x70>)
  208ec4:	f7f7 fe54 	bl	200b70 <chSysHalt>
  208ec8:	20000dc8 	.word	0x20000dc8
  208ecc:	0800bf5c 	.word	0x0800bf5c
  208ed0:	0800bc04 	.word	0x0800bc04
	...

00208ee0 <main>:

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  208ee0:	4bb9      	ldr	r3, [pc, #740]	; (2091c8 <main+0x2e8>)
  208ee2:	2200      	movs	r2, #0
  208ee4:	49b9      	ldr	r1, [pc, #740]	; (2091cc <main+0x2ec>)
  rccResetAHB2(~0);
  208ee6:	f04f 34ff 	mov.w	r4, #4294967295
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  208eea:	691d      	ldr	r5, [r3, #16]
  PWR->CR1 |= PWR_CR1_DBP;
  208eec:	48b8      	ldr	r0, [pc, #736]	; (2091d0 <main+0x2f0>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  208eee:	4329      	orrs	r1, r5
}

/*
 * Application entry point.
 */
int main(void) {
  208ef0:	b580      	push	{r7, lr}
  208ef2:	6119      	str	r1, [r3, #16]
  208ef4:	b088      	sub	sp, #32
  208ef6:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
  208ef8:	6959      	ldr	r1, [r3, #20]
  208efa:	615c      	str	r4, [r3, #20]
  208efc:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  208efe:	6a19      	ldr	r1, [r3, #32]
  208f00:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
  208f04:	6219      	str	r1, [r3, #32]
  208f06:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
  208f08:	6a59      	ldr	r1, [r3, #36]	; 0x24
  208f0a:	625c      	str	r4, [r3, #36]	; 0x24
  208f0c:	625a      	str	r2, [r3, #36]	; 0x24
  PWR->CR1 |= PWR_CR1_DBP;
  208f0e:	6801      	ldr	r1, [r0, #0]
  208f10:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  208f14:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
  208f16:	6f19      	ldr	r1, [r3, #112]	; 0x70
  208f18:	f401 7140 	and.w	r1, r1, #768	; 0x300
  208f1c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
  208f20:	d003      	beq.n	208f2a <main+0x4a>
    RCC->BDCR = RCC_BDCR_BDRST;
  208f22:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  208f26:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
  208f28:	671a      	str	r2, [r3, #112]	; 0x70
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  208f2a:	4ba7      	ldr	r3, [pc, #668]	; (2091c8 <main+0x2e8>)
  208f2c:	6f19      	ldr	r1, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  208f2e:	461a      	mov	r2, r3
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  208f30:	f041 0119 	orr.w	r1, r1, #25
  208f34:	6719      	str	r1, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  208f36:	6f13      	ldr	r3, [r2, #112]	; 0x70
  208f38:	079b      	lsls	r3, r3, #30
  208f3a:	d5fc      	bpl.n	208f36 <main+0x56>
  PWR->CSR1 &= ~PWR_CSR1_BRE;
  208f3c:	48a4      	ldr	r0, [pc, #656]	; (2091d0 <main+0x2f0>)
  usbp->config       = NULL;
  208f3e:	2200      	movs	r2, #0
  usbp->state        = USB_STOP;
  208f40:	4ca4      	ldr	r4, [pc, #656]	; (2091d4 <main+0x2f4>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208f42:	2560      	movs	r5, #96	; 0x60
  208f44:	6843      	ldr	r3, [r0, #4]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208f46:	f04f 0c40 	mov.w	ip, #64	; 0x40
  usbp->config       = NULL;
  208f4a:	6062      	str	r2, [r4, #4]
  208f4c:	f44f 7680 	mov.w	r6, #256	; 0x100
  208f50:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208f54:	49a0      	ldr	r1, [pc, #640]	; (2091d8 <main+0x2f8>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208f56:	f44f 7700 	mov.w	r7, #512	; 0x200
  208f5a:	6043      	str	r3, [r0, #4]
  208f5c:	2080      	movs	r0, #128	; 0x80
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208f5e:	f881 5306 	strb.w	r5, [r1, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208f62:	f44f 6380 	mov.w	r3, #1024	; 0x400
  208f66:	f8c1 c180 	str.w	ip, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208f6a:	f8c1 c000 	str.w	ip, [r1]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208f6e:	f881 5307 	strb.w	r5, [r1, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208f72:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208f76:	6008      	str	r0, [r1, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208f78:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208f7c:	f881 5308 	strb.w	r5, [r1, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208f80:	f8c1 6180 	str.w	r6, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208f84:	600e      	str	r6, [r1, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208f86:	f881 5309 	strb.w	r5, [r1, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208f8a:	f8c1 7180 	str.w	r7, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208f8e:	600f      	str	r7, [r1, #0]
  usbp->state        = USB_STOP;
  208f90:	2701      	movs	r7, #1
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208f92:	f881 530a 	strb.w	r5, [r1, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208f96:	f8c1 3180 	str.w	r3, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208f9a:	600b      	str	r3, [r1, #0]
  208f9c:	f104 0330 	add.w	r3, r4, #48	; 0x30
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208fa0:	f881 5317 	strb.w	r5, [r1, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208fa4:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208fa8:	6008      	str	r0, [r1, #0]
  208faa:	f104 0050 	add.w	r0, r4, #80	; 0x50
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208fae:	f881 5328 	strb.w	r5, [r1, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208fb2:	f8c1 6184 	str.w	r6, [r1, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208fb6:	604e      	str	r6, [r1, #4]
  208fb8:	7027      	strb	r7, [r4, #0]
    usbp->in_params[i]  = NULL;
  208fba:	f843 2b04 	str.w	r2, [r3], #4
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
  208fbe:	4283      	cmp	r3, r0
    usbp->out_params[i] = NULL;
  208fc0:	61da      	str	r2, [r3, #28]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
  208fc2:	d1fa      	bne.n	208fba <main+0xda>
  usbp->state        = USB_STOP;
  208fc4:	4e85      	ldr	r6, [pc, #532]	; (2091dc <main+0x2fc>)
  208fc6:	2701      	movs	r7, #1
  USBD1.otg       = OTG_FS;
  208fc8:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
  USBD1.otgparams = &fsparams;
  208fcc:	4884      	ldr	r0, [pc, #528]	; (2091e0 <main+0x300>)
  usbp->transmitting = 0;
  208fce:	60a2      	str	r2, [r4, #8]
  208fd0:	f106 0330 	add.w	r3, r6, #48	; 0x30
  usbp->config       = NULL;
  208fd4:	6072      	str	r2, [r6, #4]
  208fd6:	f106 0150 	add.w	r1, r6, #80	; 0x50
    usbp->in_params[i]  = NULL;
  208fda:	2200      	movs	r2, #0
  usbp->state        = USB_STOP;
  208fdc:	7037      	strb	r7, [r6, #0]
  208fde:	e9c4 5024 	strd	r5, r0, [r4, #144]	; 0x90
    usbp->in_params[i]  = NULL;
  208fe2:	f843 2b04 	str.w	r2, [r3], #4
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
  208fe6:	428b      	cmp	r3, r1
    usbp->out_params[i] = NULL;
  208fe8:	61da      	str	r2, [r3, #28]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
  208fea:	d1fa      	bne.n	208fe2 <main+0x102>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
  208fec:	4976      	ldr	r1, [pc, #472]	; (2091c8 <main+0x2e8>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  208fee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  usbp->transmitting = 0;
  208ff2:	60b2      	str	r2, [r6, #8]
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  208ff4:	f04f 34ff 	mov.w	r4, #4294967295
  ST_ENABLE_CLOCK();
  208ff8:	6c08      	ldr	r0, [r1, #64]	; 0x40
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  208ffa:	f642 272f 	movw	r7, #10799	; 0x2a2f
  ST_ENABLE_STOP();
  208ffe:	f8df c234 	ldr.w	ip, [pc, #564]	; 209234 <main+0x354>
  ST_ENABLE_CLOCK();
  209002:	f040 0001 	orr.w	r0, r0, #1
  tqp->next = (thread_t *)tqp;
  209006:	4d77      	ldr	r5, [pc, #476]	; (2091e4 <main+0x304>)
  209008:	6408      	str	r0, [r1, #64]	; 0x40
  20900a:	6e08      	ldr	r0, [r1, #96]	; 0x60
  20900c:	f040 0001 	orr.w	r0, r0, #1
  209010:	6608      	str	r0, [r1, #96]	; 0x60
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  209012:	2001      	movs	r0, #1
  ST_ENABLE_STOP();
  209014:	f8dc 1008 	ldr.w	r1, [ip, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
  209018:	626c      	str	r4, [r5, #36]	; 0x24
  20901a:	4301      	orrs	r1, r0
  20901c:	f8cc 1008 	str.w	r1, [ip, #8]
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  209020:	f105 0c40 	add.w	ip, r5, #64	; 0x40
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  209024:	629f      	str	r7, [r3, #40]	; 0x28
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  209026:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  20902a:	62dc      	str	r4, [r3, #44]	; 0x2c
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20902c:	2780      	movs	r7, #128	; 0x80
  STM32_ST_TIM->CCMR1  = 0;
  20902e:	619a      	str	r2, [r3, #24]
  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
  209030:	4c6d      	ldr	r4, [pc, #436]	; (2091e8 <main+0x308>)
  tqp->prev = (thread_t *)tqp;
  209032:	606d      	str	r5, [r5, #4]
  STM32_ST_TIM->CCR[0] = 0;
  209034:	635a      	str	r2, [r3, #52]	; 0x34
  ch.rlist.prio = NOPRIO;
  209036:	60aa      	str	r2, [r5, #8]
  STM32_ST_TIM->DIER   = 0;
  209038:	60da      	str	r2, [r3, #12]
  ch.rlist.newer = (thread_t *)&ch.rlist;
  20903a:	612d      	str	r5, [r5, #16]
  STM32_ST_TIM->CR2    = 0;
  20903c:	605a      	str	r2, [r3, #4]
  ch.vtlist.lasttime = (systime_t)0;
  20903e:	62aa      	str	r2, [r5, #40]	; 0x28
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  209040:	f105 021c 	add.w	r2, r5, #28
  209044:	63ac      	str	r4, [r5, #56]	; 0x38
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
  209046:	2400      	movs	r4, #0
  ch.rlist.older = (thread_t *)&ch.rlist;
  209048:	616d      	str	r5, [r5, #20]
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  20904a:	f8c5 c03c 	str.w	ip, [r5, #60]	; 0x3c
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  20904e:	6158      	str	r0, [r3, #20]
  209050:	61ea      	str	r2, [r5, #28]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
  209052:	6018      	str	r0, [r3, #0]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  209054:	622a      	str	r2, [r5, #32]
  209056:	4b60      	ldr	r3, [pc, #384]	; (2091d8 <main+0x2f8>)
  USBD2.otg       = OTG_HS;
  209058:	4864      	ldr	r0, [pc, #400]	; (2091ec <main+0x30c>)
  USBD2.otgparams = &hsparams;
  20905a:	4a65      	ldr	r2, [pc, #404]	; (2091f0 <main+0x310>)
  20905c:	f883 731c 	strb.w	r7, [r3, #796]	; 0x31c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  209060:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  USBD2.otg       = OTG_HS;
  209064:	f8c6 0090 	str.w	r0, [r6, #144]	; 0x90
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  209068:	6019      	str	r1, [r3, #0]
  USBD2.otgparams = &hsparams;
  20906a:	f8c6 2094 	str.w	r2, [r6, #148]	; 0x94
  tqp->next = (thread_t *)tqp;
  20906e:	602d      	str	r5, [r5, #0]
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
  209070:	3401      	adds	r4, #1
  209072:	eb05 1304 	add.w	r3, r5, r4, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
  209076:	2c80      	cmp	r4, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
  209078:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
  20907c:	f36f 0202 	bfc	r2, #0, #3
  209080:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
  209084:	d1f4      	bne.n	209070 <main+0x190>
  ch.dbg.isr_cnt  = (cnt_t)0;
  209086:	2700      	movs	r7, #0
  tmp->best       = (rtcnt_t)-1;
  209088:	f04f 31ff 	mov.w	r1, #4294967295
  tmp->cumulative = (rttime_t)0;
  20908c:	2200      	movs	r2, #0
  20908e:	2300      	movs	r3, #0
  chTMStartMeasurementX(&tm);
  209090:	a802      	add	r0, sp, #8
  tmp->best       = (rtcnt_t)-1;
  209092:	9102      	str	r1, [sp, #8]
  ch.tm.offset = (rtcnt_t)0;
  209094:	f8c5 7884 	str.w	r7, [r5, #2180]	; 0x884
  tmp->n          = (ucnt_t)0;
  209098:	9705      	str	r7, [sp, #20]
  tmp->cumulative = (rttime_t)0;
  20909a:	e9cd 2306 	strd	r2, r3, [sp, #24]
  ch.dbg.lock_cnt = (cnt_t)0;
  20909e:	e9c5 770c 	strd	r7, r7, [r5, #48]	; 0x30
  tmp->last       = (rtcnt_t)0;
  2090a2:	e9cd 7703 	strd	r7, r7, [sp, #12]
  chTMStartMeasurementX(&tm);
  2090a6:	f7f7 fb4b 	bl	200740 <chTMStartMeasurementX.constprop.63>
  chTMStopMeasurementX(&tm);
  2090aa:	a802      	add	r0, sp, #8
  2090ac:	f7f7 fcb8 	bl	200a20 <chTMStopMeasurementX>
  default_heap.provider = chCoreAllocAlignedWithOffset;
  2090b0:	4a50      	ldr	r2, [pc, #320]	; (2091f4 <main+0x314>)
  2090b2:	4b51      	ldr	r3, [pc, #324]	; (2091f8 <main+0x318>)
  mp->object_size = size;
  2090b4:	f04f 0e14 	mov.w	lr, #20
  2090b8:	f102 010c 	add.w	r1, r2, #12
  2090bc:	484f      	ldr	r0, [pc, #316]	; (2091fc <main+0x31c>)
  mp->owner = NULL;
  2090be:	6157      	str	r7, [r2, #20]
  dlp->next = (dyn_element_t *)dlp;
  2090c0:	f103 0910 	add.w	r9, r3, #16
  2090c4:	6010      	str	r0, [r2, #0]
  2090c6:	f103 0824 	add.w	r8, r3, #36	; 0x24
  tp->prio      = prio;
  2090ca:	f8c5 4848 	str.w	r4, [r5, #2120]	; 0x848
  2090ce:	f103 0c28 	add.w	ip, r3, #40	; 0x28
  tp->realprio  = prio;
  2090d2:	f8c5 487c 	str.w	r4, [r5, #2172]	; 0x87c
  2090d6:	f103 003c 	add.w	r0, r3, #60	; 0x3c
  2090da:	241c      	movs	r4, #28
  2090dc:	601b      	str	r3, [r3, #0]
  mp->next = NULL;
  2090de:	615f      	str	r7, [r3, #20]
  2090e0:	62df      	str	r7, [r3, #44]	; 0x2c
  2090e2:	f8c3 9010 	str.w	r9, [r3, #16]
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  2090e6:	f64f 09ff 	movw	r9, #63743	; 0xf8ff
  mp->object_size = size;
  2090ea:	f8c3 e018 	str.w	lr, [r3, #24]
  tp->refs      = (trefs_t)1;
  2090ee:	f04f 0e01 	mov.w	lr, #1
  2090f2:	631c      	str	r4, [r3, #48]	; 0x30
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  2090f4:	2420      	movs	r4, #32
  2090f6:	63d8      	str	r0, [r3, #60]	; 0x3c
  2090f8:	f885 e862 	strb.w	lr, [r5, #2146]	; 0x862
  tp->flags     = CH_FLAG_MODE_STATIC;
  2090fc:	f885 7861 	strb.w	r7, [r5, #2145]	; 0x861
  tp->mtxlist   = NULL;
  209100:	f8c5 7878 	str.w	r7, [r5, #2168]	; 0x878
  tp->epending  = (eventmask_t)0;
  209104:	f8c5 7874 	str.w	r7, [r5, #2164]	; 0x874
  H_PAGES(&default_heap.header) = 0;
  209108:	e9c2 7701 	strd	r7, r7, [r2, #4]
  tqp->prev = (thread_t *)tqp;
  20910c:	e9c2 1103 	strd	r1, r1, [r2, #12]
  209110:	f103 0140 	add.w	r1, r3, #64	; 0x40
  mp->align = align;
  209114:	2204      	movs	r2, #4
  209116:	6419      	str	r1, [r3, #64]	; 0x40
  209118:	61da      	str	r2, [r3, #28]
  mp->provider = provider;
  20911a:	4939      	ldr	r1, [pc, #228]	; (209200 <main+0x320>)
  mp->align = align;
  20911c:	635a      	str	r2, [r3, #52]	; 0x34
  ch.tm.offset = tm.last;
  20911e:	9a04      	ldr	r2, [sp, #16]
  mp->provider = provider;
  209120:	6219      	str	r1, [r3, #32]
  209122:	6399      	str	r1, [r3, #56]	; 0x38
  209124:	f8c5 2884 	str.w	r2, [r5, #2180]	; 0x884
  ch_memcore.nextmem = __heap_base__;
  209128:	4936      	ldr	r1, [pc, #216]	; (209204 <main+0x324>)
  ch_memcore.endmem  = __heap_end__;
  20912a:	4a37      	ldr	r2, [pc, #220]	; (209208 <main+0x328>)
  20912c:	e9c3 3701 	strd	r3, r7, [r3, #4]
  209130:	e9c3 8c09 	strd	r8, ip, [r3, #36]	; 0x24
  ch_memcore.nextmem = __heap_base__;
  209134:	4b35      	ldr	r3, [pc, #212]	; (20920c <main+0x32c>)
  209136:	f04f 0c10 	mov.w	ip, #16
  ch_memcore.endmem  = __heap_end__;
  20913a:	e9c3 1200 	strd	r1, r2, [r3]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  20913e:	4a34      	ldr	r2, [pc, #208]	; (209210 <main+0x330>)
  tp->name      = name;
  209140:	4b34      	ldr	r3, [pc, #208]	; (209214 <main+0x334>)
  reg_value  =  (reg_value                                   |
  209142:	4935      	ldr	r1, [pc, #212]	; (209218 <main+0x338>)
  209144:	f8c5 3858 	str.w	r3, [r5, #2136]	; 0x858
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  209148:	68d0      	ldr	r0, [r2, #12]
  REG_INSERT(tp);
  20914a:	f8d5 8014 	ldr.w	r8, [r5, #20]
  20914e:	4b33      	ldr	r3, [pc, #204]	; (20921c <main+0x33c>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  209150:	ea00 0009 	and.w	r0, r0, r9
  209154:	f8c5 8854 	str.w	r8, [r5, #2132]	; 0x854
  209158:	f8c5 5850 	str.w	r5, [r5, #2128]	; 0x850
  reg_value  =  (reg_value                                   |
  20915c:	4301      	orrs	r1, r0
  20915e:	f8c8 3010 	str.w	r3, [r8, #16]
  tlp->next = (thread_t *)tlp;
  209162:	f103 0928 	add.w	r9, r3, #40	; 0x28
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  209166:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 209238 <main+0x358>
  SCB->AIRCR =  reg_value;
  20916a:	60d1      	str	r1, [r2, #12]
  20916c:	f8d8 000c 	ldr.w	r0, [r8, #12]
  DWT->LAR = 0xC5ACCE55U;
  209170:	492b      	ldr	r1, [pc, #172]	; (209220 <main+0x340>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  209172:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
  currp->state = CH_STATE_CURRENT;
  209176:	f885 e860 	strb.w	lr, [r5, #2144]	; 0x860
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
  20917a:	e9c5 3305 	strd	r3, r3, [r5, #20]
  20917e:	f8c8 000c 	str.w	r0, [r8, #12]
  tqp->next = (thread_t *)tqp;
  209182:	332c      	adds	r3, #44	; 0x2c
  DWT->LAR = 0xC5ACCE55U;
  209184:	4827      	ldr	r0, [pc, #156]	; (209224 <main+0x344>)
  tlp->next = (thread_t *)tlp;
  209186:	f8c5 9868 	str.w	r9, [r5, #2152]	; 0x868
  20918a:	f8c1 0fb0 	str.w	r0, [r1, #4016]	; 0xfb0
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
  20918e:	6808      	ldr	r0, [r1, #0]
  tqp->next = (thread_t *)tqp;
  209190:	f8c5 386c 	str.w	r3, [r5, #2156]	; 0x86c
  tqp->prev = (thread_t *)tqp;
  209194:	f8c5 3870 	str.w	r3, [r5, #2160]	; 0x870
  209198:	ea40 000e 	orr.w	r0, r0, lr
    currp->wabase = &__main_thread_stack_base__;
  20919c:	4b22      	ldr	r3, [pc, #136]	; (209228 <main+0x348>)
  20919e:	6008      	str	r0, [r1, #0]
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  2091a0:	f882 c01f 	strb.w	ip, [r2, #31]
  2091a4:	f882 4022 	strb.w	r4, [r2, #34]	; 0x22
  2091a8:	f8c5 385c 	str.w	r3, [r5, #2140]	; 0x85c
  _dbg_check_enable();
  2091ac:	f7f8 f8d8 	bl	201360 <_dbg_check_enable>
  2091b0:	f387 8811 	msr	BASEPRI, r7
  __ASM volatile ("cpsie i" : : : "memory");
  2091b4:	b662      	cpsie	i
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
  2091b6:	481d      	ldr	r0, [pc, #116]	; (20922c <main+0x34c>)
  2091b8:	f7ff fb1a 	bl	2087f0 <chRegFindThreadByWorkingArea>
  2091bc:	2800      	cmp	r0, #0
  2091be:	d03d      	beq.n	20923c <main+0x35c>
  2091c0:	481b      	ldr	r0, [pc, #108]	; (209230 <main+0x350>)
  2091c2:	f7f7 fcd5 	bl	200b70 <chSysHalt>
  2091c6:	bf00      	nop
  2091c8:	40023800 	.word	0x40023800
  2091cc:	fffff800 	.word	0xfffff800
  2091d0:	40007000 	.word	0x40007000
  2091d4:	20000c90 	.word	0x20000c90
  2091d8:	e000e100 	.word	0xe000e100
  2091dc:	20000d2c 	.word	0x20000d2c
  2091e0:	0800c568 	.word	0x0800c568
  2091e4:	20000dc8 	.word	0x20000dc8
  2091e8:	0080fff0 	.word	0x0080fff0
  2091ec:	40040000 	.word	0x40040000
  2091f0:	0800c578 	.word	0x0800c578
  2091f4:	20001778 	.word	0x20001778
  2091f8:	20001650 	.word	0x20001650
  2091fc:	00204811 	.word	0x00204811
  209200:	00200e31 	.word	0x00200e31
  209204:	20010498 	.word	0x20010498
  209208:	20050000 	.word	0x20050000
  20920c:	20001770 	.word	0x20001770
  209210:	e000ed00 	.word	0xe000ed00
  209214:	0800c240 	.word	0x0800c240
  209218:	05fa0300 	.word	0x05fa0300
  20921c:	20001608 	.word	0x20001608
  209220:	e0001000 	.word	0xe0001000
  209224:	c5acce55 	.word	0xc5acce55
  209228:	20000400 	.word	0x20000400
  20922c:	20001698 	.word	0x20001698
  209230:	0800be24 	.word	0x0800be24
  209234:	e0042000 	.word	0xe0042000
  209238:	e000edf0 	.word	0xe000edf0
  20923c:	4bb8      	ldr	r3, [pc, #736]	; (209520 <main+0x640>)
    *startp++ = v;
  20923e:	2155      	movs	r1, #85	; 0x55
  209240:	f103 02d8 	add.w	r2, r3, #216	; 0xd8
  209244:	f803 1b01 	strb.w	r1, [r3], #1
  while (startp < endp) {
  209248:	4293      	cmp	r3, r2
  20924a:	d1fb      	bne.n	209244 <main+0x364>
  __ASM volatile ("cpsid i" : : : "memory");
  20924c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20924e:	2320      	movs	r3, #32
  209250:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  209254:	b662      	cpsie	i
  _dbg_check_lock();
  209256:	f7fa fd7b 	bl	203d50 <_dbg_check_lock>
  tp = chThdCreateSuspendedI(tdp);
  20925a:	48b2      	ldr	r0, [pc, #712]	; (209524 <main+0x644>)
  20925c:	f7f7 fdf0 	bl	200e40 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
  209260:	2100      	movs	r1, #0
  209262:	f7fa f8e5 	bl	203430 <chSchWakeupS>
  _dbg_check_unlock();
  209266:	f7fa fd23 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20926a:	682b      	ldr	r3, [r5, #0]
  20926c:	42ab      	cmp	r3, r5
  20926e:	d005      	beq.n	20927c <main+0x39c>
  209270:	69aa      	ldr	r2, [r5, #24]
  209272:	689b      	ldr	r3, [r3, #8]
  209274:	6892      	ldr	r2, [r2, #8]
  209276:	429a      	cmp	r2, r3
  209278:	f0c0 80d2 	bcc.w	209420 <main+0x540>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20927c:	2200      	movs	r2, #0
  20927e:	f382 8811 	msr	BASEPRI, r2
void portab_setup(void) {

  /*
   * ARD_D13 is programmed as output (board LED).
   */
  palClearLine(LINE_ARD_D13);
  209282:	4ba9      	ldr	r3, [pc, #676]	; (209528 <main+0x648>)
  209284:	2702      	movs	r7, #2
  sdup->vmt = &vmt;
  209286:	4ca9      	ldr	r4, [pc, #676]	; (20952c <main+0x64c>)
  sdup->state = SDU_STOP;
  209288:	2001      	movs	r0, #1
  20928a:	835f      	strh	r7, [r3, #26]
  ibqp->bsize     = size + sizeof (size_t);
  20928c:	f44f 7e82 	mov.w	lr, #260	; 0x104

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  209290:	6859      	ldr	r1, [r3, #4]
  tqp->next = (thread_t *)tqp;
  209292:	f104 090c 	add.w	r9, r4, #12
  ibqp->bn        = n;
  209296:	62e7      	str	r7, [r4, #44]	; 0x2c
  sdup->vmt = &vmt;
  209298:	46a4      	mov	ip, r4
  20929a:	f021 0102 	bic.w	r1, r1, #2
  ibqp->ptr       = NULL;
  20929e:	6362      	str	r2, [r4, #52]	; 0x34
  ibqp->top       = NULL;
  2092a0:	63a2      	str	r2, [r4, #56]	; 0x38
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  2092a2:	f204 488c 	addw	r8, r4, #1164	; 0x48c
  2092a6:	6059      	str	r1, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
  2092a8:	6899      	ldr	r1, [r3, #8]
  sdup->state = SDU_STOP;
  2092aa:	7220      	strb	r0, [r4, #8]
  2092ac:	f021 010c 	bic.w	r1, r1, #12
  ibqp->suspended = suspended;
  2092b0:	7520      	strb	r0, [r4, #20]
  ibqp->link      = link;
  2092b2:	6424      	str	r4, [r4, #64]	; 0x40
  2092b4:	6099      	str	r1, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
  2092b6:	68d9      	ldr	r1, [r3, #12]
  ibqp->bsize     = size + sizeof (size_t);
  2092b8:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
  2092bc:	f021 010c 	bic.w	r1, r1, #12
  obqp->suspended = suspended;
  2092c0:	f884 004c 	strb.w	r0, [r4, #76]	; 0x4c
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  2092c4:	f504 7021 	add.w	r0, r4, #644	; 0x284
  2092c8:	60d9      	str	r1, [r3, #12]
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
  2092ca:	6819      	ldr	r1, [r3, #0]
  2092cc:	6260      	str	r0, [r4, #36]	; 0x24
  2092ce:	f021 010c 	bic.w	r1, r1, #12
  2092d2:	f041 0104 	orr.w	r1, r1, #4
  2092d6:	6019      	str	r1, [r3, #0]
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
  2092d8:	6a19      	ldr	r1, [r3, #32]
  tqp->prev = (thread_t *)tqp;
  2092da:	e9c4 9903 	strd	r9, r9, [r4, #12]
  2092de:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  ibqp->notify    = infy;
  2092e2:	f8df 9294 	ldr.w	r9, [pc, #660]	; 209578 <main+0x698>
  2092e6:	6219      	str	r1, [r3, #32]
  ibqp->brdptr    = bp;
  2092e8:	f104 037c 	add.w	r3, r4, #124	; 0x7c
  ibqp->notify    = infy;
  2092ec:	f8c4 903c 	str.w	r9, [r4, #60]	; 0x3c
  tqp->next = (thread_t *)tqp;
  2092f0:	f104 0144 	add.w	r1, r4, #68	; 0x44
  sdup->vmt = &vmt;
  2092f4:	f8df 9284 	ldr.w	r9, [pc, #644]	; 20957c <main+0x69c>
  ibqp->bcounter  = 0;
  2092f8:	61a2      	str	r2, [r4, #24]
  2092fa:	f84c 9b04 	str.w	r9, [ip], #4
  esp->next = (event_listener_t *)esp;
  2092fe:	f8c4 c004 	str.w	ip, [r4, #4]
  obqp->notify    = onfy;
  209302:	f8df c27c 	ldr.w	ip, [pc, #636]	; 209580 <main+0x6a0>
  obqp->bcounter  = n;
  209306:	6527      	str	r7, [r4, #80]	; 0x50
  ibqp->brdptr    = bp;
  209308:	6223      	str	r3, [r4, #32]
  ibqp->bwrptr    = bp;
  20930a:	61e3      	str	r3, [r4, #28]
  ibqp->buffers   = bp;
  20930c:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
  20930e:	e9c4 1111 	strd	r1, r1, [r4, #68]	; 0x44
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  209312:	e9c4 0816 	strd	r0, r8, [r4, #88]	; 0x58
  obqp->bwrptr    = bp;
  209316:	6560      	str	r0, [r4, #84]	; 0x54
  obqp->top       = NULL;
  209318:	6722      	str	r2, [r4, #112]	; 0x70
  obqp->ptr       = NULL;
  20931a:	e9c4 021a 	strd	r0, r2, [r4, #104]	; 0x68
  obqp->bn        = n;
  20931e:	e9c4 e718 	strd	lr, r7, [r4, #96]	; 0x60
  obqp->notify    = onfy;
  209322:	e9c4 c41d 	strd	ip, r4, [r4, #116]	; 0x74
  __ASM volatile ("cpsid i" : : : "memory");
  209326:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  209328:	2320      	movs	r3, #32
  20932a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20932e:	b662      	cpsie	i
  _dbg_check_lock();
  209330:	f7fa fd0e 	bl	203d50 <_dbg_check_lock>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
  209334:	7a23      	ldrb	r3, [r4, #8]
  209336:	3b01      	subs	r3, #1
  209338:	2b01      	cmp	r3, #1
  20933a:	d874      	bhi.n	209426 <main+0x546>
  sdup->config = config;
  20933c:	4b7c      	ldr	r3, [pc, #496]	; (209530 <main+0x650>)
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  20933e:	6334      	str	r4, [r6, #48]	; 0x30
  sdup->config = config;
  209340:	f8c4 348c 	str.w	r3, [r4, #1164]	; 0x48c
  usbp->out_params[config->bulk_out - 1U] = sdup;
  209344:	6534      	str	r4, [r6, #80]	; 0x50
    usbp->in_params[config->int_in - 1U]  = sdup;
  209346:	6374      	str	r4, [r6, #52]	; 0x34
  sdup->state = SDU_READY;
  209348:	7227      	strb	r7, [r4, #8]
  _dbg_check_unlock();
  20934a:	f7fa fcb1 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20934e:	682b      	ldr	r3, [r5, #0]
  209350:	42ab      	cmp	r3, r5
  209352:	d004      	beq.n	20935e <main+0x47e>
  209354:	69aa      	ldr	r2, [r5, #24]
  209356:	689b      	ldr	r3, [r3, #8]
  209358:	6892      	ldr	r2, [r2, #8]
  20935a:	429a      	cmp	r2, r3
  20935c:	d366      	bcc.n	20942c <main+0x54c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20935e:	2700      	movs	r7, #0
  209360:	f387 8811 	msr	BASEPRI, r7
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
  209364:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
  chThdSleepMilliseconds(1500);
  209368:	f643 2098 	movw	r0, #15000	; 0x3a98
  usbDisconnectBus(serusbcfg.usbp);
  20936c:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
  209370:	f043 0302 	orr.w	r3, r3, #2
  209374:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
  chThdSleepMilliseconds(1500);
  209378:	f7fe fb9a 	bl	207ab0 <chThdSleep>
  __ASM volatile ("cpsid i" : : : "memory");
  20937c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20937e:	2320      	movs	r3, #32
  209380:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  209384:	b662      	cpsie	i
  _dbg_check_lock();
  209386:	f7fa fce3 	bl	203d50 <_dbg_check_lock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
  20938a:	f896 8000 	ldrb.w	r8, [r6]
  20938e:	f108 33ff 	add.w	r3, r8, #4294967295
  209392:	2b01      	cmp	r3, #1
  209394:	d84d      	bhi.n	209432 <main+0x552>
  usbp->config = config;
  209396:	4967      	ldr	r1, [pc, #412]	; (209534 <main+0x654>)
  209398:	463b      	mov	r3, r7
    usbp->epc[i] = NULL;
  20939a:	463a      	mov	r2, r7
  usbp->config = config;
  20939c:	6071      	str	r1, [r6, #4]
    usbp->epc[i] = NULL;
  20939e:	18f1      	adds	r1, r6, r3
  2093a0:	3304      	adds	r3, #4
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
  2093a2:	2b24      	cmp	r3, #36	; 0x24
    usbp->epc[i] = NULL;
  2093a4:	60ca      	str	r2, [r1, #12]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
  2093a6:	d1fa      	bne.n	20939e <main+0x4be>
  if (usbp->state == USB_STOP) {
  2093a8:	f1b8 0f01 	cmp.w	r8, #1
  2093ac:	d044      	beq.n	209438 <main+0x558>
  usbp->state = USB_READY;
  2093ae:	2302      	movs	r3, #2
  2093b0:	7033      	strb	r3, [r6, #0]
  _dbg_check_unlock();
  2093b2:	f7fa fc7d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2093b6:	682b      	ldr	r3, [r5, #0]
  2093b8:	42ab      	cmp	r3, r5
  2093ba:	d005      	beq.n	2093c8 <main+0x4e8>
  2093bc:	69aa      	ldr	r2, [r5, #24]
  2093be:	689b      	ldr	r3, [r3, #8]
  2093c0:	6892      	ldr	r2, [r2, #8]
  2093c2:	429a      	cmp	r2, r3
  2093c4:	f0c0 80a6 	bcc.w	209514 <main+0x634>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2093c8:	2300      	movs	r3, #0
  2093ca:	f383 8811 	msr	BASEPRI, r3
  usbStart(serusbcfg.usbp, &usbcfg);
  usbConnectBus(serusbcfg.usbp);
  2093ce:	f8d6 0090 	ldr.w	r0, [r6, #144]	; 0x90
  shellInit();

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
  2093d2:	2180      	movs	r1, #128	; 0x80
  2093d4:	4d58      	ldr	r5, [pc, #352]	; (209538 <main+0x658>)
  usbConnectBus(serusbcfg.usbp);
  2093d6:	f8d0 2804 	ldr.w	r2, [r0, #2052]	; 0x804
  2093da:	602d      	str	r5, [r5, #0]
  2093dc:	f022 0202 	bic.w	r2, r2, #2
  2093e0:	4f56      	ldr	r7, [pc, #344]	; (20953c <main+0x65c>)
  2093e2:	4e57      	ldr	r6, [pc, #348]	; (209540 <main+0x660>)
  2093e4:	f8c0 2804 	str.w	r2, [r0, #2052]	; 0x804
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
  2093e8:	4a56      	ldr	r2, [pc, #344]	; (209544 <main+0x664>)
  2093ea:	4857      	ldr	r0, [pc, #348]	; (209548 <main+0x668>)
  2093ec:	f7ff fa10 	bl	208810 <chThdCreateStatic.constprop.61>
  /*
   * Normal main() thread activity, spawning shells.
   */
  while (true) {
    if (PORTAB_SDU1.config->usbp->state == USB_ACTIVE) {
      thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
  2093f0:	4d56      	ldr	r5, [pc, #344]	; (20954c <main+0x66c>)
  2093f2:	e003      	b.n	2093fc <main+0x51c>
                                              "shell", NORMALPRIO + 1,
                                              shellThread, (void *)&shell_cfg1);
      chThdWait(shelltp);               /* Waiting termination.             */
    }
    chThdSleepMilliseconds(1000);
  2093f4:	f242 7010 	movw	r0, #10000	; 0x2710
  2093f8:	f7fe fb5a 	bl	207ab0 <chThdSleep>
    if (PORTAB_SDU1.config->usbp->state == USB_ACTIVE) {
  2093fc:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
  209400:	681b      	ldr	r3, [r3, #0]
  209402:	781b      	ldrb	r3, [r3, #0]
  209404:	2b04      	cmp	r3, #4
  209406:	d1f5      	bne.n	2093f4 <main+0x514>
      thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
  209408:	2381      	movs	r3, #129	; 0x81
  20940a:	462a      	mov	r2, r5
  20940c:	f640 01c8 	movw	r1, #2248	; 0x8c8
  209410:	9701      	str	r7, [sp, #4]
  209412:	9600      	str	r6, [sp, #0]
  209414:	2000      	movs	r0, #0
  209416:	f7fd f823 	bl	206460 <chThdCreateFromHeap>
      chThdWait(shelltp);               /* Waiting termination.             */
  20941a:	f7ff fd21 	bl	208e60 <chThdWait>
  20941e:	e7e9      	b.n	2093f4 <main+0x514>
  209420:	484b      	ldr	r0, [pc, #300]	; (209550 <main+0x670>)
  209422:	f7f7 fba5 	bl	200b70 <chSysHalt>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
  209426:	484b      	ldr	r0, [pc, #300]	; (209554 <main+0x674>)
  209428:	f7f7 fba2 	bl	200b70 <chSysHalt>
  20942c:	484a      	ldr	r0, [pc, #296]	; (209558 <main+0x678>)
  20942e:	f7f7 fb9f 	bl	200b70 <chSysHalt>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
  209432:	484a      	ldr	r0, [pc, #296]	; (20955c <main+0x67c>)
  209434:	f7f7 fb9c 	bl	200b70 <chSysHalt>
      rccEnableOTG_HS(true);
  209438:	4b49      	ldr	r3, [pc, #292]	; (209560 <main+0x680>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20943a:	f44f 5700 	mov.w	r7, #8192	; 0x2000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20943e:	f04f 0ce0 	mov.w	ip, #224	; 0xe0
      otgp->DCFG = 0x02200000 | DCFG_DSPD_HS;
  209442:	f04f 7e08 	mov.w	lr, #35651584	; 0x2200000
      rccEnableOTG_HS(true);
  209446:	6b19      	ldr	r1, [r3, #48]	; 0x30
  209448:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
  20944c:	6319      	str	r1, [r3, #48]	; 0x30
  20944e:	6d19      	ldr	r1, [r3, #80]	; 0x50
  209450:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
  209454:	6519      	str	r1, [r3, #80]	; 0x50
      rccResetOTG_HS();
  209456:	6919      	ldr	r1, [r3, #16]
  209458:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
  20945c:	6119      	str	r1, [r3, #16]
  20945e:	611a      	str	r2, [r3, #16]
      rccEnableOTG_HSULPI(true);
  209460:	6b19      	ldr	r1, [r3, #48]	; 0x30
  209462:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
  209466:	6319      	str	r1, [r3, #48]	; 0x30
  209468:	6d18      	ldr	r0, [r3, #80]	; 0x50
  20946a:	493e      	ldr	r1, [pc, #248]	; (209564 <main+0x684>)
  20946c:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
  209470:	6518      	str	r0, [r3, #80]	; 0x50
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
  209472:	23c0      	movs	r3, #192	; 0xc0
  209474:	f881 c34d 	strb.w	ip, [r1, #845]	; 0x34d
  chSysPolledDelayX(cycles);
  209478:	2020      	movs	r0, #32
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20947a:	f8c1 7188 	str.w	r7, [r1, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20947e:	608f      	str	r7, [r1, #8]
  stm32_otg_t *otgp = usbp->otg;
  209480:	f8d6 7090 	ldr.w	r7, [r6, #144]	; 0x90
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_HS) |
  209484:	4938      	ldr	r1, [pc, #224]	; (209568 <main+0x688>)
  209486:	60f9      	str	r1, [r7, #12]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_HS;
  209488:	f8c7 e800 	str.w	lr, [r7, #2048]	; 0x800
    otgp->PCGCCTL = 0;
  20948c:	f8c7 2e00 	str.w	r2, [r7, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
  209490:	603b      	str	r3, [r7, #0]
      otgp->GCCFG = 0;
  209492:	63ba      	str	r2, [r7, #56]	; 0x38
  209494:	f7f7 fb5c 	bl	200b50 <chSysPolledDelayX>
  otgp->GRSTCTL = GRSTCTL_CSRST;
  209498:	f8c7 8010 	str.w	r8, [r7, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
  20949c:	693b      	ldr	r3, [r7, #16]
  20949e:	f013 0801 	ands.w	r8, r3, #1
  2094a2:	d1fb      	bne.n	20949c <main+0x5bc>
  2094a4:	2012      	movs	r0, #18
  2094a6:	f7f7 fb53 	bl	200b50 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
  2094aa:	693b      	ldr	r3, [r7, #16]
  2094ac:	2b00      	cmp	r3, #0
  2094ae:	dafc      	bge.n	2094aa <main+0x5ca>
    otgp->GAHBCFG = 0;
  2094b0:	2200      	movs	r2, #0
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  2094b2:	f04f 30ff 	mov.w	r0, #4294967295
  2094b6:	e9d6 1324 	ldrd	r1, r3, [r6, #144]	; 0x90
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2094ba:	f8d3 c008 	ldr.w	ip, [r3, #8]
    otgp->ie[i].DIEPCTL = 0;
  2094be:	4613      	mov	r3, r2
    otgp->GAHBCFG = 0;
  2094c0:	60ba      	str	r2, [r7, #8]
  2094c2:	eb01 1248 	add.w	r2, r1, r8, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2094c6:	f108 0801 	add.w	r8, r8, #1
  2094ca:	45e0      	cmp	r8, ip
    otgp->ie[i].DIEPCTL = 0;
  2094cc:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
  2094d0:	f8c2 3910 	str.w	r3, [r2, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  2094d4:	f8c2 0908 	str.w	r0, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
  2094d8:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
  2094dc:	f8c2 3b10 	str.w	r3, [r2, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  2094e0:	f8c2 0b08 	str.w	r0, [r2, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2094e4:	d9ed      	bls.n	2094c2 <main+0x5e2>
    if (usbp->config->sof_cb == NULL)
  2094e6:	6872      	ldr	r2, [r6, #4]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  2094e8:	f04f 1001 	mov.w	r0, #65537	; 0x10001
    if (usbp->config->sof_cb == NULL)
  2094ec:	68d2      	ldr	r2, [r2, #12]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  2094ee:	f8c1 081c 	str.w	r0, [r1, #2076]	; 0x81c
    otgp->DIEPMSK  = 0;
  2094f2:	f8c7 3810 	str.w	r3, [r7, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
  2094f6:	f8c7 3814 	str.w	r3, [r7, #2068]	; 0x814
    otgp->DAINTMSK = 0;
  2094fa:	f8c7 381c 	str.w	r3, [r7, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
  2094fe:	b162      	cbz	r2, 20951a <main+0x63a>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
  209500:	4b1a      	ldr	r3, [pc, #104]	; (20956c <main+0x68c>)
  209502:	61bb      	str	r3, [r7, #24]
    otgp->GINTSTS  = 0xFFFFFFFF;
  209504:	f04f 33ff 	mov.w	r3, #4294967295
  209508:	617b      	str	r3, [r7, #20]
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
  20950a:	68bb      	ldr	r3, [r7, #8]
  20950c:	f043 0301 	orr.w	r3, r3, #1
  209510:	60bb      	str	r3, [r7, #8]
  209512:	e74c      	b.n	2093ae <main+0x4ce>
  209514:	4816      	ldr	r0, [pc, #88]	; (209570 <main+0x690>)
  209516:	f7f7 fb2b 	bl	200b70 <chSysHalt>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
  20951a:	4b16      	ldr	r3, [pc, #88]	; (209574 <main+0x694>)
  20951c:	61bb      	str	r3, [r7, #24]
  20951e:	e7f1      	b.n	209504 <main+0x624>
  209520:	20001698 	.word	0x20001698
  209524:	0800c584 	.word	0x0800c584
  209528:	40022000 	.word	0x40022000
  20952c:	20000800 	.word	0x20000800
  209530:	0800dcd8 	.word	0x0800dcd8
  209534:	0800e824 	.word	0x0800e824
  209538:	20001850 	.word	0x20001850
  20953c:	0800dd50 	.word	0x0800dd50
  209540:	002045e1 	.word	0x002045e1
  209544:	00207b01 	.word	0x00207b01
  209548:	20001fc8 	.word	0x20001fc8
  20954c:	0800c59c 	.word	0x0800c59c
  209550:	0800bc04 	.word	0x0800bc04
  209554:	0800c014 	.word	0x0800c014
  209558:	0800bbec 	.word	0x0800bbec
  20955c:	0800c094 	.word	0x0800c094
  209560:	40023800 	.word	0x40023800
  209564:	e000e100 	.word	0xe000e100
  209568:	40002700 	.word	0x40002700
  20956c:	c0303c08 	.word	0xc0303c08
  209570:	0800bd20 	.word	0x0800bd20
  209574:	c0303c00 	.word	0xc0303c00
  209578:	00201ea1 	.word	0x00201ea1
  20957c:	0800e928 	.word	0x0800e928
  209580:	00201fc1 	.word	0x00201fc1
	...

00209590 <rt_test_010_005_execute>:
static void rt_test_010_005_execute(void) {
  209590:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
  209594:	4b17      	ldr	r3, [pc, #92]	; (2095f4 <rt_test_010_005_execute+0x64>)
  test_set_step(1);
  209596:	2201      	movs	r2, #1
  209598:	f8df 9068 	ldr.w	r9, [pc, #104]	; 209604 <rt_test_010_005_execute+0x74>
    n = 0;
  20959c:	2400      	movs	r4, #0
  return chThdGetSelfX()->prio;
  20959e:	699b      	ldr	r3, [r3, #24]
  test_set_step(1);
  2095a0:	f8c9 2000 	str.w	r2, [r9]
  tprio_t prio = chThdGetPriorityX() - 1;
  2095a4:	689d      	ldr	r5, [r3, #8]
    start = test_wait_tick();
  2095a6:	f7fe fc33 	bl	207e10 <test_wait_tick>
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  2095aa:	f8df 805c 	ldr.w	r8, [pc, #92]	; 209608 <rt_test_010_005_execute+0x78>
    start = test_wait_tick();
  2095ae:	4606      	mov	r6, r0
  tprio_t prio = chThdGetPriorityX() - 1;
  2095b0:	3d01      	subs	r5, #1
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  2095b2:	4f11      	ldr	r7, [pc, #68]	; (2095f8 <rt_test_010_005_execute+0x68>)
  2095b4:	2300      	movs	r3, #0
  2095b6:	4642      	mov	r2, r8
  2095b8:	4629      	mov	r1, r5
  2095ba:	4638      	mov	r0, r7
  2095bc:	f7ff f928 	bl	208810 <chThdCreateStatic.constprop.61>
      n++;
  2095c0:	3401      	adds	r4, #1
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
  2095c2:	f7ff fc4d 	bl	208e60 <chThdWait>
  2095c6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
  2095ca:	f242 720f 	movw	r2, #9999	; 0x270f
  2095ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  2095d0:	1b9b      	subs	r3, r3, r6
  2095d2:	4293      	cmp	r3, r2
  2095d4:	d9ee      	bls.n	2095b4 <rt_test_010_005_execute+0x24>
  test_set_step(2);
  2095d6:	2302      	movs	r3, #2
    test_print("--- Score : ");
  2095d8:	4808      	ldr	r0, [pc, #32]	; (2095fc <rt_test_010_005_execute+0x6c>)
  test_set_step(2);
  2095da:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
  2095de:	f7f7 f977 	bl	2008d0 <test_print>
    test_printn(n);
  2095e2:	4620      	mov	r0, r4
  2095e4:	f7f7 f944 	bl	200870 <test_printn>
    test_println(" threads/S");
  2095e8:	4805      	ldr	r0, [pc, #20]	; (209600 <rt_test_010_005_execute+0x70>)
}
  2095ea:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" threads/S");
  2095ee:	f7f7 b94f 	b.w	200890 <test_println>
  2095f2:	bf00      	nop
  2095f4:	20000dc8 	.word	0x20000dc8
  2095f8:	20001858 	.word	0x20001858
  2095fc:	0800daac 	.word	0x0800daac
  209600:	0800da14 	.word	0x0800da14
  209604:	20001f6c 	.word	0x20001f6c
  209608:	00208631 	.word	0x00208631
  20960c:	00000000 	.word	0x00000000

00209610 <test_wait_threads>:
void test_wait_threads(void) {
  209610:	b570      	push	{r4, r5, r6, lr}
  209612:	4c07      	ldr	r4, [pc, #28]	; (209630 <test_wait_threads+0x20>)
      threads[i] = NULL;
  209614:	2600      	movs	r6, #0
  209616:	f104 0514 	add.w	r5, r4, #20
    if (threads[i] != NULL) {
  20961a:	f854 3b04 	ldr.w	r3, [r4], #4
      chThdWait(threads[i]);
  20961e:	4618      	mov	r0, r3
    if (threads[i] != NULL) {
  209620:	b11b      	cbz	r3, 20962a <test_wait_threads+0x1a>
      chThdWait(threads[i]);
  209622:	f7ff fc1d 	bl	208e60 <chThdWait>
      threads[i] = NULL;
  209626:	f844 6c04 	str.w	r6, [r4, #-4]
  for (i = 0; i < MAX_THREADS; i++)
  20962a:	42ac      	cmp	r4, r5
  20962c:	d1f5      	bne.n	20961a <test_wait_threads+0xa>
}
  20962e:	bd70      	pop	{r4, r5, r6, pc}
  209630:	20001f84 	.word	0x20001f84
	...

00209640 <rt_test_010_008_execute>:
static void rt_test_010_008_execute(void) {
  209640:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  209644:	b083      	sub	sp, #12
  return ch.rlist.current;
  209646:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 20971c <rt_test_010_008_execute+0xdc>
  test_set_step(1);
  20964a:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 209720 <rt_test_010_008_execute+0xe0>
  20964e:	2201      	movs	r2, #1
    n = 0;
  209650:	ac02      	add	r4, sp, #8
  209652:	2300      	movs	r3, #0
  test_set_step(1);
  209654:	f8c9 2000 	str.w	r2, [r9]
    n = 0;
  209658:	f844 3d04 	str.w	r3, [r4, #-4]!
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  20965c:	f7fe fbd8 	bl	207e10 <test_wait_tick>
  return chThdGetSelfX()->prio;
  209660:	f8d8 2018 	ldr.w	r2, [r8, #24]
  209664:	4623      	mov	r3, r4
  209666:	4f28      	ldr	r7, [pc, #160]	; (209708 <rt_test_010_008_execute+0xc8>)
  209668:	4e28      	ldr	r6, [pc, #160]	; (20970c <rt_test_010_008_execute+0xcc>)
  20966a:	6891      	ldr	r1, [r2, #8]
  20966c:	463a      	mov	r2, r7
  20966e:	4630      	mov	r0, r6
  209670:	4d27      	ldr	r5, [pc, #156]	; (209710 <rt_test_010_008_execute+0xd0>)
  209672:	3901      	subs	r1, #1
  209674:	f7ff f8cc 	bl	208810 <chThdCreateStatic.constprop.61>
  209678:	f8d8 2018 	ldr.w	r2, [r8, #24]
  20967c:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  20967e:	4623      	mov	r3, r4
  209680:	6891      	ldr	r1, [r2, #8]
  209682:	f506 70a4 	add.w	r0, r6, #328	; 0x148
  209686:	463a      	mov	r2, r7
  209688:	3901      	subs	r1, #1
  20968a:	f7ff f8c1 	bl	208810 <chThdCreateStatic.constprop.61>
  20968e:	f8d8 2018 	ldr.w	r2, [r8, #24]
  209692:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  209694:	4623      	mov	r3, r4
  209696:	6891      	ldr	r1, [r2, #8]
  209698:	f506 7024 	add.w	r0, r6, #656	; 0x290
  20969c:	463a      	mov	r2, r7
  20969e:	3901      	subs	r1, #1
  2096a0:	f7ff f8b6 	bl	208810 <chThdCreateStatic.constprop.61>
  2096a4:	f8d8 2018 	ldr.w	r2, [r8, #24]
  2096a8:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  2096aa:	4623      	mov	r3, r4
  2096ac:	6891      	ldr	r1, [r2, #8]
  2096ae:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
  2096b2:	463a      	mov	r2, r7
  2096b4:	3901      	subs	r1, #1
  2096b6:	f7ff f8ab 	bl	208810 <chThdCreateStatic.constprop.61>
  2096ba:	f8d8 2018 	ldr.w	r2, [r8, #24]
  2096be:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  2096c0:	4623      	mov	r3, r4
  2096c2:	6891      	ldr	r1, [r2, #8]
  2096c4:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
  2096c8:	463a      	mov	r2, r7
  2096ca:	3901      	subs	r1, #1
  2096cc:	f7ff f8a0 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(2);
  2096d0:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  2096d2:	6128      	str	r0, [r5, #16]
    chThdSleepSeconds(1);
  2096d4:	f242 7010 	movw	r0, #10000	; 0x2710
  test_set_step(2);
  2096d8:	f8c9 3000 	str.w	r3, [r9]
    chThdSleepSeconds(1);
  2096dc:	f7fe f9e8 	bl	207ab0 <chThdSleep>
    test_terminate_threads();
  2096e0:	f7fb fb1e 	bl	204d20 <test_terminate_threads>
    test_wait_threads();
  2096e4:	f7ff ff94 	bl	209610 <test_wait_threads>
  test_set_step(3);
  2096e8:	2303      	movs	r3, #3
    test_print("--- Score : ");
  2096ea:	480a      	ldr	r0, [pc, #40]	; (209714 <rt_test_010_008_execute+0xd4>)
  test_set_step(3);
  2096ec:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
  2096f0:	f7f7 f8ee 	bl	2008d0 <test_print>
    test_printn(n);
  2096f4:	9801      	ldr	r0, [sp, #4]
  2096f6:	f7f7 f8bb 	bl	200870 <test_printn>
    test_println(" ctxswc/S");
  2096fa:	4807      	ldr	r0, [pc, #28]	; (209718 <rt_test_010_008_execute+0xd8>)
  2096fc:	f7f7 f8c8 	bl	200890 <test_println>
}
  209700:	b003      	add	sp, #12
  209702:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  209706:	bf00      	nop
  209708:	00207a81 	.word	0x00207a81
  20970c:	20001858 	.word	0x20001858
  209710:	20001f84 	.word	0x20001f84
  209714:	0800daac 	.word	0x0800daac
  209718:	0800da54 	.word	0x0800da54
  20971c:	20000dc8 	.word	0x20000dc8
  209720:	20001f6c 	.word	0x20001f6c
	...

00209730 <rt_test_010_007_execute>:
static void rt_test_010_007_execute(void) {
  209730:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
  209734:	4e34      	ldr	r6, [pc, #208]	; (209808 <rt_test_010_007_execute+0xd8>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
  209736:	2300      	movs	r3, #0
  test_set_step(1);
  209738:	2501      	movs	r5, #1
  20973a:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 209838 <rt_test_010_007_execute+0x108>
  return chThdGetSelfX()->prio;
  20973e:	69b1      	ldr	r1, [r6, #24]
    n = 0;
  209740:	461c      	mov	r4, r3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
  209742:	4a32      	ldr	r2, [pc, #200]	; (20980c <rt_test_010_007_execute+0xdc>)
  209744:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
  209748:	6889      	ldr	r1, [r1, #8]
  20974a:	4831      	ldr	r0, [pc, #196]	; (209810 <rt_test_010_007_execute+0xe0>)
  20974c:	3105      	adds	r1, #5
  test_set_step(1);
  20974e:	f8c8 5000 	str.w	r5, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
  209752:	f7ff f85d 	bl	208810 <chThdCreateStatic.constprop.61>
  209756:	69b2      	ldr	r2, [r6, #24]
  209758:	4d2e      	ldr	r5, [pc, #184]	; (209814 <rt_test_010_007_execute+0xe4>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
  20975a:	4623      	mov	r3, r4
  20975c:	6891      	ldr	r1, [r2, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
  20975e:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
  209760:	3104      	adds	r1, #4
  209762:	4a2a      	ldr	r2, [pc, #168]	; (20980c <rt_test_010_007_execute+0xdc>)
  209764:	482c      	ldr	r0, [pc, #176]	; (209818 <rt_test_010_007_execute+0xe8>)
  209766:	f7ff f853 	bl	208810 <chThdCreateStatic.constprop.61>
  20976a:	69b2      	ldr	r2, [r6, #24]
  20976c:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
  20976e:	4623      	mov	r3, r4
  209770:	6891      	ldr	r1, [r2, #8]
  209772:	482a      	ldr	r0, [pc, #168]	; (20981c <rt_test_010_007_execute+0xec>)
  209774:	4a25      	ldr	r2, [pc, #148]	; (20980c <rt_test_010_007_execute+0xdc>)
  209776:	3103      	adds	r1, #3
  209778:	f7ff f84a 	bl	208810 <chThdCreateStatic.constprop.61>
  20977c:	69b2      	ldr	r2, [r6, #24]
  20977e:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
  209780:	4623      	mov	r3, r4
  209782:	6891      	ldr	r1, [r2, #8]
  209784:	4826      	ldr	r0, [pc, #152]	; (209820 <rt_test_010_007_execute+0xf0>)
  209786:	4a21      	ldr	r2, [pc, #132]	; (20980c <rt_test_010_007_execute+0xdc>)
  209788:	3102      	adds	r1, #2
  20978a:	f7ff f841 	bl	208810 <chThdCreateStatic.constprop.61>
  20978e:	69b2      	ldr	r2, [r6, #24]
  209790:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
  209792:	4623      	mov	r3, r4
  209794:	6891      	ldr	r1, [r2, #8]
  209796:	4823      	ldr	r0, [pc, #140]	; (209824 <rt_test_010_007_execute+0xf4>)
  209798:	4a1c      	ldr	r2, [pc, #112]	; (20980c <rt_test_010_007_execute+0xdc>)
  20979a:	3101      	adds	r1, #1
  20979c:	f7ff f838 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(2);
  2097a0:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
  2097a2:	6128      	str	r0, [r5, #16]
  test_set_step(2);
  2097a4:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
  2097a8:	f7fe fb32 	bl	207e10 <test_wait_tick>
      chSemReset(&sem1, 0);
  2097ac:	4d1e      	ldr	r5, [pc, #120]	; (209828 <rt_test_010_007_execute+0xf8>)
    start = test_wait_tick();
  2097ae:	4606      	mov	r6, r0
      chSemReset(&sem1, 0);
  2097b0:	2100      	movs	r1, #0
  2097b2:	4628      	mov	r0, r5
  2097b4:	f7fe f80c 	bl	2077d0 <chSemReset>
  2097b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    } while (chVTIsSystemTimeWithinX(start, end));
  2097ba:	f242 720f 	movw	r2, #9999	; 0x270f
      n++;
  2097be:	3401      	adds	r4, #1
  2097c0:	1b9b      	subs	r3, r3, r6
    } while (chVTIsSystemTimeWithinX(start, end));
  2097c2:	4293      	cmp	r3, r2
  2097c4:	d9f4      	bls.n	2097b0 <rt_test_010_007_execute+0x80>
  test_set_step(3);
  2097c6:	2303      	movs	r3, #3
  2097c8:	f8c8 3000 	str.w	r3, [r8]
    test_terminate_threads();
  2097cc:	f7fb faa8 	bl	204d20 <test_terminate_threads>
    chSemReset(&sem1, 0);
  2097d0:	2100      	movs	r1, #0
  2097d2:	4815      	ldr	r0, [pc, #84]	; (209828 <rt_test_010_007_execute+0xf8>)
  2097d4:	f7fd fffc 	bl	2077d0 <chSemReset>
    test_wait_threads();
  2097d8:	f7ff ff1a 	bl	209610 <test_wait_threads>
  test_set_step(4);
  2097dc:	2304      	movs	r3, #4
    test_print("--- Score : ");
  2097de:	4813      	ldr	r0, [pc, #76]	; (20982c <rt_test_010_007_execute+0xfc>)
  test_set_step(4);
  2097e0:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
  2097e4:	f7f7 f874 	bl	2008d0 <test_print>
    test_printn(n);
  2097e8:	4620      	mov	r0, r4
    test_printn(n * 6);
  2097ea:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    test_printn(n);
  2097ee:	f7f7 f83f 	bl	200870 <test_printn>
    test_print(" reschedules/S, ");
  2097f2:	480f      	ldr	r0, [pc, #60]	; (209830 <rt_test_010_007_execute+0x100>)
  2097f4:	f7f7 f86c 	bl	2008d0 <test_print>
    test_printn(n * 6);
  2097f8:	0060      	lsls	r0, r4, #1
  2097fa:	f7f7 f839 	bl	200870 <test_printn>
    test_println(" ctxswc/S");
  2097fe:	480d      	ldr	r0, [pc, #52]	; (209834 <rt_test_010_007_execute+0x104>)
}
  209800:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" ctxswc/S");
  209804:	f7f7 b844 	b.w	200890 <test_println>
  209808:	20000dc8 	.word	0x20000dc8
  20980c:	00207761 	.word	0x00207761
  209810:	20001858 	.word	0x20001858
  209814:	20001f84 	.word	0x20001f84
  209818:	200019a0 	.word	0x200019a0
  20981c:	20001ae8 	.word	0x20001ae8
  209820:	20001c30 	.word	0x20001c30
  209824:	20001d78 	.word	0x20001d78
  209828:	20001844 	.word	0x20001844
  20982c:	0800daac 	.word	0x0800daac
  209830:	0800da30 	.word	0x0800da30
  209834:	0800da54 	.word	0x0800da54
  209838:	20001f6c 	.word	0x20001f6c
  20983c:	00000000 	.word	0x00000000

00209840 <rt_test_010_004_execute>:
static void rt_test_010_004_execute(void) {
  209840:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return ch.rlist.current;
  209844:	4d3a      	ldr	r5, [pc, #232]	; (209930 <rt_test_010_004_execute+0xf0>)
  test_set_step(1);
  209846:	2001      	movs	r0, #1
  209848:	f8df 8100 	ldr.w	r8, [pc, #256]	; 20994c <rt_test_010_004_execute+0x10c>
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
  20984c:	2300      	movs	r3, #0
  return chThdGetSelfX()->prio;
  20984e:	69a9      	ldr	r1, [r5, #24]
  209850:	2720      	movs	r7, #32
  209852:	4a38      	ldr	r2, [pc, #224]	; (209934 <rt_test_010_004_execute+0xf4>)
    n = 0;
  209854:	461e      	mov	r6, r3
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
  209856:	6889      	ldr	r1, [r1, #8]
      chSchWakeupS(tp, MSG_OK);
  209858:	469b      	mov	fp, r3
  test_set_step(1);
  20985a:	f8c8 0000 	str.w	r0, [r8]
  20985e:	f04f 4a80 	mov.w	sl, #1073741824	; 0x40000000
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
  209862:	4401      	add	r1, r0
  209864:	4834      	ldr	r0, [pc, #208]	; (209938 <rt_test_010_004_execute+0xf8>)
  209866:	f7fe ffd3 	bl	208810 <chThdCreateStatic.constprop.61>
  20986a:	4a34      	ldr	r2, [pc, #208]	; (20993c <rt_test_010_004_execute+0xfc>)
  test_set_step(2);
  20986c:	2302      	movs	r3, #2
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
  20986e:	4604      	mov	r4, r0
  209870:	6010      	str	r0, [r2, #0]
  test_set_step(2);
  209872:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
  209876:	f7fe facb 	bl	207e10 <test_wait_tick>
  20987a:	4681      	mov	r9, r0
  __ASM volatile ("cpsid i" : : : "memory");
  20987c:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20987e:	f387 8811 	msr	BASEPRI, r7
  __ASM volatile ("cpsie i" : : : "memory");
  209882:	b662      	cpsie	i
  _dbg_check_lock();
  209884:	f7fa fa64 	bl	203d50 <_dbg_check_lock>
      chSchWakeupS(tp, MSG_OK);
  209888:	4620      	mov	r0, r4
  20988a:	2100      	movs	r1, #0
  20988c:	f7f9 fdd0 	bl	203430 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
  209890:	4620      	mov	r0, r4
  209892:	2100      	movs	r1, #0
  209894:	f7f9 fdcc 	bl	203430 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
  209898:	4620      	mov	r0, r4
  20989a:	2100      	movs	r1, #0
  20989c:	f7f9 fdc8 	bl	203430 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
  2098a0:	4620      	mov	r0, r4
  2098a2:	2100      	movs	r1, #0
  2098a4:	f7f9 fdc4 	bl	203430 <chSchWakeupS>
  _dbg_check_unlock();
  2098a8:	f7fa fa02 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2098ac:	682b      	ldr	r3, [r5, #0]
  2098ae:	42ab      	cmp	r3, r5
  2098b0:	d004      	beq.n	2098bc <rt_test_010_004_execute+0x7c>
  2098b2:	69aa      	ldr	r2, [r5, #24]
  2098b4:	689b      	ldr	r3, [r3, #8]
  2098b6:	6892      	ldr	r2, [r2, #8]
  2098b8:	429a      	cmp	r2, r3
  2098ba:	d336      	bcc.n	20992a <rt_test_010_004_execute+0xea>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2098bc:	f38b 8811 	msr	BASEPRI, fp
  2098c0:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
    } while (chVTIsSystemTimeWithinX(start, end));
  2098c4:	f242 720f 	movw	r2, #9999	; 0x270f
      n += 4;
  2098c8:	3604      	adds	r6, #4
  2098ca:	eba3 0309 	sub.w	r3, r3, r9
    } while (chVTIsSystemTimeWithinX(start, end));
  2098ce:	4293      	cmp	r3, r2
  2098d0:	d9d4      	bls.n	20987c <rt_test_010_004_execute+0x3c>
  test_set_step(3);
  2098d2:	2303      	movs	r3, #3
  2098d4:	f8c8 3000 	str.w	r3, [r8]
  __ASM volatile ("cpsid i" : : : "memory");
  2098d8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2098da:	2320      	movs	r3, #32
  2098dc:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  2098e0:	b662      	cpsie	i
  _dbg_check_lock();
  2098e2:	f7fa fa35 	bl	203d50 <_dbg_check_lock>
    chSchWakeupS(tp, MSG_TIMEOUT);
  2098e6:	4620      	mov	r0, r4
  2098e8:	f04f 31ff 	mov.w	r1, #4294967295
  2098ec:	f7f9 fda0 	bl	203430 <chSchWakeupS>
  _dbg_check_unlock();
  2098f0:	f7fa f9de 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  2098f4:	682b      	ldr	r3, [r5, #0]
  2098f6:	42ab      	cmp	r3, r5
  2098f8:	d004      	beq.n	209904 <rt_test_010_004_execute+0xc4>
  2098fa:	69aa      	ldr	r2, [r5, #24]
  2098fc:	689b      	ldr	r3, [r3, #8]
  2098fe:	6892      	ldr	r2, [r2, #8]
  209900:	429a      	cmp	r2, r3
  209902:	d312      	bcc.n	20992a <rt_test_010_004_execute+0xea>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  209904:	2300      	movs	r3, #0
  209906:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
  20990a:	f7ff fe81 	bl	209610 <test_wait_threads>
  test_set_step(4);
  20990e:	2304      	movs	r3, #4
    test_print("--- Score : ");
  209910:	480b      	ldr	r0, [pc, #44]	; (209940 <rt_test_010_004_execute+0x100>)
  test_set_step(4);
  209912:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
  209916:	f7f6 ffdb 	bl	2008d0 <test_print>
    test_printn(n * 2);
  20991a:	0070      	lsls	r0, r6, #1
  20991c:	f7f6 ffa8 	bl	200870 <test_printn>
    test_println(" ctxswc/S");
  209920:	4808      	ldr	r0, [pc, #32]	; (209944 <rt_test_010_004_execute+0x104>)
}
  209922:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_println(" ctxswc/S");
  209926:	f7f6 bfb3 	b.w	200890 <test_println>
  20992a:	4807      	ldr	r0, [pc, #28]	; (209948 <rt_test_010_004_execute+0x108>)
  20992c:	f7f7 f920 	bl	200b70 <chSysHalt>
  209930:	20000dc8 	.word	0x20000dc8
  209934:	002049e1 	.word	0x002049e1
  209938:	20001858 	.word	0x20001858
  20993c:	20001f84 	.word	0x20001f84
  209940:	0800daac 	.word	0x0800daac
  209944:	0800da54 	.word	0x0800da54
  209948:	0800bcdc 	.word	0x0800bcdc
  20994c:	20001f6c 	.word	0x20001f6c

00209950 <rt_test_010_003_execute>:
static void rt_test_010_003_execute(void) {
  209950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
  209954:	4e2b      	ldr	r6, [pc, #172]	; (209a04 <rt_test_010_003_execute+0xb4>)
  test_set_step(1);
  209956:	2401      	movs	r4, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  209958:	4d2b      	ldr	r5, [pc, #172]	; (209a08 <rt_test_010_003_execute+0xb8>)
  20995a:	2300      	movs	r3, #0
  return chThdGetSelfX()->prio;
  20995c:	69b2      	ldr	r2, [r6, #24]
  test_set_step(1);
  20995e:	4f2b      	ldr	r7, [pc, #172]	; (209a0c <rt_test_010_003_execute+0xbc>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  209960:	4628      	mov	r0, r5
  209962:	6891      	ldr	r1, [r2, #8]
  209964:	4a2a      	ldr	r2, [pc, #168]	; (209a10 <rt_test_010_003_execute+0xc0>)
  209966:	4421      	add	r1, r4
  test_set_step(1);
  209968:	603c      	str	r4, [r7, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  20996a:	f7fe ff51 	bl	208810 <chThdCreateStatic.constprop.61>
  20996e:	69b3      	ldr	r3, [r6, #24]
  209970:	4c28      	ldr	r4, [pc, #160]	; (209a14 <rt_test_010_003_execute+0xc4>)
  test_set_step(2);
  209972:	f04f 0c02 	mov.w	ip, #2
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
  209976:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 209a24 <rt_test_010_003_execute+0xd4>
  20997a:	6899      	ldr	r1, [r3, #8]
  20997c:	2300      	movs	r3, #0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  20997e:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
  209980:	4642      	mov	r2, r8
  209982:	3902      	subs	r1, #2
  209984:	f505 70a4 	add.w	r0, r5, #328	; 0x148
  test_set_step(2);
  209988:	f8c7 c000 	str.w	ip, [r7]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
  20998c:	f7fe ff40 	bl	208810 <chThdCreateStatic.constprop.61>
  209990:	69b1      	ldr	r1, [r6, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
  209992:	4642      	mov	r2, r8
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
  209994:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
  209996:	2300      	movs	r3, #0
  209998:	6889      	ldr	r1, [r1, #8]
  20999a:	f505 7024 	add.w	r0, r5, #656	; 0x290
  20999e:	3903      	subs	r1, #3
  2099a0:	f7fe ff36 	bl	208810 <chThdCreateStatic.constprop.61>
  2099a4:	69b3      	ldr	r3, [r6, #24]
  2099a6:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
  2099a8:	4642      	mov	r2, r8
  2099aa:	6899      	ldr	r1, [r3, #8]
  2099ac:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
  2099b0:	2300      	movs	r3, #0
  2099b2:	3904      	subs	r1, #4
  2099b4:	f7fe ff2c 	bl	208810 <chThdCreateStatic.constprop.61>
  2099b8:	69b3      	ldr	r3, [r6, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  2099ba:	4642      	mov	r2, r8
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
  2099bc:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  2099be:	6899      	ldr	r1, [r3, #8]
  2099c0:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
  2099c4:	2300      	movs	r3, #0
  2099c6:	3905      	subs	r1, #5
  2099c8:	f7fe ff22 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(3);
  2099cc:	2303      	movs	r3, #3
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  2099ce:	6120      	str	r0, [r4, #16]
    n = msg_loop_test(threads[0]);
  2099d0:	6820      	ldr	r0, [r4, #0]
  test_set_step(3);
  2099d2:	603b      	str	r3, [r7, #0]
    n = msg_loop_test(threads[0]);
  2099d4:	f7fe fb3c 	bl	208050 <msg_loop_test>
  2099d8:	4604      	mov	r4, r0
    test_wait_threads();
  2099da:	f7ff fe19 	bl	209610 <test_wait_threads>
  test_set_step(4);
  2099de:	2304      	movs	r3, #4
    test_print("--- Score : ");
  2099e0:	480d      	ldr	r0, [pc, #52]	; (209a18 <rt_test_010_003_execute+0xc8>)
  test_set_step(4);
  2099e2:	603b      	str	r3, [r7, #0]
    test_print("--- Score : ");
  2099e4:	f7f6 ff74 	bl	2008d0 <test_print>
    test_printn(n);
  2099e8:	4620      	mov	r0, r4
  2099ea:	f7f6 ff41 	bl	200870 <test_printn>
    test_print(" msgs/S, ");
  2099ee:	480b      	ldr	r0, [pc, #44]	; (209a1c <rt_test_010_003_execute+0xcc>)
  2099f0:	f7f6 ff6e 	bl	2008d0 <test_print>
    test_printn(n << 1);
  2099f4:	0060      	lsls	r0, r4, #1
  2099f6:	f7f6 ff3b 	bl	200870 <test_printn>
    test_println(" ctxswc/S");
  2099fa:	4809      	ldr	r0, [pc, #36]	; (209a20 <rt_test_010_003_execute+0xd0>)
}
  2099fc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" ctxswc/S");
  209a00:	f7f6 bf46 	b.w	200890 <test_println>
  209a04:	20000dc8 	.word	0x20000dc8
  209a08:	20001858 	.word	0x20001858
  209a0c:	20001f6c 	.word	0x20001f6c
  209a10:	00205da1 	.word	0x00205da1
  209a14:	20001f84 	.word	0x20001f84
  209a18:	0800daac 	.word	0x0800daac
  209a1c:	0800d9d8 	.word	0x0800d9d8
  209a20:	0800da54 	.word	0x0800da54
  209a24:	00208631 	.word	0x00208631
	...

00209a30 <rt_test_010_002_execute>:
  return ch.rlist.current;
  209a30:	4a14      	ldr	r2, [pc, #80]	; (209a84 <rt_test_010_002_execute+0x54>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  209a32:	4815      	ldr	r0, [pc, #84]	; (209a88 <rt_test_010_002_execute+0x58>)
  return chThdGetSelfX()->prio;
  209a34:	6991      	ldr	r1, [r2, #24]
  209a36:	4a15      	ldr	r2, [pc, #84]	; (209a8c <rt_test_010_002_execute+0x5c>)
  209a38:	6889      	ldr	r1, [r1, #8]
static void rt_test_010_002_execute(void) {
  209a3a:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
  209a3c:	2501      	movs	r5, #1
  209a3e:	4c14      	ldr	r4, [pc, #80]	; (209a90 <rt_test_010_002_execute+0x60>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  209a40:	2300      	movs	r3, #0
  209a42:	4429      	add	r1, r5
  test_set_step(1);
  209a44:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  209a46:	f7fe fee3 	bl	208810 <chThdCreateStatic.constprop.61>
  209a4a:	4a12      	ldr	r2, [pc, #72]	; (209a94 <rt_test_010_002_execute+0x64>)
  test_set_step(2);
  209a4c:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  209a4e:	6010      	str	r0, [r2, #0]
  test_set_step(2);
  209a50:	6023      	str	r3, [r4, #0]
    n = msg_loop_test(threads[0]);
  209a52:	f7fe fafd 	bl	208050 <msg_loop_test>
  209a56:	4605      	mov	r5, r0
    test_wait_threads();
  209a58:	f7ff fdda 	bl	209610 <test_wait_threads>
  test_set_step(3);
  209a5c:	2303      	movs	r3, #3
    test_print("--- Score : ");
  209a5e:	480e      	ldr	r0, [pc, #56]	; (209a98 <rt_test_010_002_execute+0x68>)
  test_set_step(3);
  209a60:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
  209a62:	f7f6 ff35 	bl	2008d0 <test_print>
    test_printn(n);
  209a66:	4628      	mov	r0, r5
  209a68:	f7f6 ff02 	bl	200870 <test_printn>
    test_print(" msgs/S, ");
  209a6c:	480b      	ldr	r0, [pc, #44]	; (209a9c <rt_test_010_002_execute+0x6c>)
  209a6e:	f7f6 ff2f 	bl	2008d0 <test_print>
    test_printn(n << 1);
  209a72:	0068      	lsls	r0, r5, #1
  209a74:	f7f6 fefc 	bl	200870 <test_printn>
    test_println(" ctxswc/S");
  209a78:	4809      	ldr	r0, [pc, #36]	; (209aa0 <rt_test_010_002_execute+0x70>)
}
  209a7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println(" ctxswc/S");
  209a7e:	f7f6 bf07 	b.w	200890 <test_println>
  209a82:	bf00      	nop
  209a84:	20000dc8 	.word	0x20000dc8
  209a88:	20001858 	.word	0x20001858
  209a8c:	00205da1 	.word	0x00205da1
  209a90:	20001f6c 	.word	0x20001f6c
  209a94:	20001f84 	.word	0x20001f84
  209a98:	0800daac 	.word	0x0800daac
  209a9c:	0800d9d8 	.word	0x0800d9d8
  209aa0:	0800da54 	.word	0x0800da54
	...

00209ab0 <rt_test_010_001_execute>:
  return ch.rlist.current;
  209ab0:	4a14      	ldr	r2, [pc, #80]	; (209b04 <rt_test_010_001_execute+0x54>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
  209ab2:	4815      	ldr	r0, [pc, #84]	; (209b08 <rt_test_010_001_execute+0x58>)
  return chThdGetSelfX()->prio;
  209ab4:	6991      	ldr	r1, [r2, #24]
  209ab6:	4a15      	ldr	r2, [pc, #84]	; (209b0c <rt_test_010_001_execute+0x5c>)
  209ab8:	6889      	ldr	r1, [r1, #8]
static void rt_test_010_001_execute(void) {
  209aba:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
  209abc:	4c14      	ldr	r4, [pc, #80]	; (209b10 <rt_test_010_001_execute+0x60>)
  209abe:	2501      	movs	r5, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
  209ac0:	3901      	subs	r1, #1
  209ac2:	2300      	movs	r3, #0
  test_set_step(1);
  209ac4:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
  209ac6:	f7fe fea3 	bl	208810 <chThdCreateStatic.constprop.61>
  209aca:	4a12      	ldr	r2, [pc, #72]	; (209b14 <rt_test_010_001_execute+0x64>)
  test_set_step(2);
  209acc:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
  209ace:	6010      	str	r0, [r2, #0]
  test_set_step(2);
  209ad0:	6023      	str	r3, [r4, #0]
    n = msg_loop_test(threads[0]);
  209ad2:	f7fe fabd 	bl	208050 <msg_loop_test>
  209ad6:	4605      	mov	r5, r0
    test_wait_threads();
  209ad8:	f7ff fd9a 	bl	209610 <test_wait_threads>
  test_set_step(3);
  209adc:	2303      	movs	r3, #3
    test_print("--- Score : ");
  209ade:	480e      	ldr	r0, [pc, #56]	; (209b18 <rt_test_010_001_execute+0x68>)
  test_set_step(3);
  209ae0:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
  209ae2:	f7f6 fef5 	bl	2008d0 <test_print>
    test_printn(n);
  209ae6:	4628      	mov	r0, r5
  209ae8:	f7f6 fec2 	bl	200870 <test_printn>
    test_print(" msgs/S, ");
  209aec:	480b      	ldr	r0, [pc, #44]	; (209b1c <rt_test_010_001_execute+0x6c>)
  209aee:	f7f6 feef 	bl	2008d0 <test_print>
    test_printn(n << 1);
  209af2:	0068      	lsls	r0, r5, #1
  209af4:	f7f6 febc 	bl	200870 <test_printn>
    test_println(" ctxswc/S");
  209af8:	4809      	ldr	r0, [pc, #36]	; (209b20 <rt_test_010_001_execute+0x70>)
}
  209afa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println(" ctxswc/S");
  209afe:	f7f6 bec7 	b.w	200890 <test_println>
  209b02:	bf00      	nop
  209b04:	20000dc8 	.word	0x20000dc8
  209b08:	20001858 	.word	0x20001858
  209b0c:	00205da1 	.word	0x00205da1
  209b10:	20001f6c 	.word	0x20001f6c
  209b14:	20001f84 	.word	0x20001f84
  209b18:	0800daac 	.word	0x0800daac
  209b1c:	0800d9d8 	.word	0x0800d9d8
  209b20:	0800da54 	.word	0x0800da54
	...

00209b30 <rt_test_009_002_execute>:

static void rt_test_009_002_execute(void) {
  209b30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [9.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  {
    for (i = 0; i < 4; i++)
      chPoolFree(&mp1, wa[i]);
  209b32:	493b      	ldr	r1, [pc, #236]	; (209c20 <rt_test_009_002_execute+0xf0>)
  209b34:	483b      	ldr	r0, [pc, #236]	; (209c24 <rt_test_009_002_execute+0xf4>)
  209b36:	f7fb ff43 	bl	2059c0 <chPoolFree>
  209b3a:	493b      	ldr	r1, [pc, #236]	; (209c28 <rt_test_009_002_execute+0xf8>)
  209b3c:	4839      	ldr	r0, [pc, #228]	; (209c24 <rt_test_009_002_execute+0xf4>)
  209b3e:	f7fb ff3f 	bl	2059c0 <chPoolFree>
  209b42:	493a      	ldr	r1, [pc, #232]	; (209c2c <rt_test_009_002_execute+0xfc>)
  209b44:	4837      	ldr	r0, [pc, #220]	; (209c24 <rt_test_009_002_execute+0xf4>)
  209b46:	f7fb ff3b 	bl	2059c0 <chPoolFree>
  209b4a:	4939      	ldr	r1, [pc, #228]	; (209c30 <rt_test_009_002_execute+0x100>)
  209b4c:	4835      	ldr	r0, [pc, #212]	; (209c24 <rt_test_009_002_execute+0xf4>)
  209b4e:	f7fb ff37 	bl	2059c0 <chPoolFree>
  return ch.rlist.current;
  209b52:	4a38      	ldr	r2, [pc, #224]	; (209c34 <rt_test_009_002_execute+0x104>)
  {
    prio = chThdGetPriorityX();
  }

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
  209b54:	2303      	movs	r3, #3
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
  209b56:	4c38      	ldr	r4, [pc, #224]	; (209c38 <rt_test_009_002_execute+0x108>)
  return chThdGetSelfX()->prio;
  209b58:	6992      	ldr	r2, [r2, #24]
  test_set_step(3);
  209b5a:	4e38      	ldr	r6, [pc, #224]	; (209c3c <rt_test_009_002_execute+0x10c>)
  209b5c:	6895      	ldr	r5, [r2, #8]
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
  209b5e:	4838      	ldr	r0, [pc, #224]	; (209c40 <rt_test_009_002_execute+0x110>)
  209b60:	1e69      	subs	r1, r5, #1
  209b62:	4a38      	ldr	r2, [pc, #224]	; (209c44 <rt_test_009_002_execute+0x114>)
  test_set_step(3);
  209b64:	6033      	str	r3, [r6, #0]
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
  209b66:	f7fb ffab 	bl	205ac0 <chThdCreateFromMemoryPool.constprop.31>
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
  209b6a:	1ea9      	subs	r1, r5, #2
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
  209b6c:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
  209b6e:	4a36      	ldr	r2, [pc, #216]	; (209c48 <rt_test_009_002_execute+0x118>)
  209b70:	4836      	ldr	r0, [pc, #216]	; (209c4c <rt_test_009_002_execute+0x11c>)
  209b72:	f7fb ffa5 	bl	205ac0 <chThdCreateFromMemoryPool.constprop.31>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
  209b76:	1ee9      	subs	r1, r5, #3
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
  209b78:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
  209b7a:	4a35      	ldr	r2, [pc, #212]	; (209c50 <rt_test_009_002_execute+0x120>)
  209b7c:	4835      	ldr	r0, [pc, #212]	; (209c54 <rt_test_009_002_execute+0x124>)
  209b7e:	f7fb ff9f 	bl	205ac0 <chThdCreateFromMemoryPool.constprop.31>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
  209b82:	1f29      	subs	r1, r5, #4
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
  209b84:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
  209b86:	4a34      	ldr	r2, [pc, #208]	; (209c58 <rt_test_009_002_execute+0x128>)
  209b88:	4834      	ldr	r0, [pc, #208]	; (209c5c <rt_test_009_002_execute+0x12c>)
  209b8a:	f7fb ff99 	bl	205ac0 <chThdCreateFromMemoryPool.constprop.31>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
  209b8e:	1f69      	subs	r1, r5, #5
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
  209b90:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
  209b92:	4a33      	ldr	r2, [pc, #204]	; (209c60 <rt_test_009_002_execute+0x130>)
  209b94:	4833      	ldr	r0, [pc, #204]	; (209c64 <rt_test_009_002_execute+0x134>)
  209b96:	f7fb ff93 	bl	205ac0 <chThdCreateFromMemoryPool.constprop.31>
  }

  /* [9.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  209b9a:	2304      	movs	r3, #4
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
  209b9c:	4605      	mov	r5, r0
  {
    test_assert((threads[0] != NULL) &&
  209b9e:	6820      	ldr	r0, [r4, #0]
  test_set_step(4);
  209ba0:	6033      	str	r3, [r6, #0]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
  209ba2:	6125      	str	r5, [r4, #16]
    test_assert((threads[0] != NULL) &&
  209ba4:	b138      	cbz	r0, 209bb6 <rt_test_009_002_execute+0x86>
  209ba6:	6860      	ldr	r0, [r4, #4]
  209ba8:	b128      	cbz	r0, 209bb6 <rt_test_009_002_execute+0x86>
  209baa:	68a0      	ldr	r0, [r4, #8]
  209bac:	b118      	cbz	r0, 209bb6 <rt_test_009_002_execute+0x86>
  209bae:	68e0      	ldr	r0, [r4, #12]
  209bb0:	3000      	adds	r0, #0
  209bb2:	bf18      	it	ne
  209bb4:	2001      	movne	r0, #1
  209bb6:	492c      	ldr	r1, [pc, #176]	; (209c68 <rt_test_009_002_execute+0x138>)
  209bb8:	f7f6 fe02 	bl	2007c0 <_test_assert>
  209bbc:	b100      	cbz	r0, 209bc0 <rt_test_009_002_execute+0x90>
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  }
}
  209bbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert(threads[4] == NULL,
  209bc0:	fab5 f085 	clz	r0, r5
  209bc4:	4929      	ldr	r1, [pc, #164]	; (209c6c <rt_test_009_002_execute+0x13c>)
  209bc6:	0940      	lsrs	r0, r0, #5
  209bc8:	f7f6 fdfa 	bl	2007c0 <_test_assert>
  209bcc:	2800      	cmp	r0, #0
  209bce:	d1f6      	bne.n	209bbe <rt_test_009_002_execute+0x8e>
  test_set_step(5);
  209bd0:	2305      	movs	r3, #5
  209bd2:	6033      	str	r3, [r6, #0]
    test_wait_threads();
  209bd4:	f7ff fd1c 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
  209bd8:	4925      	ldr	r1, [pc, #148]	; (209c70 <rt_test_009_002_execute+0x140>)
  209bda:	4826      	ldr	r0, [pc, #152]	; (209c74 <rt_test_009_002_execute+0x144>)
  209bdc:	f7f6 fe90 	bl	200900 <_test_assert_sequence>
  209be0:	2800      	cmp	r0, #0
  209be2:	d1ec      	bne.n	209bbe <rt_test_009_002_execute+0x8e>
  test_set_step(6);
  209be4:	2306      	movs	r3, #6
  209be6:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
  209be8:	4f0e      	ldr	r7, [pc, #56]	; (209c24 <rt_test_009_002_execute+0xf4>)
  209bea:	4d23      	ldr	r5, [pc, #140]	; (209c78 <rt_test_009_002_execute+0x148>)
  test_set_step(6);
  209bec:	6033      	str	r3, [r6, #0]
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
  209bee:	4638      	mov	r0, r7
  209bf0:	f7fb ff36 	bl	205a60 <chPoolAlloc>
  209bf4:	3000      	adds	r0, #0
  209bf6:	4629      	mov	r1, r5
  209bf8:	bf18      	it	ne
  209bfa:	2001      	movne	r0, #1
  209bfc:	f7f6 fde0 	bl	2007c0 <_test_assert>
  209c00:	2800      	cmp	r0, #0
  209c02:	d1dc      	bne.n	209bbe <rt_test_009_002_execute+0x8e>
    for (i = 0; i < 4; i++)
  209c04:	3c01      	subs	r4, #1
  209c06:	d1f2      	bne.n	209bee <rt_test_009_002_execute+0xbe>
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  209c08:	4806      	ldr	r0, [pc, #24]	; (209c24 <rt_test_009_002_execute+0xf4>)
  209c0a:	f7fb ff29 	bl	205a60 <chPoolAlloc>
  209c0e:	fab0 f080 	clz	r0, r0
  209c12:	491a      	ldr	r1, [pc, #104]	; (209c7c <rt_test_009_002_execute+0x14c>)
  209c14:	0940      	lsrs	r0, r0, #5
}
  209c16:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  209c1a:	f7f6 bdd1 	b.w	2007c0 <_test_assert>
  209c1e:	bf00      	nop
  209c20:	20001858 	.word	0x20001858
  209c24:	20001808 	.word	0x20001808
  209c28:	200019a0 	.word	0x200019a0
  209c2c:	20001ae8 	.word	0x20001ae8
  209c30:	20001c30 	.word	0x20001c30
  209c34:	20000dc8 	.word	0x20000dc8
  209c38:	20001f84 	.word	0x20001f84
  209c3c:	20001f6c 	.word	0x20001f6c
  209c40:	0800d924 	.word	0x0800d924
  209c44:	0800d6e8 	.word	0x0800d6e8
  209c48:	0800d6ec 	.word	0x0800d6ec
  209c4c:	0800d92c 	.word	0x0800d92c
  209c50:	0800d934 	.word	0x0800d934
  209c54:	0800d938 	.word	0x0800d938
  209c58:	0800e68c 	.word	0x0800e68c
  209c5c:	0800d940 	.word	0x0800d940
  209c60:	0800d774 	.word	0x0800d774
  209c64:	0800d948 	.word	0x0800d948
  209c68:	0800d950 	.word	0x0800d950
  209c6c:	0800d968 	.word	0x0800d968
  209c70:	0800d7d4 	.word	0x0800d7d4
  209c74:	0800c688 	.word	0x0800c688
  209c78:	0800d984 	.word	0x0800d984
  209c7c:	0800d994 	.word	0x0800d994

00209c80 <rt_test_009_001_execute>:
  return ch.rlist.current;
  209c80:	494a      	ldr	r1, [pc, #296]	; (209dac <rt_test_009_001_execute+0x12c>)
  test_set_step(2);
  209c82:	2302      	movs	r3, #2
    n1 = chHeapStatus(&heap1, &total1, &largest1);
  209c84:	484a      	ldr	r0, [pc, #296]	; (209db0 <rt_test_009_001_execute+0x130>)
static void rt_test_009_001_execute(void) {
  209c86:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  209c8a:	b086      	sub	sp, #24
  return chThdGetSelfX()->prio;
  209c8c:	698d      	ldr	r5, [r1, #24]
  test_set_step(2);
  209c8e:	4c49      	ldr	r4, [pc, #292]	; (209db4 <rt_test_009_001_execute+0x134>)
    n1 = chHeapStatus(&heap1, &total1, &largest1);
  209c90:	a905      	add	r1, sp, #20
  209c92:	aa04      	add	r2, sp, #16
  209c94:	68ae      	ldr	r6, [r5, #8]
  test_set_step(2);
  209c96:	6023      	str	r3, [r4, #0]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
  209c98:	f7fc ffea 	bl	206c70 <chHeapStatus>
  209c9c:	4605      	mov	r5, r0
    test_assert(n1 == 1, "heap fragmented");
  209c9e:	f1a0 0001 	sub.w	r0, r0, #1
  209ca2:	4945      	ldr	r1, [pc, #276]	; (209db8 <rt_test_009_001_execute+0x138>)
  209ca4:	fab0 f080 	clz	r0, r0
  209ca8:	0940      	lsrs	r0, r0, #5
  209caa:	f7f6 fd89 	bl	2007c0 <_test_assert>
  209cae:	b110      	cbz	r0, 209cb6 <rt_test_009_001_execute+0x36>
}
  209cb0:	b006      	add	sp, #24
  209cb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    threads[0] = chThdCreateFromHeap(&heap1,
  209cb6:	4a41      	ldr	r2, [pc, #260]	; (209dbc <rt_test_009_001_execute+0x13c>)
  test_set_step(3);
  209cb8:	2703      	movs	r7, #3
    threads[0] = chThdCreateFromHeap(&heap1,
  209cba:	f8df 8138 	ldr.w	r8, [pc, #312]	; 209df4 <rt_test_009_001_execute+0x174>
  209cbe:	1e73      	subs	r3, r6, #1
  209cc0:	9201      	str	r2, [sp, #4]
  209cc2:	f44f 71a4 	mov.w	r1, #328	; 0x148
  209cc6:	f8cd 8000 	str.w	r8, [sp]
  209cca:	4a3d      	ldr	r2, [pc, #244]	; (209dc0 <rt_test_009_001_execute+0x140>)
  209ccc:	4838      	ldr	r0, [pc, #224]	; (209db0 <rt_test_009_001_execute+0x130>)
  test_set_step(3);
  209cce:	6027      	str	r7, [r4, #0]
    threads[0] = chThdCreateFromHeap(&heap1,
  209cd0:	f7fc fbc6 	bl	206460 <chThdCreateFromHeap>
  209cd4:	4603      	mov	r3, r0
    test_assert(threads[0] != NULL, "thread creation failed");
  209cd6:	3000      	adds	r0, #0
    threads[0] = chThdCreateFromHeap(&heap1,
  209cd8:	4f3a      	ldr	r7, [pc, #232]	; (209dc4 <rt_test_009_001_execute+0x144>)
    test_assert(threads[0] != NULL, "thread creation failed");
  209cda:	bf18      	it	ne
  209cdc:	2001      	movne	r0, #1
  209cde:	493a      	ldr	r1, [pc, #232]	; (209dc8 <rt_test_009_001_execute+0x148>)
    threads[0] = chThdCreateFromHeap(&heap1,
  209ce0:	603b      	str	r3, [r7, #0]
    test_assert(threads[0] != NULL, "thread creation failed");
  209ce2:	f7f6 fd6d 	bl	2007c0 <_test_assert>
  209ce6:	2800      	cmp	r0, #0
  209ce8:	d1e2      	bne.n	209cb0 <rt_test_009_001_execute+0x30>
    threads[1] = chThdCreateFromHeap(&heap1,
  209cea:	4a38      	ldr	r2, [pc, #224]	; (209dcc <rt_test_009_001_execute+0x14c>)
  test_set_step(4);
  209cec:	f04f 0c04 	mov.w	ip, #4
    threads[1] = chThdCreateFromHeap(&heap1,
  209cf0:	1eb3      	subs	r3, r6, #2
  209cf2:	f44f 71a4 	mov.w	r1, #328	; 0x148
  209cf6:	9201      	str	r2, [sp, #4]
  209cf8:	f8cd 8000 	str.w	r8, [sp]
  209cfc:	4a34      	ldr	r2, [pc, #208]	; (209dd0 <rt_test_009_001_execute+0x150>)
  209cfe:	482c      	ldr	r0, [pc, #176]	; (209db0 <rt_test_009_001_execute+0x130>)
  test_set_step(4);
  209d00:	f8c4 c000 	str.w	ip, [r4]
    threads[1] = chThdCreateFromHeap(&heap1,
  209d04:	f7fc fbac 	bl	206460 <chThdCreateFromHeap>
  209d08:	4603      	mov	r3, r0
    test_assert(threads[1] != NULL, "thread creation failed");
  209d0a:	3000      	adds	r0, #0
  209d0c:	492e      	ldr	r1, [pc, #184]	; (209dc8 <rt_test_009_001_execute+0x148>)
  209d0e:	bf18      	it	ne
  209d10:	2001      	movne	r0, #1
    threads[1] = chThdCreateFromHeap(&heap1,
  209d12:	607b      	str	r3, [r7, #4]
    test_assert(threads[1] != NULL, "thread creation failed");
  209d14:	f7f6 fd54 	bl	2007c0 <_test_assert>
  209d18:	2800      	cmp	r0, #0
  209d1a:	d1c9      	bne.n	209cb0 <rt_test_009_001_execute+0x30>
    threads[2] = chThdCreateFromHeap(&heap1,
  209d1c:	4a2d      	ldr	r2, [pc, #180]	; (209dd4 <rt_test_009_001_execute+0x154>)
  test_set_step(5);
  209d1e:	f04f 0c05 	mov.w	ip, #5
    threads[2] = chThdCreateFromHeap(&heap1,
  209d22:	1ef3      	subs	r3, r6, #3
  209d24:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  209d28:	9201      	str	r2, [sp, #4]
  209d2a:	f8cd 8000 	str.w	r8, [sp]
  209d2e:	4a2a      	ldr	r2, [pc, #168]	; (209dd8 <rt_test_009_001_execute+0x158>)
  209d30:	481f      	ldr	r0, [pc, #124]	; (209db0 <rt_test_009_001_execute+0x130>)
  test_set_step(5);
  209d32:	f8c4 c000 	str.w	ip, [r4]
    threads[2] = chThdCreateFromHeap(&heap1,
  209d36:	f7fc fb93 	bl	206460 <chThdCreateFromHeap>
  209d3a:	4603      	mov	r3, r0
    test_assert(threads[2] == NULL, "thread creation not failed");
  209d3c:	fab0 f080 	clz	r0, r0
  209d40:	4926      	ldr	r1, [pc, #152]	; (209ddc <rt_test_009_001_execute+0x15c>)
  209d42:	0940      	lsrs	r0, r0, #5
    threads[2] = chThdCreateFromHeap(&heap1,
  209d44:	60bb      	str	r3, [r7, #8]
    test_assert(threads[2] == NULL, "thread creation not failed");
  209d46:	f7f6 fd3b 	bl	2007c0 <_test_assert>
  209d4a:	2800      	cmp	r0, #0
  209d4c:	d1b0      	bne.n	209cb0 <rt_test_009_001_execute+0x30>
  test_set_step(6);
  209d4e:	2306      	movs	r3, #6
  209d50:	6023      	str	r3, [r4, #0]
    test_wait_threads();
  209d52:	f7ff fc5d 	bl	209610 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
  209d56:	4922      	ldr	r1, [pc, #136]	; (209de0 <rt_test_009_001_execute+0x160>)
  209d58:	4822      	ldr	r0, [pc, #136]	; (209de4 <rt_test_009_001_execute+0x164>)
  209d5a:	f7f6 fdd1 	bl	200900 <_test_assert_sequence>
  209d5e:	2800      	cmp	r0, #0
  209d60:	d1a6      	bne.n	209cb0 <rt_test_009_001_execute+0x30>
  test_set_step(7);
  209d62:	2307      	movs	r3, #7
    n2 = chHeapStatus(&heap1, &total2, &largest2);
  209d64:	a903      	add	r1, sp, #12
  209d66:	aa02      	add	r2, sp, #8
  209d68:	4811      	ldr	r0, [pc, #68]	; (209db0 <rt_test_009_001_execute+0x130>)
  test_set_step(7);
  209d6a:	6023      	str	r3, [r4, #0]
    n2 = chHeapStatus(&heap1, &total2, &largest2);
  209d6c:	f7fc ff80 	bl	206c70 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
  209d70:	1a28      	subs	r0, r5, r0
  209d72:	491d      	ldr	r1, [pc, #116]	; (209de8 <rt_test_009_001_execute+0x168>)
  209d74:	fab0 f080 	clz	r0, r0
  209d78:	0940      	lsrs	r0, r0, #5
  209d7a:	f7f6 fd21 	bl	2007c0 <_test_assert>
  209d7e:	2800      	cmp	r0, #0
  209d80:	d196      	bne.n	209cb0 <rt_test_009_001_execute+0x30>
    test_assert(total1 == total2, "total free space changed");
  209d82:	9805      	ldr	r0, [sp, #20]
  209d84:	9b03      	ldr	r3, [sp, #12]
  209d86:	4919      	ldr	r1, [pc, #100]	; (209dec <rt_test_009_001_execute+0x16c>)
  209d88:	1ac0      	subs	r0, r0, r3
  209d8a:	fab0 f080 	clz	r0, r0
  209d8e:	0940      	lsrs	r0, r0, #5
  209d90:	f7f6 fd16 	bl	2007c0 <_test_assert>
  209d94:	2800      	cmp	r0, #0
  209d96:	d18b      	bne.n	209cb0 <rt_test_009_001_execute+0x30>
    test_assert(largest1 == largest2, "largest fragment size changed");
  209d98:	9804      	ldr	r0, [sp, #16]
  209d9a:	9b02      	ldr	r3, [sp, #8]
  209d9c:	4914      	ldr	r1, [pc, #80]	; (209df0 <rt_test_009_001_execute+0x170>)
  209d9e:	1ac3      	subs	r3, r0, r3
  209da0:	4258      	negs	r0, r3
  209da2:	4158      	adcs	r0, r3
  209da4:	f7f6 fd0c 	bl	2007c0 <_test_assert>
  209da8:	e782      	b.n	209cb0 <rt_test_009_001_execute+0x30>
  209daa:	bf00      	nop
  209dac:	20000dc8 	.word	0x20000dc8
  209db0:	200017dc 	.word	0x200017dc
  209db4:	20001f6c 	.word	0x20001f6c
  209db8:	0800c730 	.word	0x0800c730
  209dbc:	0800d6e8 	.word	0x0800d6e8
  209dc0:	0800d924 	.word	0x0800d924
  209dc4:	20001f84 	.word	0x20001f84
  209dc8:	0800d950 	.word	0x0800d950
  209dcc:	0800d6ec 	.word	0x0800d6ec
  209dd0:	0800d92c 	.word	0x0800d92c
  209dd4:	0800d934 	.word	0x0800d934
  209dd8:	0800d938 	.word	0x0800d938
  209ddc:	0800d968 	.word	0x0800d968
  209de0:	0800d7d4 	.word	0x0800d7d4
  209de4:	0800d8bc 	.word	0x0800d8bc
  209de8:	0800d8c0 	.word	0x0800d8c0
  209dec:	0800d8d8 	.word	0x0800d8d8
  209df0:	0800d8f4 	.word	0x0800d8f4
  209df4:	002057f1 	.word	0x002057f1
	...

00209e00 <rt_test_008_007_execute>:

static void rt_test_008_007_execute(void) {
  209e00:	b5f0      	push	{r4, r5, r6, r7, lr}
  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
  209e02:	4e2a      	ldr	r6, [pc, #168]	; (209eac <rt_test_008_007_execute+0xac>)
  209e04:	b08b      	sub	sp, #44	; 0x2c
  209e06:	4f2a      	ldr	r7, [pc, #168]	; (209eb0 <rt_test_008_007_execute+0xb0>)
  209e08:	2201      	movs	r2, #1
  209e0a:	a905      	add	r1, sp, #20
  209e0c:	4630      	mov	r0, r6
  209e0e:	f7fa f88f 	bl	203f30 <chEvtRegisterMaskWithFlags.constprop.43>
  209e12:	4669      	mov	r1, sp
  209e14:	2204      	movs	r2, #4
  209e16:	4638      	mov	r0, r7
  209e18:	f7fa f88a 	bl	203f30 <chEvtRegisterMaskWithFlags.constprop.43>
  }

  /* [8.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  209e1c:	4c25      	ldr	r4, [pc, #148]	; (209eb4 <rt_test_008_007_execute+0xb4>)
  209e1e:	2302      	movs	r3, #2
  209e20:	6023      	str	r3, [r4, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
  209e22:	f7fd fff5 	bl	207e10 <test_wait_tick>
  return ch.rlist.current;
  209e26:	4a24      	ldr	r2, [pc, #144]	; (209eb8 <rt_test_008_007_execute+0xb8>)
  209e28:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  209e2a:	4b24      	ldr	r3, [pc, #144]	; (209ebc <rt_test_008_007_execute+0xbc>)
  return chThdGetSelfX()->prio;
  209e2c:	6991      	ldr	r1, [r2, #24]
  209e2e:	4824      	ldr	r0, [pc, #144]	; (209ec0 <rt_test_008_007_execute+0xc0>)
  209e30:	6889      	ldr	r1, [r1, #8]
  209e32:	4a24      	ldr	r2, [pc, #144]	; (209ec4 <rt_test_008_007_execute+0xc4>)
  209e34:	3901      	subs	r1, #1
  209e36:	f7fe fceb 	bl	208810 <chThdCreateStatic.constprop.61>
  }

  /* [8.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
  209e3a:	2203      	movs	r2, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  209e3c:	4b22      	ldr	r3, [pc, #136]	; (209ec8 <rt_test_008_007_execute+0xc8>)
  test_set_step(3);
  209e3e:	6022      	str	r2, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  209e40:	6018      	str	r0, [r3, #0]
  {
    m = chEvtWaitAll(5);
  209e42:	f7fa f965 	bl	204110 <chEvtWaitAll.constprop.36>
    test_assert_time_window(target_time,
  209e46:	f505 7102 	add.w	r1, r5, #520	; 0x208
  209e4a:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
  209e4e:	f7f6 fc7f 	bl	200750 <_test_assert_time_window.constprop.2>
  209e52:	b108      	cbz	r0, 209e58 <rt_test_008_007_execute+0x58>
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
}
  209e54:	b00b      	add	sp, #44	; 0x2c
  209e56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  209e58:	f7fa f89a 	bl	203f90 <chEvtGetAndClearEvents.constprop.42>
    test_assert(m == 0, "stuck event");
  209e5c:	fab0 f080 	clz	r0, r0
  209e60:	491a      	ldr	r1, [pc, #104]	; (209ecc <rt_test_008_007_execute+0xcc>)
  209e62:	0940      	lsrs	r0, r0, #5
  209e64:	f7f6 fcac 	bl	2007c0 <_test_assert>
  209e68:	2800      	cmp	r0, #0
  209e6a:	d1f3      	bne.n	209e54 <rt_test_008_007_execute+0x54>
    test_wait_threads();
  209e6c:	f7ff fbd0 	bl	209610 <test_wait_threads>
  test_set_step(4);
  209e70:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el1);
  209e72:	a905      	add	r1, sp, #20
  209e74:	4630      	mov	r0, r6
  test_set_step(4);
  209e76:	6023      	str	r3, [r4, #0]
    chEvtUnregister(&es1, &el1);
  209e78:	f7fc f82a 	bl	205ed0 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
  209e7c:	4669      	mov	r1, sp
  209e7e:	4638      	mov	r0, r7
  209e80:	f7fc f826 	bl	205ed0 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
  209e84:	6830      	ldr	r0, [r6, #0]
  209e86:	4912      	ldr	r1, [pc, #72]	; (209ed0 <rt_test_008_007_execute+0xd0>)
  209e88:	1b80      	subs	r0, r0, r6
  209e8a:	fab0 f080 	clz	r0, r0
  209e8e:	0940      	lsrs	r0, r0, #5
  209e90:	f7f6 fc96 	bl	2007c0 <_test_assert>
  209e94:	2800      	cmp	r0, #0
  209e96:	d1dd      	bne.n	209e54 <rt_test_008_007_execute+0x54>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  209e98:	6838      	ldr	r0, [r7, #0]
  209e9a:	490d      	ldr	r1, [pc, #52]	; (209ed0 <rt_test_008_007_execute+0xd0>)
  209e9c:	1bc0      	subs	r0, r0, r7
  209e9e:	fab0 f080 	clz	r0, r0
  209ea2:	0940      	lsrs	r0, r0, #5
  209ea4:	f7f6 fc8c 	bl	2007c0 <_test_assert>
  209ea8:	e7d4      	b.n	209e54 <rt_test_008_007_execute+0x54>
  209eaa:	bf00      	nop
  209eac:	2001040c 	.word	0x2001040c
  209eb0:	20010410 	.word	0x20010410
  209eb4:	20001f6c 	.word	0x20001f6c
  209eb8:	20000dc8 	.word	0x20000dc8
  209ebc:	0800d6e8 	.word	0x0800d6e8
  209ec0:	20001858 	.word	0x20001858
  209ec4:	00207b51 	.word	0x00207b51
  209ec8:	20001f84 	.word	0x20001f84
  209ecc:	0800d8a0 	.word	0x0800d8a0
  209ed0:	0800d7b4 	.word	0x0800d7b4
	...

00209ee0 <rt_test_008_005_execute>:
static void rt_test_008_005_execute(void) {
  209ee0:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(5);
  209ee2:	2005      	movs	r0, #5
  test_set_step(2);
  209ee4:	4c28      	ldr	r4, [pc, #160]	; (209f88 <rt_test_008_005_execute+0xa8>)
    chEvtAddEvents(5);
  209ee6:	f7fb ffcb 	bl	205e80 <chEvtAddEvents>
  test_set_step(2);
  209eea:	2302      	movs	r3, #2
  209eec:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAll(5);
  209eee:	f7fa f90f 	bl	204110 <chEvtWaitAll.constprop.36>
    test_assert(m == 5, "unexpected pending bit");
  209ef2:	f1a0 0005 	sub.w	r0, r0, #5
  209ef6:	4925      	ldr	r1, [pc, #148]	; (209f8c <rt_test_008_005_execute+0xac>)
  209ef8:	fab0 f080 	clz	r0, r0
  209efc:	0940      	lsrs	r0, r0, #5
  209efe:	f7f6 fc5f 	bl	2007c0 <_test_assert>
  209f02:	b100      	cbz	r0, 209f06 <rt_test_008_005_execute+0x26>
}
  209f04:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  209f06:	f7fa f843 	bl	203f90 <chEvtGetAndClearEvents.constprop.42>
    test_assert(m == 0, "stuck event");
  209f0a:	fab0 f080 	clz	r0, r0
  209f0e:	4920      	ldr	r1, [pc, #128]	; (209f90 <rt_test_008_005_execute+0xb0>)
  209f10:	0940      	lsrs	r0, r0, #5
  209f12:	f7f6 fc55 	bl	2007c0 <_test_assert>
  209f16:	2800      	cmp	r0, #0
  209f18:	d1f4      	bne.n	209f04 <rt_test_008_005_execute+0x24>
    chEvtAddEvents(4);
  209f1a:	2004      	movs	r0, #4
  209f1c:	f7fb ffb0 	bl	205e80 <chEvtAddEvents>
  test_set_step(4);
  209f20:	2304      	movs	r3, #4
  209f22:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
  209f24:	f7fd ff74 	bl	207e10 <test_wait_tick>
  return ch.rlist.current;
  209f28:	4b1a      	ldr	r3, [pc, #104]	; (209f94 <rt_test_008_005_execute+0xb4>)
  209f2a:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  209f2c:	4a1a      	ldr	r2, [pc, #104]	; (209f98 <rt_test_008_005_execute+0xb8>)
  209f2e:	699b      	ldr	r3, [r3, #24]
  209f30:	481a      	ldr	r0, [pc, #104]	; (209f9c <rt_test_008_005_execute+0xbc>)
  209f32:	6899      	ldr	r1, [r3, #8]
  209f34:	3901      	subs	r1, #1
  209f36:	f7fe fc6b 	bl	208810 <chThdCreateStatic.constprop.61>
  209f3a:	4a19      	ldr	r2, [pc, #100]	; (209fa0 <rt_test_008_005_execute+0xc0>)
  test_set_step(5);
  209f3c:	2305      	movs	r3, #5
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  209f3e:	6010      	str	r0, [r2, #0]
  test_set_step(5);
  209f40:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAll(5);
  209f42:	f7fa f8e5 	bl	204110 <chEvtWaitAll.constprop.36>
    test_assert_time_window(target_time,
  209f46:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitAll(5);
  209f4a:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
  209f4c:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
  209f50:	f7f6 fbfe 	bl	200750 <_test_assert_time_window.constprop.2>
  209f54:	2800      	cmp	r0, #0
  209f56:	d1d5      	bne.n	209f04 <rt_test_008_005_execute+0x24>
    test_assert(m == 5, "event flags error");
  209f58:	f1a4 0005 	sub.w	r0, r4, #5
  209f5c:	4911      	ldr	r1, [pc, #68]	; (209fa4 <rt_test_008_005_execute+0xc4>)
  209f5e:	fab0 f080 	clz	r0, r0
  209f62:	0940      	lsrs	r0, r0, #5
  209f64:	f7f6 fc2c 	bl	2007c0 <_test_assert>
  209f68:	2800      	cmp	r0, #0
  209f6a:	d1cb      	bne.n	209f04 <rt_test_008_005_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  209f6c:	f7fa f810 	bl	203f90 <chEvtGetAndClearEvents.constprop.42>
    test_assert(m == 0, "stuck event");
  209f70:	fab0 f080 	clz	r0, r0
  209f74:	4906      	ldr	r1, [pc, #24]	; (209f90 <rt_test_008_005_execute+0xb0>)
  209f76:	0940      	lsrs	r0, r0, #5
  209f78:	f7f6 fc22 	bl	2007c0 <_test_assert>
  209f7c:	2800      	cmp	r0, #0
  209f7e:	d1c1      	bne.n	209f04 <rt_test_008_005_execute+0x24>
}
  209f80:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
  209f84:	f7ff bb44 	b.w	209610 <test_wait_threads>
  209f88:	20001f6c 	.word	0x20001f6c
  209f8c:	0800d844 	.word	0x0800d844
  209f90:	0800d8a0 	.word	0x0800d8a0
  209f94:	20000dc8 	.word	0x20000dc8
  209f98:	00207be1 	.word	0x00207be1
  209f9c:	20001858 	.word	0x20001858
  209fa0:	20001f84 	.word	0x20001f84
  209fa4:	0800d85c 	.word	0x0800d85c
	...

00209fb0 <rt_test_008_004_execute>:
static void rt_test_008_004_execute(void) {
  209fb0:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(5);
  209fb2:	2005      	movs	r0, #5
  test_set_step(2);
  209fb4:	4c27      	ldr	r4, [pc, #156]	; (20a054 <rt_test_008_004_execute+0xa4>)
    chEvtAddEvents(5);
  209fb6:	f7fb ff63 	bl	205e80 <chEvtAddEvents>
  test_set_step(2);
  209fba:	2302      	movs	r3, #2
  209fbc:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAny(ALL_EVENTS);
  209fbe:	f7fa f877 	bl	2040b0 <chEvtWaitAny.constprop.37>
    test_assert(m == 5, "unexpected pending bit");
  209fc2:	f1a0 0005 	sub.w	r0, r0, #5
  209fc6:	4924      	ldr	r1, [pc, #144]	; (20a058 <rt_test_008_004_execute+0xa8>)
  209fc8:	fab0 f080 	clz	r0, r0
  209fcc:	0940      	lsrs	r0, r0, #5
  209fce:	f7f6 fbf7 	bl	2007c0 <_test_assert>
  209fd2:	b100      	cbz	r0, 209fd6 <rt_test_008_004_execute+0x26>
}
  209fd4:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  209fd6:	f7f9 ffdb 	bl	203f90 <chEvtGetAndClearEvents.constprop.42>
    test_assert(m == 0, "stuck event");
  209fda:	fab0 f080 	clz	r0, r0
  209fde:	491f      	ldr	r1, [pc, #124]	; (20a05c <rt_test_008_004_execute+0xac>)
  209fe0:	0940      	lsrs	r0, r0, #5
  209fe2:	f7f6 fbed 	bl	2007c0 <_test_assert>
  209fe6:	2800      	cmp	r0, #0
  209fe8:	d1f4      	bne.n	209fd4 <rt_test_008_004_execute+0x24>
  test_set_step(3);
  209fea:	2303      	movs	r3, #3
  209fec:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
  209fee:	f7fd ff0f 	bl	207e10 <test_wait_tick>
  209ff2:	4b1b      	ldr	r3, [pc, #108]	; (20a060 <rt_test_008_004_execute+0xb0>)
  209ff4:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  209ff6:	4a1b      	ldr	r2, [pc, #108]	; (20a064 <rt_test_008_004_execute+0xb4>)
  209ff8:	699b      	ldr	r3, [r3, #24]
  209ffa:	481b      	ldr	r0, [pc, #108]	; (20a068 <rt_test_008_004_execute+0xb8>)
  209ffc:	6899      	ldr	r1, [r3, #8]
  209ffe:	3901      	subs	r1, #1
  20a000:	f7fe fc06 	bl	208810 <chThdCreateStatic.constprop.61>
  20a004:	4a19      	ldr	r2, [pc, #100]	; (20a06c <rt_test_008_004_execute+0xbc>)
  test_set_step(4);
  20a006:	2304      	movs	r3, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20a008:	6010      	str	r0, [r2, #0]
  test_set_step(4);
  20a00a:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAny(ALL_EVENTS);
  20a00c:	f7fa f850 	bl	2040b0 <chEvtWaitAny.constprop.37>
    test_assert_time_window(target_time,
  20a010:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitAny(ALL_EVENTS);
  20a014:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
  20a016:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
  20a01a:	f7f6 fb99 	bl	200750 <_test_assert_time_window.constprop.2>
  20a01e:	2800      	cmp	r0, #0
  20a020:	d1d8      	bne.n	209fd4 <rt_test_008_004_execute+0x24>
    test_assert(m == 1, "event flag error");
  20a022:	f1a4 0001 	sub.w	r0, r4, #1
  20a026:	4912      	ldr	r1, [pc, #72]	; (20a070 <rt_test_008_004_execute+0xc0>)
  20a028:	fab0 f080 	clz	r0, r0
  20a02c:	0940      	lsrs	r0, r0, #5
  20a02e:	f7f6 fbc7 	bl	2007c0 <_test_assert>
  20a032:	2800      	cmp	r0, #0
  20a034:	d1ce      	bne.n	209fd4 <rt_test_008_004_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20a036:	f7f9 ffab 	bl	203f90 <chEvtGetAndClearEvents.constprop.42>
    test_assert(m == 0, "stuck event");
  20a03a:	fab0 f080 	clz	r0, r0
  20a03e:	4907      	ldr	r1, [pc, #28]	; (20a05c <rt_test_008_004_execute+0xac>)
  20a040:	0940      	lsrs	r0, r0, #5
  20a042:	f7f6 fbbd 	bl	2007c0 <_test_assert>
  20a046:	2800      	cmp	r0, #0
  20a048:	d1c4      	bne.n	209fd4 <rt_test_008_004_execute+0x24>
}
  20a04a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
  20a04e:	f7ff badf 	b.w	209610 <test_wait_threads>
  20a052:	bf00      	nop
  20a054:	20001f6c 	.word	0x20001f6c
  20a058:	0800d844 	.word	0x0800d844
  20a05c:	0800d8a0 	.word	0x0800d8a0
  20a060:	20000dc8 	.word	0x20000dc8
  20a064:	00207be1 	.word	0x00207be1
  20a068:	20001858 	.word	0x20001858
  20a06c:	20001f84 	.word	0x20001f84
  20a070:	0800d820 	.word	0x0800d820
	...

0020a080 <rt_test_008_003_execute>:
static void rt_test_008_003_execute(void) {
  20a080:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(7);
  20a082:	2007      	movs	r0, #7
  test_set_step(2);
  20a084:	4c33      	ldr	r4, [pc, #204]	; (20a154 <rt_test_008_003_execute+0xd4>)
    chEvtAddEvents(7);
  20a086:	f7fb fefb 	bl	205e80 <chEvtAddEvents>
  test_set_step(2);
  20a08a:	2302      	movs	r3, #2
  20a08c:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOne(ALL_EVENTS);
  20a08e:	f7f9 ffdf 	bl	204050 <chEvtWaitOne.constprop.38>
    test_assert(m == 1, "single event error");
  20a092:	f1a0 0001 	sub.w	r0, r0, #1
  20a096:	4930      	ldr	r1, [pc, #192]	; (20a158 <rt_test_008_003_execute+0xd8>)
  20a098:	fab0 f080 	clz	r0, r0
  20a09c:	0940      	lsrs	r0, r0, #5
  20a09e:	f7f6 fb8f 	bl	2007c0 <_test_assert>
  20a0a2:	b100      	cbz	r0, 20a0a6 <rt_test_008_003_execute+0x26>
}
  20a0a4:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtWaitOne(ALL_EVENTS);
  20a0a6:	f7f9 ffd3 	bl	204050 <chEvtWaitOne.constprop.38>
    test_assert(m == 2, "single event error");
  20a0aa:	f1a0 0002 	sub.w	r0, r0, #2
  20a0ae:	492a      	ldr	r1, [pc, #168]	; (20a158 <rt_test_008_003_execute+0xd8>)
  20a0b0:	fab0 f080 	clz	r0, r0
  20a0b4:	0940      	lsrs	r0, r0, #5
  20a0b6:	f7f6 fb83 	bl	2007c0 <_test_assert>
  20a0ba:	2800      	cmp	r0, #0
  20a0bc:	d1f2      	bne.n	20a0a4 <rt_test_008_003_execute+0x24>
    m = chEvtWaitOne(ALL_EVENTS);
  20a0be:	f7f9 ffc7 	bl	204050 <chEvtWaitOne.constprop.38>
    test_assert(m == 4, "single event error");
  20a0c2:	f1a0 0004 	sub.w	r0, r0, #4
  20a0c6:	4924      	ldr	r1, [pc, #144]	; (20a158 <rt_test_008_003_execute+0xd8>)
  20a0c8:	fab0 f080 	clz	r0, r0
  20a0cc:	0940      	lsrs	r0, r0, #5
  20a0ce:	f7f6 fb77 	bl	2007c0 <_test_assert>
  20a0d2:	2800      	cmp	r0, #0
  20a0d4:	d1e6      	bne.n	20a0a4 <rt_test_008_003_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20a0d6:	f7f9 ff5b 	bl	203f90 <chEvtGetAndClearEvents.constprop.42>
    test_assert(m == 0, "stuck event");
  20a0da:	fab0 f080 	clz	r0, r0
  20a0de:	491f      	ldr	r1, [pc, #124]	; (20a15c <rt_test_008_003_execute+0xdc>)
  20a0e0:	0940      	lsrs	r0, r0, #5
  20a0e2:	f7f6 fb6d 	bl	2007c0 <_test_assert>
  20a0e6:	2800      	cmp	r0, #0
  20a0e8:	d1dc      	bne.n	20a0a4 <rt_test_008_003_execute+0x24>
  test_set_step(3);
  20a0ea:	2303      	movs	r3, #3
  20a0ec:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
  20a0ee:	f7fd fe8f 	bl	207e10 <test_wait_tick>
  20a0f2:	4b1b      	ldr	r3, [pc, #108]	; (20a160 <rt_test_008_003_execute+0xe0>)
  20a0f4:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20a0f6:	4a1b      	ldr	r2, [pc, #108]	; (20a164 <rt_test_008_003_execute+0xe4>)
  20a0f8:	699b      	ldr	r3, [r3, #24]
  20a0fa:	481b      	ldr	r0, [pc, #108]	; (20a168 <rt_test_008_003_execute+0xe8>)
  20a0fc:	6899      	ldr	r1, [r3, #8]
  20a0fe:	3901      	subs	r1, #1
  20a100:	f7fe fb86 	bl	208810 <chThdCreateStatic.constprop.61>
  20a104:	4a19      	ldr	r2, [pc, #100]	; (20a16c <rt_test_008_003_execute+0xec>)
  test_set_step(4);
  20a106:	2304      	movs	r3, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20a108:	6010      	str	r0, [r2, #0]
  test_set_step(4);
  20a10a:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOne(ALL_EVENTS);
  20a10c:	f7f9 ffa0 	bl	204050 <chEvtWaitOne.constprop.38>
    test_assert_time_window(target_time,
  20a110:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitOne(ALL_EVENTS);
  20a114:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
  20a116:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
  20a11a:	f7f6 fb19 	bl	200750 <_test_assert_time_window.constprop.2>
  20a11e:	2800      	cmp	r0, #0
  20a120:	d1c0      	bne.n	20a0a4 <rt_test_008_003_execute+0x24>
    test_assert(m == 1, "event flag error");
  20a122:	f1a4 0001 	sub.w	r0, r4, #1
  20a126:	4912      	ldr	r1, [pc, #72]	; (20a170 <rt_test_008_003_execute+0xf0>)
  20a128:	fab0 f080 	clz	r0, r0
  20a12c:	0940      	lsrs	r0, r0, #5
  20a12e:	f7f6 fb47 	bl	2007c0 <_test_assert>
  20a132:	2800      	cmp	r0, #0
  20a134:	d1b6      	bne.n	20a0a4 <rt_test_008_003_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
  20a136:	f7f9 ff2b 	bl	203f90 <chEvtGetAndClearEvents.constprop.42>
    test_assert(m == 0, "stuck event");
  20a13a:	fab0 f080 	clz	r0, r0
  20a13e:	4907      	ldr	r1, [pc, #28]	; (20a15c <rt_test_008_003_execute+0xdc>)
  20a140:	0940      	lsrs	r0, r0, #5
  20a142:	f7f6 fb3d 	bl	2007c0 <_test_assert>
  20a146:	2800      	cmp	r0, #0
  20a148:	d1ac      	bne.n	20a0a4 <rt_test_008_003_execute+0x24>
}
  20a14a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
  20a14e:	f7ff ba5f 	b.w	209610 <test_wait_threads>
  20a152:	bf00      	nop
  20a154:	20001f6c 	.word	0x20001f6c
  20a158:	0800d7fc 	.word	0x0800d7fc
  20a15c:	0800d8a0 	.word	0x0800d8a0
  20a160:	20000dc8 	.word	0x20000dc8
  20a164:	00207be1 	.word	0x00207be1
  20a168:	20001858 	.word	0x20001858
  20a16c:	20001f84 	.word	0x20001f84
  20a170:	0800d820 	.word	0x0800d820
	...

0020a180 <rt_test_007_001_execute>:
 * - [7.1.1] Starting the messenger thread.
 * - [7.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void rt_test_007_001_execute(void) {
  20a180:	b538      	push	{r3, r4, r5, lr}
  20a182:	4b15      	ldr	r3, [pc, #84]	; (20a1d8 <rt_test_007_001_execute+0x58>)
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
  20a184:	2001      	movs	r0, #1
  20a186:	4d15      	ldr	r5, [pc, #84]	; (20a1dc <rt_test_007_001_execute+0x5c>)
                                   msg_thread1, chThdGetSelfX());
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
  20a188:	2404      	movs	r4, #4
  20a18a:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
  20a18c:	4a14      	ldr	r2, [pc, #80]	; (20a1e0 <rt_test_007_001_execute+0x60>)
  20a18e:	6899      	ldr	r1, [r3, #8]
  test_set_step(1);
  20a190:	6028      	str	r0, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
  20a192:	4401      	add	r1, r0
  20a194:	4813      	ldr	r0, [pc, #76]	; (20a1e4 <rt_test_007_001_execute+0x64>)
  20a196:	f7fe fb3b 	bl	208810 <chThdCreateStatic.constprop.61>
  20a19a:	4a13      	ldr	r2, [pc, #76]	; (20a1e8 <rt_test_007_001_execute+0x68>)
  test_set_step(2);
  20a19c:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
  20a19e:	6010      	str	r0, [r2, #0]
  test_set_step(2);
  20a1a0:	602b      	str	r3, [r5, #0]
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
  20a1a2:	f7fb fdc5 	bl	205d30 <chMsgWait>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
  20a1a6:	f890 2020 	ldrb.w	r2, [r0, #32]
  20a1aa:	2a0d      	cmp	r2, #13
  20a1ac:	d002      	beq.n	20a1b4 <rt_test_007_001_execute+0x34>
  20a1ae:	480f      	ldr	r0, [pc, #60]	; (20a1ec <rt_test_007_001_execute+0x6c>)
  20a1b0:	f7f6 fcde 	bl	200b70 <chSysHalt>
  return tp->u.sentmsg;
  20a1b4:	6a45      	ldr	r5, [r0, #36]	; 0x24
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
  20a1b6:	4629      	mov	r1, r5
  20a1b8:	f7fb fd8a 	bl	205cd0 <chMsgRelease>
      test_emit_token(msg);
  20a1bc:	b2e8      	uxtb	r0, r5
  20a1be:	f7fa fde7 	bl	204d90 <test_emit_token>
    for (i = 0; i < 4; i++) {
  20a1c2:	3c01      	subs	r4, #1
  20a1c4:	d1ed      	bne.n	20a1a2 <rt_test_007_001_execute+0x22>
    }
    test_wait_threads();
  20a1c6:	f7ff fa23 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
  20a1ca:	4909      	ldr	r1, [pc, #36]	; (20a1f0 <rt_test_007_001_execute+0x70>)
  20a1cc:	4809      	ldr	r0, [pc, #36]	; (20a1f4 <rt_test_007_001_execute+0x74>)
  }
}
  20a1ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_sequence("ABCD", "invalid sequence");
  20a1d2:	f7f6 bb95 	b.w	200900 <_test_assert_sequence>
  20a1d6:	bf00      	nop
  20a1d8:	20000dc8 	.word	0x20000dc8
  20a1dc:	20001f6c 	.word	0x20001f6c
  20a1e0:	00205e51 	.word	0x00205e51
  20a1e4:	20001858 	.word	0x20001858
  20a1e8:	20001f84 	.word	0x20001f84
  20a1ec:	0800bd44 	.word	0x0800bd44
  20a1f0:	0800d7d4 	.word	0x0800d7d4
  20a1f4:	0800c688 	.word	0x0800c688
	...

0020a200 <rt_test_006_009_execute>:

static void rt_test_006_009_execute(void) {
  20a200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  20a202:	4b1d      	ldr	r3, [pc, #116]	; (20a278 <rt_test_006_009_execute+0x78>)
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  20a204:	f04f 0c02 	mov.w	ip, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  20a208:	4e1c      	ldr	r6, [pc, #112]	; (20a27c <rt_test_006_009_execute+0x7c>)
  return chThdGetSelfX()->prio;
  20a20a:	699b      	ldr	r3, [r3, #24]
  test_set_step(2);
  20a20c:	4c1c      	ldr	r4, [pc, #112]	; (20a280 <rt_test_006_009_execute+0x80>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  20a20e:	4630      	mov	r0, r6
  20a210:	689f      	ldr	r7, [r3, #8]
  20a212:	4d1c      	ldr	r5, [pc, #112]	; (20a284 <rt_test_006_009_execute+0x84>)
  20a214:	1c79      	adds	r1, r7, #1
  20a216:	4b1c      	ldr	r3, [pc, #112]	; (20a288 <rt_test_006_009_execute+0x88>)
  20a218:	4a1c      	ldr	r2, [pc, #112]	; (20a28c <rt_test_006_009_execute+0x8c>)
  test_set_step(2);
  20a21a:	f8c4 c000 	str.w	ip, [r4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  20a21e:	f7fe faf7 	bl	208810 <chThdCreateStatic.constprop.61>
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  20a222:	f04f 0c03 	mov.w	ip, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  20a226:	6028      	str	r0, [r5, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
  20a228:	1cb9      	adds	r1, r7, #2
  20a22a:	f506 70a4 	add.w	r0, r6, #328	; 0x148
  20a22e:	4b18      	ldr	r3, [pc, #96]	; (20a290 <rt_test_006_009_execute+0x90>)
  20a230:	4a18      	ldr	r2, [pc, #96]	; (20a294 <rt_test_006_009_execute+0x94>)
  test_set_step(3);
  20a232:	f8c4 c000 	str.w	ip, [r4]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
  20a236:	f7fe faeb 	bl	208810 <chThdCreateStatic.constprop.61>
  }

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  20a23a:	f04f 0c04 	mov.w	ip, #4
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
  20a23e:	1cf9      	adds	r1, r7, #3
  20a240:	4a15      	ldr	r2, [pc, #84]	; (20a298 <rt_test_006_009_execute+0x98>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
  20a242:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
  20a244:	f506 7024 	add.w	r0, r6, #656	; 0x290
  20a248:	4b14      	ldr	r3, [pc, #80]	; (20a29c <rt_test_006_009_execute+0x9c>)
  test_set_step(4);
  20a24a:	f8c4 c000 	str.w	ip, [r4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
  20a24e:	f7fe fadf 	bl	208810 <chThdCreateStatic.constprop.61>
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
  20a252:	2305      	movs	r3, #5
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
  20a254:	60a8      	str	r0, [r5, #8]
  test_set_step(5);
  20a256:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
  20a258:	f7f9 fe3a 	bl	203ed0 <chCondSignal.constprop.51>
  }

  /* [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
  20a25c:	2306      	movs	r3, #6
  20a25e:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
  20a260:	f7f9 fe36 	bl	203ed0 <chCondSignal.constprop.51>
  }

  /* [6.9.7] Checking the order of operations.*/
  test_set_step(7);
  20a264:	2307      	movs	r3, #7
  20a266:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
  20a268:	f7ff f9d2 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
  20a26c:	490c      	ldr	r1, [pc, #48]	; (20a2a0 <rt_test_006_009_execute+0xa0>)
  20a26e:	480d      	ldr	r0, [pc, #52]	; (20a2a4 <rt_test_006_009_execute+0xa4>)
  }
}
  20a270:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
  20a274:	f7f6 bb44 	b.w	200900 <_test_assert_sequence>
  20a278:	20000dc8 	.word	0x20000dc8
  20a27c:	20001858 	.word	0x20001858
  20a280:	20001f6c 	.word	0x20001f6c
  20a284:	20001f84 	.word	0x20001f84
  20a288:	0800d6e8 	.word	0x0800d6e8
  20a28c:	00206781 	.word	0x00206781
  20a290:	0800d934 	.word	0x0800d934
  20a294:	00206841 	.word	0x00206841
  20a298:	002068e1 	.word	0x002068e1
  20a29c:	0800d6ec 	.word	0x0800d6ec
  20a2a0:	0800d7d4 	.word	0x0800d7d4
  20a2a4:	0800d7e8 	.word	0x0800d7e8
	...

0020a2b0 <rt_test_006_008_execute>:
static void rt_test_006_008_execute(void) {
  20a2b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
  20a2b2:	4e31      	ldr	r6, [pc, #196]	; (20a378 <rt_test_006_008_execute+0xc8>)
  test_set_step(1);
  20a2b4:	f04f 0c01 	mov.w	ip, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a2b8:	4c30      	ldr	r4, [pc, #192]	; (20a37c <rt_test_006_008_execute+0xcc>)
  return chThdGetSelfX()->prio;
  20a2ba:	69b3      	ldr	r3, [r6, #24]
  test_set_step(1);
  20a2bc:	4f30      	ldr	r7, [pc, #192]	; (20a380 <rt_test_006_008_execute+0xd0>)
  20a2be:	689d      	ldr	r5, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a2c0:	4a30      	ldr	r2, [pc, #192]	; (20a384 <rt_test_006_008_execute+0xd4>)
  20a2c2:	eb05 010c 	add.w	r1, r5, ip
  20a2c6:	4b30      	ldr	r3, [pc, #192]	; (20a388 <rt_test_006_008_execute+0xd8>)
  20a2c8:	4830      	ldr	r0, [pc, #192]	; (20a38c <rt_test_006_008_execute+0xdc>)
  test_set_step(1);
  20a2ca:	f8c7 c000 	str.w	ip, [r7]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a2ce:	f7fe fa9f 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
  20a2d2:	1ca9      	adds	r1, r5, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a2d4:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
  20a2d6:	4b2e      	ldr	r3, [pc, #184]	; (20a390 <rt_test_006_008_execute+0xe0>)
  20a2d8:	4a2a      	ldr	r2, [pc, #168]	; (20a384 <rt_test_006_008_execute+0xd4>)
  20a2da:	482e      	ldr	r0, [pc, #184]	; (20a394 <rt_test_006_008_execute+0xe4>)
  20a2dc:	f7fe fa98 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
  20a2e0:	1ce9      	adds	r1, r5, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
  20a2e2:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
  20a2e4:	4b2c      	ldr	r3, [pc, #176]	; (20a398 <rt_test_006_008_execute+0xe8>)
  20a2e6:	4a27      	ldr	r2, [pc, #156]	; (20a384 <rt_test_006_008_execute+0xd4>)
  20a2e8:	482c      	ldr	r0, [pc, #176]	; (20a39c <rt_test_006_008_execute+0xec>)
  20a2ea:	f7fe fa91 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
  20a2ee:	1d29      	adds	r1, r5, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
  20a2f0:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
  20a2f2:	4b2b      	ldr	r3, [pc, #172]	; (20a3a0 <rt_test_006_008_execute+0xf0>)
  20a2f4:	4a23      	ldr	r2, [pc, #140]	; (20a384 <rt_test_006_008_execute+0xd4>)
  20a2f6:	482b      	ldr	r0, [pc, #172]	; (20a3a4 <rt_test_006_008_execute+0xf4>)
  20a2f8:	f7fe fa8a 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
  20a2fc:	1d69      	adds	r1, r5, #5
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
  20a2fe:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
  20a300:	4b29      	ldr	r3, [pc, #164]	; (20a3a8 <rt_test_006_008_execute+0xf8>)
  20a302:	4a20      	ldr	r2, [pc, #128]	; (20a384 <rt_test_006_008_execute+0xd4>)
  20a304:	4829      	ldr	r0, [pc, #164]	; (20a3ac <rt_test_006_008_execute+0xfc>)
  20a306:	f7fe fa83 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(2);
  20a30a:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
  20a30c:	6120      	str	r0, [r4, #16]
  test_set_step(2);
  20a30e:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20a310:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a312:	2320      	movs	r3, #32
  20a314:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20a318:	b662      	cpsie	i
  return (bool)(tqp->next != (const thread_t *)tqp);
  20a31a:	4c25      	ldr	r4, [pc, #148]	; (20a3b0 <rt_test_006_008_execute+0x100>)
  _dbg_check_lock();
  20a31c:	f7f9 fd18 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  20a320:	f7f6 fd36 	bl	200d90 <chDbgCheckClassI>
  20a324:	6823      	ldr	r3, [r4, #0]
  while (queue_notempty(&cp->queue)) {
  20a326:	42a3      	cmp	r3, r4
  20a328:	d00b      	beq.n	20a342 <rt_test_006_008_execute+0x92>
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
  20a32a:	f06f 0501 	mvn.w	r5, #1
  tqp->next             = tp->queue.next;
  20a32e:	681a      	ldr	r2, [r3, #0]
  20a330:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
  20a332:	6054      	str	r4, [r2, #4]
  tqp->next             = tp->queue.next;
  20a334:	6022      	str	r2, [r4, #0]
  20a336:	f7f6 fddb 	bl	200ef0 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
  20a33a:	6823      	ldr	r3, [r4, #0]
  20a33c:	6245      	str	r5, [r0, #36]	; 0x24
  while (queue_notempty(&cp->queue)) {
  20a33e:	42a3      	cmp	r3, r4
  20a340:	d1f5      	bne.n	20a32e <rt_test_006_008_execute+0x7e>
  chSchRescheduleS();
  20a342:	f7f9 fc9d 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  20a346:	f7f9 fcb3 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20a34a:	6833      	ldr	r3, [r6, #0]
  20a34c:	42b3      	cmp	r3, r6
  20a34e:	d004      	beq.n	20a35a <rt_test_006_008_execute+0xaa>
  20a350:	69b2      	ldr	r2, [r6, #24]
  20a352:	689b      	ldr	r3, [r3, #8]
  20a354:	6892      	ldr	r2, [r2, #8]
  20a356:	429a      	cmp	r2, r3
  20a358:	d30a      	bcc.n	20a370 <rt_test_006_008_execute+0xc0>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a35a:	2300      	movs	r3, #0
  20a35c:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
  20a360:	f7ff f956 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20a364:	4913      	ldr	r1, [pc, #76]	; (20a3b4 <rt_test_006_008_execute+0x104>)
  20a366:	4814      	ldr	r0, [pc, #80]	; (20a3b8 <rt_test_006_008_execute+0x108>)
}
  20a368:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
  20a36c:	f7f6 bac8 	b.w	200900 <_test_assert_sequence>
  20a370:	4812      	ldr	r0, [pc, #72]	; (20a3bc <rt_test_006_008_execute+0x10c>)
  20a372:	f7f6 fbfd 	bl	200b70 <chSysHalt>
  20a376:	bf00      	nop
  20a378:	20000dc8 	.word	0x20000dc8
  20a37c:	20001f84 	.word	0x20001f84
  20a380:	20001f6c 	.word	0x20001f6c
  20a384:	00206841 	.word	0x00206841
  20a388:	0800d774 	.word	0x0800d774
  20a38c:	20001858 	.word	0x20001858
  20a390:	0800e68c 	.word	0x0800e68c
  20a394:	200019a0 	.word	0x200019a0
  20a398:	0800d934 	.word	0x0800d934
  20a39c:	20001ae8 	.word	0x20001ae8
  20a3a0:	0800d6ec 	.word	0x0800d6ec
  20a3a4:	20001c30 	.word	0x20001c30
  20a3a8:	0800d6e8 	.word	0x0800d6e8
  20a3ac:	20001d78 	.word	0x20001d78
  20a3b0:	20010404 	.word	0x20010404
  20a3b4:	0800d7d4 	.word	0x0800d7d4
  20a3b8:	0800d770 	.word	0x0800d770
  20a3bc:	0800bc28 	.word	0x0800bc28

0020a3c0 <rt_test_006_007_execute>:
static void rt_test_006_007_execute(void) {
  20a3c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
  20a3c2:	4e2d      	ldr	r6, [pc, #180]	; (20a478 <rt_test_006_007_execute+0xb8>)
  test_set_step(1);
  20a3c4:	f04f 0c01 	mov.w	ip, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a3c8:	4c2c      	ldr	r4, [pc, #176]	; (20a47c <rt_test_006_007_execute+0xbc>)
  return chThdGetSelfX()->prio;
  20a3ca:	69b3      	ldr	r3, [r6, #24]
  test_set_step(1);
  20a3cc:	4f2c      	ldr	r7, [pc, #176]	; (20a480 <rt_test_006_007_execute+0xc0>)
  20a3ce:	689d      	ldr	r5, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a3d0:	4a2c      	ldr	r2, [pc, #176]	; (20a484 <rt_test_006_007_execute+0xc4>)
  20a3d2:	eb05 010c 	add.w	r1, r5, ip
  20a3d6:	4b2c      	ldr	r3, [pc, #176]	; (20a488 <rt_test_006_007_execute+0xc8>)
  20a3d8:	482c      	ldr	r0, [pc, #176]	; (20a48c <rt_test_006_007_execute+0xcc>)
  test_set_step(1);
  20a3da:	f8c7 c000 	str.w	ip, [r7]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a3de:	f7fe fa17 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
  20a3e2:	1ca9      	adds	r1, r5, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
  20a3e4:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
  20a3e6:	4b2a      	ldr	r3, [pc, #168]	; (20a490 <rt_test_006_007_execute+0xd0>)
  20a3e8:	4a26      	ldr	r2, [pc, #152]	; (20a484 <rt_test_006_007_execute+0xc4>)
  20a3ea:	482a      	ldr	r0, [pc, #168]	; (20a494 <rt_test_006_007_execute+0xd4>)
  20a3ec:	f7fe fa10 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
  20a3f0:	1ce9      	adds	r1, r5, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
  20a3f2:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
  20a3f4:	4b28      	ldr	r3, [pc, #160]	; (20a498 <rt_test_006_007_execute+0xd8>)
  20a3f6:	4a23      	ldr	r2, [pc, #140]	; (20a484 <rt_test_006_007_execute+0xc4>)
  20a3f8:	4828      	ldr	r0, [pc, #160]	; (20a49c <rt_test_006_007_execute+0xdc>)
  20a3fa:	f7fe fa09 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
  20a3fe:	1d29      	adds	r1, r5, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
  20a400:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
  20a402:	4b27      	ldr	r3, [pc, #156]	; (20a4a0 <rt_test_006_007_execute+0xe0>)
  20a404:	4a1f      	ldr	r2, [pc, #124]	; (20a484 <rt_test_006_007_execute+0xc4>)
  20a406:	4827      	ldr	r0, [pc, #156]	; (20a4a4 <rt_test_006_007_execute+0xe4>)
  20a408:	f7fe fa02 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
  20a40c:	1d69      	adds	r1, r5, #5
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
  20a40e:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
  20a410:	4b25      	ldr	r3, [pc, #148]	; (20a4a8 <rt_test_006_007_execute+0xe8>)
  20a412:	4a1c      	ldr	r2, [pc, #112]	; (20a484 <rt_test_006_007_execute+0xc4>)
  20a414:	4825      	ldr	r0, [pc, #148]	; (20a4ac <rt_test_006_007_execute+0xec>)
  20a416:	f7fe f9fb 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(2);
  20a41a:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
  20a41c:	6120      	str	r0, [r4, #16]
  test_set_step(2);
  20a41e:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20a420:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a422:	2320      	movs	r3, #32
  20a424:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20a428:	b662      	cpsie	i
  _dbg_check_lock();
  20a42a:	f7f9 fc91 	bl	203d50 <_dbg_check_lock>
    chCondSignalI(&c1);
  20a42e:	f7f7 ff7f 	bl	202330 <chCondSignalI.constprop.50>
    chCondSignalI(&c1);
  20a432:	f7f7 ff7d 	bl	202330 <chCondSignalI.constprop.50>
    chCondSignalI(&c1);
  20a436:	f7f7 ff7b 	bl	202330 <chCondSignalI.constprop.50>
    chCondSignalI(&c1);
  20a43a:	f7f7 ff79 	bl	202330 <chCondSignalI.constprop.50>
    chCondSignalI(&c1);
  20a43e:	f7f7 ff77 	bl	202330 <chCondSignalI.constprop.50>
    chSchRescheduleS();
  20a442:	f7f9 fc1d 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  20a446:	f7f9 fc33 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20a44a:	6833      	ldr	r3, [r6, #0]
  20a44c:	42b3      	cmp	r3, r6
  20a44e:	d004      	beq.n	20a45a <rt_test_006_007_execute+0x9a>
  20a450:	69b2      	ldr	r2, [r6, #24]
  20a452:	689b      	ldr	r3, [r3, #8]
  20a454:	6892      	ldr	r2, [r2, #8]
  20a456:	429a      	cmp	r2, r3
  20a458:	d30a      	bcc.n	20a470 <rt_test_006_007_execute+0xb0>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a45a:	2300      	movs	r3, #0
  20a45c:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
  20a460:	f7ff f8d6 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20a464:	4912      	ldr	r1, [pc, #72]	; (20a4b0 <rt_test_006_007_execute+0xf0>)
  20a466:	4813      	ldr	r0, [pc, #76]	; (20a4b4 <rt_test_006_007_execute+0xf4>)
}
  20a468:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
  20a46c:	f7f6 ba48 	b.w	200900 <_test_assert_sequence>
  20a470:	4811      	ldr	r0, [pc, #68]	; (20a4b8 <rt_test_006_007_execute+0xf8>)
  20a472:	f7f6 fb7d 	bl	200b70 <chSysHalt>
  20a476:	bf00      	nop
  20a478:	20000dc8 	.word	0x20000dc8
  20a47c:	20001f84 	.word	0x20001f84
  20a480:	20001f6c 	.word	0x20001f6c
  20a484:	00206841 	.word	0x00206841
  20a488:	0800d774 	.word	0x0800d774
  20a48c:	20001858 	.word	0x20001858
  20a490:	0800e68c 	.word	0x0800e68c
  20a494:	200019a0 	.word	0x200019a0
  20a498:	0800d934 	.word	0x0800d934
  20a49c:	20001ae8 	.word	0x20001ae8
  20a4a0:	0800d6ec 	.word	0x0800d6ec
  20a4a4:	20001c30 	.word	0x20001c30
  20a4a8:	0800d6e8 	.word	0x0800d6e8
  20a4ac:	20001d78 	.word	0x20001d78
  20a4b0:	0800d7d4 	.word	0x0800d7d4
  20a4b4:	0800d770 	.word	0x0800d770
  20a4b8:	0800bcc4 	.word	0x0800bcc4
  20a4bc:	00000000 	.word	0x00000000

0020a4c0 <rt_test_005_006_teardown>:
  test_wait_threads();
  20a4c0:	f7ff b8a6 	b.w	209610 <test_wait_threads>
	...

0020a4d0 <rt_test_006_004_teardown>:
  20a4d0:	f7ff b89e 	b.w	209610 <test_wait_threads>
	...

0020a4e0 <rt_test_006_001_execute>:
static void rt_test_006_001_execute(void) {
  20a4e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
  20a4e2:	4f24      	ldr	r7, [pc, #144]	; (20a574 <rt_test_006_001_execute+0x94>)
  test_set_step(2);
  20a4e4:	2302      	movs	r3, #2
  20a4e6:	4e24      	ldr	r6, [pc, #144]	; (20a578 <rt_test_006_001_execute+0x98>)
  return chThdGetSelfX()->prio;
  20a4e8:	69ba      	ldr	r2, [r7, #24]
    chMtxLock(&m1);
  20a4ea:	4824      	ldr	r0, [pc, #144]	; (20a57c <rt_test_006_001_execute+0x9c>)
  20a4ec:	6894      	ldr	r4, [r2, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  20a4ee:	4d24      	ldr	r5, [pc, #144]	; (20a580 <rt_test_006_001_execute+0xa0>)
  test_set_step(2);
  20a4f0:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
  20a4f2:	f7fb fee5 	bl	2062c0 <chMtxLock>
  test_set_step(3);
  20a4f6:	f04f 0c03 	mov.w	ip, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  20a4fa:	1c61      	adds	r1, r4, #1
  20a4fc:	4b21      	ldr	r3, [pc, #132]	; (20a584 <rt_test_006_001_execute+0xa4>)
  20a4fe:	4a22      	ldr	r2, [pc, #136]	; (20a588 <rt_test_006_001_execute+0xa8>)
  20a500:	4822      	ldr	r0, [pc, #136]	; (20a58c <rt_test_006_001_execute+0xac>)
  test_set_step(3);
  20a502:	f8c6 c000 	str.w	ip, [r6]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  20a506:	f7fe f983 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  20a50a:	1ca1      	adds	r1, r4, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  20a50c:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  20a50e:	4b20      	ldr	r3, [pc, #128]	; (20a590 <rt_test_006_001_execute+0xb0>)
  20a510:	4a1d      	ldr	r2, [pc, #116]	; (20a588 <rt_test_006_001_execute+0xa8>)
  20a512:	4820      	ldr	r0, [pc, #128]	; (20a594 <rt_test_006_001_execute+0xb4>)
  20a514:	f7fe f97c 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  20a518:	1ce1      	adds	r1, r4, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  20a51a:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  20a51c:	4b1e      	ldr	r3, [pc, #120]	; (20a598 <rt_test_006_001_execute+0xb8>)
  20a51e:	4a1a      	ldr	r2, [pc, #104]	; (20a588 <rt_test_006_001_execute+0xa8>)
  20a520:	481e      	ldr	r0, [pc, #120]	; (20a59c <rt_test_006_001_execute+0xbc>)
  20a522:	f7fe f975 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  20a526:	1d21      	adds	r1, r4, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  20a528:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  20a52a:	4b1d      	ldr	r3, [pc, #116]	; (20a5a0 <rt_test_006_001_execute+0xc0>)
  20a52c:	4a16      	ldr	r2, [pc, #88]	; (20a588 <rt_test_006_001_execute+0xa8>)
  20a52e:	481d      	ldr	r0, [pc, #116]	; (20a5a4 <rt_test_006_001_execute+0xc4>)
  20a530:	f7fe f96e 	bl	208810 <chThdCreateStatic.constprop.61>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  20a534:	1d61      	adds	r1, r4, #5
  20a536:	4a14      	ldr	r2, [pc, #80]	; (20a588 <rt_test_006_001_execute+0xa8>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  20a538:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  20a53a:	4b1b      	ldr	r3, [pc, #108]	; (20a5a8 <rt_test_006_001_execute+0xc8>)
  20a53c:	481b      	ldr	r0, [pc, #108]	; (20a5ac <rt_test_006_001_execute+0xcc>)
  20a53e:	f7fe f967 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(4);
  20a542:	2304      	movs	r3, #4
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  20a544:	6128      	str	r0, [r5, #16]
    chMtxUnlock(&m1);
  20a546:	480d      	ldr	r0, [pc, #52]	; (20a57c <rt_test_006_001_execute+0x9c>)
  test_set_step(4);
  20a548:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
  20a54a:	f7fb fd89 	bl	206060 <chMtxUnlock>
    test_wait_threads();
  20a54e:	f7ff f85f 	bl	209610 <test_wait_threads>
  20a552:	69bb      	ldr	r3, [r7, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
  20a554:	4916      	ldr	r1, [pc, #88]	; (20a5b0 <rt_test_006_001_execute+0xd0>)
  20a556:	6898      	ldr	r0, [r3, #8]
  20a558:	1b00      	subs	r0, r0, r4
  20a55a:	fab0 f080 	clz	r0, r0
  20a55e:	0940      	lsrs	r0, r0, #5
  20a560:	f7f6 f92e 	bl	2007c0 <_test_assert>
  20a564:	b100      	cbz	r0, 20a568 <rt_test_006_001_execute+0x88>
}
  20a566:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
  20a568:	4912      	ldr	r1, [pc, #72]	; (20a5b4 <rt_test_006_001_execute+0xd4>)
  20a56a:	4813      	ldr	r0, [pc, #76]	; (20a5b8 <rt_test_006_001_execute+0xd8>)
}
  20a56c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
  20a570:	f7f6 b9c6 	b.w	200900 <_test_assert_sequence>
  20a574:	20000dc8 	.word	0x20000dc8
  20a578:	20001f6c 	.word	0x20001f6c
  20a57c:	20010438 	.word	0x20010438
  20a580:	20001f84 	.word	0x20001f84
  20a584:	0800d774 	.word	0x0800d774
  20a588:	00206901 	.word	0x00206901
  20a58c:	20001858 	.word	0x20001858
  20a590:	0800e68c 	.word	0x0800e68c
  20a594:	200019a0 	.word	0x200019a0
  20a598:	0800d934 	.word	0x0800d934
  20a59c:	20001ae8 	.word	0x20001ae8
  20a5a0:	0800d6ec 	.word	0x0800d6ec
  20a5a4:	20001c30 	.word	0x20001c30
  20a5a8:	0800d6e8 	.word	0x0800d6e8
  20a5ac:	20001d78 	.word	0x20001d78
  20a5b0:	0800d738 	.word	0x0800d738
  20a5b4:	0800d7d4 	.word	0x0800d7d4
  20a5b8:	0800d770 	.word	0x0800d770
  20a5bc:	00000000 	.word	0x00000000

0020a5c0 <rt_test_005_005_teardown>:
  20a5c0:	f7ff b826 	b.w	209610 <test_wait_threads>
	...

0020a5d0 <rt_test_005_004_execute>:
static void rt_test_005_004_execute(void) {
  20a5d0:	b570      	push	{r4, r5, r6, lr}
  return ch.rlist.current;
  20a5d2:	4d44      	ldr	r5, [pc, #272]	; (20a6e4 <rt_test_005_004_execute+0x114>)
  test_set_step(1);
  20a5d4:	2601      	movs	r6, #1
  20a5d6:	4c44      	ldr	r4, [pc, #272]	; (20a6e8 <rt_test_005_004_execute+0x118>)
  return chThdGetSelfX()->prio;
  20a5d8:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
  20a5da:	4b44      	ldr	r3, [pc, #272]	; (20a6ec <rt_test_005_004_execute+0x11c>)
  20a5dc:	6891      	ldr	r1, [r2, #8]
  20a5de:	4844      	ldr	r0, [pc, #272]	; (20a6f0 <rt_test_005_004_execute+0x120>)
  20a5e0:	4a44      	ldr	r2, [pc, #272]	; (20a6f4 <rt_test_005_004_execute+0x124>)
  20a5e2:	4431      	add	r1, r6
  test_set_step(1);
  20a5e4:	6026      	str	r6, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
  20a5e6:	f7fe f913 	bl	208810 <chThdCreateStatic.constprop.61>
  20a5ea:	4a43      	ldr	r2, [pc, #268]	; (20a6f8 <rt_test_005_004_execute+0x128>)
  test_set_step(2);
  20a5ec:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
  20a5ee:	6010      	str	r0, [r2, #0]
  test_set_step(2);
  20a5f0:	6023      	str	r3, [r4, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20a5f2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a5f4:	2320      	movs	r3, #32
  20a5f6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20a5fa:	b662      	cpsie	i
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  20a5fc:	4c3f      	ldr	r4, [pc, #252]	; (20a6fc <rt_test_005_004_execute+0x12c>)
  _dbg_check_lock();
  20a5fe:	f7f9 fba7 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  20a602:	f7f6 fbc5 	bl	200d90 <chDbgCheckClassI>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
  20a606:	68a3      	ldr	r3, [r4, #8]
  20a608:	6822      	ldr	r2, [r4, #0]
  20a60a:	2b00      	cmp	r3, #0
  20a60c:	db04      	blt.n	20a618 <rt_test_005_004_execute+0x48>
  20a60e:	42a2      	cmp	r2, r4
  20a610:	d004      	beq.n	20a61c <rt_test_005_004_execute+0x4c>
  20a612:	483b      	ldr	r0, [pc, #236]	; (20a700 <rt_test_005_004_execute+0x130>)
  20a614:	f7f6 faac 	bl	200b70 <chSysHalt>
  20a618:	42a2      	cmp	r2, r4
  20a61a:	d0fa      	beq.n	20a612 <rt_test_005_004_execute+0x42>
    if (++sp->cnt <= (cnt_t)0) {
  20a61c:	3301      	adds	r3, #1
  20a61e:	2b00      	cmp	r3, #0
  20a620:	60a3      	str	r3, [r4, #8]
  20a622:	dd55      	ble.n	20a6d0 <rt_test_005_004_execute+0x100>
  20a624:	68a3      	ldr	r3, [r4, #8]
  20a626:	3301      	adds	r3, #1
  20a628:	2b00      	cmp	r3, #0
  20a62a:	60a3      	str	r3, [r4, #8]
  20a62c:	dd47      	ble.n	20a6be <rt_test_005_004_execute+0xee>
    chSchRescheduleS();
  20a62e:	f7f9 fb27 	bl	203c80 <chSchRescheduleS>
  _dbg_check_unlock();
  20a632:	f7f9 fb3d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20a636:	682b      	ldr	r3, [r5, #0]
  20a638:	42ab      	cmp	r3, r5
  20a63a:	d004      	beq.n	20a646 <rt_test_005_004_execute+0x76>
  20a63c:	69aa      	ldr	r2, [r5, #24]
  20a63e:	689b      	ldr	r3, [r3, #8]
  20a640:	6892      	ldr	r2, [r2, #8]
  20a642:	429a      	cmp	r2, r3
  20a644:	d338      	bcc.n	20a6b8 <rt_test_005_004_execute+0xe8>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a646:	2300      	movs	r3, #0
  20a648:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
  20a64c:	f7fe ffe0 	bl	209610 <test_wait_threads>
  __ASM volatile ("cpsid i" : : : "memory");
  20a650:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a652:	2320      	movs	r3, #32
  20a654:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20a658:	b662      	cpsie	i
  _dbg_check_lock();
  20a65a:	f7f9 fb79 	bl	203d50 <_dbg_check_lock>
  20a65e:	f7f6 fb97 	bl	200d90 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
  20a662:	68a0      	ldr	r0, [r4, #8]
  20a664:	4927      	ldr	r1, [pc, #156]	; (20a704 <rt_test_005_004_execute+0x134>)
  20a666:	f1a0 0001 	sub.w	r0, r0, #1
  20a66a:	fab0 f080 	clz	r0, r0
  20a66e:	0940      	lsrs	r0, r0, #5
  20a670:	f7f6 f8a6 	bl	2007c0 <_test_assert>
  20a674:	b990      	cbnz	r0, 20a69c <rt_test_005_004_execute+0xcc>
  _dbg_check_unlock();
  20a676:	f7f9 fb1b 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20a67a:	682b      	ldr	r3, [r5, #0]
  20a67c:	42ab      	cmp	r3, r5
  20a67e:	d004      	beq.n	20a68a <rt_test_005_004_execute+0xba>
  20a680:	69aa      	ldr	r2, [r5, #24]
  20a682:	689b      	ldr	r3, [r3, #8]
  20a684:	6892      	ldr	r2, [r2, #8]
  20a686:	429a      	cmp	r2, r3
  20a688:	d316      	bcc.n	20a6b8 <rt_test_005_004_execute+0xe8>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a68a:	2300      	movs	r3, #0
  20a68c:	f383 8811 	msr	BASEPRI, r3
    test_assert_sequence("A", "invalid sequence");
  20a690:	491d      	ldr	r1, [pc, #116]	; (20a708 <rt_test_005_004_execute+0x138>)
  20a692:	4816      	ldr	r0, [pc, #88]	; (20a6ec <rt_test_005_004_execute+0x11c>)
}
  20a694:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_sequence("A", "invalid sequence");
  20a698:	f7f6 b932 	b.w	200900 <_test_assert_sequence>
  _dbg_check_unlock();
  20a69c:	f7f9 fb08 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20a6a0:	682b      	ldr	r3, [r5, #0]
  20a6a2:	42ab      	cmp	r3, r5
  20a6a4:	d004      	beq.n	20a6b0 <rt_test_005_004_execute+0xe0>
  20a6a6:	69aa      	ldr	r2, [r5, #24]
  20a6a8:	689b      	ldr	r3, [r3, #8]
  20a6aa:	6892      	ldr	r2, [r2, #8]
  20a6ac:	429a      	cmp	r2, r3
  20a6ae:	d303      	bcc.n	20a6b8 <rt_test_005_004_execute+0xe8>
  20a6b0:	2300      	movs	r3, #0
  20a6b2:	f383 8811 	msr	BASEPRI, r3
}
  20a6b6:	bd70      	pop	{r4, r5, r6, pc}
  20a6b8:	4814      	ldr	r0, [pc, #80]	; (20a70c <rt_test_005_004_execute+0x13c>)
  20a6ba:	f7f6 fa59 	bl	200b70 <chSysHalt>
  thread_t *tp = tqp->next;
  20a6be:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
  20a6c0:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  20a6c2:	605c      	str	r4, [r3, #4]
  tqp->next             = tp->queue.next;
  20a6c4:	6023      	str	r3, [r4, #0]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
  20a6c6:	f7f6 fc13 	bl	200ef0 <chSchReadyI>
  20a6ca:	2300      	movs	r3, #0
  20a6cc:	6243      	str	r3, [r0, #36]	; 0x24
  20a6ce:	e7ae      	b.n	20a62e <rt_test_005_004_execute+0x5e>
  thread_t *tp = tqp->next;
  20a6d0:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
  20a6d2:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  20a6d4:	605c      	str	r4, [r3, #4]
  tqp->next             = tp->queue.next;
  20a6d6:	6023      	str	r3, [r4, #0]
  20a6d8:	f7f6 fc0a 	bl	200ef0 <chSchReadyI>
  20a6dc:	2300      	movs	r3, #0
  20a6de:	6243      	str	r3, [r0, #36]	; 0x24
  20a6e0:	e7a0      	b.n	20a624 <rt_test_005_004_execute+0x54>
  20a6e2:	bf00      	nop
  20a6e4:	20000dc8 	.word	0x20000dc8
  20a6e8:	20001f6c 	.word	0x20001f6c
  20a6ec:	0800d6e8 	.word	0x0800d6e8
  20a6f0:	20001858 	.word	0x20001858
  20a6f4:	002077b1 	.word	0x002077b1
  20a6f8:	20001f84 	.word	0x20001f84
  20a6fc:	20001838 	.word	0x20001838
  20a700:	0800befc 	.word	0x0800befc
  20a704:	0800d644 	.word	0x0800d644
  20a708:	0800d7d4 	.word	0x0800d7d4
  20a70c:	0800bcb8 	.word	0x0800bcb8

0020a710 <rt_test_005_003_execute>:
static void rt_test_005_003_execute(void) {
  20a710:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
  20a714:	2301      	movs	r3, #1
  20a716:	4c49      	ldr	r4, [pc, #292]	; (20a83c <rt_test_005_003_execute+0x12c>)
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  20a718:	2000      	movs	r0, #0
  test_set_step(1);
  20a71a:	6023      	str	r3, [r4, #0]
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  20a71c:	f7f9 fb28 	bl	203d70 <chSemWaitTimeout.constprop.58>
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
  20a720:	f1a0 30ff 	sub.w	r0, r0, #4294967295
  20a724:	4946      	ldr	r1, [pc, #280]	; (20a840 <rt_test_005_003_execute+0x130>)
  20a726:	fab0 f080 	clz	r0, r0
  20a72a:	0940      	lsrs	r0, r0, #5
  20a72c:	f7f6 f848 	bl	2007c0 <_test_assert>
  20a730:	b108      	cbz	r0, 20a736 <rt_test_005_003_execute+0x26>
}
  20a732:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return (bool)(tqp->next == (const thread_t *)tqp);
  20a736:	4d43      	ldr	r5, [pc, #268]	; (20a844 <rt_test_005_003_execute+0x134>)
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
  20a738:	4943      	ldr	r1, [pc, #268]	; (20a848 <rt_test_005_003_execute+0x138>)
  20a73a:	6828      	ldr	r0, [r5, #0]
  20a73c:	1b40      	subs	r0, r0, r5
  20a73e:	fab0 f080 	clz	r0, r0
  20a742:	0940      	lsrs	r0, r0, #5
  20a744:	f7f6 f83c 	bl	2007c0 <_test_assert>
  20a748:	2800      	cmp	r0, #0
  20a74a:	d1f2      	bne.n	20a732 <rt_test_005_003_execute+0x22>
    test_assert(sem1.cnt == 0, "counter not zero");
  20a74c:	68a8      	ldr	r0, [r5, #8]
  20a74e:	493f      	ldr	r1, [pc, #252]	; (20a84c <rt_test_005_003_execute+0x13c>)
  20a750:	fab0 f080 	clz	r0, r0
  20a754:	0940      	lsrs	r0, r0, #5
  20a756:	f7f6 f833 	bl	2007c0 <_test_assert>
  20a75a:	2800      	cmp	r0, #0
  20a75c:	d1e9      	bne.n	20a732 <rt_test_005_003_execute+0x22>
  return ch.rlist.current;
  20a75e:	493c      	ldr	r1, [pc, #240]	; (20a850 <rt_test_005_003_execute+0x140>)
  test_set_step(2);
  20a760:	2602      	movs	r6, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20a762:	4603      	mov	r3, r0
  20a764:	4a3b      	ldr	r2, [pc, #236]	; (20a854 <rt_test_005_003_execute+0x144>)
  return chThdGetSelfX()->prio;
  20a766:	6989      	ldr	r1, [r1, #24]
  20a768:	483b      	ldr	r0, [pc, #236]	; (20a858 <rt_test_005_003_execute+0x148>)
  20a76a:	6889      	ldr	r1, [r1, #8]
  test_set_step(2);
  20a76c:	6026      	str	r6, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
  20a76e:	3901      	subs	r1, #1
  20a770:	f7fe f84e 	bl	208810 <chThdCreateStatic.constprop.61>
  20a774:	4b39      	ldr	r3, [pc, #228]	; (20a85c <rt_test_005_003_execute+0x14c>)
  20a776:	6018      	str	r0, [r3, #0]
    msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
  20a778:	f241 3088 	movw	r0, #5000	; 0x1388
  20a77c:	f7f9 faf8 	bl	203d70 <chSemWaitTimeout.constprop.58>
  20a780:	4606      	mov	r6, r0
    test_wait_threads();
  20a782:	f7fe ff45 	bl	209610 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
  20a786:	492e      	ldr	r1, [pc, #184]	; (20a840 <rt_test_005_003_execute+0x130>)
  20a788:	fab6 f086 	clz	r0, r6
  20a78c:	0940      	lsrs	r0, r0, #5
  20a78e:	f7f6 f817 	bl	2007c0 <_test_assert>
  20a792:	2800      	cmp	r0, #0
  20a794:	d1cd      	bne.n	20a732 <rt_test_005_003_execute+0x22>
  20a796:	6828      	ldr	r0, [r5, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
  20a798:	492b      	ldr	r1, [pc, #172]	; (20a848 <rt_test_005_003_execute+0x138>)
  20a79a:	1b40      	subs	r0, r0, r5
  20a79c:	fab0 f080 	clz	r0, r0
  20a7a0:	0940      	lsrs	r0, r0, #5
  20a7a2:	f7f6 f80d 	bl	2007c0 <_test_assert>
  20a7a6:	2800      	cmp	r0, #0
  20a7a8:	d1c3      	bne.n	20a732 <rt_test_005_003_execute+0x22>
    test_assert(sem1.cnt == 0, "counter not zero");
  20a7aa:	68a8      	ldr	r0, [r5, #8]
  20a7ac:	4927      	ldr	r1, [pc, #156]	; (20a84c <rt_test_005_003_execute+0x13c>)
  20a7ae:	fab0 f080 	clz	r0, r0
  20a7b2:	0940      	lsrs	r0, r0, #5
  20a7b4:	f7f6 f804 	bl	2007c0 <_test_assert>
  20a7b8:	2800      	cmp	r0, #0
  20a7ba:	d1ba      	bne.n	20a732 <rt_test_005_003_execute+0x22>
  test_set_step(3);
  20a7bc:	2303      	movs	r3, #3
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
  20a7be:	2641      	movs	r6, #65	; 0x41
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
  20a7c0:	f8df 807c 	ldr.w	r8, [pc, #124]	; 20a840 <rt_test_005_003_execute+0x130>
  test_set_step(3);
  20a7c4:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
  20a7c6:	f7fd fb23 	bl	207e10 <test_wait_tick>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
  20a7ca:	4f1f      	ldr	r7, [pc, #124]	; (20a848 <rt_test_005_003_execute+0x138>)
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
  20a7cc:	4681      	mov	r9, r0
      test_assert(sem1.cnt == 0, "counter not zero");
  20a7ce:	4c1f      	ldr	r4, [pc, #124]	; (20a84c <rt_test_005_003_execute+0x13c>)
      test_emit_token('A' + i);
  20a7d0:	4630      	mov	r0, r6
  20a7d2:	f7fa fadd 	bl	204d90 <test_emit_token>
      msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
  20a7d6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  20a7da:	f7f9 fac9 	bl	203d70 <chSemWaitTimeout.constprop.58>
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
  20a7de:	f1a0 30ff 	sub.w	r0, r0, #4294967295
  20a7e2:	4641      	mov	r1, r8
  20a7e4:	fab0 f080 	clz	r0, r0
  20a7e8:	0940      	lsrs	r0, r0, #5
  20a7ea:	f7f5 ffe9 	bl	2007c0 <_test_assert>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
  20a7ee:	4639      	mov	r1, r7
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
  20a7f0:	2800      	cmp	r0, #0
  20a7f2:	d19e      	bne.n	20a732 <rt_test_005_003_execute+0x22>
  20a7f4:	6828      	ldr	r0, [r5, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
  20a7f6:	1b40      	subs	r0, r0, r5
  20a7f8:	fab0 f080 	clz	r0, r0
  20a7fc:	0940      	lsrs	r0, r0, #5
  20a7fe:	f7f5 ffdf 	bl	2007c0 <_test_assert>
      test_assert(sem1.cnt == 0, "counter not zero");
  20a802:	4621      	mov	r1, r4
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
  20a804:	2800      	cmp	r0, #0
  20a806:	d194      	bne.n	20a732 <rt_test_005_003_execute+0x22>
      test_assert(sem1.cnt == 0, "counter not zero");
  20a808:	68a8      	ldr	r0, [r5, #8]
  20a80a:	3601      	adds	r6, #1
  20a80c:	fab0 f080 	clz	r0, r0
  20a810:	0940      	lsrs	r0, r0, #5
  20a812:	f7f5 ffd5 	bl	2007c0 <_test_assert>
  20a816:	2800      	cmp	r0, #0
  20a818:	d18b      	bne.n	20a732 <rt_test_005_003_execute+0x22>
  20a81a:	b2f6      	uxtb	r6, r6
    for (i = 0; i < 5; i++) {
  20a81c:	2e46      	cmp	r6, #70	; 0x46
  20a81e:	d1d7      	bne.n	20a7d0 <rt_test_005_003_execute+0xc0>
    test_assert_sequence("ABCDE", "invalid sequence");
  20a820:	490f      	ldr	r1, [pc, #60]	; (20a860 <rt_test_005_003_execute+0x150>)
  20a822:	4810      	ldr	r0, [pc, #64]	; (20a864 <rt_test_005_003_execute+0x154>)
  20a824:	f7f6 f86c 	bl	200900 <_test_assert_sequence>
  20a828:	2800      	cmp	r0, #0
  20a82a:	d182      	bne.n	20a732 <rt_test_005_003_execute+0x22>
    test_assert_time_window(target_time,
  20a82c:	f609 11d8 	addw	r1, r9, #2520	; 0x9d8
  20a830:	f609 10c4 	addw	r0, r9, #2500	; 0x9c4
}
  20a834:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert_time_window(target_time,
  20a838:	f7f5 bf8a 	b.w	200750 <_test_assert_time_window.constprop.2>
  20a83c:	20001f6c 	.word	0x20001f6c
  20a840:	0800c6a0 	.word	0x0800c6a0
  20a844:	20001838 	.word	0x20001838
  20a848:	0800d728 	.word	0x0800d728
  20a84c:	0800d664 	.word	0x0800d664
  20a850:	20000dc8 	.word	0x20000dc8
  20a854:	00207cc1 	.word	0x00207cc1
  20a858:	20001858 	.word	0x20001858
  20a85c:	20001f84 	.word	0x20001f84
  20a860:	0800d7d4 	.word	0x0800d7d4
  20a864:	0800d770 	.word	0x0800d770
	...

0020a870 <rt_test_005_002_execute>:
static void rt_test_005_002_execute(void) {
  20a870:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
  20a874:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 20a958 <rt_test_005_002_execute+0xe8>
  test_set_step(1);
  20a878:	2401      	movs	r4, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  20a87a:	4f2c      	ldr	r7, [pc, #176]	; (20a92c <rt_test_005_002_execute+0xbc>)
  return chThdGetSelfX()->prio;
  20a87c:	f8d8 3018 	ldr.w	r3, [r8, #24]
  20a880:	4e2b      	ldr	r6, [pc, #172]	; (20a930 <rt_test_005_002_execute+0xc0>)
  20a882:	463a      	mov	r2, r7
  20a884:	6899      	ldr	r1, [r3, #8]
  test_set_step(1);
  20a886:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 20a95c <rt_test_005_002_execute+0xec>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  20a88a:	4630      	mov	r0, r6
  20a88c:	3105      	adds	r1, #5
  20a88e:	4b29      	ldr	r3, [pc, #164]	; (20a934 <rt_test_005_002_execute+0xc4>)
  test_set_step(1);
  20a890:	f8c9 4000 	str.w	r4, [r9]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  20a894:	f7fd ffbc 	bl	208810 <chThdCreateStatic.constprop.61>
  20a898:	f8d8 3018 	ldr.w	r3, [r8, #24]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  20a89c:	463a      	mov	r2, r7
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  20a89e:	4d26      	ldr	r5, [pc, #152]	; (20a938 <rt_test_005_002_execute+0xc8>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  20a8a0:	6899      	ldr	r1, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  20a8a2:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  20a8a4:	f506 70a4 	add.w	r0, r6, #328	; 0x148
  20a8a8:	4421      	add	r1, r4
  20a8aa:	4b24      	ldr	r3, [pc, #144]	; (20a93c <rt_test_005_002_execute+0xcc>)
  20a8ac:	f7fd ffb0 	bl	208810 <chThdCreateStatic.constprop.61>
  20a8b0:	f8d8 3018 	ldr.w	r3, [r8, #24]
  20a8b4:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  20a8b6:	463a      	mov	r2, r7
  20a8b8:	6899      	ldr	r1, [r3, #8]
  20a8ba:	f506 7024 	add.w	r0, r6, #656	; 0x290
  20a8be:	4b20      	ldr	r3, [pc, #128]	; (20a940 <rt_test_005_002_execute+0xd0>)
  20a8c0:	3103      	adds	r1, #3
    chSemSignal(&sem1);
  20a8c2:	4c20      	ldr	r4, [pc, #128]	; (20a944 <rt_test_005_002_execute+0xd4>)
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  20a8c4:	f7fd ffa4 	bl	208810 <chThdCreateStatic.constprop.61>
  20a8c8:	f8d8 3018 	ldr.w	r3, [r8, #24]
  20a8cc:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  20a8ce:	463a      	mov	r2, r7
  20a8d0:	6899      	ldr	r1, [r3, #8]
  20a8d2:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
  20a8d6:	4b1c      	ldr	r3, [pc, #112]	; (20a948 <rt_test_005_002_execute+0xd8>)
  20a8d8:	3104      	adds	r1, #4
  20a8da:	f7fd ff99 	bl	208810 <chThdCreateStatic.constprop.61>
  20a8de:	f8d8 3018 	ldr.w	r3, [r8, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  20a8e2:	463a      	mov	r2, r7
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  20a8e4:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  20a8e6:	6899      	ldr	r1, [r3, #8]
  20a8e8:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
  20a8ec:	4b17      	ldr	r3, [pc, #92]	; (20a94c <rt_test_005_002_execute+0xdc>)
  20a8ee:	3102      	adds	r1, #2
  20a8f0:	f7fd ff8e 	bl	208810 <chThdCreateStatic.constprop.61>
  test_set_step(2);
  20a8f4:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  20a8f6:	6128      	str	r0, [r5, #16]
    chSemSignal(&sem1);
  20a8f8:	4620      	mov	r0, r4
  test_set_step(2);
  20a8fa:	f8c9 3000 	str.w	r3, [r9]
    chSemSignal(&sem1);
  20a8fe:	f7fc feaf 	bl	207660 <chSemSignal>
    chSemSignal(&sem1);
  20a902:	4620      	mov	r0, r4
  20a904:	f7fc feac 	bl	207660 <chSemSignal>
    chSemSignal(&sem1);
  20a908:	4620      	mov	r0, r4
  20a90a:	f7fc fea9 	bl	207660 <chSemSignal>
    chSemSignal(&sem1);
  20a90e:	4620      	mov	r0, r4
  20a910:	f7fc fea6 	bl	207660 <chSemSignal>
    chSemSignal(&sem1);
  20a914:	4620      	mov	r0, r4
  20a916:	f7fc fea3 	bl	207660 <chSemSignal>
    test_wait_threads();
  20a91a:	f7fe fe79 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20a91e:	490c      	ldr	r1, [pc, #48]	; (20a950 <rt_test_005_002_execute+0xe0>)
  20a920:	480c      	ldr	r0, [pc, #48]	; (20a954 <rt_test_005_002_execute+0xe4>)
}
  20a922:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
  20a926:	f7f5 bfeb 	b.w	200900 <_test_assert_sequence>
  20a92a:	bf00      	nop
  20a92c:	002077b1 	.word	0x002077b1
  20a930:	20001858 	.word	0x20001858
  20a934:	0800d6e8 	.word	0x0800d6e8
  20a938:	20001f84 	.word	0x20001f84
  20a93c:	0800d6ec 	.word	0x0800d6ec
  20a940:	0800d934 	.word	0x0800d934
  20a944:	20001838 	.word	0x20001838
  20a948:	0800e68c 	.word	0x0800e68c
  20a94c:	0800d774 	.word	0x0800d774
  20a950:	0800d7d4 	.word	0x0800d7d4
  20a954:	0800d770 	.word	0x0800d770
  20a958:	20000dc8 	.word	0x20000dc8
  20a95c:	20001f6c 	.word	0x20001f6c

0020a960 <rt_test_004_001_execute>:

static void rt_test_004_001_execute(void) {
  20a960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
  20a962:	4c44      	ldr	r4, [pc, #272]	; (20aa74 <rt_test_004_001_execute+0x114>)
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
  20a964:	2501      	movs	r5, #1
  20a966:	4e44      	ldr	r6, [pc, #272]	; (20aa78 <rt_test_004_001_execute+0x118>)
  return chThdGetSelfX()->prio;
  20a968:	69a2      	ldr	r2, [r4, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
  20a96a:	4b44      	ldr	r3, [pc, #272]	; (20aa7c <rt_test_004_001_execute+0x11c>)
  20a96c:	6891      	ldr	r1, [r2, #8]
  20a96e:	4844      	ldr	r0, [pc, #272]	; (20aa80 <rt_test_004_001_execute+0x120>)
  20a970:	4a44      	ldr	r2, [pc, #272]	; (20aa84 <rt_test_004_001_execute+0x124>)
  20a972:	3901      	subs	r1, #1
  test_set_step(1);
  20a974:	6035      	str	r5, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
  20a976:	f7fd ff4b 	bl	208810 <chThdCreateStatic.constprop.61>
  20a97a:	4b43      	ldr	r3, [pc, #268]	; (20aa88 <rt_test_004_001_execute+0x128>)
  20a97c:	6018      	str	r0, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20a97e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a980:	2320      	movs	r3, #32
  20a982:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20a986:	b662      	cpsie	i
  chDbgAssert(*trp == NULL, "not NULL");
  20a988:	4d40      	ldr	r5, [pc, #256]	; (20aa8c <rt_test_004_001_execute+0x12c>)
  _dbg_check_lock();
  20a98a:	f7f9 f9e1 	bl	203d50 <_dbg_check_lock>
  20a98e:	682b      	ldr	r3, [r5, #0]
  20a990:	b113      	cbz	r3, 20a998 <rt_test_004_001_execute+0x38>
  20a992:	483f      	ldr	r0, [pc, #252]	; (20aa90 <rt_test_004_001_execute+0x130>)
  20a994:	f7f6 f8ec 	bl	200b70 <chSysHalt>
  return ch.rlist.current;
  20a998:	69a3      	ldr	r3, [r4, #24]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
  20a99a:	f04f 31ff 	mov.w	r1, #4294967295
  20a99e:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
  20a9a0:	625d      	str	r5, [r3, #36]	; 0x24
  *trp = tp;
  20a9a2:	602b      	str	r3, [r5, #0]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
  20a9a4:	f7f8 fe54 	bl	203650 <chSchGoSleepTimeoutS>
  20a9a8:	4607      	mov	r7, r0
  _dbg_check_unlock();
  20a9aa:	f7f9 f981 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20a9ae:	6823      	ldr	r3, [r4, #0]
  20a9b0:	42a3      	cmp	r3, r4
  20a9b2:	d004      	beq.n	20a9be <rt_test_004_001_execute+0x5e>
  20a9b4:	69a2      	ldr	r2, [r4, #24]
  20a9b6:	689b      	ldr	r3, [r3, #8]
  20a9b8:	6892      	ldr	r2, [r2, #8]
  20a9ba:	429a      	cmp	r2, r3
  20a9bc:	d357      	bcc.n	20aa6e <rt_test_004_001_execute+0x10e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a9be:	2300      	movs	r3, #0
  20a9c0:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
  20a9c4:	6828      	ldr	r0, [r5, #0]
  20a9c6:	4933      	ldr	r1, [pc, #204]	; (20aa94 <rt_test_004_001_execute+0x134>)
  20a9c8:	fab0 f080 	clz	r0, r0
  20a9cc:	0940      	lsrs	r0, r0, #5
  20a9ce:	f7f5 fef7 	bl	2007c0 <_test_assert>
  20a9d2:	b100      	cbz	r0, 20a9d6 <rt_test_004_001_execute+0x76>
                            chTimeAddX(time, TIME_MS2I(1000) + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  }
}
  20a9d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert(MSG_OK == msg,"wrong returned message");
  20a9d6:	fab7 f087 	clz	r0, r7
  20a9da:	492f      	ldr	r1, [pc, #188]	; (20aa98 <rt_test_004_001_execute+0x138>)
  20a9dc:	0940      	lsrs	r0, r0, #5
  20a9de:	f7f5 feef 	bl	2007c0 <_test_assert>
  20a9e2:	2800      	cmp	r0, #0
  20a9e4:	d1f6      	bne.n	20a9d4 <rt_test_004_001_execute+0x74>
    test_wait_threads();
  20a9e6:	f7fe fe13 	bl	209610 <test_wait_threads>
  test_set_step(2);
  20a9ea:	2302      	movs	r3, #2
  20a9ec:	6033      	str	r3, [r6, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20a9ee:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20a9f0:	2320      	movs	r3, #32
  20a9f2:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20a9f6:	b662      	cpsie	i
  _dbg_check_lock();
  20a9f8:	f7f9 f9aa 	bl	203d50 <_dbg_check_lock>
  20a9fc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  chDbgAssert(*trp == NULL, "not NULL");
  20aa00:	682b      	ldr	r3, [r5, #0]
  20aa02:	6a56      	ldr	r6, [r2, #36]	; 0x24
  20aa04:	2b00      	cmp	r3, #0
  20aa06:	d1c4      	bne.n	20a992 <rt_test_004_001_execute+0x32>
  20aa08:	69a3      	ldr	r3, [r4, #24]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
  20aa0a:	f242 7110 	movw	r1, #10000	; 0x2710
  20aa0e:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
  20aa10:	625d      	str	r5, [r3, #36]	; 0x24
  *trp = tp;
  20aa12:	602b      	str	r3, [r5, #0]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
  20aa14:	f7f8 fe1c 	bl	203650 <chSchGoSleepTimeoutS>
  20aa18:	4607      	mov	r7, r0
  _dbg_check_unlock();
  20aa1a:	f7f9 f949 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20aa1e:	6823      	ldr	r3, [r4, #0]
  20aa20:	42a3      	cmp	r3, r4
  20aa22:	d004      	beq.n	20aa2e <rt_test_004_001_execute+0xce>
  20aa24:	69a2      	ldr	r2, [r4, #24]
  20aa26:	689b      	ldr	r3, [r3, #8]
  20aa28:	6892      	ldr	r2, [r2, #8]
  20aa2a:	429a      	cmp	r2, r3
  20aa2c:	d31f      	bcc.n	20aa6e <rt_test_004_001_execute+0x10e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20aa2e:	2300      	movs	r3, #0
  20aa30:	f383 8811 	msr	BASEPRI, r3
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(1000)),
  20aa34:	f242 7113 	movw	r1, #10003	; 0x2713
  20aa38:	f242 7010 	movw	r0, #10000	; 0x2710
  20aa3c:	4431      	add	r1, r6
  20aa3e:	4430      	add	r0, r6
  20aa40:	f7f5 fe86 	bl	200750 <_test_assert_time_window.constprop.2>
  20aa44:	2800      	cmp	r0, #0
  20aa46:	d1c5      	bne.n	20a9d4 <rt_test_004_001_execute+0x74>
    test_assert(NULL == tr1, "not NULL");
  20aa48:	6828      	ldr	r0, [r5, #0]
  20aa4a:	4912      	ldr	r1, [pc, #72]	; (20aa94 <rt_test_004_001_execute+0x134>)
  20aa4c:	fab0 f080 	clz	r0, r0
  20aa50:	0940      	lsrs	r0, r0, #5
  20aa52:	f7f5 feb5 	bl	2007c0 <_test_assert>
  20aa56:	2800      	cmp	r0, #0
  20aa58:	d1bc      	bne.n	20a9d4 <rt_test_004_001_execute+0x74>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  20aa5a:	f1a7 30ff 	sub.w	r0, r7, #4294967295
  20aa5e:	490e      	ldr	r1, [pc, #56]	; (20aa98 <rt_test_004_001_execute+0x138>)
  20aa60:	fab0 f080 	clz	r0, r0
}
  20aa64:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  20aa68:	0940      	lsrs	r0, r0, #5
  20aa6a:	f7f5 bea9 	b.w	2007c0 <_test_assert>
  20aa6e:	480b      	ldr	r0, [pc, #44]	; (20aa9c <rt_test_004_001_execute+0x13c>)
  20aa70:	f7f6 f87e 	bl	200b70 <chSysHalt>
  20aa74:	20000dc8 	.word	0x20000dc8
  20aa78:	20001f6c 	.word	0x20001f6c
  20aa7c:	0800d6e8 	.word	0x0800d6e8
  20aa80:	20001858 	.word	0x20001858
  20aa84:	00205761 	.word	0x00205761
  20aa88:	20001f84 	.word	0x20001f84
  20aa8c:	20001f98 	.word	0x20001f98
  20aa90:	0800bf7c 	.word	0x0800bf7c
  20aa94:	0800d5cc 	.word	0x0800d5cc
  20aa98:	0800d5fc 	.word	0x0800d5fc
  20aa9c:	0800bcac 	.word	0x0800bcac

0020aaa0 <rt_test_003_002_execute>:
static void rt_test_003_002_execute(void) {
  20aaa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  20aaa2:	4d54      	ldr	r5, [pc, #336]	; (20abf4 <rt_test_003_002_execute+0x154>)
  test_set_step(1);
  20aaa4:	2401      	movs	r4, #1
  20aaa6:	4e54      	ldr	r6, [pc, #336]	; (20abf8 <rt_test_003_002_execute+0x158>)
  return chThdGetSelfX()->prio;
  20aaa8:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  20aaaa:	4b54      	ldr	r3, [pc, #336]	; (20abfc <rt_test_003_002_execute+0x15c>)
  20aaac:	6891      	ldr	r1, [r2, #8]
  20aaae:	4854      	ldr	r0, [pc, #336]	; (20ac00 <rt_test_003_002_execute+0x160>)
  20aab0:	4a54      	ldr	r2, [pc, #336]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20aab2:	3905      	subs	r1, #5
  test_set_step(1);
  20aab4:	6034      	str	r4, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  20aab6:	f7fd feab 	bl	208810 <chThdCreateStatic.constprop.61>
  20aaba:	69ab      	ldr	r3, [r5, #24]
  20aabc:	4c52      	ldr	r4, [pc, #328]	; (20ac08 <rt_test_003_002_execute+0x168>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  20aabe:	6899      	ldr	r1, [r3, #8]
  20aac0:	4a50      	ldr	r2, [pc, #320]	; (20ac04 <rt_test_003_002_execute+0x164>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  20aac2:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  20aac4:	3904      	subs	r1, #4
  20aac6:	4b51      	ldr	r3, [pc, #324]	; (20ac0c <rt_test_003_002_execute+0x16c>)
  20aac8:	4851      	ldr	r0, [pc, #324]	; (20ac10 <rt_test_003_002_execute+0x170>)
  20aaca:	f7fd fea1 	bl	208810 <chThdCreateStatic.constprop.61>
  20aace:	69ab      	ldr	r3, [r5, #24]
  20aad0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  20aad2:	6899      	ldr	r1, [r3, #8]
  20aad4:	4a4b      	ldr	r2, [pc, #300]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20aad6:	4b4f      	ldr	r3, [pc, #316]	; (20ac14 <rt_test_003_002_execute+0x174>)
  20aad8:	3903      	subs	r1, #3
  20aada:	484f      	ldr	r0, [pc, #316]	; (20ac18 <rt_test_003_002_execute+0x178>)
  20aadc:	f7fd fe98 	bl	208810 <chThdCreateStatic.constprop.61>
  20aae0:	69ab      	ldr	r3, [r5, #24]
  20aae2:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  20aae4:	6899      	ldr	r1, [r3, #8]
  20aae6:	4a47      	ldr	r2, [pc, #284]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20aae8:	4b4c      	ldr	r3, [pc, #304]	; (20ac1c <rt_test_003_002_execute+0x17c>)
  20aaea:	3902      	subs	r1, #2
  20aaec:	484c      	ldr	r0, [pc, #304]	; (20ac20 <rt_test_003_002_execute+0x180>)
  20aaee:	f7fd fe8f 	bl	208810 <chThdCreateStatic.constprop.61>
  20aaf2:	69ab      	ldr	r3, [r5, #24]
  20aaf4:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  20aaf6:	6899      	ldr	r1, [r3, #8]
  20aaf8:	4a42      	ldr	r2, [pc, #264]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20aafa:	3901      	subs	r1, #1
  20aafc:	4b49      	ldr	r3, [pc, #292]	; (20ac24 <rt_test_003_002_execute+0x184>)
  20aafe:	484a      	ldr	r0, [pc, #296]	; (20ac28 <rt_test_003_002_execute+0x188>)
  20ab00:	f7fd fe86 	bl	208810 <chThdCreateStatic.constprop.61>
  20ab04:	6120      	str	r0, [r4, #16]
    test_wait_threads();
  20ab06:	f7fe fd83 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20ab0a:	4948      	ldr	r1, [pc, #288]	; (20ac2c <rt_test_003_002_execute+0x18c>)
  20ab0c:	4848      	ldr	r0, [pc, #288]	; (20ac30 <rt_test_003_002_execute+0x190>)
  20ab0e:	f7f5 fef7 	bl	200900 <_test_assert_sequence>
  20ab12:	b100      	cbz	r0, 20ab16 <rt_test_003_002_execute+0x76>
}
  20ab14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  20ab16:	69aa      	ldr	r2, [r5, #24]
  test_set_step(2);
  20ab18:	2702      	movs	r7, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  20ab1a:	4b42      	ldr	r3, [pc, #264]	; (20ac24 <rt_test_003_002_execute+0x184>)
  20ab1c:	6891      	ldr	r1, [r2, #8]
  20ab1e:	4842      	ldr	r0, [pc, #264]	; (20ac28 <rt_test_003_002_execute+0x188>)
  20ab20:	4a38      	ldr	r2, [pc, #224]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20ab22:	3901      	subs	r1, #1
  test_set_step(2);
  20ab24:	6037      	str	r7, [r6, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  20ab26:	f7fd fe73 	bl	208810 <chThdCreateStatic.constprop.61>
  20ab2a:	69ab      	ldr	r3, [r5, #24]
  20ab2c:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  20ab2e:	6899      	ldr	r1, [r3, #8]
  20ab30:	4a34      	ldr	r2, [pc, #208]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20ab32:	4b3a      	ldr	r3, [pc, #232]	; (20ac1c <rt_test_003_002_execute+0x17c>)
  20ab34:	3902      	subs	r1, #2
  20ab36:	483a      	ldr	r0, [pc, #232]	; (20ac20 <rt_test_003_002_execute+0x180>)
  20ab38:	f7fd fe6a 	bl	208810 <chThdCreateStatic.constprop.61>
  20ab3c:	69ab      	ldr	r3, [r5, #24]
  20ab3e:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  20ab40:	6899      	ldr	r1, [r3, #8]
  20ab42:	4a30      	ldr	r2, [pc, #192]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20ab44:	4b33      	ldr	r3, [pc, #204]	; (20ac14 <rt_test_003_002_execute+0x174>)
  20ab46:	3903      	subs	r1, #3
  20ab48:	4833      	ldr	r0, [pc, #204]	; (20ac18 <rt_test_003_002_execute+0x178>)
  20ab4a:	f7fd fe61 	bl	208810 <chThdCreateStatic.constprop.61>
  20ab4e:	69ab      	ldr	r3, [r5, #24]
  20ab50:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  20ab52:	6899      	ldr	r1, [r3, #8]
  20ab54:	4a2b      	ldr	r2, [pc, #172]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20ab56:	4b2d      	ldr	r3, [pc, #180]	; (20ac0c <rt_test_003_002_execute+0x16c>)
  20ab58:	3904      	subs	r1, #4
  20ab5a:	482d      	ldr	r0, [pc, #180]	; (20ac10 <rt_test_003_002_execute+0x170>)
  20ab5c:	f7fd fe58 	bl	208810 <chThdCreateStatic.constprop.61>
  20ab60:	69ab      	ldr	r3, [r5, #24]
  20ab62:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  20ab64:	6899      	ldr	r1, [r3, #8]
  20ab66:	4a27      	ldr	r2, [pc, #156]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20ab68:	3905      	subs	r1, #5
  20ab6a:	4b24      	ldr	r3, [pc, #144]	; (20abfc <rt_test_003_002_execute+0x15c>)
  20ab6c:	4824      	ldr	r0, [pc, #144]	; (20ac00 <rt_test_003_002_execute+0x160>)
  20ab6e:	f7fd fe4f 	bl	208810 <chThdCreateStatic.constprop.61>
  20ab72:	6020      	str	r0, [r4, #0]
    test_wait_threads();
  20ab74:	f7fe fd4c 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20ab78:	492c      	ldr	r1, [pc, #176]	; (20ac2c <rt_test_003_002_execute+0x18c>)
  20ab7a:	482d      	ldr	r0, [pc, #180]	; (20ac30 <rt_test_003_002_execute+0x190>)
  20ab7c:	f7f5 fec0 	bl	200900 <_test_assert_sequence>
  20ab80:	2800      	cmp	r0, #0
  20ab82:	d1c7      	bne.n	20ab14 <rt_test_003_002_execute+0x74>
  20ab84:	69aa      	ldr	r2, [r5, #24]
  test_set_step(3);
  20ab86:	2003      	movs	r0, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  20ab88:	4b20      	ldr	r3, [pc, #128]	; (20ac0c <rt_test_003_002_execute+0x16c>)
  20ab8a:	6891      	ldr	r1, [r2, #8]
  test_set_step(3);
  20ab8c:	6030      	str	r0, [r6, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  20ab8e:	4a1d      	ldr	r2, [pc, #116]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20ab90:	3904      	subs	r1, #4
  20ab92:	481f      	ldr	r0, [pc, #124]	; (20ac10 <rt_test_003_002_execute+0x170>)
  20ab94:	f7fd fe3c 	bl	208810 <chThdCreateStatic.constprop.61>
  20ab98:	69ab      	ldr	r3, [r5, #24]
  20ab9a:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  20ab9c:	6899      	ldr	r1, [r3, #8]
  20ab9e:	4a19      	ldr	r2, [pc, #100]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20aba0:	4b16      	ldr	r3, [pc, #88]	; (20abfc <rt_test_003_002_execute+0x15c>)
  20aba2:	3905      	subs	r1, #5
  20aba4:	4816      	ldr	r0, [pc, #88]	; (20ac00 <rt_test_003_002_execute+0x160>)
  20aba6:	f7fd fe33 	bl	208810 <chThdCreateStatic.constprop.61>
  20abaa:	69ab      	ldr	r3, [r5, #24]
  20abac:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  20abae:	6899      	ldr	r1, [r3, #8]
  20abb0:	4a14      	ldr	r2, [pc, #80]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20abb2:	4b1c      	ldr	r3, [pc, #112]	; (20ac24 <rt_test_003_002_execute+0x184>)
  20abb4:	3901      	subs	r1, #1
  20abb6:	481c      	ldr	r0, [pc, #112]	; (20ac28 <rt_test_003_002_execute+0x188>)
  20abb8:	f7fd fe2a 	bl	208810 <chThdCreateStatic.constprop.61>
  20abbc:	69ab      	ldr	r3, [r5, #24]
  20abbe:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  20abc0:	6899      	ldr	r1, [r3, #8]
  20abc2:	4a10      	ldr	r2, [pc, #64]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20abc4:	4b15      	ldr	r3, [pc, #84]	; (20ac1c <rt_test_003_002_execute+0x17c>)
  20abc6:	3902      	subs	r1, #2
  20abc8:	4815      	ldr	r0, [pc, #84]	; (20ac20 <rt_test_003_002_execute+0x180>)
  20abca:	f7fd fe21 	bl	208810 <chThdCreateStatic.constprop.61>
  20abce:	69ab      	ldr	r3, [r5, #24]
  20abd0:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  20abd2:	6899      	ldr	r1, [r3, #8]
  20abd4:	4a0b      	ldr	r2, [pc, #44]	; (20ac04 <rt_test_003_002_execute+0x164>)
  20abd6:	4b0f      	ldr	r3, [pc, #60]	; (20ac14 <rt_test_003_002_execute+0x174>)
  20abd8:	3903      	subs	r1, #3
  20abda:	480f      	ldr	r0, [pc, #60]	; (20ac18 <rt_test_003_002_execute+0x178>)
  20abdc:	f7fd fe18 	bl	208810 <chThdCreateStatic.constprop.61>
  20abe0:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
  20abe2:	f7fe fd15 	bl	209610 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  20abe6:	4911      	ldr	r1, [pc, #68]	; (20ac2c <rt_test_003_002_execute+0x18c>)
  20abe8:	4811      	ldr	r0, [pc, #68]	; (20ac30 <rt_test_003_002_execute+0x190>)
}
  20abea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
  20abee:	f7f5 be87 	b.w	200900 <_test_assert_sequence>
  20abf2:	bf00      	nop
  20abf4:	20000dc8 	.word	0x20000dc8
  20abf8:	20001f6c 	.word	0x20001f6c
  20abfc:	0800d774 	.word	0x0800d774
  20ac00:	20001858 	.word	0x20001858
  20ac04:	002057e1 	.word	0x002057e1
  20ac08:	20001f84 	.word	0x20001f84
  20ac0c:	0800e68c 	.word	0x0800e68c
  20ac10:	200019a0 	.word	0x200019a0
  20ac14:	0800d934 	.word	0x0800d934
  20ac18:	20001ae8 	.word	0x20001ae8
  20ac1c:	0800d6ec 	.word	0x0800d6ec
  20ac20:	20001c30 	.word	0x20001c30
  20ac24:	0800d6e8 	.word	0x0800d6e8
  20ac28:	20001d78 	.word	0x20001d78
  20ac2c:	0800d7d4 	.word	0x0800d7d4
  20ac30:	0800d770 	.word	0x0800d770
	...

0020ac40 <cmd_test>:
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
  thread_t *tp;
  tfunc_t tfp;

  (void)argv;
  if (argc != 1) {
  20ac40:	2901      	cmp	r1, #1
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
  20ac42:	b530      	push	{r4, r5, lr}
  20ac44:	4604      	mov	r4, r0
  20ac46:	b083      	sub	sp, #12
  if (argc != 1) {
  20ac48:	d11c      	bne.n	20ac84 <cmd_test+0x44>
    shellUsage(chp, "test rt|oslib");
    return;
  }
  if (!strcmp(argv[0], "rt")) {
  20ac4a:	6815      	ldr	r5, [r2, #0]
  20ac4c:	4916      	ldr	r1, [pc, #88]	; (20aca8 <cmd_test+0x68>)
  20ac4e:	4628      	mov	r0, r5
  20ac50:	f7f5 fc0a 	bl	200468 <strcmp>
  20ac54:	b1f0      	cbz	r0, 20ac94 <cmd_test+0x54>
    tfp = test_rt;
  }
  else if (!strcmp(argv[0], "oslib")) {
  20ac56:	4628      	mov	r0, r5
  20ac58:	4914      	ldr	r1, [pc, #80]	; (20acac <cmd_test+0x6c>)
  20ac5a:	f7f5 fc05 	bl	200468 <strcmp>
  20ac5e:	b988      	cbnz	r0, 20ac84 <cmd_test+0x44>
    tfp = test_oslib;
  20ac60:	4d13      	ldr	r5, [pc, #76]	; (20acb0 <cmd_test+0x70>)
  return ch.rlist.current;
  20ac62:	4b14      	ldr	r3, [pc, #80]	; (20acb4 <cmd_test+0x74>)
  }
  else {
    shellUsage(chp, "test rt|oslib");
    return;
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
  20ac64:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
  20ac68:	4a13      	ldr	r2, [pc, #76]	; (20acb8 <cmd_test+0x78>)
  20ac6a:	2000      	movs	r0, #0
  return chThdGetSelfX()->prio;
  20ac6c:	699b      	ldr	r3, [r3, #24]
  20ac6e:	689b      	ldr	r3, [r3, #8]
  20ac70:	e9cd 5400 	strd	r5, r4, [sp]
  20ac74:	f7fb fbf4 	bl	206460 <chThdCreateFromHeap>
                           "test", chThdGetPriorityX(),
                           tfp, chp);
  if (tp == NULL) {
  20ac78:	b170      	cbz	r0, 20ac98 <cmd_test+0x58>
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
    return;
  }
  chThdWait(tp);
}
  20ac7a:	b003      	add	sp, #12
  20ac7c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  chThdWait(tp);
  20ac80:	f7fe b8ee 	b.w	208e60 <chThdWait>
    shellUsage(chp, "test rt|oslib");
  20ac84:	4620      	mov	r0, r4
  20ac86:	4a0d      	ldr	r2, [pc, #52]	; (20acbc <cmd_test+0x7c>)
  20ac88:	490d      	ldr	r1, [pc, #52]	; (20acc0 <cmd_test+0x80>)
}
  20ac8a:	b003      	add	sp, #12
  20ac8c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    shellUsage(chp, "test rt|oslib");
  20ac90:	f7f8 b8fe 	b.w	202e90 <chprintf>
    tfp = test_rt;
  20ac94:	4d0b      	ldr	r5, [pc, #44]	; (20acc4 <cmd_test+0x84>)
  20ac96:	e7e4      	b.n	20ac62 <cmd_test+0x22>
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
  20ac98:	4620      	mov	r0, r4
  20ac9a:	490b      	ldr	r1, [pc, #44]	; (20acc8 <cmd_test+0x88>)
}
  20ac9c:	b003      	add	sp, #12
  20ac9e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
  20aca2:	f7f8 b8f5 	b.w	202e90 <chprintf>
  20aca6:	bf00      	nop
  20aca8:	0800c444 	.word	0x0800c444
  20acac:	0800c43c 	.word	0x0800c43c
  20acb0:	002083f1 	.word	0x002083f1
  20acb4:	20000dc8 	.word	0x20000dc8
  20acb8:	0800e28c 	.word	0x0800e28c
  20acbc:	0800c434 	.word	0x0800c434
  20acc0:	0800c270 	.word	0x0800c270
  20acc4:	002083e1 	.word	0x002083e1
  20acc8:	0800c448 	.word	0x0800c448
  20accc:	00000000 	.word	0x00000000

0020acd0 <chSysGetStatusAndLockX>:
syssts_t chSysGetStatusAndLockX(void) {
  20acd0:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
  20acd2:	f3ef 8411 	mrs	r4, BASEPRI
  if (port_irq_enabled(sts)) {
  20acd6:	b95c      	cbnz	r4, 20acf0 <chSysGetStatusAndLockX+0x20>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  20acd8:	f3ef 8305 	mrs	r3, IPSR
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
  20acdc:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (port_is_isr_context()) {
  20ace0:	b943      	cbnz	r3, 20acf4 <chSysGetStatusAndLockX+0x24>
  __ASM volatile ("cpsid i" : : : "memory");
  20ace2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ace4:	2320      	movs	r3, #32
  20ace6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20acea:	b662      	cpsie	i
  _dbg_check_lock();
  20acec:	f7f9 f830 	bl	203d50 <_dbg_check_lock>
}
  20acf0:	4620      	mov	r0, r4
  20acf2:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
  20acf4:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20acf6:	2320      	movs	r3, #32
  20acf8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20acfc:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  20acfe:	f7f6 fadf 	bl	2012c0 <_dbg_check_lock_from_isr>
  20ad02:	4620      	mov	r0, r4
  20ad04:	bd10      	pop	{r4, pc}
  20ad06:	bf00      	nop
	...

0020ad10 <rt_test_002_002_execute>:
static void rt_test_002_002_execute(void) {
  20ad10:	b530      	push	{r4, r5, lr}
  test_set_step(1);
  20ad12:	2301      	movs	r3, #1
  20ad14:	4d64      	ldr	r5, [pc, #400]	; (20aea8 <rt_test_002_002_execute+0x198>)
static void rt_test_002_002_execute(void) {
  20ad16:	b087      	sub	sp, #28
  test_set_step(1);
  20ad18:	602b      	str	r3, [r5, #0]
    sts = chSysGetStatusAndLockX();
  20ad1a:	f7ff ffd9 	bl	20acd0 <chSysGetStatusAndLockX>
  if (port_irq_enabled(sts)) {
  20ad1e:	b908      	cbnz	r0, 20ad24 <rt_test_002_002_execute+0x14>
  20ad20:	f7f8 ffee 	bl	203d00 <chSysRestoreStatusX.part.2>
  test_set_step(2);
  20ad24:	2302      	movs	r3, #2
  20ad26:	602b      	str	r3, [r5, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20ad28:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ad2a:	2320      	movs	r3, #32
  20ad2c:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20ad30:	b662      	cpsie	i
  _dbg_check_lock();
  20ad32:	f7f9 f80d 	bl	203d50 <_dbg_check_lock>
    sts = chSysGetStatusAndLockX();
  20ad36:	f7ff ffcb 	bl	20acd0 <chSysGetStatusAndLockX>
  20ad3a:	b908      	cbnz	r0, 20ad40 <rt_test_002_002_execute+0x30>
  20ad3c:	f7f8 ffe0 	bl	203d00 <chSysRestoreStatusX.part.2>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20ad40:	4c5a      	ldr	r4, [pc, #360]	; (20aeac <rt_test_002_002_execute+0x19c>)
  _dbg_check_unlock();
  20ad42:	f7f8 ffb5 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20ad46:	6823      	ldr	r3, [r4, #0]
  20ad48:	42a3      	cmp	r3, r4
  20ad4a:	d004      	beq.n	20ad56 <rt_test_002_002_execute+0x46>
  20ad4c:	69a2      	ldr	r2, [r4, #24]
  20ad4e:	689b      	ldr	r3, [r3, #8]
  20ad50:	6892      	ldr	r2, [r2, #8]
  20ad52:	429a      	cmp	r2, r3
  20ad54:	d372      	bcc.n	20ae3c <rt_test_002_002_execute+0x12c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ad56:	2300      	movs	r3, #0
  20ad58:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
  20ad5c:	2303      	movs	r3, #3
  20ad5e:	602b      	str	r3, [r5, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
  20ad60:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
  20ad64:	2b00      	cmp	r3, #0
  20ad66:	d074      	beq.n	20ae52 <rt_test_002_002_execute+0x142>
  20ad68:	f3ef 8311 	mrs	r3, BASEPRI
  20ad6c:	2b00      	cmp	r3, #0
  20ad6e:	d068      	beq.n	20ae42 <rt_test_002_002_execute+0x132>
  _dbg_check_unlock();
  20ad70:	f7f8 ff9e 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20ad74:	6823      	ldr	r3, [r4, #0]
  20ad76:	42a3      	cmp	r3, r4
  20ad78:	d004      	beq.n	20ad84 <rt_test_002_002_execute+0x74>
  20ad7a:	69a2      	ldr	r2, [r4, #24]
  20ad7c:	689b      	ldr	r3, [r3, #8]
  20ad7e:	6892      	ldr	r2, [r2, #8]
  20ad80:	429a      	cmp	r2, r3
  20ad82:	d35b      	bcc.n	20ae3c <rt_test_002_002_execute+0x12c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ad84:	2300      	movs	r3, #0
  20ad86:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
  20ad8a:	2304      	movs	r3, #4
  20ad8c:	602b      	str	r3, [r5, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  20ad8e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ad90:	2320      	movs	r3, #32
  20ad92:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20ad96:	b662      	cpsie	i
  _dbg_check_lock();
  20ad98:	f7f8 ffda 	bl	203d50 <_dbg_check_lock>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
  20ad9c:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
  20ada0:	2b00      	cmp	r3, #0
  20ada2:	d162      	bne.n	20ae6a <rt_test_002_002_execute+0x15a>
  20ada4:	f3ef 8311 	mrs	r3, BASEPRI
  20ada8:	2b00      	cmp	r3, #0
  20adaa:	d16f      	bne.n	20ae8c <rt_test_002_002_execute+0x17c>
  test_set_step(5);
  20adac:	2205      	movs	r2, #5
  vtp->func = NULL;
  20adae:	2300      	movs	r3, #0
  20adb0:	602a      	str	r2, [r5, #0]
  20adb2:	9304      	str	r3, [sp, #16]
  __ASM volatile ("cpsid i" : : : "memory");
  20adb4:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20adb6:	2320      	movs	r3, #32
  20adb8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20adbc:	b662      	cpsie	i
  _dbg_check_lock();
  20adbe:	f7f8 ffc7 	bl	203d50 <_dbg_check_lock>
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
    chVTDoResetI(vtp);
  20adc2:	ad01      	add	r5, sp, #4
  chDbgCheckClassI();
  20adc4:	f7f5 ffe4 	bl	200d90 <chDbgCheckClassI>
  if (chVTIsArmedI(vtp)) {
  20adc8:	9b04      	ldr	r3, [sp, #16]
  20adca:	b113      	cbz	r3, 20add2 <rt_test_002_002_execute+0xc2>
    chVTDoResetI(vtp);
  20adcc:	4628      	mov	r0, r5
  20adce:	f7f7 fa07 	bl	2021e0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
  20add2:	2300      	movs	r3, #0
  20add4:	4628      	mov	r0, r5
  20add6:	4a36      	ldr	r2, [pc, #216]	; (20aeb0 <rt_test_002_002_execute+0x1a0>)
  20add8:	2101      	movs	r1, #1
  20adda:	f7f7 fa49 	bl	202270 <chVTDoSetI>
  _dbg_check_unlock();
  20adde:	f7f8 ff67 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20ade2:	6823      	ldr	r3, [r4, #0]
  20ade4:	42a3      	cmp	r3, r4
  20ade6:	d004      	beq.n	20adf2 <rt_test_002_002_execute+0xe2>
  20ade8:	69a2      	ldr	r2, [r4, #24]
  20adea:	689b      	ldr	r3, [r3, #8]
  20adec:	6892      	ldr	r2, [r2, #8]
  20adee:	429a      	cmp	r2, r3
  20adf0:	d324      	bcc.n	20ae3c <rt_test_002_002_execute+0x12c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20adf2:	2300      	movs	r3, #0
  20adf4:	f383 8811 	msr	BASEPRI, r3
    chThdSleep(10);
  20adf8:	200a      	movs	r0, #10
  20adfa:	f7fc fe59 	bl	207ab0 <chThdSleep>
  __ASM volatile ("cpsid i" : : : "memory");
  20adfe:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ae00:	2320      	movs	r3, #32
  20ae02:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20ae06:	b662      	cpsie	i
  _dbg_check_lock();
  20ae08:	f7f8 ffa2 	bl	203d50 <_dbg_check_lock>
  chDbgCheckClassI();
  20ae0c:	f7f5 ffc0 	bl	200d90 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
  20ae10:	9d04      	ldr	r5, [sp, #16]
  _dbg_check_unlock();
  20ae12:	f7f8 ff4d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20ae16:	6823      	ldr	r3, [r4, #0]
  20ae18:	42a3      	cmp	r3, r4
  20ae1a:	d004      	beq.n	20ae26 <rt_test_002_002_execute+0x116>
  20ae1c:	69a2      	ldr	r2, [r4, #24]
  20ae1e:	689b      	ldr	r3, [r3, #8]
  20ae20:	6892      	ldr	r2, [r2, #8]
  20ae22:	429a      	cmp	r2, r3
  20ae24:	d30a      	bcc.n	20ae3c <rt_test_002_002_execute+0x12c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ae26:	2300      	movs	r3, #0
  20ae28:	f383 8811 	msr	BASEPRI, r3
    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
  20ae2c:	fab5 f085 	clz	r0, r5
  20ae30:	4920      	ldr	r1, [pc, #128]	; (20aeb4 <rt_test_002_002_execute+0x1a4>)
  20ae32:	0940      	lsrs	r0, r0, #5
  20ae34:	f7f5 fcc4 	bl	2007c0 <_test_assert>
}
  20ae38:	b007      	add	sp, #28
  20ae3a:	bd30      	pop	{r4, r5, pc}
  20ae3c:	481e      	ldr	r0, [pc, #120]	; (20aeb8 <rt_test_002_002_execute+0x1a8>)
  20ae3e:	f7f5 fe97 	bl	200b70 <chSysHalt>
  __ASM volatile ("cpsid i" : : : "memory");
  20ae42:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ae44:	2320      	movs	r3, #32
  20ae46:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20ae4a:	b662      	cpsie	i
  _dbg_check_lock();
  20ae4c:	f7f8 ff80 	bl	203d50 <_dbg_check_lock>
  20ae50:	e78e      	b.n	20ad70 <rt_test_002_002_execute+0x60>
  __ASM volatile ("cpsid i" : : : "memory");
  20ae52:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ae54:	2320      	movs	r3, #32
  20ae56:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20ae5a:	b662      	cpsie	i
  20ae5c:	f7f8 ff78 	bl	203d50 <_dbg_check_lock>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
  20ae60:	f3ef 8311 	mrs	r3, BASEPRI
  if (port_irq_enabled(port_get_irq_status())) {
  20ae64:	2b00      	cmp	r3, #0
  20ae66:	d183      	bne.n	20ad70 <rt_test_002_002_execute+0x60>
  20ae68:	e7eb      	b.n	20ae42 <rt_test_002_002_execute+0x132>
  _dbg_check_unlock();
  20ae6a:	f7f8 ff21 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20ae6e:	6823      	ldr	r3, [r4, #0]
  20ae70:	42a3      	cmp	r3, r4
  20ae72:	d004      	beq.n	20ae7e <rt_test_002_002_execute+0x16e>
  20ae74:	69a2      	ldr	r2, [r4, #24]
  20ae76:	689b      	ldr	r3, [r3, #8]
  20ae78:	6892      	ldr	r2, [r2, #8]
  20ae7a:	429a      	cmp	r2, r3
  20ae7c:	d3de      	bcc.n	20ae3c <rt_test_002_002_execute+0x12c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20ae7e:	2300      	movs	r3, #0
  20ae80:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
  20ae84:	f3ef 8311 	mrs	r3, BASEPRI
  if (!port_irq_enabled(port_get_irq_status())) {
  20ae88:	2b00      	cmp	r3, #0
  20ae8a:	d08f      	beq.n	20adac <rt_test_002_002_execute+0x9c>
  _dbg_check_unlock();
  20ae8c:	f7f8 ff10 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20ae90:	6823      	ldr	r3, [r4, #0]
  20ae92:	42a3      	cmp	r3, r4
  20ae94:	d004      	beq.n	20aea0 <rt_test_002_002_execute+0x190>
  20ae96:	69a2      	ldr	r2, [r4, #24]
  20ae98:	689b      	ldr	r3, [r3, #8]
  20ae9a:	6892      	ldr	r2, [r2, #8]
  20ae9c:	429a      	cmp	r2, r3
  20ae9e:	d3cd      	bcc.n	20ae3c <rt_test_002_002_execute+0x12c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20aea0:	2300      	movs	r3, #0
  20aea2:	f383 8811 	msr	BASEPRI, r3
  20aea6:	e781      	b.n	20adac <rt_test_002_002_execute+0x9c>
  20aea8:	20001f6c 	.word	0x20001f6c
  20aeac:	20000dc8 	.word	0x20000dc8
  20aeb0:	0020aec1 	.word	0x0020aec1
  20aeb4:	0800d4b8 	.word	0x0800d4b8
  20aeb8:	0800bc94 	.word	0x0800bc94
  20aebc:	00000000 	.word	0x00000000

0020aec0 <vtcb>:
static void vtcb(void *p) {
  20aec0:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
  20aec2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20aec4:	2420      	movs	r4, #32
  20aec6:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
  20aeca:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  20aecc:	f7f6 f9f8 	bl	2012c0 <_dbg_check_lock_from_isr>
  _dbg_check_unlock_from_isr();
  20aed0:	f7f6 f9de 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20aed4:	2300      	movs	r3, #0
  20aed6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsid i" : : : "memory");
  20aeda:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20aedc:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
  20aee0:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  20aee2:	f7f6 f9ed 	bl	2012c0 <_dbg_check_lock_from_isr>
  sts = chSysGetStatusAndLockX();
  20aee6:	f7ff fef3 	bl	20acd0 <chSysGetStatusAndLockX>
  20aeea:	b908      	cbnz	r0, 20aef0 <vtcb+0x30>
  20aeec:	f7f8 ff08 	bl	203d00 <chSysRestoreStatusX.part.2>
  _dbg_check_unlock_from_isr();
  20aef0:	f7f6 f9ce 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20aef4:	2300      	movs	r3, #0
  20aef6:	f383 8811 	msr	BASEPRI, r3
}
  20aefa:	bd10      	pop	{r4, pc}
  20aefc:	0000      	movs	r0, r0
	...

0020af00 <obqWriteTimeout>:
                       size_t n, sysinterval_t timeout) {
  20af00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20af04:	b085      	sub	sp, #20
  osalDbgCheck(n > 0U);
  20af06:	2a00      	cmp	r2, #0
  20af08:	f000 8095 	beq.w	20b036 <obqWriteTimeout+0x136>
  20af0c:	4604      	mov	r4, r0
  20af0e:	468b      	mov	fp, r1
  20af10:	4698      	mov	r8, r3
  20af12:	4617      	mov	r7, r2
  __ASM volatile ("cpsid i" : : : "memory");
  20af14:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20af16:	2320      	movs	r3, #32
  20af18:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20af1c:	b662      	cpsie	i
  _dbg_check_lock();
  20af1e:	f7f8 ff17 	bl	203d50 <_dbg_check_lock>
  20af22:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  20af26:	f108 32ff 	add.w	r2, r8, #4294967295
  size_t w = 0;
  20af2a:	2500      	movs	r5, #0
    if (obqp->ptr == NULL) {
  20af2c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  20af2e:	9201      	str	r2, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20af30:	46a9      	mov	r9, r5
  20af32:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  20af34:	9303      	str	r3, [sp, #12]
  return systime + (systime_t)interval;
  20af36:	eb08 0302 	add.w	r3, r8, r2
  20af3a:	4e40      	ldr	r6, [pc, #256]	; (20b03c <obqWriteTimeout+0x13c>)
  20af3c:	9302      	str	r3, [sp, #8]
    if (obqp->ptr == NULL) {
  20af3e:	2800      	cmp	r0, #0
  20af40:	d051      	beq.n	20afe6 <obqWriteTimeout+0xe6>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
  20af42:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if (size > (n - w)) {
  20af44:	eba7 0a05 	sub.w	sl, r7, r5
    size = (size_t)obqp->top - (size_t)obqp->ptr;
  20af48:	1a1b      	subs	r3, r3, r0
  20af4a:	459a      	cmp	sl, r3
  20af4c:	bf28      	it	cs
  20af4e:	469a      	movcs	sl, r3
    if (size > 64U) {
  20af50:	f1ba 0f40 	cmp.w	sl, #64	; 0x40
  20af54:	d923      	bls.n	20af9e <obqWriteTimeout+0x9e>
      memcpy(obqp->ptr, bp, 64U);
  20af56:	f10b 0340 	add.w	r3, fp, #64	; 0x40
  20af5a:	f8db e000 	ldr.w	lr, [fp]
  20af5e:	f10b 0b10 	add.w	fp, fp, #16
  20af62:	f85b cc0c 	ldr.w	ip, [fp, #-12]
  20af66:	3010      	adds	r0, #16
  20af68:	f85b 1c08 	ldr.w	r1, [fp, #-8]
  20af6c:	f85b 2c04 	ldr.w	r2, [fp, #-4]
  20af70:	459b      	cmp	fp, r3
  20af72:	f840 ec10 	str.w	lr, [r0, #-16]
  20af76:	f840 cc0c 	str.w	ip, [r0, #-12]
  20af7a:	f840 1c08 	str.w	r1, [r0, #-8]
  20af7e:	f840 2c04 	str.w	r2, [r0, #-4]
  20af82:	d1ea      	bne.n	20af5a <obqWriteTimeout+0x5a>
      obqp->ptr += 64U;
  20af84:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      w         += 64U;
  20af86:	3540      	adds	r5, #64	; 0x40
    if (obqp->ptr >= obqp->top) {
  20af88:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      obqp->ptr += 64U;
  20af8a:	3340      	adds	r3, #64	; 0x40
    if (obqp->ptr >= obqp->top) {
  20af8c:	429a      	cmp	r2, r3
      obqp->ptr += 64U;
  20af8e:	62a3      	str	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
  20af90:	d811      	bhi.n	20afb6 <obqWriteTimeout+0xb6>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  20af92:	69e1      	ldr	r1, [r4, #28]
  20af94:	4620      	mov	r0, r4
  20af96:	3904      	subs	r1, #4
  20af98:	f7f6 ffd2 	bl	201f40 <obqPostFullBufferS>
  20af9c:	e00b      	b.n	20afb6 <obqWriteTimeout+0xb6>
      memcpy(obqp->ptr, bp, size);
  20af9e:	4652      	mov	r2, sl
  20afa0:	4659      	mov	r1, fp
  20afa2:	f7f5 f9b7 	bl	200314 <memcpy>
      obqp->ptr += size;
  20afa6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
  20afa8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      w         += size;
  20afaa:	4455      	add	r5, sl
      obqp->ptr += size;
  20afac:	4453      	add	r3, sl
      bp        += size;
  20afae:	44d3      	add	fp, sl
    if (obqp->ptr >= obqp->top) {
  20afb0:	429a      	cmp	r2, r3
      obqp->ptr += size;
  20afb2:	62a3      	str	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
  20afb4:	d9ed      	bls.n	20af92 <obqWriteTimeout+0x92>
  _dbg_check_unlock();
  20afb6:	f7f8 fe7b 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20afba:	6833      	ldr	r3, [r6, #0]
  20afbc:	42b3      	cmp	r3, r6
  20afbe:	d004      	beq.n	20afca <obqWriteTimeout+0xca>
  20afc0:	69b2      	ldr	r2, [r6, #24]
  20afc2:	689b      	ldr	r3, [r3, #8]
  20afc4:	6892      	ldr	r2, [r2, #8]
  20afc6:	429a      	cmp	r2, r3
  20afc8:	d32d      	bcc.n	20b026 <obqWriteTimeout+0x126>
  20afca:	f389 8811 	msr	BASEPRI, r9
    if (w >= n) {
  20afce:	42bd      	cmp	r5, r7
  20afd0:	d225      	bcs.n	20b01e <obqWriteTimeout+0x11e>
  __ASM volatile ("cpsid i" : : : "memory");
  20afd2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20afd4:	2320      	movs	r3, #32
  20afd6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20afda:	b662      	cpsie	i
  _dbg_check_lock();
  20afdc:	f7f8 feb8 	bl	203d50 <_dbg_check_lock>
    if (obqp->ptr == NULL) {
  20afe0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  20afe2:	2800      	cmp	r0, #0
  20afe4:	d1ad      	bne.n	20af42 <obqWriteTimeout+0x42>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  20afe6:	9b01      	ldr	r3, [sp, #4]
  20afe8:	3303      	adds	r3, #3
  20afea:	d81f      	bhi.n	20b02c <obqWriteTimeout+0x12c>
  20afec:	9b03      	ldr	r3, [sp, #12]
  20afee:	6a59      	ldr	r1, [r3, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
  20aff0:	9b02      	ldr	r3, [sp, #8]
  20aff2:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
  20aff4:	4588      	cmp	r8, r1
  20aff6:	d305      	bcc.n	20b004 <obqWriteTimeout+0x104>
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
  20aff8:	4620      	mov	r0, r4
  20affa:	f7f8 fb99 	bl	203730 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
  20affe:	b908      	cbnz	r0, 20b004 <obqWriteTimeout+0x104>
  20b000:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  20b002:	e79e      	b.n	20af42 <obqWriteTimeout+0x42>
  _dbg_check_unlock();
  20b004:	f7f8 fe54 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20b008:	6833      	ldr	r3, [r6, #0]
  20b00a:	42b3      	cmp	r3, r6
  20b00c:	d004      	beq.n	20b018 <obqWriteTimeout+0x118>
  20b00e:	69b2      	ldr	r2, [r6, #24]
  20b010:	689b      	ldr	r3, [r3, #8]
  20b012:	6892      	ldr	r2, [r2, #8]
  20b014:	429a      	cmp	r2, r3
  20b016:	d306      	bcc.n	20b026 <obqWriteTimeout+0x126>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b018:	2300      	movs	r3, #0
  20b01a:	f383 8811 	msr	BASEPRI, r3
}
  20b01e:	4628      	mov	r0, r5
  20b020:	b005      	add	sp, #20
  20b022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  20b026:	4806      	ldr	r0, [pc, #24]	; (20b040 <obqWriteTimeout+0x140>)
  20b028:	f7f5 fda2 	bl	200b70 <chSysHalt>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
  20b02c:	4641      	mov	r1, r8
  20b02e:	4620      	mov	r0, r4
  20b030:	f7f8 fb7e 	bl	203730 <obqGetEmptyBufferTimeoutS>
  20b034:	e7e3      	b.n	20affe <obqWriteTimeout+0xfe>
  osalDbgCheck(n > 0U);
  20b036:	4803      	ldr	r0, [pc, #12]	; (20b044 <obqWriteTimeout+0x144>)
  20b038:	f7f5 fd9a 	bl	200b70 <chSysHalt>
  20b03c:	20000dc8 	.word	0x20000dc8
  20b040:	0800bd14 	.word	0x0800bd14
  20b044:	0800c158 	.word	0x0800c158
	...

0020b050 <_writet>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
  20b050:	3044      	adds	r0, #68	; 0x44
  20b052:	f7ff bf55 	b.w	20af00 <obqWriteTimeout>
  20b056:	bf00      	nop
	...

0020b060 <_write>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
  20b060:	3044      	adds	r0, #68	; 0x44
  20b062:	f04f 33ff 	mov.w	r3, #4294967295
  20b066:	f7ff bf4b 	b.w	20af00 <obqWriteTimeout>
  20b06a:	bf00      	nop
  20b06c:	0000      	movs	r0, r0
	...

0020b070 <obqPutTimeout>:
                    sysinterval_t timeout) {
  20b070:	b570      	push	{r4, r5, r6, lr}
  20b072:	4604      	mov	r4, r0
  20b074:	b082      	sub	sp, #8
  20b076:	460d      	mov	r5, r1
  20b078:	4616      	mov	r6, r2
  __ASM volatile ("cpsid i" : : : "memory");
  20b07a:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b07c:	2320      	movs	r3, #32
  20b07e:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20b082:	b662      	cpsie	i
  _dbg_check_lock();
  20b084:	f7f8 fe64 	bl	203d50 <_dbg_check_lock>
  if (obqp->ptr == NULL) {
  20b088:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  20b08a:	b1fb      	cbz	r3, 20b0cc <obqPutTimeout+0x5c>
  *obqp->ptr = b;
  20b08c:	701d      	strb	r5, [r3, #0]
  if (obqp->ptr >= obqp->top) {
  20b08e:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
  obqp->ptr++;
  20b092:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
  20b094:	4293      	cmp	r3, r2
  obqp->ptr++;
  20b096:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
  20b098:	d212      	bcs.n	20b0c0 <obqPutTimeout+0x50>
  _dbg_check_unlock();
  20b09a:	f7f8 fe09 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20b09e:	4b17      	ldr	r3, [pc, #92]	; (20b0fc <obqPutTimeout+0x8c>)
  20b0a0:	681a      	ldr	r2, [r3, #0]
  20b0a2:	429a      	cmp	r2, r3
  20b0a4:	d004      	beq.n	20b0b0 <obqPutTimeout+0x40>
  20b0a6:	6999      	ldr	r1, [r3, #24]
  20b0a8:	6893      	ldr	r3, [r2, #8]
  20b0aa:	688a      	ldr	r2, [r1, #8]
  20b0ac:	429a      	cmp	r2, r3
  20b0ae:	d304      	bcc.n	20b0ba <obqPutTimeout+0x4a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b0b0:	2000      	movs	r0, #0
  20b0b2:	f380 8811 	msr	BASEPRI, r0
}
  20b0b6:	b002      	add	sp, #8
  20b0b8:	bd70      	pop	{r4, r5, r6, pc}
  20b0ba:	4811      	ldr	r0, [pc, #68]	; (20b100 <obqPutTimeout+0x90>)
  20b0bc:	f7f5 fd58 	bl	200b70 <chSysHalt>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  20b0c0:	69e1      	ldr	r1, [r4, #28]
  20b0c2:	4620      	mov	r0, r4
  20b0c4:	3904      	subs	r1, #4
  20b0c6:	f7f6 ff3b 	bl	201f40 <obqPostFullBufferS>
  20b0ca:	e7e6      	b.n	20b09a <obqPutTimeout+0x2a>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
  20b0cc:	4631      	mov	r1, r6
  20b0ce:	4620      	mov	r0, r4
  20b0d0:	f7f8 fb2e 	bl	203730 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
  20b0d4:	b908      	cbnz	r0, 20b0da <obqPutTimeout+0x6a>
  20b0d6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  20b0d8:	e7d8      	b.n	20b08c <obqPutTimeout+0x1c>
  20b0da:	9001      	str	r0, [sp, #4]
  _dbg_check_unlock();
  20b0dc:	f7f8 fde8 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20b0e0:	4b06      	ldr	r3, [pc, #24]	; (20b0fc <obqPutTimeout+0x8c>)
  20b0e2:	9801      	ldr	r0, [sp, #4]
  20b0e4:	681a      	ldr	r2, [r3, #0]
  20b0e6:	429a      	cmp	r2, r3
  20b0e8:	d004      	beq.n	20b0f4 <obqPutTimeout+0x84>
  20b0ea:	6999      	ldr	r1, [r3, #24]
  20b0ec:	6893      	ldr	r3, [r2, #8]
  20b0ee:	688a      	ldr	r2, [r1, #8]
  20b0f0:	429a      	cmp	r2, r3
  20b0f2:	d3e2      	bcc.n	20b0ba <obqPutTimeout+0x4a>
  20b0f4:	2300      	movs	r3, #0
  20b0f6:	f383 8811 	msr	BASEPRI, r3
  20b0fa:	e7dc      	b.n	20b0b6 <obqPutTimeout+0x46>
  20b0fc:	20000dc8 	.word	0x20000dc8
  20b100:	0800bd14 	.word	0x0800bd14
	...

0020b110 <_putt>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
  20b110:	3044      	adds	r0, #68	; 0x44
  20b112:	f7ff bfad 	b.w	20b070 <obqPutTimeout>
  20b116:	bf00      	nop
	...

0020b120 <_put>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
  20b120:	3044      	adds	r0, #68	; 0x44
  20b122:	f04f 32ff 	mov.w	r2, #4294967295
  20b126:	f7ff bfa3 	b.w	20b070 <obqPutTimeout>
  20b12a:	bf00      	nop
  20b12c:	0000      	movs	r0, r0
	...

0020b130 <ibqReadTimeout>:
                      size_t n, sysinterval_t timeout) {
  20b130:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20b134:	b085      	sub	sp, #20
  osalDbgCheck(n > 0U);
  20b136:	2a00      	cmp	r2, #0
  20b138:	f000 8094 	beq.w	20b264 <ibqReadTimeout+0x134>
  20b13c:	4604      	mov	r4, r0
  20b13e:	460f      	mov	r7, r1
  20b140:	4699      	mov	r9, r3
  20b142:	4690      	mov	r8, r2
  __ASM volatile ("cpsid i" : : : "memory");
  20b144:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b146:	2320      	movs	r3, #32
  20b148:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20b14c:	b662      	cpsie	i
  _dbg_check_lock();
  20b14e:	f7f8 fdff 	bl	203d50 <_dbg_check_lock>
  20b152:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  20b156:	f109 32ff 	add.w	r2, r9, #4294967295
  size_t r = 0;
  20b15a:	2500      	movs	r5, #0
    if (ibqp->ptr == NULL) {
  20b15c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  20b15e:	9201      	str	r2, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b160:	46aa      	mov	sl, r5
  20b162:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  20b164:	9303      	str	r3, [sp, #12]
  return systime + (systime_t)interval;
  20b166:	eb09 0302 	add.w	r3, r9, r2
  20b16a:	4e40      	ldr	r6, [pc, #256]	; (20b26c <ibqReadTimeout+0x13c>)
  20b16c:	9302      	str	r3, [sp, #8]
    if (ibqp->ptr == NULL) {
  20b16e:	2900      	cmp	r1, #0
  20b170:	d050      	beq.n	20b214 <ibqReadTimeout+0xe4>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
  20b172:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if (size > (n - r)) {
  20b174:	eba8 0b05 	sub.w	fp, r8, r5
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
  20b178:	1a5b      	subs	r3, r3, r1
  20b17a:	459b      	cmp	fp, r3
  20b17c:	bf28      	it	cs
  20b17e:	469b      	movcs	fp, r3
    if (size > 64U) {
  20b180:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
  20b184:	d922      	bls.n	20b1cc <ibqReadTimeout+0x9c>
      memcpy(bp, ibqp->ptr, 64U);
  20b186:	463b      	mov	r3, r7
  20b188:	f101 0240 	add.w	r2, r1, #64	; 0x40
  20b18c:	f8d1 b000 	ldr.w	fp, [r1]
  20b190:	3110      	adds	r1, #16
  20b192:	f851 ec0c 	ldr.w	lr, [r1, #-12]
  20b196:	3310      	adds	r3, #16
  20b198:	f851 cc08 	ldr.w	ip, [r1, #-8]
  20b19c:	f851 0c04 	ldr.w	r0, [r1, #-4]
  20b1a0:	4291      	cmp	r1, r2
  20b1a2:	f843 bc10 	str.w	fp, [r3, #-16]
  20b1a6:	f843 ec0c 	str.w	lr, [r3, #-12]
  20b1aa:	f843 cc08 	str.w	ip, [r3, #-8]
  20b1ae:	f843 0c04 	str.w	r0, [r3, #-4]
  20b1b2:	d1eb      	bne.n	20b18c <ibqReadTimeout+0x5c>
      ibqp->ptr += 64U;
  20b1b4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += 64U;
  20b1b6:	3740      	adds	r7, #64	; 0x40
    if (ibqp->ptr >= ibqp->top) {
  20b1b8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      r         += 64U;
  20b1ba:	3540      	adds	r5, #64	; 0x40
      ibqp->ptr += 64U;
  20b1bc:	3340      	adds	r3, #64	; 0x40
    if (ibqp->ptr >= ibqp->top) {
  20b1be:	429a      	cmp	r2, r3
      ibqp->ptr += 64U;
  20b1c0:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
  20b1c2:	d80f      	bhi.n	20b1e4 <ibqReadTimeout+0xb4>
      ibqReleaseEmptyBufferS(ibqp);
  20b1c4:	4620      	mov	r0, r4
  20b1c6:	f7f6 ffdb 	bl	202180 <ibqReleaseEmptyBufferS>
  20b1ca:	e00b      	b.n	20b1e4 <ibqReadTimeout+0xb4>
      memcpy(bp, ibqp->ptr, size);
  20b1cc:	465a      	mov	r2, fp
  20b1ce:	4638      	mov	r0, r7
  20b1d0:	f7f5 f8a0 	bl	200314 <memcpy>
      ibqp->ptr += size;
  20b1d4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
  20b1d6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      r         += size;
  20b1d8:	445d      	add	r5, fp
      ibqp->ptr += size;
  20b1da:	445b      	add	r3, fp
      bp        += size;
  20b1dc:	445f      	add	r7, fp
    if (ibqp->ptr >= ibqp->top) {
  20b1de:	429a      	cmp	r2, r3
      ibqp->ptr += size;
  20b1e0:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
  20b1e2:	d9ef      	bls.n	20b1c4 <ibqReadTimeout+0x94>
  _dbg_check_unlock();
  20b1e4:	f7f8 fd64 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20b1e8:	6833      	ldr	r3, [r6, #0]
  20b1ea:	42b3      	cmp	r3, r6
  20b1ec:	d004      	beq.n	20b1f8 <ibqReadTimeout+0xc8>
  20b1ee:	69b2      	ldr	r2, [r6, #24]
  20b1f0:	689b      	ldr	r3, [r3, #8]
  20b1f2:	6892      	ldr	r2, [r2, #8]
  20b1f4:	429a      	cmp	r2, r3
  20b1f6:	d32d      	bcc.n	20b254 <ibqReadTimeout+0x124>
  20b1f8:	f38a 8811 	msr	BASEPRI, sl
    if (r >= n) {
  20b1fc:	4545      	cmp	r5, r8
  20b1fe:	d225      	bcs.n	20b24c <ibqReadTimeout+0x11c>
  __ASM volatile ("cpsid i" : : : "memory");
  20b200:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b202:	2320      	movs	r3, #32
  20b204:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20b208:	b662      	cpsie	i
  _dbg_check_lock();
  20b20a:	f7f8 fda1 	bl	203d50 <_dbg_check_lock>
    if (ibqp->ptr == NULL) {
  20b20e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  20b210:	2900      	cmp	r1, #0
  20b212:	d1ae      	bne.n	20b172 <ibqReadTimeout+0x42>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  20b214:	9b01      	ldr	r3, [sp, #4]
  20b216:	3303      	adds	r3, #3
  20b218:	d81f      	bhi.n	20b25a <ibqReadTimeout+0x12a>
  20b21a:	9b03      	ldr	r3, [sp, #12]
  20b21c:	6a59      	ldr	r1, [r3, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
  20b21e:	9b02      	ldr	r3, [sp, #8]
  20b220:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
  20b222:	4589      	cmp	r9, r1
  20b224:	d305      	bcc.n	20b232 <ibqReadTimeout+0x102>
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
  20b226:	4620      	mov	r0, r4
  20b228:	f7f8 faaa 	bl	203780 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
  20b22c:	b908      	cbnz	r0, 20b232 <ibqReadTimeout+0x102>
  20b22e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  20b230:	e79f      	b.n	20b172 <ibqReadTimeout+0x42>
  _dbg_check_unlock();
  20b232:	f7f8 fd3d 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20b236:	6833      	ldr	r3, [r6, #0]
  20b238:	42b3      	cmp	r3, r6
  20b23a:	d004      	beq.n	20b246 <ibqReadTimeout+0x116>
  20b23c:	69b2      	ldr	r2, [r6, #24]
  20b23e:	689b      	ldr	r3, [r3, #8]
  20b240:	6892      	ldr	r2, [r2, #8]
  20b242:	429a      	cmp	r2, r3
  20b244:	d306      	bcc.n	20b254 <ibqReadTimeout+0x124>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b246:	2300      	movs	r3, #0
  20b248:	f383 8811 	msr	BASEPRI, r3
}
  20b24c:	4628      	mov	r0, r5
  20b24e:	b005      	add	sp, #20
  20b250:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  20b254:	4806      	ldr	r0, [pc, #24]	; (20b270 <ibqReadTimeout+0x140>)
  20b256:	f7f5 fc8b 	bl	200b70 <chSysHalt>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
  20b25a:	4649      	mov	r1, r9
  20b25c:	4620      	mov	r0, r4
  20b25e:	f7f8 fa8f 	bl	203780 <ibqGetFullBufferTimeoutS>
  20b262:	e7e3      	b.n	20b22c <ibqReadTimeout+0xfc>
  osalDbgCheck(n > 0U);
  20b264:	4803      	ldr	r0, [pc, #12]	; (20b274 <ibqReadTimeout+0x144>)
  20b266:	f7f5 fc83 	bl	200b70 <chSysHalt>
  20b26a:	bf00      	nop
  20b26c:	20000dc8 	.word	0x20000dc8
  20b270:	0800bd14 	.word	0x0800bd14
  20b274:	0800c084 	.word	0x0800c084
	...

0020b280 <_readt>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
  20b280:	300c      	adds	r0, #12
  20b282:	f7ff bf55 	b.w	20b130 <ibqReadTimeout>
  20b286:	bf00      	nop
	...

0020b290 <_read>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
  20b290:	300c      	adds	r0, #12
  20b292:	f04f 33ff 	mov.w	r3, #4294967295
  20b296:	f7ff bf4b 	b.w	20b130 <ibqReadTimeout>
  20b29a:	bf00      	nop
  20b29c:	0000      	movs	r0, r0
	...

0020b2a0 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
  20b2a0:	b530      	push	{r4, r5, lr}
  20b2a2:	4604      	mov	r4, r0
  20b2a4:	b083      	sub	sp, #12
  20b2a6:	460d      	mov	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
  20b2a8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b2aa:	2320      	movs	r3, #32
  20b2ac:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20b2b0:	b662      	cpsie	i
  _dbg_check_lock();
  20b2b2:	f7f8 fd4d 	bl	203d50 <_dbg_check_lock>
  if (ibqp->ptr == NULL) {
  20b2b6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  20b2b8:	b353      	cbz	r3, 20b310 <ibqGetTimeout+0x70>
  msg = (msg_t)*ibqp->ptr;
  20b2ba:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
  20b2be:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  ibqp->ptr++;
  20b2c0:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
  20b2c2:	4293      	cmp	r3, r2
  20b2c4:	d220      	bcs.n	20b308 <ibqGetTimeout+0x68>
  _dbg_check_unlock();
  20b2c6:	f7f8 fcf3 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20b2ca:	4b15      	ldr	r3, [pc, #84]	; (20b320 <ibqGetTimeout+0x80>)
  20b2cc:	681a      	ldr	r2, [r3, #0]
  20b2ce:	429a      	cmp	r2, r3
  20b2d0:	d004      	beq.n	20b2dc <ibqGetTimeout+0x3c>
  20b2d2:	6999      	ldr	r1, [r3, #24]
  20b2d4:	6893      	ldr	r3, [r2, #8]
  20b2d6:	688a      	ldr	r2, [r1, #8]
  20b2d8:	429a      	cmp	r2, r3
  20b2da:	d312      	bcc.n	20b302 <ibqGetTimeout+0x62>
  msg = (msg_t)*ibqp->ptr;
  20b2dc:	4628      	mov	r0, r5
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b2de:	2300      	movs	r3, #0
  20b2e0:	f383 8811 	msr	BASEPRI, r3
}
  20b2e4:	b003      	add	sp, #12
  20b2e6:	bd30      	pop	{r4, r5, pc}
  20b2e8:	9001      	str	r0, [sp, #4]
  _dbg_check_unlock();
  20b2ea:	f7f8 fce1 	bl	203cb0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
  20b2ee:	4b0c      	ldr	r3, [pc, #48]	; (20b320 <ibqGetTimeout+0x80>)
  20b2f0:	9801      	ldr	r0, [sp, #4]
  20b2f2:	681a      	ldr	r2, [r3, #0]
  20b2f4:	429a      	cmp	r2, r3
  20b2f6:	d0f2      	beq.n	20b2de <ibqGetTimeout+0x3e>
  20b2f8:	6999      	ldr	r1, [r3, #24]
  20b2fa:	6893      	ldr	r3, [r2, #8]
  20b2fc:	688a      	ldr	r2, [r1, #8]
  20b2fe:	429a      	cmp	r2, r3
  20b300:	d2ed      	bcs.n	20b2de <ibqGetTimeout+0x3e>
  20b302:	4808      	ldr	r0, [pc, #32]	; (20b324 <ibqGetTimeout+0x84>)
  20b304:	f7f5 fc34 	bl	200b70 <chSysHalt>
    ibqReleaseEmptyBufferS(ibqp);
  20b308:	4620      	mov	r0, r4
  20b30a:	f7f6 ff39 	bl	202180 <ibqReleaseEmptyBufferS>
  20b30e:	e7da      	b.n	20b2c6 <ibqGetTimeout+0x26>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
  20b310:	4629      	mov	r1, r5
  20b312:	4620      	mov	r0, r4
  20b314:	f7f8 fa34 	bl	203780 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
  20b318:	2800      	cmp	r0, #0
  20b31a:	d1e5      	bne.n	20b2e8 <ibqGetTimeout+0x48>
  20b31c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  20b31e:	e7cc      	b.n	20b2ba <ibqGetTimeout+0x1a>
  20b320:	20000dc8 	.word	0x20000dc8
  20b324:	0800bd14 	.word	0x0800bd14
	...

0020b330 <_gett>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
  20b330:	300c      	adds	r0, #12
  20b332:	f7ff bfb5 	b.w	20b2a0 <ibqGetTimeout>
  20b336:	bf00      	nop
	...

0020b340 <_get>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
  20b340:	300c      	adds	r0, #12
  20b342:	f04f 31ff 	mov.w	r1, #4294967295
  20b346:	f7ff bfab 	b.w	20b2a0 <ibqGetTimeout>
  20b34a:	bf00      	nop
  20b34c:	0000      	movs	r0, r0
	...

0020b350 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
  20b350:	4aa5      	ldr	r2, [pc, #660]	; (20b5e8 <__early_init+0x298>)
  20b352:	2300      	movs	r3, #0
  gpiop->OTYPER  = config->otyper;
  20b354:	48a5      	ldr	r0, [pc, #660]	; (20b5ec <__early_init+0x29c>)
  gpiop->ODR     = config->odr;
  20b356:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->OSPEEDR = config->ospeedr;
  20b35a:	f46f 4c40 	mvn.w	ip, #49152	; 0xc000
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
  20b35e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
  20b362:	6914      	ldr	r4, [r2, #16]
  20b364:	f240 76ff 	movw	r6, #2047	; 0x7ff
  gpiop->PUPDR   = config->pupdr;
  20b368:	4fa1      	ldr	r7, [pc, #644]	; (20b5f0 <__early_init+0x2a0>)
  gpiop->OSPEEDR = config->ospeedr;
  20b36a:	f06f 4e70 	mvn.w	lr, #4026531840	; 0xf0000000
  rccResetAHB1(STM32_GPIO_EN_MASK);
  20b36e:	4334      	orrs	r4, r6
  gpiop->AFRL    = config->afrl;
  20b370:	f640 48cc 	movw	r8, #3276	; 0xccc
  rccResetAHB1(STM32_GPIO_EN_MASK);
  20b374:	6114      	str	r4, [r2, #16]
  20b376:	6113      	str	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  20b378:	6b14      	ldr	r4, [r2, #48]	; 0x30
  20b37a:	4334      	orrs	r4, r6
  20b37c:	6314      	str	r4, [r2, #48]	; 0x30
  gpiop->OSPEEDR = config->ospeedr;
  20b37e:	f04f 34ff 	mov.w	r4, #4294967295
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  20b382:	6d15      	ldr	r5, [r2, #80]	; 0x50
  20b384:	4335      	orrs	r5, r6
  gpiop->AFRL    = config->afrl;
  20b386:	4e9b      	ldr	r6, [pc, #620]	; (20b5f4 <__early_init+0x2a4>)
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  20b388:	6515      	str	r5, [r2, #80]	; 0x50
  gpiop->AFRH    = config->afrh;
  20b38a:	4d9b      	ldr	r5, [pc, #620]	; (20b5f8 <__early_init+0x2a8>)
  gpiop->OTYPER  = config->otyper;
  20b38c:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20b38e:	f8c0 c008 	str.w	ip, [r0, #8]
  gpiop->ODR     = config->odr;
  20b392:	f640 7cff 	movw	ip, #4095	; 0xfff
  gpiop->PUPDR   = config->pupdr;
  20b396:	60c7      	str	r7, [r0, #12]
  20b398:	f241 4710 	movw	r7, #5136	; 0x1410
  gpiop->ODR     = config->odr;
  20b39c:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
  20b39e:	6206      	str	r6, [r0, #32]
  gpiop->AFRH    = config->afrh;
  20b3a0:	f04f 36cc 	mov.w	r6, #3435973836	; 0xcccccccc
  20b3a4:	6245      	str	r5, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
  20b3a6:	4d95      	ldr	r5, [pc, #596]	; (20b5fc <__early_init+0x2ac>)
  20b3a8:	6005      	str	r5, [r0, #0]
  gpiop->PUPDR   = config->pupdr;
  20b3aa:	4d95      	ldr	r5, [pc, #596]	; (20b600 <__early_init+0x2b0>)
  gpiop->OTYPER  = config->otyper;
  20b3ac:	f8c0 3404 	str.w	r3, [r0, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  20b3b0:	f8c0 4408 	str.w	r4, [r0, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
  20b3b4:	f8c0 540c 	str.w	r5, [r0, #1036]	; 0x40c
  gpiop->AFRL    = config->afrl;
  20b3b8:	4d92      	ldr	r5, [pc, #584]	; (20b604 <__early_init+0x2b4>)
  gpiop->ODR     = config->odr;
  20b3ba:	f8c0 1414 	str.w	r1, [r0, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
  20b3be:	f8c0 5420 	str.w	r5, [r0, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  20b3c2:	4d91      	ldr	r5, [pc, #580]	; (20b608 <__early_init+0x2b8>)
  20b3c4:	f8c0 5424 	str.w	r5, [r0, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  20b3c8:	4d90      	ldr	r5, [pc, #576]	; (20b60c <__early_init+0x2bc>)
  20b3ca:	f8c0 5400 	str.w	r5, [r0, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
  20b3ce:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  20b3d2:	6043      	str	r3, [r0, #4]
  gpiop->AFRL    = config->afrl;
  20b3d4:	f04f 15cc 	mov.w	r5, #13369548	; 0xcc00cc
  gpiop->OSPEEDR = config->ospeedr;
  20b3d8:	f8c0 e008 	str.w	lr, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  20b3dc:	f8df e27c 	ldr.w	lr, [pc, #636]	; 20b65c <__early_init+0x30c>
  20b3e0:	f8c0 e00c 	str.w	lr, [r0, #12]
  gpiop->AFRL    = config->afrl;
  20b3e4:	f8df e278 	ldr.w	lr, [pc, #632]	; 20b660 <__early_init+0x310>
  gpiop->ODR     = config->odr;
  20b3e8:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
  20b3ea:	f8c0 e020 	str.w	lr, [r0, #32]
  gpiop->AFRH    = config->afrh;
  20b3ee:	f8df e274 	ldr.w	lr, [pc, #628]	; 20b664 <__early_init+0x314>
  20b3f2:	f8c0 e024 	str.w	lr, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
  20b3f6:	f8df e270 	ldr.w	lr, [pc, #624]	; 20b668 <__early_init+0x318>
  20b3fa:	f8c0 e000 	str.w	lr, [r0]
  gpiop->PUPDR   = config->pupdr;
  20b3fe:	f8df e26c 	ldr.w	lr, [pc, #620]	; 20b66c <__early_init+0x31c>
  gpiop->OTYPER  = config->otyper;
  20b402:	f8c0 3404 	str.w	r3, [r0, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  20b406:	f8c0 4408 	str.w	r4, [r0, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
  20b40a:	f8c0 e40c 	str.w	lr, [r0, #1036]	; 0x40c
  gpiop->OTYPER  = config->otyper;
  20b40e:	f44f 7ec0 	mov.w	lr, #384	; 0x180
  gpiop->ODR     = config->odr;
  20b412:	f8c0 c414 	str.w	ip, [r0, #1044]	; 0x414
  gpiop->AFRH    = config->afrh;
  20b416:	f8df c258 	ldr.w	ip, [pc, #600]	; 20b670 <__early_init+0x320>
  gpiop->AFRL    = config->afrl;
  20b41a:	f8c0 8420 	str.w	r8, [r0, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  20b41e:	f04f 0804 	mov.w	r8, #4
  20b422:	f8c0 c424 	str.w	ip, [r0, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  20b426:	f8df c24c 	ldr.w	ip, [pc, #588]	; 20b674 <__early_init+0x324>
  20b42a:	f8c0 c400 	str.w	ip, [r0, #1024]	; 0x400
  gpiop->AFRL    = config->afrl;
  20b42e:	f04f 3cee 	mov.w	ip, #4008636142	; 0xeeeeeeee
  gpiop->OTYPER  = config->otyper;
  20b432:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  20b436:	f8c0 4808 	str.w	r4, [r0, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  20b43a:	f8c0 780c 	str.w	r7, [r0, #2060]	; 0x80c
  gpiop->AFRL    = config->afrl;
  20b43e:	4f74      	ldr	r7, [pc, #464]	; (20b610 <__early_init+0x2c0>)
  gpiop->ODR     = config->odr;
  20b440:	f8c0 1814 	str.w	r1, [r0, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
  20b444:	f8c0 7820 	str.w	r7, [r0, #2080]	; 0x820
  gpiop->ODR     = config->odr;
  20b448:	f64f 77f7 	movw	r7, #65527	; 0xfff7
  gpiop->AFRH    = config->afrh;
  20b44c:	f8c0 6824 	str.w	r6, [r0, #2084]	; 0x824
  gpiop->MODER   = config->moder;
  20b450:	4e70      	ldr	r6, [pc, #448]	; (20b614 <__early_init+0x2c4>)
  20b452:	f8c0 6800 	str.w	r6, [r0, #2048]	; 0x800
  gpiop->OTYPER  = config->otyper;
  20b456:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
  gpiop->PUPDR   = config->pupdr;
  20b45a:	4e6f      	ldr	r6, [pc, #444]	; (20b618 <__early_init+0x2c8>)
  gpiop->OTYPER  = config->otyper;
  20b45c:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20b45e:	6084      	str	r4, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  20b460:	60c6      	str	r6, [r0, #12]
  gpiop->AFRL    = config->afrl;
  20b462:	4e6e      	ldr	r6, [pc, #440]	; (20b61c <__early_init+0x2cc>)
  gpiop->ODR     = config->odr;
  20b464:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
  20b466:	6206      	str	r6, [r0, #32]
  gpiop->AFRH    = config->afrh;
  20b468:	4e6d      	ldr	r6, [pc, #436]	; (20b620 <__early_init+0x2d0>)
  20b46a:	6246      	str	r6, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
  20b46c:	4e6d      	ldr	r6, [pc, #436]	; (20b624 <__early_init+0x2d4>)
  20b46e:	6006      	str	r6, [r0, #0]
  gpiop->PUPDR   = config->pupdr;
  20b470:	4e6d      	ldr	r6, [pc, #436]	; (20b628 <__early_init+0x2d8>)
  gpiop->OTYPER  = config->otyper;
  20b472:	f8c0 3404 	str.w	r3, [r0, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  20b476:	f8c0 4408 	str.w	r4, [r0, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
  20b47a:	f8c0 640c 	str.w	r6, [r0, #1036]	; 0x40c
  gpiop->MODER   = config->moder;
  20b47e:	f64a 266a 	movw	r6, #43626	; 0xaa6a
  gpiop->ODR     = config->odr;
  20b482:	f8c0 1414 	str.w	r1, [r0, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
  20b486:	f8c0 5420 	str.w	r5, [r0, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  20b48a:	4d68      	ldr	r5, [pc, #416]	; (20b62c <__early_init+0x2dc>)
  20b48c:	f8c0 5424 	str.w	r5, [r0, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  20b490:	4d67      	ldr	r5, [pc, #412]	; (20b630 <__early_init+0x2e0>)
  20b492:	f8c0 5400 	str.w	r5, [r0, #1024]	; 0x400
#if !STM32_NO_INIT
  /* PWR clock enabled.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
  20b496:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  gpiop->OTYPER  = config->otyper;
  20b49a:	f8c0 e804 	str.w	lr, [r0, #2052]	; 0x804
  gpiop->PUPDR   = config->pupdr;
  20b49e:	f10e 4eaa 	add.w	lr, lr, #1426063360	; 0x55000000
  gpiop->OSPEEDR = config->ospeedr;
  20b4a2:	f8c0 4808 	str.w	r4, [r0, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  20b4a6:	f50e 0ea8 	add.w	lr, lr, #5505024	; 0x540000
  20b4aa:	f50e 6e69 	add.w	lr, lr, #3728	; 0xe90
  20b4ae:	f8c0 e80c 	str.w	lr, [r0, #2060]	; 0x80c
  gpiop->AFRL    = config->afrl;
  20b4b2:	f8df e1c4 	ldr.w	lr, [pc, #452]	; 20b678 <__early_init+0x328>
  gpiop->ODR     = config->odr;
  20b4b6:	f8c0 1814 	str.w	r1, [r0, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
  20b4ba:	f8c0 e820 	str.w	lr, [r0, #2080]	; 0x820
  gpiop->MODER   = config->moder;
  20b4be:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 20b67c <__early_init+0x32c>
  gpiop->AFRH    = config->afrh;
  20b4c2:	f8c0 8824 	str.w	r8, [r0, #2084]	; 0x824
  gpiop->MODER   = config->moder;
  20b4c6:	f8c0 e800 	str.w	lr, [r0, #2048]	; 0x800
  gpiop->OTYPER  = config->otyper;
  20b4ca:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
  20b4ce:	6043      	str	r3, [r0, #4]
#endif

  /* PWR initialization.*/
  PWR->CR1 = STM32_VOS;
  20b4d0:	f44f 4e40 	mov.w	lr, #49152	; 0xc000
  gpiop->OSPEEDR = config->ospeedr;
  20b4d4:	6084      	str	r4, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  20b4d6:	4c57      	ldr	r4, [pc, #348]	; (20b634 <__early_init+0x2e4>)
  20b4d8:	60c4      	str	r4, [r0, #12]
  gpiop->AFRH    = config->afrh;
  20b4da:	4c57      	ldr	r4, [pc, #348]	; (20b638 <__early_init+0x2e8>)
  gpiop->ODR     = config->odr;
  20b4dc:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
  20b4de:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
  20b4e0:	6244      	str	r4, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
  20b4e2:	4c56      	ldr	r4, [pc, #344]	; (20b63c <__early_init+0x2ec>)
  20b4e4:	6004      	str	r4, [r0, #0]
  gpiop->OTYPER  = config->otyper;
  20b4e6:	f8c0 3404 	str.w	r3, [r0, #1028]	; 0x404
  gpiop->AFRH    = config->afrh;
  20b4ea:	4c55      	ldr	r4, [pc, #340]	; (20b640 <__early_init+0x2f0>)
  gpiop->OSPEEDR = config->ospeedr;
  20b4ec:	f8c0 3408 	str.w	r3, [r0, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
  20b4f0:	f8c0 340c 	str.w	r3, [r0, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
  20b4f4:	f8c0 1414 	str.w	r1, [r0, #1044]	; 0x414
  gpiop->MODER   = config->moder;
  20b4f8:	4952      	ldr	r1, [pc, #328]	; (20b644 <__early_init+0x2f4>)
  gpiop->AFRL    = config->afrl;
  20b4fa:	f8c0 c420 	str.w	ip, [r0, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  20b4fe:	f8c0 4424 	str.w	r4, [r0, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  20b502:	f8c0 1400 	str.w	r1, [r0, #1024]	; 0x400
  gpiop->AFRL    = config->afrl;
  20b506:	4950      	ldr	r1, [pc, #320]	; (20b648 <__early_init+0x2f8>)
  gpiop->OTYPER  = config->otyper;
  20b508:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  20b50c:	f8c0 3808 	str.w	r3, [r0, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  20b510:	f8c0 380c 	str.w	r3, [r0, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
  20b514:	f8c0 7814 	str.w	r7, [r0, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
  20b518:	f8c0 1820 	str.w	r1, [r0, #2080]	; 0x820

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
  20b51c:	4611      	mov	r1, r2
  gpiop->AFRH    = config->afrh;
  20b51e:	f8c0 3824 	str.w	r3, [r0, #2084]	; 0x824
  PWR->CR1 = STM32_VOS;
  20b522:	4b4a      	ldr	r3, [pc, #296]	; (20b64c <__early_init+0x2fc>)
  gpiop->MODER   = config->moder;
  20b524:	f8c0 6800 	str.w	r6, [r0, #2048]	; 0x800
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
  20b528:	6415      	str	r5, [r2, #64]	; 0x40
  PWR->CR1 = STM32_VOS;
  20b52a:	f8c3 e000 	str.w	lr, [r3]
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  20b52e:	6813      	ldr	r3, [r2, #0]
  20b530:	f043 0301 	orr.w	r3, r3, #1
  20b534:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
  20b536:	680b      	ldr	r3, [r1, #0]
  20b538:	079e      	lsls	r6, r3, #30
  20b53a:	d5fc      	bpl.n	20b536 <__early_init+0x1e6>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
  20b53c:	688b      	ldr	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  20b53e:	4a2a      	ldr	r2, [pc, #168]	; (20b5e8 <__early_init+0x298>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
  20b540:	f023 0303 	bic.w	r3, r3, #3
  20b544:	608b      	str	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  20b546:	6893      	ldr	r3, [r2, #8]
  20b548:	f013 030c 	ands.w	r3, r3, #12
  20b54c:	d1fb      	bne.n	20b546 <__early_init+0x1f6>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  20b54e:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  20b550:	4925      	ldr	r1, [pc, #148]	; (20b5e8 <__early_init+0x298>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  20b552:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
  20b556:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  20b558:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
  20b55a:	6813      	ldr	r3, [r2, #0]
  20b55c:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
  20b560:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  20b562:	680b      	ldr	r3, [r1, #0]
  20b564:	039d      	lsls	r5, r3, #14
  20b566:	d5fc      	bpl.n	20b562 <__early_init+0x212>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  20b568:	4b39      	ldr	r3, [pc, #228]	; (20b650 <__early_init+0x300>)
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;

  /* Synchronization with voltage regulator stabilization.*/
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  20b56a:	4838      	ldr	r0, [pc, #224]	; (20b64c <__early_init+0x2fc>)
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  20b56c:	604b      	str	r3, [r1, #4]
  RCC->CR |= RCC_CR_PLLON;
  20b56e:	680b      	ldr	r3, [r1, #0]
  20b570:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  20b574:	600b      	str	r3, [r1, #0]
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  20b576:	6843      	ldr	r3, [r0, #4]
  20b578:	045c      	lsls	r4, r3, #17
  20b57a:	d5fc      	bpl.n	20b576 <__early_init+0x226>
    ;                           /* Waits until power regulator is stable.   */

#if STM32_OVERDRIVE_REQUIRED
  /* Overdrive activation performed after activating the PLL in order to save
     time as recommended in RM in "Entering Over-drive mode" paragraph.*/
  PWR->CR1 |= PWR_CR1_ODEN;
  20b57c:	6803      	ldr	r3, [r0, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  20b57e:	4a33      	ldr	r2, [pc, #204]	; (20b64c <__early_init+0x2fc>)
  PWR->CR1 |= PWR_CR1_ODEN;
  20b580:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  20b584:	6003      	str	r3, [r0, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  20b586:	6853      	ldr	r3, [r2, #4]
  20b588:	03d9      	lsls	r1, r3, #15
  20b58a:	d5fc      	bpl.n	20b586 <__early_init+0x236>
      ;
  PWR->CR1 |= PWR_CR1_ODSWEN;
  20b58c:	6813      	ldr	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  20b58e:	492f      	ldr	r1, [pc, #188]	; (20b64c <__early_init+0x2fc>)
  PWR->CR1 |= PWR_CR1_ODSWEN;
  20b590:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  20b594:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  20b596:	684b      	ldr	r3, [r1, #4]
  20b598:	039a      	lsls	r2, r3, #14
  20b59a:	d5fc      	bpl.n	20b596 <__early_init+0x246>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
  20b59c:	4a12      	ldr	r2, [pc, #72]	; (20b5e8 <__early_init+0x298>)
  20b59e:	6813      	ldr	r3, [r2, #0]
  20b5a0:	019b      	lsls	r3, r3, #6
  20b5a2:	d5fc      	bpl.n	20b59e <__early_init+0x24e>
                  STM32_UART8SEL  | STM32_UART7SEL  | STM32_USART6SEL |
                  STM32_UART5SEL  | STM32_UART4SEL  | STM32_USART3SEL |
                  STM32_USART2SEL | STM32_USART1SEL;

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  20b5a4:	4b2b      	ldr	r3, [pc, #172]	; (20b654 <__early_init+0x304>)
  20b5a6:	f240 3107 	movw	r1, #775	; 0x307
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  20b5aa:	4d2b      	ldr	r5, [pc, #172]	; (20b658 <__early_init+0x308>)
    RCC->DCKCFGR1 = dckcfgr1;
  20b5ac:	f240 1401 	movw	r4, #257	; 0x101
  RCC->DCKCFGR2 = STM32_SDMMC2SEL | STM32_SDMMC1SEL | STM32_CK48MSEL  |
  20b5b0:	2000      	movs	r0, #0
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  20b5b2:	6095      	str	r5, [r2, #8]
    RCC->DCKCFGR1 = dckcfgr1;
  20b5b4:	f8c2 408c 	str.w	r4, [r2, #140]	; 0x8c
  RCC->DCKCFGR2 = STM32_SDMMC2SEL | STM32_SDMMC1SEL | STM32_CK48MSEL  |
  20b5b8:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  20b5bc:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  20b5be:	6893      	ldr	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  20b5c0:	4909      	ldr	r1, [pc, #36]	; (20b5e8 <__early_init+0x298>)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  20b5c2:	f043 0302 	orr.w	r3, r3, #2
  20b5c6:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  20b5c8:	688b      	ldr	r3, [r1, #8]
  20b5ca:	f003 030c 	and.w	r3, r3, #12
  20b5ce:	2b08      	cmp	r3, #8
  20b5d0:	d1fa      	bne.n	20b5c8 <__early_init+0x278>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
  20b5d2:	6c4b      	ldr	r3, [r1, #68]	; 0x44
  20b5d4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  20b5d8:	644b      	str	r3, [r1, #68]	; 0x44
  20b5da:	6e4b      	ldr	r3, [r1, #100]	; 0x64
  20b5dc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  20b5e0:	664b      	str	r3, [r1, #100]	; 0x64

  stm32_gpio_init();
  stm32_clock_init();
}
  20b5e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  20b5e6:	bf00      	nop
  20b5e8:	40023800 	.word	0x40023800
  20b5ec:	40020000 	.word	0x40020000
  20b5f0:	40011111 	.word	0x40011111
  20b5f4:	b0a0abb0 	.word	0xb0a0abb0
  20b5f8:	000aaa70 	.word	0x000aaa70
  20b5fc:	2aa888a8 	.word	0x2aa888a8
  20b600:	50051511 	.word	0x50051511
  20b604:	70a000aa 	.word	0x70a000aa
  20b608:	00aaaa00 	.word	0x00aaaa00
  20b60c:	0aa0888a 	.word	0x0aa0888a
  20b610:	c00e00cc 	.word	0xc00e00cc
  20b614:	aaaa820a 	.word	0xaaaa820a
  20b618:	00155000 	.word	0x00155000
  20b61c:	00cccccc 	.word	0x00cccccc
  20b620:	ccccc000 	.word	0xccccc000
  20b624:	aa800aaa 	.word	0xaa800aaa
  20b628:	00145050 	.word	0x00145050
  20b62c:	cbb9b00c 	.word	0xcbb9b00c
  20b630:	aa820a0a 	.word	0xaa820a0a
  20b634:	00015555 	.word	0x00015555
  20b638:	eee00ee0 	.word	0xeee00ee0
  20b63c:	a9280000 	.word	0xa9280000
  20b640:	eee0eeee 	.word	0xeee0eeee
  20b644:	a8aaaaaa 	.word	0xa8aaaaaa
  20b648:	eeee0eee 	.word	0xeeee0eee
  20b64c:	40007000 	.word	0x40007000
  20b650:	09406c19 	.word	0x09406c19
  20b654:	40023c00 	.word	0x40023c00
  20b658:	30999400 	.word	0x30999400
  20b65c:	04001000 	.word	0x04001000
  20b660:	00bbcaba 	.word	0x00bbcaba
  20b664:	000ccccc 	.word	0x000ccccc
  20b668:	02aa0aaa 	.word	0x02aa0aaa
  20b66c:	05405040 	.word	0x05405040
  20b670:	cc000ccc 	.word	0xcc000ccc
  20b674:	a02a042a 	.word	0xa02a042a
  20b678:	40cac000 	.word	0x40cac000
  20b67c:	00028a80 	.word	0x00028a80

0020b680 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
  20b680:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
  20b684:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
  OSAL_IRQ_PROLOGUE();
  20b688:	4837      	ldr	r0, [pc, #220]	; (20b768 <VectorB0+0xe8>)
  20b68a:	f7f5 fa49 	bl	200b20 <_trace_isr_enter>
  20b68e:	f7f5 fde7 	bl	201260 <_dbg_check_enter_isr>
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
  20b692:	f8d8 3010 	ldr.w	r3, [r8, #16]
  20b696:	079b      	lsls	r3, r3, #30
  20b698:	d408      	bmi.n	20b6ac <VectorB0+0x2c>
  OSAL_IRQ_EPILOGUE();
  20b69a:	f7f5 fdc9 	bl	201230 <_dbg_check_leave_isr>
  20b69e:	4832      	ldr	r0, [pc, #200]	; (20b768 <VectorB0+0xe8>)
  20b6a0:	f7f5 fa26 	bl	200af0 <_trace_isr_leave>
}
  20b6a4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
  20b6a8:	f7f5 b98a 	b.w	2009c0 <_port_irq_epilogue>
    STM32_ST_TIM->SR = 0U;
  20b6ac:	2600      	movs	r6, #0
  20b6ae:	f8c8 6010 	str.w	r6, [r8, #16]
  __ASM volatile ("cpsid i" : : : "memory");
  20b6b2:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b6b4:	2320      	movs	r3, #32
  20b6b6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  20b6ba:	b662      	cpsie	i
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
  20b6bc:	4d2b      	ldr	r5, [pc, #172]	; (20b76c <VectorB0+0xec>)
  _dbg_check_lock_from_isr();
  20b6be:	f7f5 fdff 	bl	2012c0 <_dbg_check_lock_from_isr>
  chDbgCheckClassI();
  20b6c2:	f7f5 fb65 	bl	200d90 <chDbgCheckClassI>
  20b6c6:	46aa      	mov	sl, r5
  chDbgCheckClassI();
  20b6c8:	f7f5 fb62 	bl	200d90 <chDbgCheckClassI>
  vtp = ch.vtlist.next;
  20b6cc:	f85a 4f1c 	ldr.w	r4, [sl, #28]!
  20b6d0:	68a3      	ldr	r3, [r4, #8]
  20b6d2:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
  20b6d6:	6aaa      	ldr	r2, [r5, #40]	; 0x28
  20b6d8:	eba1 0902 	sub.w	r9, r1, r2

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
  20b6dc:	4599      	cmp	r9, r3
  20b6de:	d322      	bcc.n	20b726 <VectorB0+0xa6>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b6e0:	2720      	movs	r7, #32
  20b6e2:	e010      	b.n	20b706 <VectorB0+0x86>
  _dbg_check_unlock_from_isr();
  20b6e4:	f7f5 fdd4 	bl	201290 <_dbg_check_unlock_from_isr>
  20b6e8:	f386 8811 	msr	BASEPRI, r6
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
  20b6ec:	6920      	ldr	r0, [r4, #16]
  20b6ee:	47d8      	blx	fp
  __ASM volatile ("cpsid i" : : : "memory");
  20b6f0:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b6f2:	f387 8811 	msr	BASEPRI, r7
  __ASM volatile ("cpsie i" : : : "memory");
  20b6f6:	b662      	cpsie	i
  _dbg_check_lock_from_isr();
  20b6f8:	f7f5 fde2 	bl	2012c0 <_dbg_check_lock_from_isr>
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
  20b6fc:	69ec      	ldr	r4, [r5, #28]
    }
    while (vtp->delta <= nowdelta);
  20b6fe:	68a3      	ldr	r3, [r4, #8]
  20b700:	4599      	cmp	r9, r3
  20b702:	d3e6      	bcc.n	20b6d2 <VectorB0+0x52>
  20b704:	6aaa      	ldr	r2, [r5, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  20b706:	6821      	ldr	r1, [r4, #0]
      ch.vtlist.lasttime += vtp->delta;
  20b708:	441a      	add	r2, r3
      fn = vtp->func;
  20b70a:	f8d4 b00c 	ldr.w	fp, [r4, #12]
      nowdelta -= vtp->delta;
  20b70e:	eba9 0903 	sub.w	r9, r9, r3
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  20b712:	4551      	cmp	r1, sl
      ch.vtlist.lasttime += vtp->delta;
  20b714:	62aa      	str	r2, [r5, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  20b716:	f8c1 a004 	str.w	sl, [r1, #4]
      ch.vtlist.next = vtp->next;
  20b71a:	61e9      	str	r1, [r5, #28]
      vtp->func = NULL;
  20b71c:	60e6      	str	r6, [r4, #12]
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  20b71e:	d1e1      	bne.n	20b6e4 <VectorB0+0x64>
  STM32_ST_TIM->DIER = 0;
  20b720:	f8c8 600c 	str.w	r6, [r8, #12]
  20b724:	e7de      	b.n	20b6e4 <VectorB0+0x64>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  20b726:	69eb      	ldr	r3, [r5, #28]
  20b728:	4553      	cmp	r3, sl
  20b72a:	d013      	beq.n	20b754 <VectorB0+0xd4>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
  20b72c:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.lasttime += nowdelta;
  20b72e:	62a9      	str	r1, [r5, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
  20b730:	eba2 0209 	sub.w	r2, r2, r9
  20b734:	609a      	str	r2, [r3, #8]
  return systime + (systime_t)interval;
  20b736:	68a4      	ldr	r4, [r4, #8]
  20b738:	2c02      	cmp	r4, #2
  20b73a:	bf2c      	ite	cs
  20b73c:	190c      	addcs	r4, r1, r4
  20b73e:	1c8c      	addcc	r4, r1, #2
  20b740:	4620      	mov	r0, r4
  20b742:	f7f6 fd3d 	bl	2021c0 <stSetAlarm>
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
  20b746:	6aaa      	ldr	r2, [r5, #40]	; 0x28
  return (systime_t)STM32_ST_TIM->CNT;
  20b748:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
  20b74c:	1aa1      	subs	r1, r4, r2
  20b74e:	1a9b      	subs	r3, r3, r2
  20b750:	428b      	cmp	r3, r1
  20b752:	d805      	bhi.n	20b760 <VectorB0+0xe0>
  _dbg_check_unlock_from_isr();
  20b754:	f7f5 fd9c 	bl	201290 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20b758:	2300      	movs	r3, #0
  20b75a:	f383 8811 	msr	BASEPRI, r3
  20b75e:	e79c      	b.n	20b69a <VectorB0+0x1a>
  20b760:	4803      	ldr	r0, [pc, #12]	; (20b770 <VectorB0+0xf0>)
  20b762:	f7f5 fa05 	bl	200b70 <chSysHalt>
  20b766:	bf00      	nop
  20b768:	0800bfe4 	.word	0x0800bfe4
  20b76c:	20000dc8 	.word	0x20000dc8
  20b770:	0800bcf4 	.word	0x0800bcf4
	...

0020b780 <Vector174>:
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
  20b780:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
  20b782:	4c09      	ldr	r4, [pc, #36]	; (20b7a8 <Vector174+0x28>)
  20b784:	4620      	mov	r0, r4
  20b786:	f7f5 f9cb 	bl	200b20 <_trace_isr_enter>
  20b78a:	f7f5 fd69 	bl	201260 <_dbg_check_enter_isr>
  usb_lld_serve_interrupt(&USBD2);
  20b78e:	4807      	ldr	r0, [pc, #28]	; (20b7ac <Vector174+0x2c>)
  20b790:	f7f5 ffc6 	bl	201720 <usb_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
  20b794:	f7f5 fd4c 	bl	201230 <_dbg_check_leave_isr>
  20b798:	4620      	mov	r0, r4
  20b79a:	f7f5 f9a9 	bl	200af0 <_trace_isr_leave>
}
  20b79e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20b7a2:	f7f5 b90d 	b.w	2009c0 <_port_irq_epilogue>
  20b7a6:	bf00      	nop
  20b7a8:	0800c174 	.word	0x0800c174
  20b7ac:	20000d2c 	.word	0x20000d2c

0020b7b0 <Vector14C>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
  20b7b0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
  20b7b2:	4c09      	ldr	r4, [pc, #36]	; (20b7d8 <Vector14C+0x28>)
  20b7b4:	4620      	mov	r0, r4
  20b7b6:	f7f5 f9b3 	bl	200b20 <_trace_isr_enter>
  20b7ba:	f7f5 fd51 	bl	201260 <_dbg_check_enter_isr>
  usb_lld_serve_interrupt(&USBD1);
  20b7be:	4807      	ldr	r0, [pc, #28]	; (20b7dc <Vector14C+0x2c>)
  20b7c0:	f7f5 ffae 	bl	201720 <usb_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
  20b7c4:	f7f5 fd34 	bl	201230 <_dbg_check_leave_isr>
  20b7c8:	4620      	mov	r0, r4
  20b7ca:	f7f5 f991 	bl	200af0 <_trace_isr_leave>
}
  20b7ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20b7d2:	f7f5 b8f5 	b.w	2009c0 <_port_irq_epilogue>
  20b7d6:	bf00      	nop
  20b7d8:	0800c168 	.word	0x0800c168
  20b7dc:	20000c90 	.word	0x20000c90

0020b7e0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
  20b7e0:	b4f0      	push	{r4, r5, r6, r7}
  20b7e2:	4e14      	ldr	r6, [pc, #80]	; (20b834 <__init_ram_areas+0x54>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
  20b7e4:	2700      	movs	r7, #0
void __init_ram_areas(void) {
  20b7e6:	4d14      	ldr	r5, [pc, #80]	; (20b838 <__init_ram_areas+0x58>)
  20b7e8:	f106 0c70 	add.w	ip, r6, #112	; 0x70
  20b7ec:	4c13      	ldr	r4, [pc, #76]	; (20b83c <__init_ram_areas+0x5c>)
  20b7ee:	4b14      	ldr	r3, [pc, #80]	; (20b840 <__init_ram_areas+0x60>)
  20b7f0:	4914      	ldr	r1, [pc, #80]	; (20b844 <__init_ram_areas+0x64>)
    while (p < rap->clear_area) {
  20b7f2:	429c      	cmp	r4, r3
  20b7f4:	d911      	bls.n	20b81a <__init_ram_areas+0x3a>
  20b7f6:	3904      	subs	r1, #4
  20b7f8:	461a      	mov	r2, r3
      *p = *tp;
  20b7fa:	f851 0f04 	ldr.w	r0, [r1, #4]!
  20b7fe:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
  20b802:	4294      	cmp	r4, r2
  20b804:	d8f9      	bhi.n	20b7fa <__init_ram_areas+0x1a>
  20b806:	43da      	mvns	r2, r3
  20b808:	4414      	add	r4, r2
  20b80a:	f024 0403 	bic.w	r4, r4, #3
  20b80e:	3404      	adds	r4, #4
  20b810:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
  20b812:	429d      	cmp	r5, r3
  20b814:	d903      	bls.n	20b81e <__init_ram_areas+0x3e>
      *p = 0;
  20b816:	f843 7b04 	str.w	r7, [r3], #4
    while (p < rap->no_init_area) {
  20b81a:	429d      	cmp	r5, r3
  20b81c:	d8fb      	bhi.n	20b816 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
  20b81e:	4566      	cmp	r6, ip
  20b820:	d005      	beq.n	20b82e <__init_ram_areas+0x4e>
  20b822:	e9d6 1304 	ldrd	r1, r3, [r6, #16]
  20b826:	e9d6 4506 	ldrd	r4, r5, [r6, #24]
  20b82a:	3610      	adds	r6, #16
  20b82c:	e7e1      	b.n	20b7f2 <__init_ram_areas+0x12>
#endif
}
  20b82e:	bcf0      	pop	{r4, r5, r6, r7}
  20b830:	4770      	bx	lr
  20b832:	bf00      	nop
  20b834:	0800c924 	.word	0x0800c924
  20b838:	20010498 	.word	0x20010498
  20b83c:	20010498 	.word	0x20010498
  20b840:	20010498 	.word	0x20010498
  20b844:	0800edec 	.word	0x0800edec
	...

0020b850 <__default_exit>:
void __default_exit(void) {
  20b850:	e7fe      	b.n	20b850 <__default_exit>
  20b852:	bf00      	nop
	...

0020b860 <__late_init>:
void __late_init(void) {}
  20b860:	4770      	bx	lr
  20b862:	bf00      	nop
	...

0020b870 <__core_init>:
void __core_init(void) {
  20b870:	b4f0      	push	{r4, r5, r6, r7}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  20b872:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  20b876:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  20b87a:	481d      	ldr	r0, [pc, #116]	; (20b8f0 <__core_init+0x80>)
  20b87c:	2200      	movs	r2, #0
  20b87e:	f8c0 2250 	str.w	r2, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  20b882:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  20b886:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  20b88a:	6943      	ldr	r3, [r0, #20]
  20b88c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  20b890:	6143      	str	r3, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  20b892:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  20b896:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
  20b89a:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  20b89e:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
  20b8a2:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  20b8a6:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  20b8aa:	f3c5 06c9 	ubfx	r6, r5, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  20b8ae:	f3c5 354e 	ubfx	r5, r5, #13, #15
  20b8b2:	07b7      	lsls	r7, r6, #30
  20b8b4:	016d      	lsls	r5, r5, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  20b8b6:	ea05 040c 	and.w	r4, r5, ip
  20b8ba:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  20b8bc:	4632      	mov	r2, r6
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  20b8be:	ea44 0301 	orr.w	r3, r4, r1
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
  20b8c2:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  20b8c4:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
  20b8c8:	f8c0 3260 	str.w	r3, [r0, #608]	; 0x260
      } while (ways-- != 0U);
  20b8cc:	1c53      	adds	r3, r2, #1
  20b8ce:	d1f6      	bne.n	20b8be <__core_init+0x4e>
  20b8d0:	3d20      	subs	r5, #32
    } while(sets-- != 0U);
  20b8d2:	f115 0f20 	cmn.w	r5, #32
  20b8d6:	d1ee      	bne.n	20b8b6 <__core_init+0x46>
  20b8d8:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  20b8dc:	6943      	ldr	r3, [r0, #20]
  20b8de:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  20b8e2:	6143      	str	r3, [r0, #20]
  20b8e4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  20b8e8:	f3bf 8f6f 	isb	sy
}
  20b8ec:	bcf0      	pop	{r4, r5, r6, r7}
  20b8ee:	4770      	bx	lr
  20b8f0:	e000ed00 	.word	0xe000ed00

0020b8f4 <memset>:
  20b8f4:	b4f0      	push	{r4, r5, r6, r7}
  20b8f6:	0786      	lsls	r6, r0, #30
  20b8f8:	d043      	beq.n	20b982 <memset+0x8e>
  20b8fa:	1e54      	subs	r4, r2, #1
  20b8fc:	2a00      	cmp	r2, #0
  20b8fe:	d03e      	beq.n	20b97e <memset+0x8a>
  20b900:	b2ca      	uxtb	r2, r1
  20b902:	4603      	mov	r3, r0
  20b904:	e002      	b.n	20b90c <memset+0x18>
  20b906:	f114 34ff 	adds.w	r4, r4, #4294967295
  20b90a:	d338      	bcc.n	20b97e <memset+0x8a>
  20b90c:	f803 2b01 	strb.w	r2, [r3], #1
  20b910:	079d      	lsls	r5, r3, #30
  20b912:	d1f8      	bne.n	20b906 <memset+0x12>
  20b914:	2c03      	cmp	r4, #3
  20b916:	d92b      	bls.n	20b970 <memset+0x7c>
  20b918:	b2cd      	uxtb	r5, r1
  20b91a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  20b91e:	2c0f      	cmp	r4, #15
  20b920:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  20b924:	d916      	bls.n	20b954 <memset+0x60>
  20b926:	f1a4 0710 	sub.w	r7, r4, #16
  20b92a:	093f      	lsrs	r7, r7, #4
  20b92c:	f103 0620 	add.w	r6, r3, #32
  20b930:	eb06 1607 	add.w	r6, r6, r7, lsl #4
  20b934:	f103 0210 	add.w	r2, r3, #16
  20b938:	e942 5504 	strd	r5, r5, [r2, #-16]
  20b93c:	e942 5502 	strd	r5, r5, [r2, #-8]
  20b940:	3210      	adds	r2, #16
  20b942:	42b2      	cmp	r2, r6
  20b944:	d1f8      	bne.n	20b938 <memset+0x44>
  20b946:	f004 040f 	and.w	r4, r4, #15
  20b94a:	3701      	adds	r7, #1
  20b94c:	2c03      	cmp	r4, #3
  20b94e:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  20b952:	d90d      	bls.n	20b970 <memset+0x7c>
  20b954:	461e      	mov	r6, r3
  20b956:	4622      	mov	r2, r4
  20b958:	3a04      	subs	r2, #4
  20b95a:	2a03      	cmp	r2, #3
  20b95c:	f846 5b04 	str.w	r5, [r6], #4
  20b960:	d8fa      	bhi.n	20b958 <memset+0x64>
  20b962:	1f22      	subs	r2, r4, #4
  20b964:	f022 0203 	bic.w	r2, r2, #3
  20b968:	3204      	adds	r2, #4
  20b96a:	4413      	add	r3, r2
  20b96c:	f004 0403 	and.w	r4, r4, #3
  20b970:	b12c      	cbz	r4, 20b97e <memset+0x8a>
  20b972:	b2c9      	uxtb	r1, r1
  20b974:	441c      	add	r4, r3
  20b976:	f803 1b01 	strb.w	r1, [r3], #1
  20b97a:	429c      	cmp	r4, r3
  20b97c:	d1fb      	bne.n	20b976 <memset+0x82>
  20b97e:	bcf0      	pop	{r4, r5, r6, r7}
  20b980:	4770      	bx	lr
  20b982:	4614      	mov	r4, r2
  20b984:	4603      	mov	r3, r0
  20b986:	e7c5      	b.n	20b914 <memset+0x20>

0020b988 <strchr>:
  20b988:	b2c9      	uxtb	r1, r1
  20b98a:	f000 0303 	and.w	r3, r0, #3
  20b98e:	2900      	cmp	r1, #0
  20b990:	d043      	beq.n	20ba1a <strchr+0x92>
  20b992:	b17b      	cbz	r3, 20b9b4 <strchr+0x2c>
  20b994:	7803      	ldrb	r3, [r0, #0]
  20b996:	2b00      	cmp	r3, #0
  20b998:	d067      	beq.n	20ba6a <strchr+0xe2>
  20b99a:	4299      	cmp	r1, r3
  20b99c:	d03c      	beq.n	20ba18 <strchr+0x90>
  20b99e:	1c43      	adds	r3, r0, #1
  20b9a0:	e005      	b.n	20b9ae <strchr+0x26>
  20b9a2:	f813 2b01 	ldrb.w	r2, [r3], #1
  20b9a6:	2a00      	cmp	r2, #0
  20b9a8:	d05d      	beq.n	20ba66 <strchr+0xde>
  20b9aa:	428a      	cmp	r2, r1
  20b9ac:	d034      	beq.n	20ba18 <strchr+0x90>
  20b9ae:	079a      	lsls	r2, r3, #30
  20b9b0:	4618      	mov	r0, r3
  20b9b2:	d1f6      	bne.n	20b9a2 <strchr+0x1a>
  20b9b4:	b470      	push	{r4, r5, r6}
  20b9b6:	6804      	ldr	r4, [r0, #0]
  20b9b8:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
  20b9bc:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
  20b9c0:	ea86 0504 	eor.w	r5, r6, r4
  20b9c4:	f1a5 3301 	sub.w	r3, r5, #16843009	; 0x1010101
  20b9c8:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
  20b9cc:	ea23 0305 	bic.w	r3, r3, r5
  20b9d0:	ea22 0204 	bic.w	r2, r2, r4
  20b9d4:	4313      	orrs	r3, r2
  20b9d6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  20b9da:	d10f      	bne.n	20b9fc <strchr+0x74>
  20b9dc:	f850 4f04 	ldr.w	r4, [r0, #4]!
  20b9e0:	ea84 0506 	eor.w	r5, r4, r6
  20b9e4:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
  20b9e8:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
  20b9ec:	ea22 0205 	bic.w	r2, r2, r5
  20b9f0:	ea23 0304 	bic.w	r3, r3, r4
  20b9f4:	4313      	orrs	r3, r2
  20b9f6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  20b9fa:	d0ef      	beq.n	20b9dc <strchr+0x54>
  20b9fc:	7803      	ldrb	r3, [r0, #0]
  20b9fe:	b143      	cbz	r3, 20ba12 <strchr+0x8a>
  20ba00:	4299      	cmp	r1, r3
  20ba02:	d102      	bne.n	20ba0a <strchr+0x82>
  20ba04:	e006      	b.n	20ba14 <strchr+0x8c>
  20ba06:	428b      	cmp	r3, r1
  20ba08:	d004      	beq.n	20ba14 <strchr+0x8c>
  20ba0a:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  20ba0e:	2b00      	cmp	r3, #0
  20ba10:	d1f9      	bne.n	20ba06 <strchr+0x7e>
  20ba12:	4618      	mov	r0, r3
  20ba14:	bc70      	pop	{r4, r5, r6}
  20ba16:	4770      	bx	lr
  20ba18:	4770      	bx	lr
  20ba1a:	b15b      	cbz	r3, 20ba34 <strchr+0xac>
  20ba1c:	7803      	ldrb	r3, [r0, #0]
  20ba1e:	2b00      	cmp	r3, #0
  20ba20:	d0fa      	beq.n	20ba18 <strchr+0x90>
  20ba22:	1c43      	adds	r3, r0, #1
  20ba24:	e003      	b.n	20ba2e <strchr+0xa6>
  20ba26:	7802      	ldrb	r2, [r0, #0]
  20ba28:	3301      	adds	r3, #1
  20ba2a:	2a00      	cmp	r2, #0
  20ba2c:	d0f4      	beq.n	20ba18 <strchr+0x90>
  20ba2e:	0799      	lsls	r1, r3, #30
  20ba30:	4618      	mov	r0, r3
  20ba32:	d1f8      	bne.n	20ba26 <strchr+0x9e>
  20ba34:	6802      	ldr	r2, [r0, #0]
  20ba36:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
  20ba3a:	ea23 0302 	bic.w	r3, r3, r2
  20ba3e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  20ba42:	d108      	bne.n	20ba56 <strchr+0xce>
  20ba44:	f850 2f04 	ldr.w	r2, [r0, #4]!
  20ba48:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
  20ba4c:	ea23 0302 	bic.w	r3, r3, r2
  20ba50:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  20ba54:	d0f6      	beq.n	20ba44 <strchr+0xbc>
  20ba56:	7803      	ldrb	r3, [r0, #0]
  20ba58:	2b00      	cmp	r3, #0
  20ba5a:	d0dd      	beq.n	20ba18 <strchr+0x90>
  20ba5c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  20ba60:	2b00      	cmp	r3, #0
  20ba62:	d1fb      	bne.n	20ba5c <strchr+0xd4>
  20ba64:	4770      	bx	lr
  20ba66:	4610      	mov	r0, r2
  20ba68:	4770      	bx	lr
  20ba6a:	4618      	mov	r0, r3
  20ba6c:	4770      	bx	lr
  20ba6e:	bf00      	nop

0020ba70 <strncmp>:
  20ba70:	2a00      	cmp	r2, #0
  20ba72:	d041      	beq.n	20baf8 <strncmp+0x88>
  20ba74:	ea40 0301 	orr.w	r3, r0, r1
  20ba78:	f013 0303 	ands.w	r3, r3, #3
  20ba7c:	b4f0      	push	{r4, r5, r6, r7}
  20ba7e:	d125      	bne.n	20bacc <strncmp+0x5c>
  20ba80:	2a03      	cmp	r2, #3
  20ba82:	d923      	bls.n	20bacc <strncmp+0x5c>
  20ba84:	6804      	ldr	r4, [r0, #0]
  20ba86:	680d      	ldr	r5, [r1, #0]
  20ba88:	42ac      	cmp	r4, r5
  20ba8a:	d11f      	bne.n	20bacc <strncmp+0x5c>
  20ba8c:	3a04      	subs	r2, #4
  20ba8e:	d035      	beq.n	20bafc <strncmp+0x8c>
  20ba90:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
  20ba94:	ea25 0404 	bic.w	r4, r5, r4
  20ba98:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  20ba9c:	d131      	bne.n	20bb02 <strncmp+0x92>
  20ba9e:	1d07      	adds	r7, r0, #4
  20baa0:	1d0d      	adds	r5, r1, #4
  20baa2:	e00d      	b.n	20bac0 <strncmp+0x50>
  20baa4:	f857 3b04 	ldr.w	r3, [r7], #4
  20baa8:	680e      	ldr	r6, [r1, #0]
  20baaa:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
  20baae:	42b3      	cmp	r3, r6
  20bab0:	ea24 0403 	bic.w	r4, r4, r3
  20bab4:	d10a      	bne.n	20bacc <strncmp+0x5c>
  20bab6:	3a04      	subs	r2, #4
  20bab8:	d020      	beq.n	20bafc <strncmp+0x8c>
  20baba:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  20babe:	d11d      	bne.n	20bafc <strncmp+0x8c>
  20bac0:	2a03      	cmp	r2, #3
  20bac2:	4629      	mov	r1, r5
  20bac4:	4638      	mov	r0, r7
  20bac6:	f105 0504 	add.w	r5, r5, #4
  20baca:	d8eb      	bhi.n	20baa4 <strncmp+0x34>
  20bacc:	7803      	ldrb	r3, [r0, #0]
  20bace:	780c      	ldrb	r4, [r1, #0]
  20bad0:	429c      	cmp	r4, r3
  20bad2:	f102 32ff 	add.w	r2, r2, #4294967295
  20bad6:	d10c      	bne.n	20baf2 <strncmp+0x82>
  20bad8:	b182      	cbz	r2, 20bafc <strncmp+0x8c>
  20bada:	b914      	cbnz	r4, 20bae2 <strncmp+0x72>
  20badc:	e00e      	b.n	20bafc <strncmp+0x8c>
  20bade:	b16a      	cbz	r2, 20bafc <strncmp+0x8c>
  20bae0:	b17b      	cbz	r3, 20bb02 <strncmp+0x92>
  20bae2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  20bae6:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  20baea:	42a3      	cmp	r3, r4
  20baec:	f102 32ff 	add.w	r2, r2, #4294967295
  20baf0:	d0f5      	beq.n	20bade <strncmp+0x6e>
  20baf2:	1b18      	subs	r0, r3, r4
  20baf4:	bcf0      	pop	{r4, r5, r6, r7}
  20baf6:	4770      	bx	lr
  20baf8:	4610      	mov	r0, r2
  20bafa:	4770      	bx	lr
  20bafc:	2000      	movs	r0, #0
  20bafe:	bcf0      	pop	{r4, r5, r6, r7}
  20bb00:	4770      	bx	lr
  20bb02:	4618      	mov	r0, r3
  20bb04:	e7f6      	b.n	20baf4 <strncmp+0x84>
  20bb06:	bf00      	nop

0020bb08 <strncpy>:
  20bb08:	ea40 0301 	orr.w	r3, r0, r1
  20bb0c:	079b      	lsls	r3, r3, #30
  20bb0e:	b470      	push	{r4, r5, r6}
  20bb10:	d12a      	bne.n	20bb68 <strncpy+0x60>
  20bb12:	2a03      	cmp	r2, #3
  20bb14:	d928      	bls.n	20bb68 <strncpy+0x60>
  20bb16:	460c      	mov	r4, r1
  20bb18:	4603      	mov	r3, r0
  20bb1a:	4621      	mov	r1, r4
  20bb1c:	f854 6b04 	ldr.w	r6, [r4], #4
  20bb20:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
  20bb24:	ea25 0506 	bic.w	r5, r5, r6
  20bb28:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
  20bb2c:	d106      	bne.n	20bb3c <strncpy+0x34>
  20bb2e:	3a04      	subs	r2, #4
  20bb30:	2a03      	cmp	r2, #3
  20bb32:	f843 6b04 	str.w	r6, [r3], #4
  20bb36:	4621      	mov	r1, r4
  20bb38:	d8ef      	bhi.n	20bb1a <strncpy+0x12>
  20bb3a:	b19a      	cbz	r2, 20bb64 <strncpy+0x5c>
  20bb3c:	780c      	ldrb	r4, [r1, #0]
  20bb3e:	701c      	strb	r4, [r3, #0]
  20bb40:	3a01      	subs	r2, #1
  20bb42:	3301      	adds	r3, #1
  20bb44:	b13c      	cbz	r4, 20bb56 <strncpy+0x4e>
  20bb46:	b16a      	cbz	r2, 20bb64 <strncpy+0x5c>
  20bb48:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  20bb4c:	f803 4b01 	strb.w	r4, [r3], #1
  20bb50:	3a01      	subs	r2, #1
  20bb52:	2c00      	cmp	r4, #0
  20bb54:	d1f7      	bne.n	20bb46 <strncpy+0x3e>
  20bb56:	b12a      	cbz	r2, 20bb64 <strncpy+0x5c>
  20bb58:	441a      	add	r2, r3
  20bb5a:	2100      	movs	r1, #0
  20bb5c:	f803 1b01 	strb.w	r1, [r3], #1
  20bb60:	4293      	cmp	r3, r2
  20bb62:	d1fb      	bne.n	20bb5c <strncpy+0x54>
  20bb64:	bc70      	pop	{r4, r5, r6}
  20bb66:	4770      	bx	lr
  20bb68:	4603      	mov	r3, r0
  20bb6a:	e7e6      	b.n	20bb3a <strncpy+0x32>

0020bb6c <strpbrk>:
  20bb6c:	b430      	push	{r4, r5}
  20bb6e:	7804      	ldrb	r4, [r0, #0]
  20bb70:	b1dc      	cbz	r4, 20bbaa <strpbrk+0x3e>
  20bb72:	780d      	ldrb	r5, [r1, #0]
  20bb74:	b19d      	cbz	r5, 20bb9e <strpbrk+0x32>
  20bb76:	42ac      	cmp	r4, r5
  20bb78:	d00f      	beq.n	20bb9a <strpbrk+0x2e>
  20bb7a:	460a      	mov	r2, r1
  20bb7c:	e001      	b.n	20bb82 <strpbrk+0x16>
  20bb7e:	429c      	cmp	r4, r3
  20bb80:	d00b      	beq.n	20bb9a <strpbrk+0x2e>
  20bb82:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  20bb86:	2b00      	cmp	r3, #0
  20bb88:	d1f9      	bne.n	20bb7e <strpbrk+0x12>
  20bb8a:	f810 4f01 	ldrb.w	r4, [r0, #1]!
  20bb8e:	2c00      	cmp	r4, #0
  20bb90:	d1f0      	bne.n	20bb74 <strpbrk+0x8>
  20bb92:	7813      	ldrb	r3, [r2, #0]
  20bb94:	2b00      	cmp	r3, #0
  20bb96:	bf08      	it	eq
  20bb98:	2000      	moveq	r0, #0
  20bb9a:	bc30      	pop	{r4, r5}
  20bb9c:	4770      	bx	lr
  20bb9e:	f810 4f01 	ldrb.w	r4, [r0, #1]!
  20bba2:	460a      	mov	r2, r1
  20bba4:	2c00      	cmp	r4, #0
  20bba6:	d1e5      	bne.n	20bb74 <strpbrk+0x8>
  20bba8:	e7f3      	b.n	20bb92 <strpbrk+0x26>
  20bbaa:	4620      	mov	r0, r4
  20bbac:	e7f5      	b.n	20bb9a <strpbrk+0x2e>
  20bbae:	bf00      	nop

0020bbb0 <strspn>:
  20bbb0:	b470      	push	{r4, r5, r6}
  20bbb2:	7804      	ldrb	r4, [r0, #0]
  20bbb4:	b1a4      	cbz	r4, 20bbe0 <strspn+0x30>
  20bbb6:	780d      	ldrb	r5, [r1, #0]
  20bbb8:	4606      	mov	r6, r0
  20bbba:	b14d      	cbz	r5, 20bbd0 <strspn+0x20>
  20bbbc:	42a5      	cmp	r5, r4
  20bbbe:	d00a      	beq.n	20bbd6 <strspn+0x26>
  20bbc0:	460a      	mov	r2, r1
  20bbc2:	e001      	b.n	20bbc8 <strspn+0x18>
  20bbc4:	42a3      	cmp	r3, r4
  20bbc6:	d006      	beq.n	20bbd6 <strspn+0x26>
  20bbc8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  20bbcc:	2b00      	cmp	r3, #0
  20bbce:	d1f9      	bne.n	20bbc4 <strspn+0x14>
  20bbd0:	1b80      	subs	r0, r0, r6
  20bbd2:	bc70      	pop	{r4, r5, r6}
  20bbd4:	4770      	bx	lr
  20bbd6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
  20bbda:	2c00      	cmp	r4, #0
  20bbdc:	d1ed      	bne.n	20bbba <strspn+0xa>
  20bbde:	e7f7      	b.n	20bbd0 <strspn+0x20>
  20bbe0:	4620      	mov	r0, r4
  20bbe2:	e7f6      	b.n	20bbd2 <strspn+0x22>
