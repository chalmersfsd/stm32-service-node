
build/stm32l476_discovery/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000279 	.word	0x08000279
 8000008:	0800027b 	.word	0x0800027b
 800000c:	0800027a 	.word	0x0800027a
 8000010:	0800027a 	.word	0x0800027a
 8000014:	0800027a 	.word	0x0800027a
 8000018:	0800027a 	.word	0x0800027a
 800001c:	0800027a 	.word	0x0800027a
 8000020:	0800027a 	.word	0x0800027a
 8000024:	0800027a 	.word	0x0800027a
 8000028:	0800027a 	.word	0x0800027a
 800002c:	08003631 	.word	0x08003631
 8000030:	0800027a 	.word	0x0800027a
 8000034:	0800027a 	.word	0x0800027a
 8000038:	0800027a 	.word	0x0800027a
 800003c:	0800027a 	.word	0x0800027a
 8000040:	0800027a 	.word	0x0800027a
 8000044:	0800027a 	.word	0x0800027a
 8000048:	0800027a 	.word	0x0800027a
 800004c:	0800027a 	.word	0x0800027a
 8000050:	0800027a 	.word	0x0800027a
 8000054:	0800027a 	.word	0x0800027a
 8000058:	0800027a 	.word	0x0800027a
 800005c:	0800027a 	.word	0x0800027a
 8000060:	0800027a 	.word	0x0800027a
 8000064:	0800027a 	.word	0x0800027a
 8000068:	0800027a 	.word	0x0800027a
 800006c:	0800027a 	.word	0x0800027a
 8000070:	0800027a 	.word	0x0800027a
 8000074:	0800027a 	.word	0x0800027a
 8000078:	0800027a 	.word	0x0800027a
 800007c:	0800027a 	.word	0x0800027a
 8000080:	0800027a 	.word	0x0800027a
 8000084:	0800027a 	.word	0x0800027a
 8000088:	0800027a 	.word	0x0800027a
 800008c:	0800027a 	.word	0x0800027a
 8000090:	0800027a 	.word	0x0800027a
 8000094:	0800027a 	.word	0x0800027a
 8000098:	0800027a 	.word	0x0800027a
 800009c:	0800027a 	.word	0x0800027a
 80000a0:	0800027a 	.word	0x0800027a
 80000a4:	0800027a 	.word	0x0800027a
 80000a8:	0800027a 	.word	0x0800027a
 80000ac:	0800027a 	.word	0x0800027a
 80000b0:	0800b351 	.word	0x0800b351
 80000b4:	0800027a 	.word	0x0800027a
 80000b8:	0800027a 	.word	0x0800027a
 80000bc:	0800027a 	.word	0x0800027a
 80000c0:	0800027a 	.word	0x0800027a
 80000c4:	0800027a 	.word	0x0800027a
 80000c8:	0800027a 	.word	0x0800027a
 80000cc:	0800027a 	.word	0x0800027a
 80000d0:	0800027a 	.word	0x0800027a
 80000d4:	0800027a 	.word	0x0800027a
 80000d8:	0800027a 	.word	0x0800027a
 80000dc:	0800027a 	.word	0x0800027a
 80000e0:	0800027a 	.word	0x0800027a
 80000e4:	0800027a 	.word	0x0800027a
 80000e8:	0800027a 	.word	0x0800027a
 80000ec:	0800027a 	.word	0x0800027a
 80000f0:	0800027a 	.word	0x0800027a
 80000f4:	0800027a 	.word	0x0800027a
 80000f8:	0800027a 	.word	0x0800027a
 80000fc:	0800027a 	.word	0x0800027a
 8000100:	0800027a 	.word	0x0800027a
 8000104:	0800027a 	.word	0x0800027a
 8000108:	0800027a 	.word	0x0800027a
 800010c:	0800027a 	.word	0x0800027a
 8000110:	0800027a 	.word	0x0800027a
 8000114:	0800027a 	.word	0x0800027a
 8000118:	0800027a 	.word	0x0800027a
 800011c:	0800027a 	.word	0x0800027a
 8000120:	0800027a 	.word	0x0800027a
 8000124:	0800027a 	.word	0x0800027a
 8000128:	0800027a 	.word	0x0800027a
 800012c:	0800027a 	.word	0x0800027a
 8000130:	0800027a 	.word	0x0800027a
 8000134:	0800027a 	.word	0x0800027a
 8000138:	0800027a 	.word	0x0800027a
 800013c:	0800027a 	.word	0x0800027a
 8000140:	0800027a 	.word	0x0800027a
 8000144:	0800027a 	.word	0x0800027a
 8000148:	0800027a 	.word	0x0800027a
 800014c:	0800b431 	.word	0x0800b431
 8000150:	0800027a 	.word	0x0800027a
 8000154:	0800027a 	.word	0x0800027a
 8000158:	0800027a 	.word	0x0800027a
 800015c:	0800027a 	.word	0x0800027a
 8000160:	0800027a 	.word	0x0800027a
 8000164:	0800027a 	.word	0x0800027a
 8000168:	0800027a 	.word	0x0800027a
 800016c:	0800027a 	.word	0x0800027a
 8000170:	0800027a 	.word	0x0800027a
 8000174:	0800027a 	.word	0x0800027a
 8000178:	0800027a 	.word	0x0800027a
 800017c:	0800027a 	.word	0x0800027a
 8000180:	0800027a 	.word	0x0800027a
 8000184:	0800027a 	.word	0x0800027a
 8000188:	0800027a 	.word	0x0800027a
 800018c:	0800027a 	.word	0x0800027a
 8000190:	0800027a 	.word	0x0800027a
 8000194:	0800027a 	.word	0x0800027a
 8000198:	0800027a 	.word	0x0800027a
 800019c:	0800027a 	.word	0x0800027a

Disassembly of section .text:

080001a0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001a0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001a2:	4827      	ldr	r0, [pc, #156]	; (8000240 <endfiniloop+0x4>)
                msr     MSP, r0
 80001a4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001a8:	4826      	ldr	r0, [pc, #152]	; (8000244 <endfiniloop+0x8>)
                msr     PSP, r0
 80001aa:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ae:	4826      	ldr	r0, [pc, #152]	; (8000248 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001b0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001b4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001b8:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001ba:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001bc:	f380 8814 	msr	CONTROL, r0
                isb
 80001c0:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80001c4:	f00b fb84 	bl	800b8d0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 80001c8:	f00a ff62 	bl	800b090 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80001cc:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80001d0:	491e      	ldr	r1, [pc, #120]	; (800024c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 80001d2:	4a1b      	ldr	r2, [pc, #108]	; (8000240 <endfiniloop+0x4>)

080001d4 <msloop>:
msloop:
                cmp     r1, r2
 80001d4:	4291      	cmp	r1, r2
                itt     lo
 80001d6:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001d8:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 80001dc:	e7fa      	bcc.n	80001d4 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80001de:	491c      	ldr	r1, [pc, #112]	; (8000250 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 80001e0:	4a18      	ldr	r2, [pc, #96]	; (8000244 <endfiniloop+0x8>)

080001e2 <psloop>:
psloop:
                cmp     r1, r2
 80001e2:	4291      	cmp	r1, r2
                itt     lo
 80001e4:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001e6:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 80001ea:	e7fa      	bcc.n	80001e2 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 80001ec:	4919      	ldr	r1, [pc, #100]	; (8000254 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 80001ee:	4a1a      	ldr	r2, [pc, #104]	; (8000258 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 80001f0:	4b1a      	ldr	r3, [pc, #104]	; (800025c <endfiniloop+0x20>)

080001f2 <dloop>:
dloop:
                cmp     r2, r3
 80001f2:	429a      	cmp	r2, r3
                ittt    lo
 80001f4:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 80001f6:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 80001fa:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 80001fe:	e7f8      	bcc.n	80001f2 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000200:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000202:	4917      	ldr	r1, [pc, #92]	; (8000260 <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000204:	4a17      	ldr	r2, [pc, #92]	; (8000264 <endfiniloop+0x28>)

08000206 <bloop>:
bloop:
                cmp     r1, r2
 8000206:	4291      	cmp	r1, r2
                itt     lo
 8000208:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800020a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800020e:	e7fa      	bcc.n	8000206 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000210:	f00b fb16 	bl	800b840 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000214:	f00b fb54 	bl	800b8c0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8000218:	4c13      	ldr	r4, [pc, #76]	; (8000268 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800021a:	4d14      	ldr	r5, [pc, #80]	; (800026c <endfiniloop+0x30>)

0800021c <initloop>:
initloop:
                cmp     r4, r5
 800021c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800021e:	da03      	bge.n	8000228 <endinitloop>
                ldr     r1, [r4], #4
 8000220:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000224:	4788      	blx	r1
                b       initloop
 8000226:	e7f9      	b.n	800021c <initloop>

08000228 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000228:	f008 fcba 	bl	8008ba0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800022c:	4c10      	ldr	r4, [pc, #64]	; (8000270 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 800022e:	4d11      	ldr	r5, [pc, #68]	; (8000274 <endfiniloop+0x38>)

08000230 <finiloop>:
finiloop:
                cmp     r4, r5
 8000230:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000232:	da03      	bge.n	800023c <endfiniloop>
                ldr     r1, [r4], #4
 8000234:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000238:	4788      	blx	r1
                b       finiloop
 800023a:	e7f9      	b.n	8000230 <finiloop>

0800023c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800023c:	f00b bb38 	b.w	800b8b0 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000240:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000244:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000248:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800024c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000250:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 8000254:	0800e8f4 	.word	0x0800e8f4
                ldr     r2, =_data_start
 8000258:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 800025c:	20000c98 	.word	0x20000c98
                ldr     r1, =_bss_start
 8000260:	20000c98 	.word	0x20000c98
                ldr     r2, =_bss_end
 8000264:	20001ce0 	.word	0x20001ce0
                ldr     r4, =__init_array_start
 8000268:	080001a0 	.word	0x080001a0
                ldr     r5, =__init_array_end
 800026c:	080001a0 	.word	0x080001a0
                ldr     r4, =__fini_array_start
 8000270:	080001a0 	.word	0x080001a0
                ldr     r5, =__fini_array_end
 8000274:	080001a0 	.word	0x080001a0

08000278 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000278:	e792      	b.n	80001a0 <_crt0_entry>

0800027a <NMI_Handler>:
Vector3F0:
Vector3F4:
Vector3F8:
Vector3FC:
#endif
        bl          _unhandled_exception
 800027a:	f000 f800 	bl	800027e <_unhandled_exception>

0800027e <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 800027e:	e7fe      	b.n	800027e <_unhandled_exception>

08000280 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000284:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000288:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 800028a:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800028c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000290 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 8000290:	f003 fa2e 	bl	80036f0 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000294:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000296:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 800029a:	4628      	mov	r0, r5
                blx     r4
 800029c:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 800029e:	2000      	movs	r0, #0
                bl      chThdExit
 80002a0:	f007 ff66 	bl	8008170 <chThdExit>

080002a4 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 80002a4:	f003 fa8c 	bl	80037c0 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80002a8:	f003 f9d2 	bl	8003650 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002ac:	f003 fa20 	bl	80036f0 <_dbg_check_unlock>

080002b0 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002b0:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002b2:	e7fe      	b.n	80002b2 <_port_exit_from_isr+0x2>

080002b4 <memcpy>:
 80002b4:	4684      	mov	ip, r0
 80002b6:	ea41 0300 	orr.w	r3, r1, r0
 80002ba:	f013 0303 	ands.w	r3, r3, #3
 80002be:	d16d      	bne.n	800039c <memcpy+0xe8>
 80002c0:	3a40      	subs	r2, #64	; 0x40
 80002c2:	d341      	bcc.n	8000348 <memcpy+0x94>
 80002c4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002c8:	f840 3b04 	str.w	r3, [r0], #4
 80002cc:	f851 3b04 	ldr.w	r3, [r1], #4
 80002d0:	f840 3b04 	str.w	r3, [r0], #4
 80002d4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002d8:	f840 3b04 	str.w	r3, [r0], #4
 80002dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e0:	f840 3b04 	str.w	r3, [r0], #4
 80002e4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e8:	f840 3b04 	str.w	r3, [r0], #4
 80002ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f0:	f840 3b04 	str.w	r3, [r0], #4
 80002f4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f8:	f840 3b04 	str.w	r3, [r0], #4
 80002fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000300:	f840 3b04 	str.w	r3, [r0], #4
 8000304:	f851 3b04 	ldr.w	r3, [r1], #4
 8000308:	f840 3b04 	str.w	r3, [r0], #4
 800030c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000310:	f840 3b04 	str.w	r3, [r0], #4
 8000314:	f851 3b04 	ldr.w	r3, [r1], #4
 8000318:	f840 3b04 	str.w	r3, [r0], #4
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	3a40      	subs	r2, #64	; 0x40
 8000346:	d2bd      	bcs.n	80002c4 <memcpy+0x10>
 8000348:	3230      	adds	r2, #48	; 0x30
 800034a:	d311      	bcc.n	8000370 <memcpy+0xbc>
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	3a10      	subs	r2, #16
 800036e:	d2ed      	bcs.n	800034c <memcpy+0x98>
 8000370:	320c      	adds	r2, #12
 8000372:	d305      	bcc.n	8000380 <memcpy+0xcc>
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	3a04      	subs	r2, #4
 800037e:	d2f9      	bcs.n	8000374 <memcpy+0xc0>
 8000380:	3204      	adds	r2, #4
 8000382:	d008      	beq.n	8000396 <memcpy+0xe2>
 8000384:	07d2      	lsls	r2, r2, #31
 8000386:	bf1c      	itt	ne
 8000388:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800038c:	f800 3b01 	strbne.w	r3, [r0], #1
 8000390:	d301      	bcc.n	8000396 <memcpy+0xe2>
 8000392:	880b      	ldrh	r3, [r1, #0]
 8000394:	8003      	strh	r3, [r0, #0]
 8000396:	4660      	mov	r0, ip
 8000398:	4770      	bx	lr
 800039a:	bf00      	nop
 800039c:	2a08      	cmp	r2, #8
 800039e:	d313      	bcc.n	80003c8 <memcpy+0x114>
 80003a0:	078b      	lsls	r3, r1, #30
 80003a2:	d08d      	beq.n	80002c0 <memcpy+0xc>
 80003a4:	f010 0303 	ands.w	r3, r0, #3
 80003a8:	d08a      	beq.n	80002c0 <memcpy+0xc>
 80003aa:	f1c3 0304 	rsb	r3, r3, #4
 80003ae:	1ad2      	subs	r2, r2, r3
 80003b0:	07db      	lsls	r3, r3, #31
 80003b2:	bf1c      	itt	ne
 80003b4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003b8:	f800 3b01 	strbne.w	r3, [r0], #1
 80003bc:	d380      	bcc.n	80002c0 <memcpy+0xc>
 80003be:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003c2:	f820 3b02 	strh.w	r3, [r0], #2
 80003c6:	e77b      	b.n	80002c0 <memcpy+0xc>
 80003c8:	3a04      	subs	r2, #4
 80003ca:	d3d9      	bcc.n	8000380 <memcpy+0xcc>
 80003cc:	3a01      	subs	r2, #1
 80003ce:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003d2:	f800 3b01 	strb.w	r3, [r0], #1
 80003d6:	d2f9      	bcs.n	80003cc <memcpy+0x118>
 80003d8:	780b      	ldrb	r3, [r1, #0]
 80003da:	7003      	strb	r3, [r0, #0]
 80003dc:	784b      	ldrb	r3, [r1, #1]
 80003de:	7043      	strb	r3, [r0, #1]
 80003e0:	788b      	ldrb	r3, [r1, #2]
 80003e2:	7083      	strb	r3, [r0, #2]
 80003e4:	4660      	mov	r0, ip
 80003e6:	4770      	bx	lr
	...
 8000400:	eba2 0003 	sub.w	r0, r2, r3
 8000404:	4770      	bx	lr
 8000406:	bf00      	nop

08000408 <strcmp>:
 8000408:	7802      	ldrb	r2, [r0, #0]
 800040a:	780b      	ldrb	r3, [r1, #0]
 800040c:	2a01      	cmp	r2, #1
 800040e:	bf28      	it	cs
 8000410:	429a      	cmpcs	r2, r3
 8000412:	d1f5      	bne.n	8000400 <memcpy+0x14c>
 8000414:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000418:	ea40 0401 	orr.w	r4, r0, r1
 800041c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000420:	f06f 0c00 	mvn.w	ip, #0
 8000424:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000428:	b312      	cbz	r2, 8000470 <strcmp+0x68>
 800042a:	ea80 0401 	eor.w	r4, r0, r1
 800042e:	f014 0f07 	tst.w	r4, #7
 8000432:	d16a      	bne.n	800050a <strcmp+0x102>
 8000434:	f000 0407 	and.w	r4, r0, #7
 8000438:	f020 0007 	bic.w	r0, r0, #7
 800043c:	f004 0503 	and.w	r5, r4, #3
 8000440:	f021 0107 	bic.w	r1, r1, #7
 8000444:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000448:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800044c:	f014 0f04 	tst.w	r4, #4
 8000450:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000454:	fa0c f405 	lsl.w	r4, ip, r5
 8000458:	ea62 0204 	orn	r2, r2, r4
 800045c:	ea66 0604 	orn	r6, r6, r4
 8000460:	d00a      	beq.n	8000478 <strcmp+0x70>
 8000462:	ea63 0304 	orn	r3, r3, r4
 8000466:	4662      	mov	r2, ip
 8000468:	ea67 0704 	orn	r7, r7, r4
 800046c:	4666      	mov	r6, ip
 800046e:	e003      	b.n	8000478 <strcmp+0x70>
 8000470:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000474:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000478:	fa82 f54c 	uadd8	r5, r2, ip
 800047c:	ea82 0406 	eor.w	r4, r2, r6
 8000480:	faa4 f48c 	sel	r4, r4, ip
 8000484:	bb6c      	cbnz	r4, 80004e2 <strcmp+0xda>
 8000486:	fa83 f54c 	uadd8	r5, r3, ip
 800048a:	ea83 0507 	eor.w	r5, r3, r7
 800048e:	faa5 f58c 	sel	r5, r5, ip
 8000492:	b995      	cbnz	r5, 80004ba <strcmp+0xb2>
 8000494:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 8000498:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 800049c:	fa82 f54c 	uadd8	r5, r2, ip
 80004a0:	ea82 0406 	eor.w	r4, r2, r6
 80004a4:	faa4 f48c 	sel	r4, r4, ip
 80004a8:	fa83 f54c 	uadd8	r5, r3, ip
 80004ac:	ea83 0507 	eor.w	r5, r3, r7
 80004b0:	faa5 f58c 	sel	r5, r5, ip
 80004b4:	4325      	orrs	r5, r4
 80004b6:	d0db      	beq.n	8000470 <strcmp+0x68>
 80004b8:	b99c      	cbnz	r4, 80004e2 <strcmp+0xda>
 80004ba:	ba2d      	rev	r5, r5
 80004bc:	fab5 f485 	clz	r4, r5
 80004c0:	f024 0407 	bic.w	r4, r4, #7
 80004c4:	fa27 f104 	lsr.w	r1, r7, r4
 80004c8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80004cc:	fa23 f304 	lsr.w	r3, r3, r4
 80004d0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80004d4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80004d8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80004dc:	eba0 0001 	sub.w	r0, r0, r1
 80004e0:	4770      	bx	lr
 80004e2:	ba24      	rev	r4, r4
 80004e4:	fab4 f484 	clz	r4, r4
 80004e8:	f024 0407 	bic.w	r4, r4, #7
 80004ec:	fa26 f104 	lsr.w	r1, r6, r4
 80004f0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80004f4:	fa22 f204 	lsr.w	r2, r2, r4
 80004f8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 80004fc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000500:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000504:	eba0 0001 	sub.w	r0, r0, r1
 8000508:	4770      	bx	lr
 800050a:	f014 0f03 	tst.w	r4, #3
 800050e:	d13c      	bne.n	800058a <strcmp+0x182>
 8000510:	f010 0403 	ands.w	r4, r0, #3
 8000514:	d128      	bne.n	8000568 <strcmp+0x160>
 8000516:	f850 2b08 	ldr.w	r2, [r0], #8
 800051a:	f851 3b08 	ldr.w	r3, [r1], #8
 800051e:	fa82 f54c 	uadd8	r5, r2, ip
 8000522:	ea82 0503 	eor.w	r5, r2, r3
 8000526:	faa5 f58c 	sel	r5, r5, ip
 800052a:	b95d      	cbnz	r5, 8000544 <strcmp+0x13c>
 800052c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000530:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000534:	fa82 f54c 	uadd8	r5, r2, ip
 8000538:	ea82 0503 	eor.w	r5, r2, r3
 800053c:	faa5 f58c 	sel	r5, r5, ip
 8000540:	2d00      	cmp	r5, #0
 8000542:	d0e8      	beq.n	8000516 <strcmp+0x10e>
 8000544:	ba2d      	rev	r5, r5
 8000546:	fab5 f485 	clz	r4, r5
 800054a:	f024 0407 	bic.w	r4, r4, #7
 800054e:	fa23 f104 	lsr.w	r1, r3, r4
 8000552:	fa22 f204 	lsr.w	r2, r2, r4
 8000556:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800055a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800055e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000562:	eba0 0001 	sub.w	r0, r0, r1
 8000566:	4770      	bx	lr
 8000568:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800056c:	f020 0003 	bic.w	r0, r0, #3
 8000570:	f850 2b08 	ldr.w	r2, [r0], #8
 8000574:	f021 0103 	bic.w	r1, r1, #3
 8000578:	f851 3b08 	ldr.w	r3, [r1], #8
 800057c:	fa0c f404 	lsl.w	r4, ip, r4
 8000580:	ea62 0204 	orn	r2, r2, r4
 8000584:	ea63 0304 	orn	r3, r3, r4
 8000588:	e7c9      	b.n	800051e <strcmp+0x116>
 800058a:	f010 0403 	ands.w	r4, r0, #3
 800058e:	d01a      	beq.n	80005c6 <strcmp+0x1be>
 8000590:	eba1 0104 	sub.w	r1, r1, r4
 8000594:	f020 0003 	bic.w	r0, r0, #3
 8000598:	07e4      	lsls	r4, r4, #31
 800059a:	f850 2b04 	ldr.w	r2, [r0], #4
 800059e:	d006      	beq.n	80005ae <strcmp+0x1a6>
 80005a0:	d20f      	bcs.n	80005c2 <strcmp+0x1ba>
 80005a2:	788b      	ldrb	r3, [r1, #2]
 80005a4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80005a8:	1ae4      	subs	r4, r4, r3
 80005aa:	d106      	bne.n	80005ba <strcmp+0x1b2>
 80005ac:	b12b      	cbz	r3, 80005ba <strcmp+0x1b2>
 80005ae:	78cb      	ldrb	r3, [r1, #3]
 80005b0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80005b4:	1ae4      	subs	r4, r4, r3
 80005b6:	d100      	bne.n	80005ba <strcmp+0x1b2>
 80005b8:	b91b      	cbnz	r3, 80005c2 <strcmp+0x1ba>
 80005ba:	4620      	mov	r0, r4
 80005bc:	f85d 4b10 	ldr.w	r4, [sp], #16
 80005c0:	4770      	bx	lr
 80005c2:	f101 0104 	add.w	r1, r1, #4
 80005c6:	f850 2b04 	ldr.w	r2, [r0], #4
 80005ca:	07cc      	lsls	r4, r1, #31
 80005cc:	f021 0103 	bic.w	r1, r1, #3
 80005d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80005d4:	d848      	bhi.n	8000668 <strcmp+0x260>
 80005d6:	d224      	bcs.n	8000622 <strcmp+0x21a>
 80005d8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 80005dc:	fa82 f54c 	uadd8	r5, r2, ip
 80005e0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 80005e4:	faa5 f58c 	sel	r5, r5, ip
 80005e8:	d10a      	bne.n	8000600 <strcmp+0x1f8>
 80005ea:	b965      	cbnz	r5, 8000606 <strcmp+0x1fe>
 80005ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80005f0:	ea84 0402 	eor.w	r4, r4, r2
 80005f4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 80005f8:	d10e      	bne.n	8000618 <strcmp+0x210>
 80005fa:	f850 2b04 	ldr.w	r2, [r0], #4
 80005fe:	e7eb      	b.n	80005d8 <strcmp+0x1d0>
 8000600:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000604:	e055      	b.n	80006b2 <strcmp+0x2aa>
 8000606:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800060a:	d14d      	bne.n	80006a8 <strcmp+0x2a0>
 800060c:	7808      	ldrb	r0, [r1, #0]
 800060e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000612:	f1c0 0000 	rsb	r0, r0, #0
 8000616:	4770      	bx	lr
 8000618:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800061c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000620:	e047      	b.n	80006b2 <strcmp+0x2aa>
 8000622:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000626:	fa82 f54c 	uadd8	r5, r2, ip
 800062a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800062e:	faa5 f58c 	sel	r5, r5, ip
 8000632:	d10a      	bne.n	800064a <strcmp+0x242>
 8000634:	b965      	cbnz	r5, 8000650 <strcmp+0x248>
 8000636:	f851 3b04 	ldr.w	r3, [r1], #4
 800063a:	ea84 0402 	eor.w	r4, r4, r2
 800063e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000642:	d10c      	bne.n	800065e <strcmp+0x256>
 8000644:	f850 2b04 	ldr.w	r2, [r0], #4
 8000648:	e7eb      	b.n	8000622 <strcmp+0x21a>
 800064a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800064e:	e030      	b.n	80006b2 <strcmp+0x2aa>
 8000650:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000654:	d128      	bne.n	80006a8 <strcmp+0x2a0>
 8000656:	880b      	ldrh	r3, [r1, #0]
 8000658:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800065c:	e029      	b.n	80006b2 <strcmp+0x2aa>
 800065e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000662:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000666:	e024      	b.n	80006b2 <strcmp+0x2aa>
 8000668:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800066c:	fa82 f54c 	uadd8	r5, r2, ip
 8000670:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000674:	faa5 f58c 	sel	r5, r5, ip
 8000678:	d10a      	bne.n	8000690 <strcmp+0x288>
 800067a:	b965      	cbnz	r5, 8000696 <strcmp+0x28e>
 800067c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000680:	ea84 0402 	eor.w	r4, r4, r2
 8000684:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 8000688:	d109      	bne.n	800069e <strcmp+0x296>
 800068a:	f850 2b04 	ldr.w	r2, [r0], #4
 800068e:	e7eb      	b.n	8000668 <strcmp+0x260>
 8000690:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8000694:	e00d      	b.n	80006b2 <strcmp+0x2aa>
 8000696:	f015 0fff 	tst.w	r5, #255	; 0xff
 800069a:	d105      	bne.n	80006a8 <strcmp+0x2a0>
 800069c:	680b      	ldr	r3, [r1, #0]
 800069e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80006a2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80006a6:	e004      	b.n	80006b2 <strcmp+0x2aa>
 80006a8:	f04f 0000 	mov.w	r0, #0
 80006ac:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006b0:	4770      	bx	lr
 80006b2:	ba12      	rev	r2, r2
 80006b4:	ba1b      	rev	r3, r3
 80006b6:	fa82 f44c 	uadd8	r4, r2, ip
 80006ba:	ea82 0403 	eor.w	r4, r2, r3
 80006be:	faa4 f58c 	sel	r5, r4, ip
 80006c2:	fab5 f485 	clz	r4, r5
 80006c6:	fa02 f204 	lsl.w	r2, r2, r4
 80006ca:	fa03 f304 	lsl.w	r3, r3, r4
 80006ce:	ea4f 6012 	mov.w	r0, r2, lsr #24
 80006d2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006d6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 80006da:	4770      	bx	lr
 80006dc:	0000      	movs	r0, r0
	...

080006e0 <otg_txfifo_handler.constprop.69>:
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 80006e0:	4b28      	ldr	r3, [pc, #160]	; (8000784 <otg_txfifo_handler.constprop.69+0xa4>)
 80006e2:	eb03 0280 	add.w	r2, r3, r0, lsl #2
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 80006e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 80006ea:	68d1      	ldr	r1, [r2, #12]
 80006ec:	6edd      	ldr	r5, [r3, #108]	; 0x6c
 80006ee:	694a      	ldr	r2, [r1, #20]
 80006f0:	e9d2 4300 	ldrd	r4, r3, [r2]
 80006f4:	429c      	cmp	r4, r3
 80006f6:	d935      	bls.n	8000764 <otg_txfifo_handler.constprop.69+0x84>
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80006f8:	1c46      	adds	r6, r0, #1
    if (n > usbp->epc[ep]->in_maxsize)
 80006fa:	8a0f      	ldrh	r7, [r1, #16]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80006fc:	eb05 3606 	add.w	r6, r5, r6, lsl #12
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000700:	eb05 1c40 	add.w	ip, r5, r0, lsl #5
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8000704:	1ae3      	subs	r3, r4, r3
    if (n > usbp->epc[ep]->in_maxsize)
 8000706:	42bb      	cmp	r3, r7
 8000708:	d90c      	bls.n	8000724 <otg_txfifo_handler.constprop.69+0x44>
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800070a:	f8dc 3918 	ldr.w	r3, [ip, #2328]	; 0x918
 800070e:	b29b      	uxth	r3, r3
 8000710:	ebb7 0f83 	cmp.w	r7, r3, lsl #2
 8000714:	d834      	bhi.n	8000780 <otg_txfifo_handler.constprop.69+0xa0>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000716:	6891      	ldr	r1, [r2, #8]
  osalDbgAssert(n > 0, "is zero");
 8000718:	bb87      	cbnz	r7, 800077c <otg_txfifo_handler.constprop.69+0x9c>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800071a:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800071c:	4b1a      	ldr	r3, [pc, #104]	; (8000788 <otg_txfifo_handler.constprop.69+0xa8>)
 800071e:	4a1b      	ldr	r2, [pc, #108]	; (800078c <otg_txfifo_handler.constprop.69+0xac>)
 8000720:	62da      	str	r2, [r3, #44]	; 0x2c
 8000722:	e7fe      	b.n	8000722 <otg_txfifo_handler.constprop.69+0x42>
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000724:	f8dc 1918 	ldr.w	r1, [ip, #2328]	; 0x918
 8000728:	b289      	uxth	r1, r1
 800072a:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
 800072e:	d827      	bhi.n	8000780 <otg_txfifo_handler.constprop.69+0xa0>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000730:	6891      	ldr	r1, [r2, #8]
    *fifop = *((uint32_t *)buf);
 8000732:	680c      	ldr	r4, [r1, #0]
 8000734:	6034      	str	r4, [r6, #0]
    if (n <= 4) {
 8000736:	2b04      	cmp	r3, #4
 8000738:	d90b      	bls.n	8000752 <otg_txfifo_handler.constprop.69+0x72>
 800073a:	1f5c      	subs	r4, r3, #5
 800073c:	f024 0403 	bic.w	r4, r4, #3
 8000740:	3404      	adds	r4, #4
 8000742:	440c      	add	r4, r1
 8000744:	468e      	mov	lr, r1
    *fifop = *((uint32_t *)buf);
 8000746:	f85e 8f04 	ldr.w	r8, [lr, #4]!
 800074a:	f8c6 8000 	str.w	r8, [r6]
    if (n <= 4) {
 800074e:	45a6      	cmp	lr, r4
 8000750:	d1f9      	bne.n	8000746 <otg_txfifo_handler.constprop.69+0x66>
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 8000752:	eb01 0e03 	add.w	lr, r1, r3
    usbp->epc[ep]->in_state->txcnt += n;
 8000756:	6851      	ldr	r1, [r2, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000758:	6814      	ldr	r4, [r2, #0]
    usbp->epc[ep]->in_state->txcnt += n;
 800075a:	440b      	add	r3, r1
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 800075c:	429c      	cmp	r4, r3
    usbp->epc[ep]->in_state->txcnt += n;
 800075e:	e9c2 3e01 	strd	r3, lr, [r2, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000762:	d8cf      	bhi.n	8000704 <otg_txfifo_handler.constprop.69+0x24>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8000764:	2301      	movs	r3, #1
 8000766:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
 800076a:	fa03 f000 	lsl.w	r0, r3, r0
 800076e:	ea22 0200 	bic.w	r2, r2, r0
 8000772:	f8c5 2834 	str.w	r2, [r5, #2100]	; 0x834
      return true;
 8000776:	4618      	mov	r0, r3
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
  }
}
 8000778:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  osalDbgAssert(n > 0, "is zero");
 800077c:	463b      	mov	r3, r7
 800077e:	e7d8      	b.n	8000732 <otg_txfifo_handler.constprop.69+0x52>
      return false;
 8000780:	2000      	movs	r0, #0
 8000782:	e7f9      	b.n	8000778 <otg_txfifo_handler.constprop.69+0x98>
 8000784:	20001128 	.word	0x20001128
 8000788:	200011a0 	.word	0x200011a0
 800078c:	0800c080 	.word	0x0800c080

08000790 <chTMStartMeasurementX.constprop.61>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000790:	4b01      	ldr	r3, [pc, #4]	; (8000798 <chTMStartMeasurementX.constprop.61+0x8>)
 8000792:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8000794:	6083      	str	r3, [r0, #8]
}
 8000796:	4770      	bx	lr
 8000798:	e0001000 	.word	0xe0001000
 800079c:	00000000 	.word	0x00000000

080007a0 <_test_assert_time_window.constprop.1>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80007a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((time - start) < (end - start));
 80007a4:	1a09      	subs	r1, r1, r0
 80007a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80007a8:	1a1b      	subs	r3, r3, r0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 80007aa:	428b      	cmp	r3, r1
 80007ac:	d308      	bcc.n	80007c0 <_test_assert_time_window.constprop.1+0x20>
  test_failure_message = msg;
 80007ae:	4905      	ldr	r1, [pc, #20]	; (80007c4 <_test_assert_time_window.constprop.1+0x24>)
  test_local_fail      = true;
 80007b0:	4a05      	ldr	r2, [pc, #20]	; (80007c8 <_test_assert_time_window.constprop.1+0x28>)
  test_global_fail     = true;
 80007b2:	4b06      	ldr	r3, [pc, #24]	; (80007cc <_test_assert_time_window.constprop.1+0x2c>)
  test_failure_message = msg;
 80007b4:	4806      	ldr	r0, [pc, #24]	; (80007d0 <_test_assert_time_window.constprop.1+0x30>)
 80007b6:	6008      	str	r0, [r1, #0]
  test_local_fail      = true;
 80007b8:	2001      	movs	r0, #1
 80007ba:	7010      	strb	r0, [r2, #0]
  test_global_fail     = true;
 80007bc:	7018      	strb	r0, [r3, #0]
 80007be:	4770      	bx	lr
    return _test_fail(msg);
  return false;
 80007c0:	2000      	movs	r0, #0
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
 80007c2:	4770      	bx	lr
 80007c4:	20001a94 	.word	0x20001a94
 80007c8:	20001b38 	.word	0x20001b38
 80007cc:	20001a98 	.word	0x20001a98
 80007d0:	0800c1ac 	.word	0x0800c1ac
	...

080007e0 <oslib_test_003_001_setup>:
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 80007e0:	4b0b      	ldr	r3, [pc, #44]	; (8000810 <oslib_test_003_001_setup+0x30>)
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
 80007e2:	4a0c      	ldr	r2, [pc, #48]	; (8000814 <oslib_test_003_001_setup+0x34>)
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 80007e4:	1dd9      	adds	r1, r3, #7
 80007e6:	f021 0107 	bic.w	r1, r1, #7
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 80007ea:	1acb      	subs	r3, r1, r3
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80007ec:	f1c3 0378 	rsb	r3, r3, #120	; 0x78
 * - [3.1.10] Testing final conditions. The heap geometry must be the
 *   same than the one registered at beginning.
 * .
 */

static void oslib_test_003_001_setup(void) {
 80007f0:	b410      	push	{r4}
  heapp->provider = NULL;
 80007f2:	2000      	movs	r0, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80007f4:	f102 040c 	add.w	r4, r2, #12
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80007f8:	08db      	lsrs	r3, r3, #3
 80007fa:	604b      	str	r3, [r1, #4]
  H_NEXT(&heapp->header) = hp;
 80007fc:	6051      	str	r1, [r2, #4]
  H_NEXT(hp) = NULL;
 80007fe:	6008      	str	r0, [r1, #0]
  tqp->prev = (thread_t *)tqp;
 8000800:	e9c2 4403 	strd	r4, r4, [r2, #12]
  heapp->provider = NULL;
 8000804:	6010      	str	r0, [r2, #0]
  H_PAGES(&heapp->header) = 0;
 8000806:	6090      	str	r0, [r2, #8]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000808:	6150      	str	r0, [r2, #20]
  chHeapObjectInit(&test_heap, test_heap_buffer, sizeof(test_heap_buffer));
}
 800080a:	bc10      	pop	{r4}
 800080c:	4770      	bx	lr
 800080e:	bf00      	nop
 8000810:	20001ab8 	.word	0x20001ab8
 8000814:	20001a9c 	.word	0x20001a9c
	...

08000820 <oslib_test_002_003_setup>:
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8000820:	4b05      	ldr	r3, [pc, #20]	; (8000838 <oslib_test_002_003_setup+0x18>)
 8000822:	2200      	movs	r2, #0
  mp->object_size = size;
 8000824:	2104      	movs	r1, #4
 8000826:	e9c3 3300 	strd	r3, r3, [r3]
  mp->next = NULL;
 800082a:	60da      	str	r2, [r3, #12]
  mp->align = align;
  mp->provider = provider;
 800082c:	619a      	str	r2, [r3, #24]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 800082e:	609a      	str	r2, [r3, #8]
  mp->align = align;
 8000830:	e9c3 1104 	strd	r1, r1, [r3, #16]
 * .
 */

static void oslib_test_002_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}
 8000834:	4770      	bx	lr
 8000836:	bf00      	nop
 8000838:	20000c14 	.word	0x20000c14
 800083c:	00000000 	.word	0x00000000

08000840 <oslib_test_002_002_setup>:
 8000840:	f7ff bfee 	b.w	8000820 <oslib_test_002_003_setup>
	...

08000850 <null_provider>:
}
 8000850:	2000      	movs	r0, #0
 8000852:	4770      	bx	lr
	...

08000860 <oslib_test_001_003_setup>:
 *   active state.
 * - [1.3.4] Testing chMBFetchTimeout() and chMBFetchI() timeout.
 * .
 */

static void oslib_test_001_003_setup(void) {
 8000860:	b430      	push	{r4, r5}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));

  mbp->buffer = buf;
 8000862:	4b0a      	ldr	r3, [pc, #40]	; (800088c <oslib_test_001_003_setup+0x2c>)
 8000864:	4a0a      	ldr	r2, [pc, #40]	; (8000890 <oslib_test_001_003_setup+0x30>)
 8000866:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8000868:	f102 0510 	add.w	r5, r2, #16
  tqp->next = (thread_t *)tqp;
 800086c:	f103 0418 	add.w	r4, r3, #24
  mbp->cnt    = (size_t)0;
 8000870:	2100      	movs	r1, #0
 8000872:	f103 0020 	add.w	r0, r3, #32
  mbp->top    = &buf[n];
 8000876:	605d      	str	r5, [r3, #4]
  tqp->prev = (thread_t *)tqp;
 8000878:	e9c3 4406 	strd	r4, r4, [r3, #24]
  mbp->wrptr  = buf;
 800087c:	e9c3 2202 	strd	r2, r2, [r3, #8]
 8000880:	e9c3 0008 	strd	r0, r0, [r3, #32]
  mbp->cnt    = (size_t)0;
 8000884:	6119      	str	r1, [r3, #16]
  mbp->reset  = false;
 8000886:	7519      	strb	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8000888:	bc30      	pop	{r4, r5}
 800088a:	4770      	bx	lr
 800088c:	20000c58 	.word	0x20000c58
 8000890:	200013c8 	.word	0x200013c8
	...

080008a0 <oslib_test_001_002_setup>:
 80008a0:	f7ff bfde 	b.w	8000860 <oslib_test_001_003_setup>
	...

080008b0 <oslib_test_001_001_setup>:
 80008b0:	f7ff bfd6 	b.w	8000860 <oslib_test_001_003_setup>
	...

080008c0 <tmo>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 80008c0:	4770      	bx	lr
 80008c2:	bf00      	nop
	...

080008d0 <rt_test_009_001_setup>:
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 80008d0:	4b0b      	ldr	r3, [pc, #44]	; (8000900 <rt_test_009_001_setup+0x30>)
  heapp->provider = NULL;
 80008d2:	4a0c      	ldr	r2, [pc, #48]	; (8000904 <rt_test_009_001_setup+0x34>)
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 80008d4:	1dd9      	adds	r1, r3, #7
 80008d6:	f021 0107 	bic.w	r1, r1, #7
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 80008da:	1acb      	subs	r3, r1, r3
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80008dc:	f5c3 63cc 	rsb	r3, r3, #1632	; 0x660
 *   freeing memory.
 * - [9.1.7] Getting heap info again for verification.
 * .
 */

static void rt_test_009_001_setup(void) {
 80008e0:	b410      	push	{r4}
  heapp->provider = NULL;
 80008e2:	2000      	movs	r0, #0
  tqp->next = (thread_t *)tqp;
 80008e4:	f102 040c 	add.w	r4, r2, #12
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80008e8:	08db      	lsrs	r3, r3, #3
 80008ea:	604b      	str	r3, [r1, #4]
  H_NEXT(&heapp->header) = hp;
 80008ec:	6051      	str	r1, [r2, #4]
  H_NEXT(hp) = NULL;
 80008ee:	6008      	str	r0, [r1, #0]
  tqp->prev = (thread_t *)tqp;
 80008f0:	e9c2 4403 	strd	r4, r4, [r2, #12]
  heapp->provider = NULL;
 80008f4:	6010      	str	r0, [r2, #0]
  H_PAGES(&heapp->header) = 0;
 80008f6:	6090      	str	r0, [r2, #8]
 80008f8:	6150      	str	r0, [r2, #20]
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}
 80008fa:	bc10      	pop	{r4}
 80008fc:	4770      	bx	lr
 80008fe:	bf00      	nop
 8000900:	20001428 	.word	0x20001428
 8000904:	200013ac 	.word	0x200013ac
	...

08000910 <rt_test_004_001_setup>:
 *   the state of the reference are tested.
 * .
 */

static void rt_test_004_001_setup(void) {
  tr1 = NULL;
 8000910:	4b01      	ldr	r3, [pc, #4]	; (8000918 <rt_test_004_001_setup+0x8>)
 8000912:	2200      	movs	r2, #0
 8000914:	601a      	str	r2, [r3, #0]
}
 8000916:	4770      	bx	lr
 8000918:	20001b68 	.word	0x20001b68
 800091c:	00000000 	.word	0x00000000

08000920 <_test_assert>:
  if (!condition)
 8000920:	b948      	cbnz	r0, 8000936 <_test_assert+0x16>
bool _test_assert(bool condition, const char *msg) {
 8000922:	b410      	push	{r4}
  test_global_fail     = true;
 8000924:	4a05      	ldr	r2, [pc, #20]	; (800093c <_test_assert+0x1c>)
  test_local_fail      = true;
 8000926:	4c06      	ldr	r4, [pc, #24]	; (8000940 <_test_assert+0x20>)
  test_failure_message = msg;
 8000928:	4b06      	ldr	r3, [pc, #24]	; (8000944 <_test_assert+0x24>)
  test_local_fail      = true;
 800092a:	2001      	movs	r0, #1
 800092c:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 800092e:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 8000930:	6019      	str	r1, [r3, #0]
}
 8000932:	bc10      	pop	{r4}
 8000934:	4770      	bx	lr
  return false;
 8000936:	2000      	movs	r0, #0
}
 8000938:	4770      	bx	lr
 800093a:	bf00      	nop
 800093c:	20001a98 	.word	0x20001a98
 8000940:	20001b38 	.word	0x20001b38
 8000944:	20001a94 	.word	0x20001a94
	...

08000950 <rt_test_002_004_execute>:

static void rt_test_002_004_execute(void) {

  /* [2.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 8000950:	4b04      	ldr	r3, [pc, #16]	; (8000964 <rt_test_002_004_execute+0x14>)
 8000952:	2101      	movs	r1, #1
 8000954:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000958:	6019      	str	r1, [r3, #0]
 800095a:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800095c:	6a53      	ldr	r3, [r2, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 800095e:	4299      	cmp	r1, r3
 8000960:	d0fc      	beq.n	800095c <rt_test_002_004_execute+0xc>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 8000962:	4770      	bx	lr
 8000964:	20001b3c 	.word	0x20001b3c
	...

08000970 <test_printn.part.0>:

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
 8000970:	b320      	cbz	r0, 80009bc <test_printn.part.0+0x4c>
void test_printn(uint32_t n) {
 8000972:	b570      	push	{r4, r5, r6, lr}
 8000974:	b084      	sub	sp, #16
    p = buf;
 8000976:	466d      	mov	r5, sp
 8000978:	462c      	mov	r4, r5
      *p++ = (n % 10) + '0', n /= 10;
 800097a:	4e11      	ldr	r6, [pc, #68]	; (80009c0 <test_printn.part.0+0x50>)
 800097c:	e000      	b.n	8000980 <test_printn.part.0+0x10>
    while (n)
 800097e:	4614      	mov	r4, r2
      *p++ = (n % 10) + '0', n /= 10;
 8000980:	fba6 2300 	umull	r2, r3, r6, r0
 8000984:	08db      	lsrs	r3, r3, #3
 8000986:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800098a:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 800098e:	f100 0130 	add.w	r1, r0, #48	; 0x30
 8000992:	4622      	mov	r2, r4
 8000994:	b2c9      	uxtb	r1, r1
 8000996:	f802 1b01 	strb.w	r1, [r2], #1
    while (n)
 800099a:	4618      	mov	r0, r3
 800099c:	2b00      	cmp	r3, #0
 800099e:	d1ee      	bne.n	800097e <test_printn.part.0+0xe>
    while (p > buf)
 80009a0:	42aa      	cmp	r2, r5
 80009a2:	d909      	bls.n	80009b8 <test_printn.part.0+0x48>
 80009a4:	4e07      	ldr	r6, [pc, #28]	; (80009c4 <test_printn.part.0+0x54>)
 80009a6:	e001      	b.n	80009ac <test_printn.part.0+0x3c>
 80009a8:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      streamPut(test_chp, *--p);
 80009ac:	6830      	ldr	r0, [r6, #0]
 80009ae:	6803      	ldr	r3, [r0, #0]
 80009b0:	68db      	ldr	r3, [r3, #12]
 80009b2:	4798      	blx	r3
    while (p > buf)
 80009b4:	42a5      	cmp	r5, r4
 80009b6:	d1f7      	bne.n	80009a8 <test_printn.part.0+0x38>
  }
}
 80009b8:	b004      	add	sp, #16
 80009ba:	bd70      	pop	{r4, r5, r6, pc}
 80009bc:	4770      	bx	lr
 80009be:	bf00      	nop
 80009c0:	cccccccd 	.word	0xcccccccd
 80009c4:	20001a90 	.word	0x20001a90
	...

080009d0 <test_printn>:
  if (!n)
 80009d0:	b928      	cbnz	r0, 80009de <test_printn+0xe>
    streamPut(test_chp, '0');
 80009d2:	4b04      	ldr	r3, [pc, #16]	; (80009e4 <test_printn+0x14>)
 80009d4:	6818      	ldr	r0, [r3, #0]
 80009d6:	6803      	ldr	r3, [r0, #0]
 80009d8:	2130      	movs	r1, #48	; 0x30
 80009da:	68db      	ldr	r3, [r3, #12]
 80009dc:	4718      	bx	r3
 80009de:	f7ff bfc7 	b.w	8000970 <test_printn.part.0>
 80009e2:	bf00      	nop
 80009e4:	20001a90 	.word	0x20001a90
	...

080009f0 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 80009f0:	b570      	push	{r4, r5, r6, lr}
  while (*msgp)
 80009f2:	7801      	ldrb	r1, [r0, #0]
 80009f4:	b189      	cbz	r1, 8000a1a <test_println+0x2a>
 80009f6:	4d0a      	ldr	r5, [pc, #40]	; (8000a20 <test_println+0x30>)
 80009f8:	4604      	mov	r4, r0
    streamPut(test_chp, *msgp++);
 80009fa:	6828      	ldr	r0, [r5, #0]
 80009fc:	6803      	ldr	r3, [r0, #0]
 80009fe:	68db      	ldr	r3, [r3, #12]
 8000a00:	4798      	blx	r3
  while (*msgp)
 8000a02:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8000a06:	2900      	cmp	r1, #0
 8000a08:	d1f7      	bne.n	80009fa <test_println+0xa>

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8000a0a:	6828      	ldr	r0, [r5, #0]
 8000a0c:	4905      	ldr	r1, [pc, #20]	; (8000a24 <test_println+0x34>)
 8000a0e:	6803      	ldr	r3, [r0, #0]
 8000a10:	2202      	movs	r2, #2
 8000a12:	685b      	ldr	r3, [r3, #4]
}
 8000a14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8000a18:	4718      	bx	r3
 8000a1a:	4d01      	ldr	r5, [pc, #4]	; (8000a20 <test_println+0x30>)
 8000a1c:	e7f5      	b.n	8000a0a <test_println+0x1a>
 8000a1e:	bf00      	nop
 8000a20:	20001a90 	.word	0x20001a90
 8000a24:	0800c488 	.word	0x0800c488
	...

08000a30 <test_print>:
  while (*msgp)
 8000a30:	7801      	ldrb	r1, [r0, #0]
 8000a32:	b159      	cbz	r1, 8000a4c <test_print+0x1c>
void test_print(const char *msgp) {
 8000a34:	b538      	push	{r3, r4, r5, lr}
 8000a36:	4d06      	ldr	r5, [pc, #24]	; (8000a50 <test_print+0x20>)
 8000a38:	4604      	mov	r4, r0
    streamPut(test_chp, *msgp++);
 8000a3a:	6828      	ldr	r0, [r5, #0]
 8000a3c:	6803      	ldr	r3, [r0, #0]
 8000a3e:	68db      	ldr	r3, [r3, #12]
 8000a40:	4798      	blx	r3
  while (*msgp)
 8000a42:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8000a46:	2900      	cmp	r1, #0
 8000a48:	d1f7      	bne.n	8000a3a <test_print+0xa>
}
 8000a4a:	bd38      	pop	{r3, r4, r5, pc}
 8000a4c:	4770      	bx	lr
 8000a4e:	bf00      	nop
 8000a50:	20001a90 	.word	0x20001a90
	...

08000a60 <_test_assert_sequence>:
bool _test_assert_sequence(char *expected, const char *msg) {
 8000a60:	b4f0      	push	{r4, r5, r6, r7}
  while (cp < test_tokp) {
 8000a62:	4e0d      	ldr	r6, [pc, #52]	; (8000a98 <_test_assert_sequence+0x38>)
  char *cp = test_tokens_buffer;
 8000a64:	4f0d      	ldr	r7, [pc, #52]	; (8000a9c <_test_assert_sequence+0x3c>)
  while (cp < test_tokp) {
 8000a66:	6835      	ldr	r5, [r6, #0]
 8000a68:	1e42      	subs	r2, r0, #1
  char *cp = test_tokens_buffer;
 8000a6a:	463b      	mov	r3, r7
 8000a6c:	e003      	b.n	8000a76 <_test_assert_sequence+0x16>
    if (*cp++ != *expected++)
 8000a6e:	f813 4b01 	ldrb.w	r4, [r3], #1
 8000a72:	4284      	cmp	r4, r0
 8000a74:	d107      	bne.n	8000a86 <_test_assert_sequence+0x26>
  while (cp < test_tokp) {
 8000a76:	429d      	cmp	r5, r3
 8000a78:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8000a7c:	d8f7      	bhi.n	8000a6e <_test_assert_sequence+0xe>
  if (*expected)
 8000a7e:	b910      	cbnz	r0, 8000a86 <_test_assert_sequence+0x26>
  test_tokp = test_tokens_buffer;
 8000a80:	6037      	str	r7, [r6, #0]
}
 8000a82:	bcf0      	pop	{r4, r5, r6, r7}
 8000a84:	4770      	bx	lr
  test_local_fail      = true;
 8000a86:	4c06      	ldr	r4, [pc, #24]	; (8000aa0 <_test_assert_sequence+0x40>)
  test_global_fail     = true;
 8000a88:	4a06      	ldr	r2, [pc, #24]	; (8000aa4 <_test_assert_sequence+0x44>)
  test_failure_message = msg;
 8000a8a:	4b07      	ldr	r3, [pc, #28]	; (8000aa8 <_test_assert_sequence+0x48>)
  test_local_fail      = true;
 8000a8c:	2001      	movs	r0, #1
 8000a8e:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 8000a90:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 8000a92:	6019      	str	r1, [r3, #0]
}
 8000a94:	bcf0      	pop	{r4, r5, r6, r7}
 8000a96:	4770      	bx	lr
 8000a98:	20001b50 	.word	0x20001b50
 8000a9c:	20001b40 	.word	0x20001b40
 8000aa0:	20001b38 	.word	0x20001b38
 8000aa4:	20001a98 	.word	0x20001a98
 8000aa8:	20001a94 	.word	0x20001a94
 8000aac:	00000000 	.word	0x00000000

08000ab0 <print_line>:
static void print_line(void) {
 8000ab0:	b570      	push	{r4, r5, r6, lr}
 8000ab2:	4d08      	ldr	r5, [pc, #32]	; (8000ad4 <print_line+0x24>)
 8000ab4:	244c      	movs	r4, #76	; 0x4c
    streamPut(test_chp, '-');
 8000ab6:	6828      	ldr	r0, [r5, #0]
 8000ab8:	6803      	ldr	r3, [r0, #0]
 8000aba:	212d      	movs	r1, #45	; 0x2d
 8000abc:	68db      	ldr	r3, [r3, #12]
 8000abe:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 8000ac0:	3c01      	subs	r4, #1
 8000ac2:	d1f8      	bne.n	8000ab6 <print_line+0x6>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8000ac4:	6828      	ldr	r0, [r5, #0]
 8000ac6:	4904      	ldr	r1, [pc, #16]	; (8000ad8 <print_line+0x28>)
 8000ac8:	6803      	ldr	r3, [r0, #0]
 8000aca:	2202      	movs	r2, #2
 8000acc:	685b      	ldr	r3, [r3, #4]
}
 8000ace:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8000ad2:	4718      	bx	r3
 8000ad4:	20001a90 	.word	0x20001a90
 8000ad8:	0800c488 	.word	0x0800c488
 8000adc:	00000000 	.word	0x00000000

08000ae0 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8000ae0:	2902      	cmp	r1, #2
 8000ae2:	d006      	beq.n	8000af2 <get_descriptor+0x12>
 8000ae4:	2903      	cmp	r1, #3
 8000ae6:	d006      	beq.n	8000af6 <get_descriptor+0x16>
 8000ae8:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 8000aea:	4806      	ldr	r0, [pc, #24]	; (8000b04 <get_descriptor+0x24>)
 8000aec:	bf18      	it	ne
 8000aee:	2000      	movne	r0, #0
 8000af0:	4770      	bx	lr
    return &vcom_configuration_descriptor;
 8000af2:	4805      	ldr	r0, [pc, #20]	; (8000b08 <get_descriptor+0x28>)
 8000af4:	4770      	bx	lr
    if (dindex < 4)
 8000af6:	2a03      	cmp	r2, #3
      return &vcom_strings[dindex];
 8000af8:	bf9a      	itte	ls
 8000afa:	4804      	ldrls	r0, [pc, #16]	; (8000b0c <get_descriptor+0x2c>)
 8000afc:	eb00 00c2 	addls.w	r0, r0, r2, lsl #3
  return NULL;
 8000b00:	2000      	movhi	r0, #0
}
 8000b02:	4770      	bx	lr
 8000b04:	0800e820 	.word	0x0800e820
 8000b08:	0800e7d4 	.word	0x0800e7d4
 8000b0c:	0800e8a8 	.word	0x0800e8a8

08000b10 <_port_irq_epilogue>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000b10:	2320      	movs	r3, #32
 8000b12:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000b16:	4b0f      	ldr	r3, [pc, #60]	; (8000b54 <_port_irq_epilogue+0x44>)
 8000b18:	685b      	ldr	r3, [r3, #4]
 8000b1a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8000b1e:	d102      	bne.n	8000b26 <_port_irq_epilogue+0x16>
 8000b20:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000b24:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000b26:	f3ef 8309 	mrs	r3, PSP
    ctxp->xpsr = (regarm_t)0x01000000;
 8000b2a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000b2e:	f843 2c04 	str.w	r2, [r3, #-4]
    ctxp--;
 8000b32:	f1a3 0220 	sub.w	r2, r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8000b36:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000b3a:	4a07      	ldr	r2, [pc, #28]	; (8000b58 <_port_irq_epilogue+0x48>)
 8000b3c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 8000b3e:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
 8000b40:	6889      	ldr	r1, [r1, #8]
 8000b42:	6892      	ldr	r2, [r2, #8]
 8000b44:	4291      	cmp	r1, r2
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000b46:	bf8c      	ite	hi
 8000b48:	4a04      	ldrhi	r2, [pc, #16]	; (8000b5c <_port_irq_epilogue+0x4c>)
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000b4a:	4a05      	ldrls	r2, [pc, #20]	; (8000b60 <_port_irq_epilogue+0x50>)
 8000b4c:	f843 2c08 	str.w	r2, [r3, #-8]
 8000b50:	4770      	bx	lr
 8000b52:	bf00      	nop
 8000b54:	e000ed00 	.word	0xe000ed00
 8000b58:	200011a0 	.word	0x200011a0
 8000b5c:	080002a5 	.word	0x080002a5
 8000b60:	080002b0 	.word	0x080002b0
	...

08000b70 <chTMStopMeasurementX>:
 8000b70:	4b0e      	ldr	r3, [pc, #56]	; (8000bac <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000b72:	4a0f      	ldr	r2, [pc, #60]	; (8000bb0 <chTMStopMeasurementX+0x40>)
 8000b74:	685b      	ldr	r3, [r3, #4]
  tmp->n++;
 8000b76:	68c1      	ldr	r1, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000b78:	b4f0      	push	{r4, r5, r6, r7}
  tmp->last = (now - tmp->last) - offset;
 8000b7a:	6884      	ldr	r4, [r0, #8]
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000b7c:	6fd6      	ldr	r6, [r2, #124]	; 0x7c
  if (tmp->last > tmp->worst) {
 8000b7e:	6842      	ldr	r2, [r0, #4]
  tmp->last = (now - tmp->last) - offset;
 8000b80:	1b1b      	subs	r3, r3, r4
  tmp->cumulative += (rttime_t)tmp->last;
 8000b82:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8000b86:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 8000b88:	18e6      	adds	r6, r4, r3
 8000b8a:	f145 0700 	adc.w	r7, r5, #0
  if (tmp->last > tmp->worst) {
 8000b8e:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8000b90:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8000b92:	bf88      	it	hi
 8000b94:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 8000b96:	3101      	adds	r1, #1
  if (tmp->last < tmp->best) {
 8000b98:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 8000b9a:	e9c0 6704 	strd	r6, r7, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8000b9e:	e9c0 3102 	strd	r3, r1, [r0, #8]
    tmp->best = tmp->last;
 8000ba2:	bf38      	it	cc
 8000ba4:	6003      	strcc	r3, [r0, #0]
}
 8000ba6:	bcf0      	pop	{r4, r5, r6, r7}
 8000ba8:	4770      	bx	lr
 8000baa:	bf00      	nop
 8000bac:	e0001000 	.word	0xe0001000
 8000bb0:	200011a0 	.word	0x200011a0
	...

08000bc0 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000bc0:	4b05      	ldr	r3, [pc, #20]	; (8000bd8 <chDbgCheckClassS+0x18>)
 8000bc2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000bc4:	b91a      	cbnz	r2, 8000bce <chDbgCheckClassS+0xe>
 8000bc6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000bc8:	2a00      	cmp	r2, #0
 8000bca:	dd00      	ble.n	8000bce <chDbgCheckClassS+0xe>
    chSysHalt("SV#11");
  }
}
 8000bcc:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
 8000bce:	b672      	cpsid	i
 8000bd0:	4a02      	ldr	r2, [pc, #8]	; (8000bdc <chDbgCheckClassS+0x1c>)
 8000bd2:	62da      	str	r2, [r3, #44]	; 0x2c
 8000bd4:	e7fe      	b.n	8000bd4 <chDbgCheckClassS+0x14>
 8000bd6:	bf00      	nop
 8000bd8:	200011a0 	.word	0x200011a0
 8000bdc:	0800c1cc 	.word	0x0800c1cc

08000be0 <chDbgCheckClassI>:
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000be0:	4b05      	ldr	r3, [pc, #20]	; (8000bf8 <chDbgCheckClassI+0x18>)
 8000be2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000be4:	2a00      	cmp	r2, #0
 8000be6:	db03      	blt.n	8000bf0 <chDbgCheckClassI+0x10>
 8000be8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000bea:	2a00      	cmp	r2, #0
 8000bec:	dd00      	ble.n	8000bf0 <chDbgCheckClassI+0x10>
}
 8000bee:	4770      	bx	lr
 8000bf0:	b672      	cpsid	i
 8000bf2:	4a02      	ldr	r2, [pc, #8]	; (8000bfc <chDbgCheckClassI+0x1c>)
 8000bf4:	62da      	str	r2, [r3, #44]	; 0x2c
 8000bf6:	e7fe      	b.n	8000bf6 <chDbgCheckClassI+0x16>
 8000bf8:	200011a0 	.word	0x200011a0
 8000bfc:	0800c1c4 	.word	0x0800c1c4

08000c00 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8000c00:	b508      	push	{r3, lr}
  struct pool_header *php = objp;

  chDbgCheckClassI();
 8000c02:	f7ff ffed 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8000c06:	b140      	cbz	r0, 8000c1a <chPoolFreeI+0x1a>
 8000c08:	b139      	cbz	r1, 8000c1a <chPoolFreeI+0x1a>

  chDbgAssert(((size_t)objp & MEM_ALIGN_MASK(mp->align)) == 0U,
 8000c0a:	6883      	ldr	r3, [r0, #8]
 8000c0c:	3b01      	subs	r3, #1
 8000c0e:	4219      	tst	r1, r3
 8000c10:	d108      	bne.n	8000c24 <chPoolFreeI+0x24>
              "unaligned object");

  php->next = mp->next;
 8000c12:	6803      	ldr	r3, [r0, #0]
 8000c14:	600b      	str	r3, [r1, #0]
  mp->next = php;
 8000c16:	6001      	str	r1, [r0, #0]
}
 8000c18:	bd08      	pop	{r3, pc}
 8000c1a:	b672      	cpsid	i
 8000c1c:	4b04      	ldr	r3, [pc, #16]	; (8000c30 <chPoolFreeI+0x30>)
 8000c1e:	4a05      	ldr	r2, [pc, #20]	; (8000c34 <chPoolFreeI+0x34>)
 8000c20:	62da      	str	r2, [r3, #44]	; 0x2c
 8000c22:	e7fe      	b.n	8000c22 <chPoolFreeI+0x22>
 8000c24:	b672      	cpsid	i
 8000c26:	4b02      	ldr	r3, [pc, #8]	; (8000c30 <chPoolFreeI+0x30>)
 8000c28:	4a02      	ldr	r2, [pc, #8]	; (8000c34 <chPoolFreeI+0x34>)
 8000c2a:	62da      	str	r2, [r3, #44]	; 0x2c
 8000c2c:	e7fe      	b.n	8000c2c <chPoolFreeI+0x2c>
 8000c2e:	bf00      	nop
 8000c30:	200011a0 	.word	0x200011a0
 8000c34:	0800be10 	.word	0x0800be10
	...

08000c40 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 8000c40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000c42:	4614      	mov	r4, r2
  uint8_t *p, *next;

  chDbgCheckClassI();
 8000c44:	f7ff ffcc 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8000c48:	b111      	cbz	r1, 8000c50 <chCoreAllocAlignedWithOffsetI+0x10>
 8000c4a:	1e4d      	subs	r5, r1, #1
 8000c4c:	400d      	ands	r5, r1
 8000c4e:	d004      	beq.n	8000c5a <chCoreAllocAlignedWithOffsetI+0x1a>
 8000c50:	b672      	cpsid	i
 8000c52:	4b0c      	ldr	r3, [pc, #48]	; (8000c84 <chCoreAllocAlignedWithOffsetI+0x44>)
 8000c54:	4a0c      	ldr	r2, [pc, #48]	; (8000c88 <chCoreAllocAlignedWithOffsetI+0x48>)
 8000c56:	62da      	str	r2, [r3, #44]	; 0x2c
 8000c58:	e7fe      	b.n	8000c58 <chCoreAllocAlignedWithOffsetI+0x18>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8000c5a:	4e0c      	ldr	r6, [pc, #48]	; (8000c8c <chCoreAllocAlignedWithOffsetI+0x4c>)
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8000c5c:	e9d6 7200 	ldrd	r7, r2, [r6]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8000c60:	443c      	add	r4, r7
  size = MEM_ALIGN_NEXT(size, align);
 8000c62:	1e43      	subs	r3, r0, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8000c64:	1860      	adds	r0, r4, r1
  size = MEM_ALIGN_NEXT(size, align);
 8000c66:	440b      	add	r3, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8000c68:	3801      	subs	r0, #1
  size = MEM_ALIGN_NEXT(size, align);
 8000c6a:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8000c6c:	4008      	ands	r0, r1
  size = MEM_ALIGN_NEXT(size, align);
 8000c6e:	400b      	ands	r3, r1
  next = p + size;
 8000c70:	4403      	add	r3, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8000c72:	429a      	cmp	r2, r3
 8000c74:	d303      	bcc.n	8000c7e <chCoreAllocAlignedWithOffsetI+0x3e>
 8000c76:	429f      	cmp	r7, r3
 8000c78:	d801      	bhi.n	8000c7e <chCoreAllocAlignedWithOffsetI+0x3e>
    return NULL;
  }

  ch_memcore.nextmem = next;
 8000c7a:	6033      	str	r3, [r6, #0]

  return p;
}
 8000c7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 8000c7e:	4628      	mov	r0, r5
}
 8000c80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c82:	bf00      	nop
 8000c84:	200011a0 	.word	0x200011a0
 8000c88:	0800bdb4 	.word	0x0800bdb4
 8000c8c:	20001340 	.word	0x20001340

08000c90 <chCoreAllocAlignedI>:
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8000c90:	2200      	movs	r2, #0
 8000c92:	f7ff bfd5 	b.w	8000c40 <chCoreAllocAlignedWithOffsetI>
 8000c96:	bf00      	nop
	...

08000ca0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8000ca0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *tp;

  chDbgCheckClassI();
 8000ca2:	f7ff ff9d 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8000ca6:	6842      	ldr	r2, [r0, #4]
 8000ca8:	0753      	lsls	r3, r2, #29
 8000caa:	d142      	bne.n	8000d32 <chThdCreateSuspendedI+0x92>
 8000cac:	6883      	ldr	r3, [r0, #8]
 8000cae:	f013 0407 	ands.w	r4, r3, #7
 8000cb2:	d13e      	bne.n	8000d32 <chThdCreateSuspendedI+0x92>
 8000cb4:	429a      	cmp	r2, r3
 8000cb6:	d23c      	bcs.n	8000d32 <chThdCreateSuspendedI+0x92>
 8000cb8:	1a99      	subs	r1, r3, r2
 8000cba:	29c7      	cmp	r1, #199	; 0xc7
 8000cbc:	d939      	bls.n	8000d32 <chThdCreateSuspendedI+0x92>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8000cbe:	68c5      	ldr	r5, [r0, #12]
 8000cc0:	2dff      	cmp	r5, #255	; 0xff
 8000cc2:	d83b      	bhi.n	8000d3c <chThdCreateSuspendedI+0x9c>
 8000cc4:	6906      	ldr	r6, [r0, #16]
 8000cc6:	2e00      	cmp	r6, #0
 8000cc8:	d038      	beq.n	8000d3c <chThdCreateSuspendedI+0x9c>
  REG_INSERT(tp);
 8000cca:	491f      	ldr	r1, [pc, #124]	; (8000d48 <chThdCreateSuspendedI+0xa8>)
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000ccc:	f843 2c2c 	str.w	r2, [r3, #-44]
  tp->state     = CH_STATE_WTSTART;
 8000cd0:	f04f 0c02 	mov.w	ip, #2
  tp->refs      = (trefs_t)1;
 8000cd4:	2701      	movs	r7, #1

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000cd6:	6802      	ldr	r2, [r0, #0]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000cd8:	f843 6c6c 	str.w	r6, [r3, #-108]
 8000cdc:	6946      	ldr	r6, [r0, #20]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000cde:	f803 4c27 	strb.w	r4, [r3, #-39]
  tp->refs      = (trefs_t)1;
 8000ce2:	f803 7c26 	strb.w	r7, [r3, #-38]
  tp->state     = CH_STATE_WTSTART;
 8000ce6:	f803 cc28 	strb.w	ip, [r3, #-40]
  REG_INSERT(tp);
 8000cea:	f843 1c38 	str.w	r1, [r3, #-56]
 8000cee:	6948      	ldr	r0, [r1, #20]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000cf0:	f843 6c68 	str.w	r6, [r3, #-104]
  tp->name      = name;
 8000cf4:	f843 2c30 	str.w	r2, [r3, #-48]
  tp->prio      = prio;
 8000cf8:	f843 5c40 	str.w	r5, [r3, #-64]
  tp->realprio  = prio;
 8000cfc:	f843 5c0c 	str.w	r5, [r3, #-12]
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8000d00:	f1a3 0248 	sub.w	r2, r3, #72	; 0x48
  tp->epending  = (eventmask_t)0;
 8000d04:	e943 4405 	strd	r4, r4, [r3, #-20]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000d08:	f1a3 076c 	sub.w	r7, r3, #108	; 0x6c
  queue_init(&tp->msgqueue);
 8000d0c:	f1a3 041c 	sub.w	r4, r3, #28
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000d10:	4e0e      	ldr	r6, [pc, #56]	; (8000d4c <chThdCreateSuspendedI+0xac>)
  REG_INSERT(tp);
 8000d12:	f843 0c34 	str.w	r0, [r3, #-52]
  list_init(&tp->waiting);
 8000d16:	f1a3 0520 	sub.w	r5, r3, #32
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000d1a:	f843 7c3c 	str.w	r7, [r3, #-60]
 8000d1e:	f843 6c4c 	str.w	r6, [r3, #-76]
  REG_INSERT(tp);
 8000d22:	6102      	str	r2, [r0, #16]
 8000d24:	614a      	str	r2, [r1, #20]
}
 8000d26:	4610      	mov	r0, r2
  tqp->next = (thread_t *)tqp;
 8000d28:	e943 5408 	strd	r5, r4, [r3, #-32]
  tqp->prev = (thread_t *)tqp;
 8000d2c:	f843 4c18 	str.w	r4, [r3, #-24]
 8000d30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000d32:	b672      	cpsid	i
 8000d34:	4b04      	ldr	r3, [pc, #16]	; (8000d48 <chThdCreateSuspendedI+0xa8>)
 8000d36:	4a06      	ldr	r2, [pc, #24]	; (8000d50 <chThdCreateSuspendedI+0xb0>)
 8000d38:	62da      	str	r2, [r3, #44]	; 0x2c
 8000d3a:	e7fe      	b.n	8000d3a <chThdCreateSuspendedI+0x9a>
 8000d3c:	b672      	cpsid	i
 8000d3e:	4b02      	ldr	r3, [pc, #8]	; (8000d48 <chThdCreateSuspendedI+0xa8>)
 8000d40:	4a03      	ldr	r2, [pc, #12]	; (8000d50 <chThdCreateSuspendedI+0xb0>)
 8000d42:	62da      	str	r2, [r3, #44]	; 0x2c
 8000d44:	e7fe      	b.n	8000d44 <chThdCreateSuspendedI+0xa4>
 8000d46:	bf00      	nop
 8000d48:	200011a0 	.word	0x200011a0
 8000d4c:	08000291 	.word	0x08000291
 8000d50:	0800bd54 	.word	0x0800bd54
	...

08000d60 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 8000d60:	b508      	push	{r3, lr}
  chDbgCheckClassI();
 8000d62:	f7ff ff3d 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000d66:	b1d0      	cbz	r0, 8000d9e <chSchReadyI+0x3e>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8000d68:	f890 3020 	ldrb.w	r3, [r0, #32]
 8000d6c:	4601      	mov	r1, r0
 8000d6e:	b18b      	cbz	r3, 8000d94 <chSchReadyI+0x34>
 8000d70:	2b0f      	cmp	r3, #15
 8000d72:	d00f      	beq.n	8000d94 <chSchReadyI+0x34>
  tp->state = CH_STATE_READY;
 8000d74:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 8000d76:	4b0c      	ldr	r3, [pc, #48]	; (8000da8 <chSchReadyI+0x48>)
  } while (cp->prio >= tp->prio);
 8000d78:	6880      	ldr	r0, [r0, #8]
  tp->state = CH_STATE_READY;
 8000d7a:	f881 2020 	strb.w	r2, [r1, #32]
    cp = cp->queue.next;
 8000d7e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000d80:	689a      	ldr	r2, [r3, #8]
 8000d82:	4282      	cmp	r2, r0
 8000d84:	d2fb      	bcs.n	8000d7e <chSchReadyI+0x1e>
  tp->queue.prev             = cp->queue.prev;
 8000d86:	685a      	ldr	r2, [r3, #4]
}
 8000d88:	4608      	mov	r0, r1
  tp->queue.prev             = cp->queue.prev;
 8000d8a:	e9c1 3200 	strd	r3, r2, [r1]
  tp->queue.prev->queue.next = tp;
 8000d8e:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8000d90:	6059      	str	r1, [r3, #4]
}
 8000d92:	bd08      	pop	{r3, pc}
 8000d94:	b672      	cpsid	i
 8000d96:	4b04      	ldr	r3, [pc, #16]	; (8000da8 <chSchReadyI+0x48>)
 8000d98:	4a04      	ldr	r2, [pc, #16]	; (8000dac <chSchReadyI+0x4c>)
 8000d9a:	62da      	str	r2, [r3, #44]	; 0x2c
 8000d9c:	e7fe      	b.n	8000d9c <chSchReadyI+0x3c>
 8000d9e:	b672      	cpsid	i
 8000da0:	4b01      	ldr	r3, [pc, #4]	; (8000da8 <chSchReadyI+0x48>)
 8000da2:	4a02      	ldr	r2, [pc, #8]	; (8000dac <chSchReadyI+0x4c>)
 8000da4:	62da      	str	r2, [r3, #44]	; 0x2c
 8000da6:	e7fe      	b.n	8000da6 <chSchReadyI+0x46>
 8000da8:	200011a0 	.word	0x200011a0
 8000dac:	0800bd48 	.word	0x0800bd48

08000db0 <chThdDequeueNextI.constprop.87>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000db0:	6803      	ldr	r3, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000db2:	4298      	cmp	r0, r3
 8000db4:	d00b      	beq.n	8000dce <chThdDequeueNextI.constprop.87+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000db6:	681a      	ldr	r2, [r3, #0]
 8000db8:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000dba:	6050      	str	r0, [r2, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8000dbc:	f893 2020 	ldrb.w	r2, [r3, #32]
 8000dc0:	2a04      	cmp	r2, #4
 8000dc2:	d005      	beq.n	8000dd0 <chThdDequeueNextI.constprop.87+0x20>
 8000dc4:	b672      	cpsid	i
 8000dc6:	4b05      	ldr	r3, [pc, #20]	; (8000ddc <chThdDequeueNextI.constprop.87+0x2c>)
 8000dc8:	4a05      	ldr	r2, [pc, #20]	; (8000de0 <chThdDequeueNextI.constprop.87+0x30>)
 8000dca:	62da      	str	r2, [r3, #44]	; 0x2c
 8000dcc:	e7fe      	b.n	8000dcc <chThdDequeueNextI.constprop.87+0x1c>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000dce:	4770      	bx	lr

  tp->u.rdymsg = msg;
 8000dd0:	2200      	movs	r2, #0
 8000dd2:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000dd4:	4618      	mov	r0, r3
 8000dd6:	f7ff bfc3 	b.w	8000d60 <chSchReadyI>
 8000dda:	bf00      	nop
 8000ddc:	200011a0 	.word	0x200011a0
 8000de0:	0800bce0 	.word	0x0800bce0
	...

08000df0 <chMBFetchI.constprop.19>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8000df0:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8000df2:	4911      	ldr	r1, [pc, #68]	; (8000e38 <chMBFetchI.constprop.19+0x48>)
  chDbgCheckClassI();
 8000df4:	f7ff fef4 	bl	8000be0 <chDbgCheckClassI>
  if (mbp->reset) {
 8000df8:	7d0b      	ldrb	r3, [r1, #20]
 8000dfa:	b9b3      	cbnz	r3, 8000e2a <chMBFetchI.constprop.19+0x3a>
 *
 * @iclass
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();
 8000dfc:	f7ff fef0 	bl	8000be0 <chDbgCheckClassI>

  return mbp->cnt;
 8000e00:	690a      	ldr	r2, [r1, #16]
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8000e02:	b1aa      	cbz	r2, 8000e30 <chMBFetchI.constprop.19+0x40>
    *msgp = *mbp->rdptr++;
 8000e04:	68cb      	ldr	r3, [r1, #12]
    if (mbp->rdptr >= mbp->top) {
 8000e06:	684c      	ldr	r4, [r1, #4]
    *msgp = *mbp->rdptr++;
 8000e08:	681d      	ldr	r5, [r3, #0]
 8000e0a:	3304      	adds	r3, #4
    if (mbp->rdptr >= mbp->top) {
 8000e0c:	42a3      	cmp	r3, r4
    *msgp = *mbp->rdptr++;
 8000e0e:	60cb      	str	r3, [r1, #12]
      mbp->rdptr = mbp->buffer;
    }
    mbp->cnt--;
 8000e10:	f102 32ff 	add.w	r2, r2, #4294967295
    *msgp = *mbp->rdptr++;
 8000e14:	6005      	str	r5, [r0, #0]
      mbp->rdptr = mbp->buffer;
 8000e16:	bf28      	it	cs
 8000e18:	680b      	ldrcs	r3, [r1, #0]

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8000e1a:	4808      	ldr	r0, [pc, #32]	; (8000e3c <chMBFetchI.constprop.19+0x4c>)
      mbp->rdptr = mbp->buffer;
 8000e1c:	bf28      	it	cs
 8000e1e:	60cb      	strcs	r3, [r1, #12]
    mbp->cnt--;
 8000e20:	610a      	str	r2, [r1, #16]
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8000e22:	f7ff ffc5 	bl	8000db0 <chThdDequeueNextI.constprop.87>

    return MSG_OK;
 8000e26:	2000      	movs	r0, #0
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
}
 8000e28:	bd38      	pop	{r3, r4, r5, pc}
    return MSG_RESET;
 8000e2a:	f06f 0001 	mvn.w	r0, #1
}
 8000e2e:	bd38      	pop	{r3, r4, r5, pc}
  return MSG_TIMEOUT;
 8000e30:	f04f 30ff 	mov.w	r0, #4294967295
}
 8000e34:	bd38      	pop	{r3, r4, r5, pc}
 8000e36:	bf00      	nop
 8000e38:	20000c58 	.word	0x20000c58
 8000e3c:	20000c70 	.word	0x20000c70

08000e40 <chThdDequeueAllI.constprop.89>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8000e40:	b538      	push	{r3, r4, r5, lr}
 8000e42:	4604      	mov	r4, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000e44:	6800      	ldr	r0, [r0, #0]

  while (queue_notempty(tqp)) {
 8000e46:	4284      	cmp	r4, r0
 8000e48:	d00b      	beq.n	8000e62 <chThdDequeueAllI.constprop.89+0x22>
  tqp->next             = tp->queue.next;
 8000e4a:	6802      	ldr	r2, [r0, #0]
 8000e4c:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000e4e:	6054      	str	r4, [r2, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8000e50:	f890 2020 	ldrb.w	r2, [r0, #32]
 8000e54:	2a04      	cmp	r2, #4
 8000e56:	d005      	beq.n	8000e64 <chThdDequeueAllI.constprop.89+0x24>
 8000e58:	b672      	cpsid	i
 8000e5a:	4b0a      	ldr	r3, [pc, #40]	; (8000e84 <chThdDequeueAllI.constprop.89+0x44>)
 8000e5c:	4a0a      	ldr	r2, [pc, #40]	; (8000e88 <chThdDequeueAllI.constprop.89+0x48>)
 8000e5e:	62da      	str	r2, [r3, #44]	; 0x2c
 8000e60:	e7fe      	b.n	8000e60 <chThdDequeueAllI.constprop.89+0x20>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000e62:	bd38      	pop	{r3, r4, r5, pc}
  tp->u.rdymsg = msg;
 8000e64:	f06f 0501 	mvn.w	r5, #1
 8000e68:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000e6a:	f7ff ff79 	bl	8000d60 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000e6e:	6820      	ldr	r0, [r4, #0]
  while (queue_notempty(tqp)) {
 8000e70:	4284      	cmp	r4, r0
 8000e72:	d0f6      	beq.n	8000e62 <chThdDequeueAllI.constprop.89+0x22>
  tqp->next             = tp->queue.next;
 8000e74:	6803      	ldr	r3, [r0, #0]
 8000e76:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000e78:	605c      	str	r4, [r3, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8000e7a:	f890 3020 	ldrb.w	r3, [r0, #32]
 8000e7e:	2b04      	cmp	r3, #4
 8000e80:	d1ea      	bne.n	8000e58 <chThdDequeueAllI.constprop.89+0x18>
 8000e82:	e7f1      	b.n	8000e68 <chThdDequeueAllI.constprop.89+0x28>
 8000e84:	200011a0 	.word	0x200011a0
 8000e88:	0800bce0 	.word	0x0800bce0
 8000e8c:	00000000 	.word	0x00000000

08000e90 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8000e90:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 8000e92:	f7ff fea5 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000e96:	b1b0      	cbz	r0, 8000ec6 <chEvtSignalI+0x36>

  tp->epending |= events;
 8000e98:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000e9a:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
 8000e9e:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000ea0:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 8000ea2:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000ea4:	d006      	beq.n	8000eb4 <chEvtSignalI+0x24>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000ea6:	2a0b      	cmp	r2, #11
 8000ea8:	d103      	bne.n	8000eb2 <chEvtSignalI+0x22>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8000eaa:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000eac:	ea32 0303 	bics.w	r3, r2, r3
 8000eb0:	d003      	beq.n	8000eba <chEvtSignalI+0x2a>
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 8000eb2:	bd08      	pop	{r3, pc}
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000eb4:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000eb6:	4213      	tst	r3, r2
 8000eb8:	d0fb      	beq.n	8000eb2 <chEvtSignalI+0x22>
    tp->u.rdymsg = MSG_OK;
 8000eba:	2300      	movs	r3, #0
 8000ebc:	6243      	str	r3, [r0, #36]	; 0x24
}
 8000ebe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void) chSchReadyI(tp);
 8000ec2:	f7ff bf4d 	b.w	8000d60 <chSchReadyI>
 8000ec6:	b672      	cpsid	i
 8000ec8:	4b01      	ldr	r3, [pc, #4]	; (8000ed0 <chEvtSignalI+0x40>)
 8000eca:	4a02      	ldr	r2, [pc, #8]	; (8000ed4 <chEvtSignalI+0x44>)
 8000ecc:	62da      	str	r2, [r3, #44]	; 0x2c
 8000ece:	e7fe      	b.n	8000ece <chEvtSignalI+0x3e>
 8000ed0:	200011a0 	.word	0x200011a0
 8000ed4:	0800bf18 	.word	0x0800bf18
	...

08000ee0 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000ee0:	b570      	push	{r4, r5, r6, lr}
  chDbgCheckClassI();
 8000ee2:	f7ff fe7d 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8000ee6:	b198      	cbz	r0, 8000f10 <chEvtBroadcastFlagsI+0x30>
  elp = esp->next;
 8000ee8:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 8000eea:	42a0      	cmp	r0, r4
 8000eec:	4605      	mov	r5, r0
 8000eee:	460e      	mov	r6, r1
 8000ef0:	d00d      	beq.n	8000f0e <chEvtBroadcastFlagsI+0x2e>
    elp->flags |= flags;
 8000ef2:	68e3      	ldr	r3, [r4, #12]
 8000ef4:	4333      	orrs	r3, r6
 8000ef6:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8000ef8:	b116      	cbz	r6, 8000f00 <chEvtBroadcastFlagsI+0x20>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8000efa:	6922      	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8000efc:	4213      	tst	r3, r2
 8000efe:	d003      	beq.n	8000f08 <chEvtBroadcastFlagsI+0x28>
      chEvtSignalI(elp->listener, elp->events);
 8000f00:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8000f04:	f7ff ffc4 	bl	8000e90 <chEvtSignalI>
    elp = elp->next;
 8000f08:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8000f0a:	42a5      	cmp	r5, r4
 8000f0c:	d1f1      	bne.n	8000ef2 <chEvtBroadcastFlagsI+0x12>
}
 8000f0e:	bd70      	pop	{r4, r5, r6, pc}
 8000f10:	b672      	cpsid	i
 8000f12:	4b02      	ldr	r3, [pc, #8]	; (8000f1c <chEvtBroadcastFlagsI+0x3c>)
 8000f14:	4a02      	ldr	r2, [pc, #8]	; (8000f20 <chEvtBroadcastFlagsI+0x40>)
 8000f16:	62da      	str	r2, [r3, #44]	; 0x2c
 8000f18:	e7fe      	b.n	8000f18 <chEvtBroadcastFlagsI+0x38>
 8000f1a:	bf00      	nop
 8000f1c:	200011a0 	.word	0x200011a0
 8000f20:	0800be3c 	.word	0x0800be3c
	...

08000f30 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8000f30:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
  mutex_t *lmp;

  chDbgCheckClassS();
 8000f32:	f7ff fe45 	bl	8000bc0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8000f36:	b190      	cbz	r0, 8000f5e <chMtxUnlockS+0x2e>
  thread_t *ctp = currp;
 8000f38:	4b20      	ldr	r3, [pc, #128]	; (8000fbc <chMtxUnlockS+0x8c>)
 8000f3a:	699d      	ldr	r5, [r3, #24]

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8000f3c:	6bae      	ldr	r6, [r5, #56]	; 0x38
 8000f3e:	2e00      	cmp	r6, #0
 8000f40:	d037      	beq.n	8000fb2 <chMtxUnlockS+0x82>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8000f42:	68b2      	ldr	r2, [r6, #8]
 8000f44:	42aa      	cmp	r2, r5
 8000f46:	d003      	beq.n	8000f50 <chMtxUnlockS+0x20>
 8000f48:	b672      	cpsid	i
 8000f4a:	4a1d      	ldr	r2, [pc, #116]	; (8000fc0 <chMtxUnlockS+0x90>)
 8000f4c:	62da      	str	r2, [r3, #44]	; 0x2c
 8000f4e:	e7fe      	b.n	8000f4e <chMtxUnlockS+0x1e>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8000f50:	4286      	cmp	r6, r0
 8000f52:	4601      	mov	r1, r0
 8000f54:	d008      	beq.n	8000f68 <chMtxUnlockS+0x38>
 8000f56:	b672      	cpsid	i
 8000f58:	4a19      	ldr	r2, [pc, #100]	; (8000fc0 <chMtxUnlockS+0x90>)
 8000f5a:	62da      	str	r2, [r3, #44]	; 0x2c
 8000f5c:	e7fe      	b.n	8000f5c <chMtxUnlockS+0x2c>
 8000f5e:	b672      	cpsid	i
 8000f60:	4b16      	ldr	r3, [pc, #88]	; (8000fbc <chMtxUnlockS+0x8c>)
 8000f62:	4a17      	ldr	r2, [pc, #92]	; (8000fc0 <chMtxUnlockS+0x90>)
 8000f64:	62da      	str	r2, [r3, #44]	; 0x2c
 8000f66:	e7fe      	b.n	8000f66 <chMtxUnlockS+0x36>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8000f68:	68c0      	ldr	r0, [r0, #12]
 8000f6a:	63a8      	str	r0, [r5, #56]	; 0x38
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8000f6c:	f7ff fe28 	bl	8000bc0 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000f70:	680c      	ldr	r4, [r1, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000f72:	42a1      	cmp	r1, r4
 8000f74:	d01a      	beq.n	8000fac <chMtxUnlockS+0x7c>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8000f76:	6bee      	ldr	r6, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000f78:	b158      	cbz	r0, 8000f92 <chMtxUnlockS+0x62>
 8000f7a:	f7ff fe21 	bl	8000bc0 <chDbgCheckClassS>
 8000f7e:	6803      	ldr	r3, [r0, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000f80:	4298      	cmp	r0, r3
 8000f82:	d003      	beq.n	8000f8c <chMtxUnlockS+0x5c>
 8000f84:	689b      	ldr	r3, [r3, #8]
 8000f86:	429e      	cmp	r6, r3
 8000f88:	bf38      	it	cc
 8000f8a:	461e      	movcc	r6, r3
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8000f8c:	68c0      	ldr	r0, [r0, #12]
      while (lmp != NULL) {
 8000f8e:	2800      	cmp	r0, #0
 8000f90:	d1f3      	bne.n	8000f7a <chMtxUnlockS+0x4a>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8000f92:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  tqp->next             = tp->queue.next;
 8000f94:	6823      	ldr	r3, [r4, #0]
      ctp->prio = newprio;
 8000f96:	60ae      	str	r6, [r5, #8]
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 8000f98:	4620      	mov	r0, r4
 8000f9a:	600b      	str	r3, [r1, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000f9c:	6059      	str	r1, [r3, #4]
      mp->next = tp->mtxlist;
 8000f9e:	e9c1 4202 	strd	r4, r2, [r1, #8]
      tp->mtxlist = mp;
 8000fa2:	63a1      	str	r1, [r4, #56]	; 0x38
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8000fa4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      (void) chSchReadyI(tp);
 8000fa8:	f7ff beda 	b.w	8000d60 <chSchReadyI>
      mp->owner = NULL;
 8000fac:	2300      	movs	r3, #0
 8000fae:	60b3      	str	r3, [r6, #8]
}
 8000fb0:	bd70      	pop	{r4, r5, r6, pc}
 8000fb2:	b672      	cpsid	i
 8000fb4:	4a02      	ldr	r2, [pc, #8]	; (8000fc0 <chMtxUnlockS+0x90>)
 8000fb6:	62da      	str	r2, [r3, #44]	; 0x2c
 8000fb8:	e7fe      	b.n	8000fb8 <chMtxUnlockS+0x88>
 8000fba:	bf00      	nop
 8000fbc:	200011a0 	.word	0x200011a0
 8000fc0:	0800bebc 	.word	0x0800bebc
	...

08000fd0 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8000fd0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 8000fd2:	f7ff fe05 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
 8000fd6:	b188      	cbz	r0, 8000ffc <chSemSignalI+0x2c>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8000fd8:	6882      	ldr	r2, [r0, #8]
 8000fda:	6803      	ldr	r3, [r0, #0]
 8000fdc:	2a00      	cmp	r2, #0
 8000fde:	db06      	blt.n	8000fee <chSemSignalI+0x1e>
 8000fe0:	4283      	cmp	r3, r0
 8000fe2:	d006      	beq.n	8000ff2 <chSemSignalI+0x22>
 8000fe4:	b672      	cpsid	i
 8000fe6:	4b0d      	ldr	r3, [pc, #52]	; (800101c <chSemSignalI+0x4c>)
 8000fe8:	4a0d      	ldr	r2, [pc, #52]	; (8001020 <chSemSignalI+0x50>)
 8000fea:	62da      	str	r2, [r3, #44]	; 0x2c
 8000fec:	e7fe      	b.n	8000fec <chSemSignalI+0x1c>
 8000fee:	4283      	cmp	r3, r0
 8000ff0:	d0f8      	beq.n	8000fe4 <chSemSignalI+0x14>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8000ff2:	3201      	adds	r2, #1
 8000ff4:	2a00      	cmp	r2, #0
 8000ff6:	6082      	str	r2, [r0, #8]
 8000ff8:	dd05      	ble.n	8001006 <chSemSignalI+0x36>
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 8000ffa:	bd08      	pop	{r3, pc}
 8000ffc:	b672      	cpsid	i
 8000ffe:	4b07      	ldr	r3, [pc, #28]	; (800101c <chSemSignalI+0x4c>)
 8001000:	4a07      	ldr	r2, [pc, #28]	; (8001020 <chSemSignalI+0x50>)
 8001002:	62da      	str	r2, [r3, #44]	; 0x2c
 8001004:	e7fe      	b.n	8001004 <chSemSignalI+0x34>
  tqp->next             = tp->queue.next;
 8001006:	681a      	ldr	r2, [r3, #0]
 8001008:	6002      	str	r2, [r0, #0]
    tp->u.rdymsg = MSG_OK;
 800100a:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 800100c:	6050      	str	r0, [r2, #4]
    (void) chSchReadyI(tp);
 800100e:	4618      	mov	r0, r3
    tp->u.rdymsg = MSG_OK;
 8001010:	6259      	str	r1, [r3, #36]	; 0x24
}
 8001012:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void) chSchReadyI(tp);
 8001016:	f7ff bea3 	b.w	8000d60 <chSchReadyI>
 800101a:	bf00      	nop
 800101c:	200011a0 	.word	0x200011a0
 8001020:	0800beac 	.word	0x0800beac
	...

08001030 <_dbg_check_leave_isr>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001030:	2320      	movs	r3, #32
 8001032:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001036:	4b07      	ldr	r3, [pc, #28]	; (8001054 <_dbg_check_leave_isr+0x24>)
 8001038:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800103a:	2a00      	cmp	r2, #0
 800103c:	dd01      	ble.n	8001042 <_dbg_check_leave_isr+0x12>
 800103e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001040:	b119      	cbz	r1, 800104a <_dbg_check_leave_isr+0x1a>
  __ASM volatile ("cpsid i" : : : "memory");
 8001042:	b672      	cpsid	i
 8001044:	4a04      	ldr	r2, [pc, #16]	; (8001058 <_dbg_check_leave_isr+0x28>)
 8001046:	62da      	str	r2, [r3, #44]	; 0x2c
 8001048:	e7fe      	b.n	8001048 <_dbg_check_leave_isr+0x18>
  ch.dbg.isr_cnt--;
 800104a:	3a01      	subs	r2, #1
 800104c:	631a      	str	r2, [r3, #48]	; 0x30
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800104e:	f381 8811 	msr	BASEPRI, r1
}
 8001052:	4770      	bx	lr
 8001054:	200011a0 	.word	0x200011a0
 8001058:	0800c17c 	.word	0x0800c17c
 800105c:	00000000 	.word	0x00000000

08001060 <_dbg_check_enter_isr>:
 8001060:	2320      	movs	r3, #32
 8001062:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001066:	4b07      	ldr	r3, [pc, #28]	; (8001084 <_dbg_check_enter_isr+0x24>)
 8001068:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800106a:	2a00      	cmp	r2, #0
 800106c:	db01      	blt.n	8001072 <_dbg_check_enter_isr+0x12>
 800106e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001070:	b119      	cbz	r1, 800107a <_dbg_check_enter_isr+0x1a>
  __ASM volatile ("cpsid i" : : : "memory");
 8001072:	b672      	cpsid	i
 8001074:	4a04      	ldr	r2, [pc, #16]	; (8001088 <_dbg_check_enter_isr+0x28>)
 8001076:	62da      	str	r2, [r3, #44]	; 0x2c
 8001078:	e7fe      	b.n	8001078 <_dbg_check_enter_isr+0x18>
  ch.dbg.isr_cnt++;
 800107a:	3201      	adds	r2, #1
 800107c:	631a      	str	r2, [r3, #48]	; 0x30
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800107e:	f381 8811 	msr	BASEPRI, r1
}
 8001082:	4770      	bx	lr
 8001084:	200011a0 	.word	0x200011a0
 8001088:	0800c174 	.word	0x0800c174
 800108c:	00000000 	.word	0x00000000

08001090 <_dbg_check_unlock_from_isr>:
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001090:	4b06      	ldr	r3, [pc, #24]	; (80010ac <_dbg_check_unlock_from_isr+0x1c>)
 8001092:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001094:	2a00      	cmp	r2, #0
 8001096:	dd05      	ble.n	80010a4 <_dbg_check_unlock_from_isr+0x14>
 8001098:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800109a:	2a00      	cmp	r2, #0
 800109c:	dd02      	ble.n	80010a4 <_dbg_check_unlock_from_isr+0x14>
  _dbg_leave_lock();
 800109e:	2200      	movs	r2, #0
 80010a0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80010a2:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
 80010a4:	b672      	cpsid	i
 80010a6:	4a02      	ldr	r2, [pc, #8]	; (80010b0 <_dbg_check_unlock_from_isr+0x20>)
 80010a8:	62da      	str	r2, [r3, #44]	; 0x2c
 80010aa:	e7fe      	b.n	80010aa <_dbg_check_unlock_from_isr+0x1a>
 80010ac:	200011a0 	.word	0x200011a0
 80010b0:	0800c1a4 	.word	0x0800c1a4
	...

080010c0 <_dbg_check_lock_from_isr>:
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80010c0:	4b06      	ldr	r3, [pc, #24]	; (80010dc <_dbg_check_lock_from_isr+0x1c>)
 80010c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80010c4:	2a00      	cmp	r2, #0
 80010c6:	dd01      	ble.n	80010cc <_dbg_check_lock_from_isr+0xc>
 80010c8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80010ca:	b11a      	cbz	r2, 80010d4 <_dbg_check_lock_from_isr+0x14>
 80010cc:	b672      	cpsid	i
 80010ce:	4a04      	ldr	r2, [pc, #16]	; (80010e0 <_dbg_check_lock_from_isr+0x20>)
 80010d0:	62da      	str	r2, [r3, #44]	; 0x2c
 80010d2:	e7fe      	b.n	80010d2 <_dbg_check_lock_from_isr+0x12>
  _dbg_enter_lock();
 80010d4:	2201      	movs	r2, #1
 80010d6:	635a      	str	r2, [r3, #52]	; 0x34
}
 80010d8:	4770      	bx	lr
 80010da:	bf00      	nop
 80010dc:	200011a0 	.word	0x200011a0
 80010e0:	0800c18c 	.word	0x0800c18c
	...

080010f0 <wakeup>:
static void wakeup(void *p) {
 80010f0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80010f2:	2320      	movs	r3, #32
 80010f4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80010f8:	f7ff ffe2 	bl	80010c0 <_dbg_check_lock_from_isr>
  switch (tp->state) {
 80010fc:	f890 3020 	ldrb.w	r3, [r0, #32]
 8001100:	2b07      	cmp	r3, #7
 8001102:	d810      	bhi.n	8001126 <wakeup+0x36>
 8001104:	e8df f003 	tbb	[pc, r3]
 8001108:	1a0f0f14 	.word	0x1a0f0f14
 800110c:	0a0f040a 	.word	0x0a0f040a
    chSemFastSignalI(tp->u.wtsemp);
 8001110:	6a41      	ldr	r1, [r0, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 8001112:	f7ff fd65 	bl	8000be0 <chDbgCheckClassI>

  sp->cnt++;
 8001116:	688b      	ldr	r3, [r1, #8]
 8001118:	3301      	adds	r3, #1
 800111a:	608b      	str	r3, [r1, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800111c:	e9d0 2300 	ldrd	r2, r3, [r0]
 8001120:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001122:	6802      	ldr	r2, [r0, #0]
 8001124:	6053      	str	r3, [r2, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 8001126:	f04f 33ff 	mov.w	r3, #4294967295
 800112a:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800112c:	f7ff fe18 	bl	8000d60 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001130:	f7ff ffae 	bl	8001090 <_dbg_check_unlock_from_isr>
 8001134:	2300      	movs	r3, #0
 8001136:	f383 8811 	msr	BASEPRI, r3
}
 800113a:	bd08      	pop	{r3, pc}
    *tp->u.wttrp = NULL;
 800113c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800113e:	2200      	movs	r2, #0
 8001140:	601a      	str	r2, [r3, #0]
  tp->u.rdymsg = MSG_TIMEOUT;
 8001142:	f04f 33ff 	mov.w	r3, #4294967295
 8001146:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001148:	f7ff fe0a 	bl	8000d60 <chSchReadyI>
 800114c:	e7f0      	b.n	8001130 <wakeup+0x40>
 800114e:	bf00      	nop

08001150 <_dbg_check_enable>:
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001150:	4b04      	ldr	r3, [pc, #16]	; (8001164 <_dbg_check_enable+0x14>)
 8001152:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001154:	b90a      	cbnz	r2, 800115a <_dbg_check_enable+0xa>
 8001156:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001158:	b11a      	cbz	r2, 8001162 <_dbg_check_enable+0x12>
  __ASM volatile ("cpsid i" : : : "memory");
 800115a:	b672      	cpsid	i
 800115c:	4a02      	ldr	r2, [pc, #8]	; (8001168 <_dbg_check_enable+0x18>)
 800115e:	62da      	str	r2, [r3, #44]	; 0x2c
 8001160:	e7fe      	b.n	8001160 <_dbg_check_enable+0x10>
}
 8001162:	4770      	bx	lr
 8001164:	200011a0 	.word	0x200011a0
 8001168:	0800c16c 	.word	0x0800c16c
 800116c:	00000000 	.word	0x00000000

08001170 <_dbg_check_suspend>:
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001170:	4b04      	ldr	r3, [pc, #16]	; (8001184 <_dbg_check_suspend+0x14>)
 8001172:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001174:	b90a      	cbnz	r2, 800117a <_dbg_check_suspend+0xa>
 8001176:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001178:	b11a      	cbz	r2, 8001182 <_dbg_check_suspend+0x12>
 800117a:	b672      	cpsid	i
 800117c:	4a02      	ldr	r2, [pc, #8]	; (8001188 <_dbg_check_suspend+0x18>)
 800117e:	62da      	str	r2, [r3, #44]	; 0x2c
 8001180:	e7fe      	b.n	8001180 <_dbg_check_suspend+0x10>
}
 8001182:	4770      	bx	lr
 8001184:	200011a0 	.word	0x200011a0
 8001188:	0800c194 	.word	0x0800c194
 800118c:	00000000 	.word	0x00000000

08001190 <rt_test_002_003_execute>:
static void rt_test_002_003_execute(void) {
 8001190:	b508      	push	{r3, lr}
  test_set_step(1);
 8001192:	4b0f      	ldr	r3, [pc, #60]	; (80011d0 <rt_test_002_003_execute+0x40>)
 8001194:	2201      	movs	r2, #1
 8001196:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001198:	2020      	movs	r0, #32
 800119a:	f380 8811 	msr	BASEPRI, r0
  __ASM volatile ("cpsie i" : : : "memory");
 800119e:	b662      	cpsie	i
  _dbg_check_suspend();
 80011a0:	f7ff ffe6 	bl	8001170 <_dbg_check_suspend>
  __ASM volatile ("cpsid i" : : : "memory");
 80011a4:	b672      	cpsid	i
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80011a6:	4b0b      	ldr	r3, [pc, #44]	; (80011d4 <rt_test_002_003_execute+0x44>)
 80011a8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80011aa:	b90a      	cbnz	r2, 80011b0 <rt_test_002_003_execute+0x20>
 80011ac:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80011ae:	b119      	cbz	r1, 80011b8 <rt_test_002_003_execute+0x28>
 80011b0:	b672      	cpsid	i
 80011b2:	4a09      	ldr	r2, [pc, #36]	; (80011d8 <rt_test_002_003_execute+0x48>)
 80011b4:	62da      	str	r2, [r3, #44]	; 0x2c
 80011b6:	e7fe      	b.n	80011b6 <rt_test_002_003_execute+0x26>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80011b8:	f380 8811 	msr	BASEPRI, r0
  __ASM volatile ("cpsie i" : : : "memory");
 80011bc:	b662      	cpsie	i
 80011be:	f7ff ffd7 	bl	8001170 <_dbg_check_suspend>
  _dbg_check_enable();
 80011c2:	f7ff ffc5 	bl	8001150 <_dbg_check_enable>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80011c6:	f381 8811 	msr	BASEPRI, r1
  __ASM volatile ("cpsie i" : : : "memory");
 80011ca:	b662      	cpsie	i
}
 80011cc:	bd08      	pop	{r3, pc}
 80011ce:	bf00      	nop
 80011d0:	20001b3c 	.word	0x20001b3c
 80011d4:	200011a0 	.word	0x200011a0
 80011d8:	0800d47c 	.word	0x0800d47c
 80011dc:	00000000 	.word	0x00000000

080011e0 <chSysPolledDelayX>:
 80011e0:	4a03      	ldr	r2, [pc, #12]	; (80011f0 <chSysPolledDelayX+0x10>)
 80011e2:	6851      	ldr	r1, [r2, #4]
 80011e4:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 80011e6:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80011e8:	4298      	cmp	r0, r3
 80011ea:	d8fb      	bhi.n	80011e4 <chSysPolledDelayX+0x4>
  }
}
 80011ec:	4770      	bx	lr
 80011ee:	bf00      	nop
 80011f0:	e0001000 	.word	0xe0001000
	...

08001200 <chSysIntegrityCheckI>:
bool chSysIntegrityCheckI(unsigned testmask) {
 8001200:	b510      	push	{r4, lr}
  chDbgCheckClassI();
 8001202:	f7ff fced 	bl	8000be0 <chDbgCheckClassI>
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001206:	07c2      	lsls	r2, r0, #31
 8001208:	d512      	bpl.n	8001230 <chSysIntegrityCheckI+0x30>
    tp = ch.rlist.queue.next;
 800120a:	4b28      	ldr	r3, [pc, #160]	; (80012ac <chSysIntegrityCheckI+0xac>)
 800120c:	e9d3 1400 	ldrd	r1, r4, [r3]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001210:	4299      	cmp	r1, r3
 8001212:	d03f      	beq.n	8001294 <chSysIntegrityCheckI+0x94>
    n = (cnt_t)0;
 8001214:	2200      	movs	r2, #0
      tp = tp->queue.next;
 8001216:	6809      	ldr	r1, [r1, #0]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001218:	4299      	cmp	r1, r3
      n++;
 800121a:	f102 0201 	add.w	r2, r2, #1
    while (tp != (thread_t *)&ch.rlist.queue) {
 800121e:	d1fa      	bne.n	8001216 <chSysIntegrityCheckI+0x16>
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001220:	428c      	cmp	r4, r1
 8001222:	d035      	beq.n	8001290 <chSysIntegrityCheckI+0x90>
      tp = tp->queue.prev;
 8001224:	6864      	ldr	r4, [r4, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001226:	429c      	cmp	r4, r3
      n--;
 8001228:	f102 32ff 	add.w	r2, r2, #4294967295
    while (tp != (thread_t *)&ch.rlist.queue) {
 800122c:	d1fa      	bne.n	8001224 <chSysIntegrityCheckI+0x24>
    if (n != (cnt_t)0) {
 800122e:	bb7a      	cbnz	r2, 8001290 <chSysIntegrityCheckI+0x90>
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8001230:	0783      	lsls	r3, r0, #30
 8001232:	d513      	bpl.n	800125c <chSysIntegrityCheckI+0x5c>
    vtp = ch.vtlist.next;
 8001234:	4c1d      	ldr	r4, [pc, #116]	; (80012ac <chSysIntegrityCheckI+0xac>)
 8001236:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800123a:	341c      	adds	r4, #28
 800123c:	42a2      	cmp	r2, r4
 800123e:	d02d      	beq.n	800129c <chSysIntegrityCheckI+0x9c>
    n = (cnt_t)0;
 8001240:	2300      	movs	r3, #0
      vtp = vtp->next;
 8001242:	6812      	ldr	r2, [r2, #0]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001244:	42a2      	cmp	r2, r4
      n++;
 8001246:	f103 0301 	add.w	r3, r3, #1
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800124a:	d1fa      	bne.n	8001242 <chSysIntegrityCheckI+0x42>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800124c:	4291      	cmp	r1, r2
 800124e:	d01f      	beq.n	8001290 <chSysIntegrityCheckI+0x90>
      vtp = vtp->prev;
 8001250:	6849      	ldr	r1, [r1, #4]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001252:	42a1      	cmp	r1, r4
      n--;
 8001254:	f103 33ff 	add.w	r3, r3, #4294967295
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001258:	d1fa      	bne.n	8001250 <chSysIntegrityCheckI+0x50>
    if (n != (cnt_t)0) {
 800125a:	b9cb      	cbnz	r3, 8001290 <chSysIntegrityCheckI+0x90>
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800125c:	f010 0004 	ands.w	r0, r0, #4
 8001260:	d015      	beq.n	800128e <chSysIntegrityCheckI+0x8e>
    tp = ch.rlist.newer;
 8001262:	4b12      	ldr	r3, [pc, #72]	; (80012ac <chSysIntegrityCheckI+0xac>)
 8001264:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8001268:	429a      	cmp	r2, r3
    n = (cnt_t)0;
 800126a:	f04f 0000 	mov.w	r0, #0
    while (tp != (thread_t *)&ch.rlist) {
 800126e:	d019      	beq.n	80012a4 <chSysIntegrityCheckI+0xa4>
      tp = tp->newer;
 8001270:	6912      	ldr	r2, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8001272:	429a      	cmp	r2, r3
      n++;
 8001274:	f100 0001 	add.w	r0, r0, #1
    while (tp != (thread_t *)&ch.rlist) {
 8001278:	d1fa      	bne.n	8001270 <chSysIntegrityCheckI+0x70>
    while (tp != (thread_t *)&ch.rlist) {
 800127a:	4291      	cmp	r1, r2
 800127c:	d008      	beq.n	8001290 <chSysIntegrityCheckI+0x90>
      tp = tp->older;
 800127e:	6949      	ldr	r1, [r1, #20]
    while (tp != (thread_t *)&ch.rlist) {
 8001280:	4299      	cmp	r1, r3
      n--;
 8001282:	f100 30ff 	add.w	r0, r0, #4294967295
    while (tp != (thread_t *)&ch.rlist) {
 8001286:	d1fa      	bne.n	800127e <chSysIntegrityCheckI+0x7e>
    if (n != (cnt_t)0) {
 8001288:	3000      	adds	r0, #0
 800128a:	bf18      	it	ne
 800128c:	2001      	movne	r0, #1
}
 800128e:	bd10      	pop	{r4, pc}
      return true;
 8001290:	2001      	movs	r0, #1
}
 8001292:	bd10      	pop	{r4, pc}
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001294:	429c      	cmp	r4, r3
 8001296:	d0cb      	beq.n	8001230 <chSysIntegrityCheckI+0x30>
    n = (cnt_t)0;
 8001298:	2200      	movs	r2, #0
 800129a:	e7c3      	b.n	8001224 <chSysIntegrityCheckI+0x24>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800129c:	42a1      	cmp	r1, r4
 800129e:	d0dd      	beq.n	800125c <chSysIntegrityCheckI+0x5c>
    n = (cnt_t)0;
 80012a0:	2300      	movs	r3, #0
 80012a2:	e7d5      	b.n	8001250 <chSysIntegrityCheckI+0x50>
    while (tp != (thread_t *)&ch.rlist) {
 80012a4:	4291      	cmp	r1, r2
 80012a6:	d1ea      	bne.n	800127e <chSysIntegrityCheckI+0x7e>
}
 80012a8:	bd10      	pop	{r4, pc}
 80012aa:	bf00      	nop
 80012ac:	200011a0 	.word	0x200011a0

080012b0 <_idle_thread>:
static void _idle_thread(void *p) {
 80012b0:	e7fe      	b.n	80012b0 <_idle_thread>
 80012b2:	bf00      	nop
	...

080012c0 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80012c0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 80012c4:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 80012c6:	68d8      	ldr	r0, [r3, #12]
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 80012c8:	b4f0      	push	{r4, r5, r6, r7}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80012ca:	6944      	ldr	r4, [r0, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 80012cc:	6823      	ldr	r3, [r4, #0]
 80012ce:	60e3      	str	r3, [r4, #12]
  if (isp->txsize == 0) {
 80012d0:	b9eb      	cbnz	r3, 800130e <usb_lld_start_in+0x4e>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 80012d2:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 80012d6:	f44f 2400 	mov.w	r4, #524288	; 0x80000
 80012da:	f8c3 4910 	str.w	r4, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80012de:	6803      	ldr	r3, [r0, #0]
 80012e0:	f003 0303 	and.w	r3, r3, #3
 80012e4:	2b01      	cmp	r3, #1
 80012e6:	d025      	beq.n	8001334 <usb_lld_start_in+0x74>
 80012e8:	b208      	sxth	r0, r1
 80012ea:	eb02 1040 	add.w	r0, r2, r0, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80012ee:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80012f0:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
 80012f4:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80012f8:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80012fc:	f8d2 0834 	ldr.w	r0, [r2, #2100]	; 0x834
 8001300:	fa03 f101 	lsl.w	r1, r3, r1
 8001304:	4301      	orrs	r1, r0
 8001306:	f8c2 1834 	str.w	r1, [r2, #2100]	; 0x834
}
 800130a:	bcf0      	pop	{r4, r5, r6, r7}
 800130c:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 800130e:	b311      	cbz	r1, 8001356 <usb_lld_start_in+0x96>
 8001310:	f043 5600 	orr.w	r6, r3, #536870912	; 0x20000000
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8001314:	8a07      	ldrh	r7, [r0, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8001316:	eb02 1541 	add.w	r5, r2, r1, lsl #5
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800131a:	1e7c      	subs	r4, r7, #1
 800131c:	4423      	add	r3, r4
 800131e:	fbb3 f3f7 	udiv	r3, r3, r7
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8001322:	ea46 43c3 	orr.w	r3, r6, r3, lsl #19
 8001326:	f8c5 3910 	str.w	r3, [r5, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800132a:	6803      	ldr	r3, [r0, #0]
 800132c:	f003 0303 	and.w	r3, r3, #3
 8001330:	2b01      	cmp	r3, #1
 8001332:	d1d9      	bne.n	80012e8 <usb_lld_start_in+0x28>
 8001334:	b208      	sxth	r0, r1
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8001336:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
 800133a:	eb02 1440 	add.w	r4, r2, r0, lsl #5
 800133e:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8001342:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
 8001346:	bf14      	ite	ne
 8001348:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 800134c:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 8001350:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
 8001354:	e7c9      	b.n	80012ea <usb_lld_start_in+0x2a>
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8001356:	2b40      	cmp	r3, #64	; 0x40
 8001358:	d9da      	bls.n	8001310 <usb_lld_start_in+0x50>
      isp->txsize = EP0_MAX_INSIZE;
 800135a:	2340      	movs	r3, #64	; 0x40
 800135c:	4e01      	ldr	r6, [pc, #4]	; (8001364 <usb_lld_start_in+0xa4>)
 800135e:	6023      	str	r3, [r4, #0]
 8001360:	e7d8      	b.n	8001314 <usb_lld_start_in+0x54>
 8001362:	bf00      	nop
 8001364:	20000040 	.word	0x20000040
	...

08001370 <otg_epin_handler.constprop.66>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8001370:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8001374:	4f23      	ldr	r7, [pc, #140]	; (8001404 <otg_epin_handler.constprop.66+0x94>)
 8001376:	6efe      	ldr	r6, [r7, #108]	; 0x6c
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8001378:	eb06 1340 	add.w	r3, r6, r0, lsl #5
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800137c:	4605      	mov	r5, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800137e:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908
  otgp->ie[ep].DIEPINT = epint;
 8001382:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8001386:	07e1      	lsls	r1, r4, #31
 8001388:	d503      	bpl.n	8001392 <otg_epin_handler.constprop.66+0x22>
 800138a:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 800138e:	07da      	lsls	r2, r3, #31
 8001390:	d409      	bmi.n	80013a6 <otg_epin_handler.constprop.66+0x36>
  if ((epint & DIEPINT_TXFE) &&
 8001392:	0623      	lsls	r3, r4, #24
 8001394:	d505      	bpl.n	80013a2 <otg_epin_handler.constprop.66+0x32>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8001396:	f8d6 2834 	ldr.w	r2, [r6, #2100]	; 0x834
 800139a:	2301      	movs	r3, #1
 800139c:	40ab      	lsls	r3, r5
  if ((epint & DIEPINT_TXFE) &&
 800139e:	4213      	tst	r3, r2
 80013a0:	d118      	bne.n	80013d4 <otg_epin_handler.constprop.66+0x64>
}
 80013a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80013a6:	eb07 0380 	add.w	r3, r7, r0, lsl #2
 80013aa:	68d9      	ldr	r1, [r3, #12]
 80013ac:	694b      	ldr	r3, [r1, #20]
    if (isp->txsize < isp->totsize) {
 80013ae:	6818      	ldr	r0, [r3, #0]
 80013b0:	68da      	ldr	r2, [r3, #12]
 80013b2:	4290      	cmp	r0, r2
 80013b4:	d313      	bcc.n	80013de <otg_epin_handler.constprop.66+0x6e>
      _usb_isr_invoke_in_cb(usbp, ep);
 80013b6:	893b      	ldrh	r3, [r7, #8]
 80013b8:	f8d1 8008 	ldr.w	r8, [r1, #8]
 80013bc:	2201      	movs	r2, #1
 80013be:	40aa      	lsls	r2, r5
 80013c0:	ea23 0302 	bic.w	r3, r3, r2
 80013c4:	813b      	strh	r3, [r7, #8]
 80013c6:	f1b8 0f00 	cmp.w	r8, #0
 80013ca:	d0e2      	beq.n	8001392 <otg_epin_handler.constprop.66+0x22>
 80013cc:	4638      	mov	r0, r7
 80013ce:	4629      	mov	r1, r5
 80013d0:	47c0      	blx	r8
 80013d2:	e7de      	b.n	8001392 <otg_epin_handler.constprop.66+0x22>
    otg_txfifo_handler(usbp, ep);
 80013d4:	4628      	mov	r0, r5
}
 80013d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    otg_txfifo_handler(usbp, ep);
 80013da:	f7ff b981 	b.w	80006e0 <otg_txfifo_handler.constprop.69>
      isp->txsize = isp->totsize - isp->txsize;
 80013de:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 80013e0:	f04f 0800 	mov.w	r8, #0
 80013e4:	e9c3 2800 	strd	r2, r8, [r3]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80013e8:	2320      	movs	r3, #32
 80013ea:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80013ee:	f7ff fe67 	bl	80010c0 <_dbg_check_lock_from_isr>
      usb_lld_start_in(usbp, ep);
 80013f2:	4629      	mov	r1, r5
 80013f4:	4638      	mov	r0, r7
 80013f6:	f7ff ff63 	bl	80012c0 <usb_lld_start_in>
  _dbg_check_unlock_from_isr();
 80013fa:	f7ff fe49 	bl	8001090 <_dbg_check_unlock_from_isr>
 80013fe:	f388 8811 	msr	BASEPRI, r8
 8001402:	e7c6      	b.n	8001392 <otg_epin_handler.constprop.66+0x22>
 8001404:	20001128 	.word	0x20001128
	...

08001410 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8001410:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8001414:	b430      	push	{r4, r5}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8001416:	68dd      	ldr	r5, [r3, #12]
 8001418:	69ab      	ldr	r3, [r5, #24]
  osp->totsize = osp->rxsize;
 800141a:	681c      	ldr	r4, [r3, #0]
 800141c:	60dc      	str	r4, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 800141e:	b919      	cbnz	r1, 8001428 <usb_lld_start_out+0x18>
 8001420:	2c40      	cmp	r4, #64	; 0x40
      osp->rxsize = EP0_MAX_OUTSIZE;
 8001422:	bf84      	itt	hi
 8001424:	2440      	movhi	r4, #64	; 0x40
 8001426:	601c      	strhi	r4, [r3, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8001428:	8a6b      	ldrh	r3, [r5, #18]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800142a:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800142c:	682d      	ldr	r5, [r5, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800142e:	1e5a      	subs	r2, r3, #1
 8001430:	4422      	add	r2, r4
 8001432:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8001436:	fb02 f303 	mul.w	r3, r2, r3
 800143a:	3303      	adds	r3, #3
 800143c:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8001440:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8001444:	eb00 1441 	add.w	r4, r0, r1, lsl #5
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8001448:	f005 0203 	and.w	r2, r5, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800144c:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8001450:	2a01      	cmp	r2, #1
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8001452:	f8c4 3b10 	str.w	r3, [r4, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8001456:	d00a      	beq.n	800146e <usb_lld_start_out+0x5e>
 8001458:	b209      	sxth	r1, r1
 800145a:	eb00 1141 	add.w	r1, r0, r1, lsl #5
}
 800145e:	bc30      	pop	{r4, r5}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8001460:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8001464:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8001468:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 800146c:	4770      	bx	lr
 800146e:	b209      	sxth	r1, r1
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8001470:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8001474:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8001478:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 800147c:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8001480:	bf14      	ite	ne
 8001482:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8001486:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 800148a:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 800148e:	e7e4      	b.n	800145a <usb_lld_start_out+0x4a>

08001490 <otg_epout_handler.constprop.67>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8001490:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8001494:	4e28      	ldr	r6, [pc, #160]	; (8001538 <otg_epout_handler.constprop.67+0xa8>)
 8001496:	6ef7      	ldr	r7, [r6, #108]	; 0x6c
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8001498:	eb07 1340 	add.w	r3, r7, r0, lsl #5
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800149c:	4605      	mov	r5, r0
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800149e:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08
  otgp->oe[ep].DOEPINT = epint;
 80014a2:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 80014a6:	0723      	lsls	r3, r4, #28
 80014a8:	d50a      	bpl.n	80014c0 <otg_epout_handler.constprop.67+0x30>
 80014aa:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 80014ae:	0718      	lsls	r0, r3, #28
 80014b0:	d506      	bpl.n	80014c0 <otg_epout_handler.constprop.67+0x30>
    _usb_isr_invoke_setup_cb(usbp, ep);
 80014b2:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 80014b6:	4629      	mov	r1, r5
 80014b8:	68db      	ldr	r3, [r3, #12]
 80014ba:	4630      	mov	r0, r6
 80014bc:	685b      	ldr	r3, [r3, #4]
 80014be:	4798      	blx	r3
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 80014c0:	07e1      	lsls	r1, r4, #31
 80014c2:	d527      	bpl.n	8001514 <otg_epout_handler.constprop.67+0x84>
 80014c4:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 80014c8:	07da      	lsls	r2, r3, #31
 80014ca:	d523      	bpl.n	8001514 <otg_epout_handler.constprop.67+0x84>
    osp = usbp->epc[ep]->out_state;
 80014cc:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 80014d0:	68d9      	ldr	r1, [r3, #12]
    if (ep == 0) {
 80014d2:	bb0d      	cbnz	r5, 8001518 <otg_epout_handler.constprop.67+0x88>
      if ((usbp->ep0state & USB_OUT_STATE) == 0)
 80014d4:	f896 304c 	ldrb.w	r3, [r6, #76]	; 0x4c
 80014d8:	06db      	lsls	r3, r3, #27
 80014da:	d51b      	bpl.n	8001514 <otg_epout_handler.constprop.67+0x84>
    osp = usbp->epc[ep]->out_state;
 80014dc:	698a      	ldr	r2, [r1, #24]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80014de:	8a48      	ldrh	r0, [r1, #18]
 80014e0:	6854      	ldr	r4, [r2, #4]
 80014e2:	fbb4 f3f0 	udiv	r3, r4, r0
 80014e6:	fb00 4313 	mls	r3, r0, r3, r4
 80014ea:	b9ab      	cbnz	r3, 8001518 <otg_epout_handler.constprop.67+0x88>
          (osp->rxsize < osp->totsize)) {
 80014ec:	6810      	ldr	r0, [r2, #0]
 80014ee:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80014f0:	4298      	cmp	r0, r3
 80014f2:	d211      	bcs.n	8001518 <otg_epout_handler.constprop.67+0x88>
        osp->rxsize = osp->totsize - osp->rxsize;
 80014f4:	1a1b      	subs	r3, r3, r0
        osp->rxcnt  = 0;
 80014f6:	e9c2 3500 	strd	r3, r5, [r2]
 80014fa:	2320      	movs	r3, #32
 80014fc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001500:	f7ff fdde 	bl	80010c0 <_dbg_check_lock_from_isr>
        usb_lld_start_out(usbp, ep);
 8001504:	4629      	mov	r1, r5
 8001506:	480c      	ldr	r0, [pc, #48]	; (8001538 <otg_epout_handler.constprop.67+0xa8>)
 8001508:	f7ff ff82 	bl	8001410 <usb_lld_start_out>
  _dbg_check_unlock_from_isr();
 800150c:	f7ff fdc0 	bl	8001090 <_dbg_check_unlock_from_isr>
 8001510:	f385 8811 	msr	BASEPRI, r5
}
 8001514:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_out_cb(usbp, ep);
 8001518:	8973      	ldrh	r3, [r6, #10]
 800151a:	68cc      	ldr	r4, [r1, #12]
 800151c:	2201      	movs	r2, #1
 800151e:	40aa      	lsls	r2, r5
 8001520:	ea23 0302 	bic.w	r3, r3, r2
 8001524:	8173      	strh	r3, [r6, #10]
 8001526:	2c00      	cmp	r4, #0
 8001528:	d0f4      	beq.n	8001514 <otg_epout_handler.constprop.67+0x84>
 800152a:	4629      	mov	r1, r5
 800152c:	4623      	mov	r3, r4
 800152e:	4802      	ldr	r0, [pc, #8]	; (8001538 <otg_epout_handler.constprop.67+0xa8>)
}
 8001530:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
 8001534:	4718      	bx	r3
 8001536:	bf00      	nop
 8001538:	20001128 	.word	0x20001128
 800153c:	00000000 	.word	0x00000000

08001540 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8001540:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001544:	4617      	mov	r7, r2
 8001546:	4698      	mov	r8, r3
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 8001548:	f7ff fb4a 	bl	8000be0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 800154c:	b108      	cbz	r0, 8001552 <usbStartTransmitI+0x12>
 800154e:	2905      	cmp	r1, #5
 8001550:	d904      	bls.n	800155c <usbStartTransmitI+0x1c>
  __ASM volatile ("cpsid i" : : : "memory");
 8001552:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 8001554:	4b0e      	ldr	r3, [pc, #56]	; (8001590 <usbStartTransmitI+0x50>)
 8001556:	4a0f      	ldr	r2, [pc, #60]	; (8001594 <usbStartTransmitI+0x54>)
 8001558:	62da      	str	r2, [r3, #44]	; 0x2c
 800155a:	e7fe      	b.n	800155a <usbStartTransmitI+0x1a>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 800155c:	2401      	movs	r4, #1
 800155e:	408c      	lsls	r4, r1
 8001560:	8905      	ldrh	r5, [r0, #8]
 8001562:	b2a4      	uxth	r4, r4
 8001564:	ea15 0604 	ands.w	r6, r5, r4
 8001568:	d10c      	bne.n	8001584 <usbStartTransmitI+0x44>
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 800156a:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800156e:	432c      	orrs	r4, r5
  isp = usbp->epc[ep]->in_state;
 8001570:	68db      	ldr	r3, [r3, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001572:	8104      	strh	r4, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8001574:	695c      	ldr	r4, [r3, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8001576:	60a7      	str	r7, [r4, #8]
  isp->txsize = n;
  isp->txcnt  = 0;
 8001578:	e9c4 8600 	strd	r8, r6, [r4]
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
}
 800157c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  usb_lld_start_in(usbp, ep);
 8001580:	f7ff be9e 	b.w	80012c0 <usb_lld_start_in>
 8001584:	b672      	cpsid	i
 8001586:	4b02      	ldr	r3, [pc, #8]	; (8001590 <usbStartTransmitI+0x50>)
 8001588:	4a02      	ldr	r2, [pc, #8]	; (8001594 <usbStartTransmitI+0x54>)
 800158a:	62da      	str	r2, [r3, #44]	; 0x2c
 800158c:	e7fe      	b.n	800158c <usbStartTransmitI+0x4c>
 800158e:	bf00      	nop
 8001590:	200011a0 	.word	0x200011a0
 8001594:	0800c11c 	.word	0x0800c11c
	...

080015a0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80015a0:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 80015a2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80015a6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 80015a8:	2b15      	cmp	r3, #21
 80015aa:	d846      	bhi.n	800163a <_usb_ep0out+0x9a>
 80015ac:	e8df f003 	tbb	[pc, r3]
 80015b0:	45454540 	.word	0x45454540
 80015b4:	452a4545 	.word	0x452a4545
 80015b8:	40404045 	.word	0x40404045
 80015bc:	45454545 	.word	0x45454545
 80015c0:	45454545 	.word	0x45454545
 80015c4:	0b1e      	.short	0x0b1e
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 80015c6:	230b      	movs	r3, #11
 80015c8:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80015cc:	2320      	movs	r3, #32
 80015ce:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80015d2:	f7ff fd75 	bl	80010c0 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 80015d6:	2300      	movs	r3, #0
 80015d8:	461a      	mov	r2, r3
 80015da:	4619      	mov	r1, r3
 80015dc:	f7ff ffb0 	bl	8001540 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 80015e0:	f7ff fd56 	bl	8001090 <_dbg_check_unlock_from_isr>
 80015e4:	2300      	movs	r3, #0
 80015e6:	f383 8811 	msr	BASEPRI, r3
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 80015ea:	bd38      	pop	{r3, r4, r5, pc}
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80015ec:	68c3      	ldr	r3, [r0, #12]
 80015ee:	699b      	ldr	r3, [r3, #24]
 80015f0:	685b      	ldr	r3, [r3, #4]
 80015f2:	2b00      	cmp	r3, #0
 80015f4:	d1f9      	bne.n	80015ea <_usb_ep0out+0x4a>
    if (usbp->ep0endcb != NULL) {
 80015f6:	6d83      	ldr	r3, [r0, #88]	; 0x58
 80015f8:	b103      	cbz	r3, 80015fc <_usb_ep0out+0x5c>
      usbp->ep0endcb(usbp);
 80015fa:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 80015fc:	2300      	movs	r3, #0
 80015fe:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 8001602:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001604:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001606:	6841      	ldr	r1, [r0, #4]
 8001608:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800160c:	680d      	ldr	r5, [r1, #0]
 800160e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001612:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001616:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800161a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800161e:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8001622:	b10d      	cbz	r5, 8001628 <_usb_ep0out+0x88>
 8001624:	2106      	movs	r1, #6
 8001626:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8001628:	2306      	movs	r3, #6
 800162a:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 800162e:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8001630:	b672      	cpsid	i
 8001632:	4b04      	ldr	r3, [pc, #16]	; (8001644 <_usb_ep0out+0xa4>)
 8001634:	4a04      	ldr	r2, [pc, #16]	; (8001648 <_usb_ep0out+0xa8>)
 8001636:	62da      	str	r2, [r3, #44]	; 0x2c
 8001638:	e7fe      	b.n	8001638 <_usb_ep0out+0x98>
 800163a:	b672      	cpsid	i
 800163c:	4b01      	ldr	r3, [pc, #4]	; (8001644 <_usb_ep0out+0xa4>)
 800163e:	4a02      	ldr	r2, [pc, #8]	; (8001648 <_usb_ep0out+0xa8>)
 8001640:	62da      	str	r2, [r3, #44]	; 0x2c
 8001642:	e7fe      	b.n	8001642 <_usb_ep0out+0xa2>
 8001644:	200011a0 	.word	0x200011a0
 8001648:	0800c160 	.word	0x0800c160
 800164c:	00000000 	.word	0x00000000

08001650 <usbStartReceiveI>:
                      uint8_t *buf, size_t n) {
 8001650:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001654:	4617      	mov	r7, r2
 8001656:	4698      	mov	r8, r3
  osalDbgCheckClassI();
 8001658:	f7ff fac2 	bl	8000be0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 800165c:	b108      	cbz	r0, 8001662 <usbStartReceiveI+0x12>
 800165e:	2905      	cmp	r1, #5
 8001660:	d904      	bls.n	800166c <usbStartReceiveI+0x1c>
 8001662:	b672      	cpsid	i
 8001664:	4b0e      	ldr	r3, [pc, #56]	; (80016a0 <usbStartReceiveI+0x50>)
 8001666:	4a0f      	ldr	r2, [pc, #60]	; (80016a4 <usbStartReceiveI+0x54>)
 8001668:	62da      	str	r2, [r3, #44]	; 0x2c
 800166a:	e7fe      	b.n	800166a <usbStartReceiveI+0x1a>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 800166c:	2401      	movs	r4, #1
 800166e:	408c      	lsls	r4, r1
 8001670:	8945      	ldrh	r5, [r0, #10]
 8001672:	b2a4      	uxth	r4, r4
 8001674:	ea15 0604 	ands.w	r6, r5, r4
 8001678:	d10c      	bne.n	8001694 <usbStartReceiveI+0x44>
  osp = usbp->epc[ep]->out_state;
 800167a:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800167e:	432c      	orrs	r4, r5
  osp = usbp->epc[ep]->out_state;
 8001680:	68db      	ldr	r3, [r3, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001682:	8144      	strh	r4, [r0, #10]
  osp = usbp->epc[ep]->out_state;
 8001684:	699c      	ldr	r4, [r3, #24]
  osp->rxbuf  = buf;
 8001686:	60a7      	str	r7, [r4, #8]
  osp->rxcnt  = 0;
 8001688:	e9c4 8600 	strd	r8, r6, [r4]
}
 800168c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  usb_lld_start_out(usbp, ep);
 8001690:	f7ff bebe 	b.w	8001410 <usb_lld_start_out>
 8001694:	b672      	cpsid	i
 8001696:	4b02      	ldr	r3, [pc, #8]	; (80016a0 <usbStartReceiveI+0x50>)
 8001698:	4a02      	ldr	r2, [pc, #8]	; (80016a4 <usbStartReceiveI+0x54>)
 800169a:	62da      	str	r2, [r3, #44]	; 0x2c
 800169c:	e7fe      	b.n	800169c <usbStartReceiveI+0x4c>
 800169e:	bf00      	nop
 80016a0:	200011a0 	.word	0x200011a0
 80016a4:	0800c0ec 	.word	0x0800c0ec
	...

080016b0 <_usb_ep0in>:
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80016b0:	b538      	push	{r3, r4, r5, lr}
  switch (usbp->ep0state) {
 80016b2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80016b6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 80016b8:	2b15      	cmp	r3, #21
 80016ba:	d84c      	bhi.n	8001756 <_usb_ep0in+0xa6>
 80016bc:	e8df f003 	tbb	[pc, r3]
 80016c0:	4b4b4b46 	.word	0x4b4b4b46
 80016c4:	4b304b4b 	.word	0x4b304b4b
 80016c8:	501c0b4b 	.word	0x501c0b4b
 80016cc:	4b4b4b4b 	.word	0x4b4b4b4b
 80016d0:	4b4b4b4b 	.word	0x4b4b4b4b
 80016d4:	4646      	.short	0x4646
  hw |= (uint16_t)*p << 8U;
 80016d6:	f890 1063 	ldrb.w	r1, [r0, #99]	; 0x63
 80016da:	f890 2062 	ldrb.w	r2, [r0, #98]	; 0x62
    if ((usbp->ep0n < max) &&
 80016de:	6d43      	ldr	r3, [r0, #84]	; 0x54
    max = (size_t)get_hword(&usbp->setup[6]);
 80016e0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    if ((usbp->ep0n < max) &&
 80016e4:	4293      	cmp	r3, r2
 80016e6:	d207      	bcs.n	80016f8 <_usb_ep0in+0x48>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80016e8:	68c2      	ldr	r2, [r0, #12]
 80016ea:	8a12      	ldrh	r2, [r2, #16]
 80016ec:	fbb3 f5f2 	udiv	r5, r3, r2
 80016f0:	fb02 3515 	mls	r5, r2, r5, r3
    if ((usbp->ep0n < max) &&
 80016f4:	2d00      	cmp	r5, #0
 80016f6:	d03a      	beq.n	800176e <_usb_ep0in+0xbe>
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 80016f8:	2314      	movs	r3, #20
 80016fa:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80016fe:	2320      	movs	r3, #32
 8001700:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001704:	f7ff fcdc 	bl	80010c0 <_dbg_check_lock_from_isr>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8001708:	2300      	movs	r3, #0
 800170a:	461a      	mov	r2, r3
 800170c:	4619      	mov	r1, r3
 800170e:	4620      	mov	r0, r4
 8001710:	f7ff ff9e 	bl	8001650 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
 8001714:	f7ff fcbc 	bl	8001090 <_dbg_check_unlock_from_isr>
 8001718:	2300      	movs	r3, #0
 800171a:	f383 8811 	msr	BASEPRI, r3
}
 800171e:	bd38      	pop	{r3, r4, r5, pc}
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001720:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001722:	6841      	ldr	r1, [r0, #4]
 8001724:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8001728:	680d      	ldr	r5, [r1, #0]
 800172a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800172e:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001732:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8001736:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800173a:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800173e:	b10d      	cbz	r5, 8001744 <_usb_ep0in+0x94>
 8001740:	2106      	movs	r1, #6
 8001742:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8001744:	2306      	movs	r3, #6
 8001746:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 800174a:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800174c:	b672      	cpsid	i
 800174e:	4b11      	ldr	r3, [pc, #68]	; (8001794 <_usb_ep0in+0xe4>)
 8001750:	4a11      	ldr	r2, [pc, #68]	; (8001798 <_usb_ep0in+0xe8>)
 8001752:	62da      	str	r2, [r3, #44]	; 0x2c
 8001754:	e7fe      	b.n	8001754 <_usb_ep0in+0xa4>
 8001756:	b672      	cpsid	i
 8001758:	4b0e      	ldr	r3, [pc, #56]	; (8001794 <_usb_ep0in+0xe4>)
 800175a:	4a0f      	ldr	r2, [pc, #60]	; (8001798 <_usb_ep0in+0xe8>)
 800175c:	62da      	str	r2, [r3, #44]	; 0x2c
 800175e:	e7fe      	b.n	800175e <_usb_ep0in+0xae>
    if (usbp->ep0endcb != NULL) {
 8001760:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8001762:	b103      	cbz	r3, 8001766 <_usb_ep0in+0xb6>
      usbp->ep0endcb(usbp);
 8001764:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 8001766:	2300      	movs	r3, #0
 8001768:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 800176c:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800176e:	2320      	movs	r3, #32
 8001770:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001774:	f7ff fca4 	bl	80010c0 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8001778:	462b      	mov	r3, r5
 800177a:	462a      	mov	r2, r5
 800177c:	4629      	mov	r1, r5
 800177e:	f7ff fedf 	bl	8001540 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8001782:	f7ff fc85 	bl	8001090 <_dbg_check_unlock_from_isr>
 8001786:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 800178a:	230a      	movs	r3, #10
 800178c:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 8001790:	bd38      	pop	{r3, r4, r5, pc}
 8001792:	bf00      	nop
 8001794:	200011a0 	.word	0x200011a0
 8001798:	0800c154 	.word	0x0800c154
 800179c:	00000000 	.word	0x00000000

080017a0 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 80017a0:	4770      	bx	lr
 80017a2:	bf00      	nop
	...

080017b0 <sduRequestsHook>:
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 80017b0:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 80017b4:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80017b8:	2b20      	cmp	r3, #32
 80017ba:	d001      	beq.n	80017c0 <sduRequestsHook+0x10>
      return false;
 80017bc:	2000      	movs	r0, #0
}
 80017be:	4770      	bx	lr
    switch (usbp->setup[1]) {
 80017c0:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 80017c4:	2b20      	cmp	r3, #32
 80017c6:	d3f9      	bcc.n	80017bc <sduRequestsHook+0xc>
 80017c8:	2b21      	cmp	r3, #33	; 0x21
 80017ca:	d807      	bhi.n	80017dc <sduRequestsHook+0x2c>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 80017cc:	4b07      	ldr	r3, [pc, #28]	; (80017ec <sduRequestsHook+0x3c>)
 80017ce:	6503      	str	r3, [r0, #80]	; 0x50
 80017d0:	2207      	movs	r2, #7
 80017d2:	2300      	movs	r3, #0
 80017d4:	e9c0 2315 	strd	r2, r3, [r0, #84]	; 0x54
      return true;
 80017d8:	2001      	movs	r0, #1
 80017da:	4770      	bx	lr
    switch (usbp->setup[1]) {
 80017dc:	2b22      	cmp	r3, #34	; 0x22
 80017de:	d1ed      	bne.n	80017bc <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80017e0:	2300      	movs	r3, #0
 80017e2:	e9c0 3314 	strd	r3, r3, [r0, #80]	; 0x50
 80017e6:	6583      	str	r3, [r0, #88]	; 0x58
      return true;
 80017e8:	2001      	movs	r0, #1
 80017ea:	4770      	bx	lr
 80017ec:	20000c30 	.word	0x20000c30

080017f0 <_ctl>:
  osalDbgCheck(sdup != NULL);
 80017f0:	b178      	cbz	r0, 8001812 <_ctl+0x22>
  switch (operation) {
 80017f2:	b149      	cbz	r1, 8001808 <_ctl+0x18>
 80017f4:	2901      	cmp	r1, #1
 80017f6:	d105      	bne.n	8001804 <_ctl+0x14>
    osalDbgCheck(arg == NULL);
 80017f8:	b122      	cbz	r2, 8001804 <_ctl+0x14>
  __ASM volatile ("cpsid i" : : : "memory");
 80017fa:	b672      	cpsid	i
 80017fc:	4b07      	ldr	r3, [pc, #28]	; (800181c <_ctl+0x2c>)
 80017fe:	4a08      	ldr	r2, [pc, #32]	; (8001820 <_ctl+0x30>)
 8001800:	62da      	str	r2, [r3, #44]	; 0x2c
 8001802:	e7fe      	b.n	8001802 <_ctl+0x12>
}
 8001804:	2000      	movs	r0, #0
 8001806:	4770      	bx	lr
 8001808:	b672      	cpsid	i
 800180a:	4b04      	ldr	r3, [pc, #16]	; (800181c <_ctl+0x2c>)
 800180c:	4a04      	ldr	r2, [pc, #16]	; (8001820 <_ctl+0x30>)
 800180e:	62da      	str	r2, [r3, #44]	; 0x2c
 8001810:	e7fe      	b.n	8001810 <_ctl+0x20>
 8001812:	b672      	cpsid	i
 8001814:	4b01      	ldr	r3, [pc, #4]	; (800181c <_ctl+0x2c>)
 8001816:	4a02      	ldr	r2, [pc, #8]	; (8001820 <_ctl+0x30>)
 8001818:	62da      	str	r2, [r3, #44]	; 0x2c
 800181a:	e7fe      	b.n	800181a <_ctl+0x2a>
 800181c:	200011a0 	.word	0x200011a0
 8001820:	0800bff8 	.word	0x0800bff8
	...

08001830 <sdu_start_receive>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8001830:	b570      	push	{r4, r5, r6, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001832:	f8d0 548c 	ldr.w	r5, [r0, #1164]	; 0x48c
 8001836:	682e      	ldr	r6, [r5, #0]
 8001838:	7833      	ldrb	r3, [r6, #0]
 800183a:	2b04      	cmp	r3, #4
 800183c:	d001      	beq.n	8001842 <sdu_start_receive+0x12>
    return true;
 800183e:	2001      	movs	r0, #1
}
 8001840:	bd70      	pop	{r4, r5, r6, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001842:	7a03      	ldrb	r3, [r0, #8]
 8001844:	2b02      	cmp	r3, #2
 8001846:	d1fa      	bne.n	800183e <sdu_start_receive+0xe>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8001848:	792b      	ldrb	r3, [r5, #4]
 800184a:	8972      	ldrh	r2, [r6, #10]
 800184c:	2401      	movs	r4, #1
 800184e:	fa04 f303 	lsl.w	r3, r4, r3
 8001852:	4213      	tst	r3, r2
 8001854:	d1f3      	bne.n	800183e <sdu_start_receive+0xe>
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();
 8001856:	f7ff f9c3 	bl	8000be0 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 800185a:	e9d0 2307 	ldrd	r2, r3, [r0, #28]
 800185e:	429a      	cmp	r2, r3
 8001860:	d009      	beq.n	8001876 <sdu_start_receive+0x46>
  if (buf == NULL) {
 8001862:	3204      	adds	r2, #4
 8001864:	d0eb      	beq.n	800183e <sdu_start_receive+0xe>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8001866:	4630      	mov	r0, r6
 8001868:	7969      	ldrb	r1, [r5, #5]
 800186a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800186e:	f7ff feef 	bl	8001650 <usbStartReceiveI>
  return false;
 8001872:	2000      	movs	r0, #0
}
 8001874:	bd70      	pop	{r4, r5, r6, pc}
 8001876:	6983      	ldr	r3, [r0, #24]
 8001878:	2b00      	cmp	r3, #0
 800187a:	d1e0      	bne.n	800183e <sdu_start_receive+0xe>
 800187c:	e7f1      	b.n	8001862 <sdu_start_receive+0x32>
 800187e:	bf00      	nop

08001880 <ibnotify>:
  (void) sdu_start_receive(sdup);
 8001880:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8001882:	f7ff bfd5 	b.w	8001830 <sdu_start_receive>
 8001886:	bf00      	nop
	...

08001890 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001890:	310d      	adds	r1, #13
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8001892:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001894:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 8001898:	b1b4      	cbz	r4, 80018c8 <sduDataReceived+0x38>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800189a:	2320      	movs	r3, #32
 800189c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80018a0:	f7ff fc0e 	bl	80010c0 <_dbg_check_lock_from_isr>
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 80018a4:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 80018a8:	6813      	ldr	r3, [r2, #0]
 80018aa:	7952      	ldrb	r2, [r2, #5]
 80018ac:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80018b0:	68db      	ldr	r3, [r3, #12]
 80018b2:	699b      	ldr	r3, [r3, #24]
 80018b4:	685d      	ldr	r5, [r3, #4]
  if (size > (size_t)0) {
 80018b6:	b945      	cbnz	r5, 80018ca <sduDataReceived+0x3a>
  (void) sdu_start_receive(sdup);
 80018b8:	4620      	mov	r0, r4
 80018ba:	f7ff ffb9 	bl	8001830 <sdu_start_receive>
  _dbg_check_unlock_from_isr();
 80018be:	f7ff fbe7 	bl	8001090 <_dbg_check_unlock_from_isr>
 80018c2:	2300      	movs	r3, #0
 80018c4:	f383 8811 	msr	BASEPRI, r3
}
 80018c8:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80018ca:	2104      	movs	r1, #4
 80018cc:	1860      	adds	r0, r4, r1
 80018ce:	f7ff fb07 	bl	8000ee0 <chEvtBroadcastFlagsI>
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();
 80018d2:	f7ff f985 	bl	8000be0 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 80018d6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80018d8:	3b04      	subs	r3, #4
 80018da:	429d      	cmp	r5, r3
 80018dc:	d904      	bls.n	80018e8 <sduDataReceived+0x58>
  __ASM volatile ("cpsid i" : : : "memory");
 80018de:	b672      	cpsid	i
 80018e0:	4b10      	ldr	r3, [pc, #64]	; (8001924 <sduDataReceived+0x94>)
 80018e2:	4a11      	ldr	r2, [pc, #68]	; (8001928 <sduDataReceived+0x98>)
 80018e4:	62da      	str	r2, [r3, #44]	; 0x2c
 80018e6:	e7fe      	b.n	80018e6 <sduDataReceived+0x56>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 80018e8:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 80018ec:	4293      	cmp	r3, r2
 80018ee:	d010      	beq.n	8001912 <sduDataReceived+0x82>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 80018f0:	601d      	str	r5, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
 80018f2:	e9d4 1009 	ldrd	r1, r0, [r4, #36]	; 0x24
  ibqp->bcounter++;
 80018f6:	69a2      	ldr	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 80018f8:	4403      	add	r3, r0
  ibqp->bcounter++;
 80018fa:	3201      	adds	r2, #1
  if (ibqp->bwrptr >= ibqp->btop) {
 80018fc:	428b      	cmp	r3, r1
  ibqp->bcounter++;
 80018fe:	61a2      	str	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 8001900:	61e3      	str	r3, [r4, #28]
  if (ibqp->bwrptr >= ibqp->btop) {
 8001902:	d301      	bcc.n	8001908 <sduDataReceived+0x78>
    ibqp->bwrptr = ibqp->buffers;
 8001904:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001906:	61e3      	str	r3, [r4, #28]
  chThdDequeueNextI(tqp, msg);
 8001908:	f104 000c 	add.w	r0, r4, #12
 800190c:	f7ff fa50 	bl	8000db0 <chThdDequeueNextI.constprop.87>
 8001910:	e7d2      	b.n	80018b8 <sduDataReceived+0x28>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 8001912:	69a2      	ldr	r2, [r4, #24]
 8001914:	2a00      	cmp	r2, #0
 8001916:	d0eb      	beq.n	80018f0 <sduDataReceived+0x60>
 8001918:	b672      	cpsid	i
 800191a:	4b02      	ldr	r3, [pc, #8]	; (8001924 <sduDataReceived+0x94>)
 800191c:	4a02      	ldr	r2, [pc, #8]	; (8001928 <sduDataReceived+0x98>)
 800191e:	62da      	str	r2, [r3, #44]	; 0x2c
 8001920:	e7fe      	b.n	8001920 <sduDataReceived+0x90>
 8001922:	bf00      	nop
 8001924:	200011a0 	.word	0x200011a0
 8001928:	0800c018 	.word	0x0800c018
 800192c:	00000000 	.word	0x00000000

08001930 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8001930:	b510      	push	{r4, lr}

  osalDbgCheckClassS();
 8001932:	f7ff f945 	bl	8000bc0 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 8001936:	b119      	cbz	r1, 8001940 <obqPostFullBufferS+0x10>
 8001938:	69c3      	ldr	r3, [r0, #28]
 800193a:	3b04      	subs	r3, #4
 800193c:	428b      	cmp	r3, r1
 800193e:	d204      	bcs.n	800194a <obqPostFullBufferS+0x1a>
 8001940:	b672      	cpsid	i
 8001942:	4b10      	ldr	r3, [pc, #64]	; (8001984 <obqPostFullBufferS+0x54>)
 8001944:	4a10      	ldr	r2, [pc, #64]	; (8001988 <obqPostFullBufferS+0x58>)
 8001946:	62da      	str	r2, [r3, #44]	; 0x2c
 8001948:	e7fe      	b.n	8001948 <obqPostFullBufferS+0x18>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 800194a:	68c3      	ldr	r3, [r0, #12]
 800194c:	b19b      	cbz	r3, 8001976 <obqPostFullBufferS+0x46>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 800194e:	6903      	ldr	r3, [r0, #16]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
 8001950:	6984      	ldr	r4, [r0, #24]
  *((size_t *)obqp->bwrptr) = size;
 8001952:	6019      	str	r1, [r3, #0]
  obqp->bwrptr += obqp->bsize;
 8001954:	69c1      	ldr	r1, [r0, #28]
  obqp->bcounter--;
 8001956:	68c2      	ldr	r2, [r0, #12]
  obqp->bwrptr += obqp->bsize;
 8001958:	440b      	add	r3, r1
  if (obqp->bwrptr >= obqp->btop) {
 800195a:	42a3      	cmp	r3, r4
  obqp->bwrptr += obqp->bsize;
 800195c:	6103      	str	r3, [r0, #16]
    obqp->bwrptr = obqp->buffers;
 800195e:	bf24      	itt	cs
 8001960:	6a43      	ldrcs	r3, [r0, #36]	; 0x24
 8001962:	6103      	strcs	r3, [r0, #16]
  obqp->bcounter--;
 8001964:	3a01      	subs	r2, #1

  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8001966:	6b03      	ldr	r3, [r0, #48]	; 0x30
  obqp->bcounter--;
 8001968:	60c2      	str	r2, [r0, #12]
  obqp->ptr = NULL;
 800196a:	2200      	movs	r2, #0
 800196c:	6282      	str	r2, [r0, #40]	; 0x28
  if (obqp->notify != NULL) {
 800196e:	b13b      	cbz	r3, 8001980 <obqPostFullBufferS+0x50>
    obqp->notify(obqp);
  }
}
 8001970:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    obqp->notify(obqp);
 8001974:	4718      	bx	r3
 8001976:	b672      	cpsid	i
 8001978:	4b02      	ldr	r3, [pc, #8]	; (8001984 <obqPostFullBufferS+0x54>)
 800197a:	4a03      	ldr	r2, [pc, #12]	; (8001988 <obqPostFullBufferS+0x58>)
 800197c:	62da      	str	r2, [r3, #44]	; 0x2c
 800197e:	e7fe      	b.n	800197e <obqPostFullBufferS+0x4e>
}
 8001980:	bd10      	pop	{r4, pc}
 8001982:	bf00      	nop
 8001984:	200011a0 	.word	0x200011a0
 8001988:	0800c130 	.word	0x0800c130
 800198c:	00000000 	.word	0x00000000

08001990 <obqGetFullBufferI>:
                           size_t *sizep) {
 8001990:	b508      	push	{r3, lr}
  osalDbgCheckClassI();
 8001992:	f7ff f925 	bl	8000be0 <chDbgCheckClassI>
  if (obqIsEmptyI(obqp)) {
 8001996:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
 800199a:	429a      	cmp	r2, r3
 800199c:	d004      	beq.n	80019a8 <obqGetFullBufferI+0x18>
  *sizep = *((size_t *)obqp->brdptr);
 800199e:	4618      	mov	r0, r3
 80019a0:	f850 3b04 	ldr.w	r3, [r0], #4
 80019a4:	600b      	str	r3, [r1, #0]
}
 80019a6:	bd08      	pop	{r3, pc}
  if (obqIsEmptyI(obqp)) {
 80019a8:	68c2      	ldr	r2, [r0, #12]
 80019aa:	2a00      	cmp	r2, #0
 80019ac:	d0f7      	beq.n	800199e <obqGetFullBufferI+0xe>
    return NULL;
 80019ae:	2000      	movs	r0, #0
}
 80019b0:	bd08      	pop	{r3, pc}
 80019b2:	bf00      	nop
	...

080019c0 <obnotify>:
static void obnotify(io_buffers_queue_t *bqp) {
 80019c0:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 80019c2:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80019c4:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 80019c8:	6813      	ldr	r3, [r2, #0]
 80019ca:	7819      	ldrb	r1, [r3, #0]
 80019cc:	2904      	cmp	r1, #4
static void obnotify(io_buffers_queue_t *bqp) {
 80019ce:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80019d0:	d001      	beq.n	80019d6 <obnotify+0x16>
}
 80019d2:	b002      	add	sp, #8
 80019d4:	bd10      	pop	{r4, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80019d6:	7a21      	ldrb	r1, [r4, #8]
 80019d8:	2902      	cmp	r1, #2
 80019da:	d1fa      	bne.n	80019d2 <obnotify+0x12>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80019dc:	7911      	ldrb	r1, [r2, #4]
 80019de:	891a      	ldrh	r2, [r3, #8]
 80019e0:	2301      	movs	r3, #1
 80019e2:	408b      	lsls	r3, r1
 80019e4:	4213      	tst	r3, r2
 80019e6:	d1f4      	bne.n	80019d2 <obnotify+0x12>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80019e8:	a901      	add	r1, sp, #4
 80019ea:	f104 0044 	add.w	r0, r4, #68	; 0x44
 80019ee:	f7ff ffcf 	bl	8001990 <obqGetFullBufferI>
    if (buf != NULL) {
 80019f2:	4602      	mov	r2, r0
 80019f4:	2800      	cmp	r0, #0
 80019f6:	d0ec      	beq.n	80019d2 <obnotify+0x12>
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80019f8:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 80019fc:	9b01      	ldr	r3, [sp, #4]
 80019fe:	7901      	ldrb	r1, [r0, #4]
 8001a00:	6800      	ldr	r0, [r0, #0]
 8001a02:	f7ff fd9d 	bl	8001540 <usbStartTransmitI>
 8001a06:	e7e4      	b.n	80019d2 <obnotify+0x12>
	...

08001a10 <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8001a10:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001a12:	2320      	movs	r3, #32
 8001a14:	b082      	sub	sp, #8
 8001a16:	f383 8811 	msr	BASEPRI, r3
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001a1a:	4c24      	ldr	r4, [pc, #144]	; (8001aac <sof_handler+0x9c>)
  _dbg_check_lock_from_isr();
 8001a1c:	f7ff fb50 	bl	80010c0 <_dbg_check_lock_from_isr>
 8001a20:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8001a24:	6813      	ldr	r3, [r2, #0]
 8001a26:	7819      	ldrb	r1, [r3, #0]
 8001a28:	2904      	cmp	r1, #4
 8001a2a:	d006      	beq.n	8001a3a <sof_handler+0x2a>
  _dbg_check_unlock_from_isr();
 8001a2c:	f7ff fb30 	bl	8001090 <_dbg_check_unlock_from_isr>
 8001a30:	2300      	movs	r3, #0
 8001a32:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&PORTAB_SDU1);
  osalSysUnlockFromISR();
}
 8001a36:	b002      	add	sp, #8
 8001a38:	bd10      	pop	{r4, pc}
 8001a3a:	7a21      	ldrb	r1, [r4, #8]
 8001a3c:	2902      	cmp	r1, #2
 8001a3e:	d1f5      	bne.n	8001a2c <sof_handler+0x1c>
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8001a40:	7911      	ldrb	r1, [r2, #4]
 8001a42:	891a      	ldrh	r2, [r3, #8]
 8001a44:	2301      	movs	r3, #1
 8001a46:	408b      	lsls	r3, r1
 8001a48:	4213      	tst	r3, r2
 8001a4a:	d1ef      	bne.n	8001a2c <sof_handler+0x1c>
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 8001a4c:	f7ff f8c8 	bl	8000be0 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8001a50:	e9d4 3215 	ldrd	r3, r2, [r4, #84]	; 0x54
 8001a54:	4293      	cmp	r3, r2
 8001a56:	d1e9      	bne.n	8001a2c <sof_handler+0x1c>
 8001a58:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8001a5a:	2a00      	cmp	r2, #0
 8001a5c:	d0e6      	beq.n	8001a2c <sof_handler+0x1c>
 8001a5e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8001a60:	2a00      	cmp	r2, #0
 8001a62:	d0e3      	beq.n	8001a2c <sof_handler+0x1c>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 8001a64:	3a04      	subs	r2, #4

    if (size > 0U) {
 8001a66:	1ad2      	subs	r2, r2, r3
 8001a68:	d0e0      	beq.n	8001a2c <sof_handler+0x1c>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 8001a6a:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
      if (obqp->bwrptr >= obqp->btop) {
 8001a6c:	e9d4 1017 	ldrd	r1, r0, [r4, #92]	; 0x5c
      obqp->bwrptr += obqp->bsize;
 8001a70:	4403      	add	r3, r0
      if (obqp->bwrptr >= obqp->btop) {
 8001a72:	428b      	cmp	r3, r1
      obqp->bcounter--;
 8001a74:	6d22      	ldr	r2, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
 8001a76:	6563      	str	r3, [r4, #84]	; 0x54
        obqp->bwrptr = obqp->buffers;
 8001a78:	bf24      	itt	cs
 8001a7a:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68
 8001a7c:	6563      	strcs	r3, [r4, #84]	; 0x54
      obqp->bcounter--;
 8001a7e:	3a01      	subs	r2, #1
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8001a80:	2300      	movs	r3, #0
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001a82:	a901      	add	r1, sp, #4
 8001a84:	480a      	ldr	r0, [pc, #40]	; (8001ab0 <sof_handler+0xa0>)
      obqp->bcounter--;
 8001a86:	6522      	str	r2, [r4, #80]	; 0x50
      obqp->ptr = NULL;
 8001a88:	66e3      	str	r3, [r4, #108]	; 0x6c
 8001a8a:	f7ff ff81 	bl	8001990 <obqGetFullBufferI>
    osalDbgAssert(buf != NULL, "queue is empty");
 8001a8e:	4602      	mov	r2, r0
 8001a90:	b138      	cbz	r0, 8001aa2 <sof_handler+0x92>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8001a92:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 8001a96:	9b01      	ldr	r3, [sp, #4]
 8001a98:	7901      	ldrb	r1, [r0, #4]
 8001a9a:	6800      	ldr	r0, [r0, #0]
 8001a9c:	f7ff fd50 	bl	8001540 <usbStartTransmitI>
 8001aa0:	e7c4      	b.n	8001a2c <sof_handler+0x1c>
  __ASM volatile ("cpsid i" : : : "memory");
 8001aa2:	b672      	cpsid	i
 8001aa4:	4b03      	ldr	r3, [pc, #12]	; (8001ab4 <sof_handler+0xa4>)
 8001aa6:	4a04      	ldr	r2, [pc, #16]	; (8001ab8 <sof_handler+0xa8>)
 8001aa8:	62da      	str	r2, [r3, #44]	; 0x2c
 8001aaa:	e7fe      	b.n	8001aaa <sof_handler+0x9a>
 8001aac:	20000c98 	.word	0x20000c98
 8001ab0:	20000cdc 	.word	0x20000cdc
 8001ab4:	200011a0 	.word	0x200011a0
 8001ab8:	0800c00c 	.word	0x0800c00c
 8001abc:	00000000 	.word	0x00000000

08001ac0 <sduDataTransmitted>:
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8001ac0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8001ac4:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8001ac8:	b082      	sub	sp, #8
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8001aca:	6a1c      	ldr	r4, [r3, #32]
  if (sdup == NULL) {
 8001acc:	b314      	cbz	r4, 8001b14 <sduDataTransmitted+0x54>
 8001ace:	460e      	mov	r6, r1
 8001ad0:	4605      	mov	r5, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001ad2:	2320      	movs	r3, #32
 8001ad4:	f383 8811 	msr	BASEPRI, r3
 8001ad8:	eb00 0781 	add.w	r7, r0, r1, lsl #2
  _dbg_check_lock_from_isr();
 8001adc:	f7ff faf0 	bl	80010c0 <_dbg_check_lock_from_isr>
  chEvtBroadcastFlagsI(esp, flags);
 8001ae0:	1d20      	adds	r0, r4, #4
 8001ae2:	2108      	movs	r1, #8
 8001ae4:	f7ff f9fc 	bl	8000ee0 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8001ae8:	68fb      	ldr	r3, [r7, #12]
 8001aea:	695b      	ldr	r3, [r3, #20]
 8001aec:	681b      	ldr	r3, [r3, #0]
 8001aee:	f104 0844 	add.w	r8, r4, #68	; 0x44
 8001af2:	bb13      	cbnz	r3, 8001b3a <sduDataTransmitted+0x7a>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001af4:	4640      	mov	r0, r8
 8001af6:	a901      	add	r1, sp, #4
 8001af8:	f7ff ff4a 	bl	8001990 <obqGetFullBufferI>
  if (buf != NULL) {
 8001afc:	4602      	mov	r2, r0
 8001afe:	b160      	cbz	r0, 8001b1a <sduDataTransmitted+0x5a>
    usbStartTransmitI(usbp, ep, buf, n);
 8001b00:	4631      	mov	r1, r6
 8001b02:	4628      	mov	r0, r5
 8001b04:	9b01      	ldr	r3, [sp, #4]
 8001b06:	f7ff fd1b 	bl	8001540 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8001b0a:	f7ff fac1 	bl	8001090 <_dbg_check_unlock_from_isr>
 8001b0e:	2300      	movs	r3, #0
 8001b10:	f383 8811 	msr	BASEPRI, r3
}
 8001b14:	b002      	add	sp, #8
 8001b16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8001b1a:	68fb      	ldr	r3, [r7, #12]
 8001b1c:	695a      	ldr	r2, [r3, #20]
 8001b1e:	6812      	ldr	r2, [r2, #0]
 8001b20:	2a00      	cmp	r2, #0
 8001b22:	d0f2      	beq.n	8001b0a <sduDataTransmitted+0x4a>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8001b24:	8a1b      	ldrh	r3, [r3, #16]
 8001b26:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8001b28:	4013      	ands	r3, r2
 8001b2a:	d1ee      	bne.n	8001b0a <sduDataTransmitted+0x4a>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8001b2c:	4631      	mov	r1, r6
 8001b2e:	f105 025c 	add.w	r2, r5, #92	; 0x5c
 8001b32:	4628      	mov	r0, r5
 8001b34:	f7ff fd04 	bl	8001540 <usbStartTransmitI>
 8001b38:	e7e7      	b.n	8001b0a <sduDataTransmitted+0x4a>
  osalDbgCheckClassI();
 8001b3a:	f7ff f851 	bl	8000be0 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 8001b3e:	e9d4 2315 	ldrd	r2, r3, [r4, #84]	; 0x54
 8001b42:	429a      	cmp	r2, r3
 8001b44:	d015      	beq.n	8001b72 <sduDataTransmitted+0xb2>
  if (obqp->brdptr >= obqp->btop) {
 8001b46:	e9d4 2117 	ldrd	r2, r1, [r4, #92]	; 0x5c
  obqp->bcounter++;
 8001b4a:	6d20      	ldr	r0, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 8001b4c:	440b      	add	r3, r1
  obqp->bcounter++;
 8001b4e:	3001      	adds	r0, #1
  if (obqp->brdptr >= obqp->btop) {
 8001b50:	4293      	cmp	r3, r2
  obqp->bcounter++;
 8001b52:	6520      	str	r0, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 8001b54:	65a3      	str	r3, [r4, #88]	; 0x58
  if (obqp->brdptr >= obqp->btop) {
 8001b56:	d301      	bcc.n	8001b5c <sduDataTransmitted+0x9c>
    obqp->brdptr = obqp->buffers;
 8001b58:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8001b5a:	65a3      	str	r3, [r4, #88]	; 0x58
  chThdDequeueNextI(tqp, msg);
 8001b5c:	4640      	mov	r0, r8
 8001b5e:	f7ff f927 	bl	8000db0 <chThdDequeueNextI.constprop.87>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001b62:	4640      	mov	r0, r8
 8001b64:	a901      	add	r1, sp, #4
 8001b66:	f7ff ff13 	bl	8001990 <obqGetFullBufferI>
  if (buf != NULL) {
 8001b6a:	4602      	mov	r2, r0
 8001b6c:	2800      	cmp	r0, #0
 8001b6e:	d1c7      	bne.n	8001b00 <sduDataTransmitted+0x40>
 8001b70:	e7d3      	b.n	8001b1a <sduDataTransmitted+0x5a>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 8001b72:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8001b74:	2a00      	cmp	r2, #0
 8001b76:	d0e6      	beq.n	8001b46 <sduDataTransmitted+0x86>
  __ASM volatile ("cpsid i" : : : "memory");
 8001b78:	b672      	cpsid	i
 8001b7a:	4b02      	ldr	r3, [pc, #8]	; (8001b84 <sduDataTransmitted+0xc4>)
 8001b7c:	4a02      	ldr	r2, [pc, #8]	; (8001b88 <sduDataTransmitted+0xc8>)
 8001b7e:	62da      	str	r2, [r3, #44]	; 0x2c
 8001b80:	e7fe      	b.n	8001b80 <sduDataTransmitted+0xc0>
 8001b82:	bf00      	nop
 8001b84:	200011a0 	.word	0x200011a0
 8001b88:	0800c0d4 	.word	0x0800c0d4
 8001b8c:	00000000 	.word	0x00000000

08001b90 <ibqReleaseEmptyBufferS>:
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8001b90:	b510      	push	{r4, lr}
  osalDbgCheckClassS();
 8001b92:	f7ff f815 	bl	8000bc0 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8001b96:	68c3      	ldr	r3, [r0, #12]
 8001b98:	b193      	cbz	r3, 8001bc0 <ibqReleaseEmptyBufferS+0x30>
  if (ibqp->brdptr >= ibqp->btop) {
 8001b9a:	e9d0 1406 	ldrd	r1, r4, [r0, #24]
  ibqp->brdptr += ibqp->bsize;
 8001b9e:	6943      	ldr	r3, [r0, #20]
  ibqp->bcounter--;
 8001ba0:	68c2      	ldr	r2, [r0, #12]
  ibqp->brdptr += ibqp->bsize;
 8001ba2:	4423      	add	r3, r4
  if (ibqp->brdptr >= ibqp->btop) {
 8001ba4:	428b      	cmp	r3, r1
  ibqp->brdptr += ibqp->bsize;
 8001ba6:	6143      	str	r3, [r0, #20]
    ibqp->brdptr = ibqp->buffers;
 8001ba8:	bf24      	itt	cs
 8001baa:	6a43      	ldrcs	r3, [r0, #36]	; 0x24
 8001bac:	6143      	strcs	r3, [r0, #20]
  ibqp->bcounter--;
 8001bae:	3a01      	subs	r2, #1
  if (ibqp->notify != NULL) {
 8001bb0:	6b03      	ldr	r3, [r0, #48]	; 0x30
  ibqp->bcounter--;
 8001bb2:	60c2      	str	r2, [r0, #12]
  ibqp->ptr = NULL;
 8001bb4:	2200      	movs	r2, #0
 8001bb6:	6282      	str	r2, [r0, #40]	; 0x28
  if (ibqp->notify != NULL) {
 8001bb8:	b13b      	cbz	r3, 8001bca <ibqReleaseEmptyBufferS+0x3a>
}
 8001bba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ibqp->notify(ibqp);
 8001bbe:	4718      	bx	r3
 8001bc0:	b672      	cpsid	i
 8001bc2:	4b02      	ldr	r3, [pc, #8]	; (8001bcc <ibqReleaseEmptyBufferS+0x3c>)
 8001bc4:	4a02      	ldr	r2, [pc, #8]	; (8001bd0 <ibqReleaseEmptyBufferS+0x40>)
 8001bc6:	62da      	str	r2, [r3, #44]	; 0x2c
 8001bc8:	e7fe      	b.n	8001bc8 <ibqReleaseEmptyBufferS+0x38>
}
 8001bca:	bd10      	pop	{r4, pc}
 8001bcc:	200011a0 	.word	0x200011a0
 8001bd0:	0800c048 	.word	0x0800c048
	...

08001be0 <stSetAlarm>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001be0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001be4:	68da      	ldr	r2, [r3, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001be6:	0792      	lsls	r2, r2, #30
 8001be8:	d501      	bpl.n	8001bee <stSetAlarm+0xe>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001bea:	6358      	str	r0, [r3, #52]	; 0x34

  st_lld_set_alarm(abstime);
}
 8001bec:	4770      	bx	lr
 8001bee:	b672      	cpsid	i
 8001bf0:	4b01      	ldr	r3, [pc, #4]	; (8001bf8 <stSetAlarm+0x18>)
 8001bf2:	4a02      	ldr	r2, [pc, #8]	; (8001bfc <stSetAlarm+0x1c>)
 8001bf4:	62da      	str	r2, [r3, #44]	; 0x2c
 8001bf6:	e7fe      	b.n	8001bf6 <stSetAlarm+0x16>
 8001bf8:	200011a0 	.word	0x200011a0
 8001bfc:	0800bfec 	.word	0x0800bfec

08001c00 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001c00:	b510      	push	{r4, lr}

  chDbgCheckClassI();
 8001c02:	f7fe ffed 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 8001c06:	68c3      	ldr	r3, [r0, #12]
 8001c08:	2b00      	cmp	r3, #0
 8001c0a:	d02f      	beq.n	8001c6c <chVTDoResetI+0x6c>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8001c0c:	4a1c      	ldr	r2, [pc, #112]	; (8001c80 <chVTDoResetI+0x80>)
 8001c0e:	69d3      	ldr	r3, [r2, #28]
 8001c10:	4283      	cmp	r3, r0
 8001c12:	d00e      	beq.n	8001c32 <chVTDoResetI+0x32>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001c14:	e9d0 3100 	ldrd	r3, r1, [r0]
 8001c18:	600b      	str	r3, [r1, #0]
    vtp->next->prev = vtp->prev;
 8001c1a:	6803      	ldr	r3, [r0, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001c1c:	321c      	adds	r2, #28
    vtp->func = NULL;
 8001c1e:	2400      	movs	r4, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001c20:	4293      	cmp	r3, r2
    vtp->next->prev = vtp->prev;
 8001c22:	6059      	str	r1, [r3, #4]
    vtp->func = NULL;
 8001c24:	60c4      	str	r4, [r0, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001c26:	d003      	beq.n	8001c30 <chVTDoResetI+0x30>
      vtp->next->delta += vtp->delta;
 8001c28:	6881      	ldr	r1, [r0, #8]
 8001c2a:	689a      	ldr	r2, [r3, #8]
 8001c2c:	440a      	add	r2, r1
 8001c2e:	609a      	str	r2, [r3, #8]
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001c30:	bd10      	pop	{r4, pc}
  ch.vtlist.next = vtp->next;
 8001c32:	4610      	mov	r0, r2
 8001c34:	6819      	ldr	r1, [r3, #0]
 8001c36:	f840 1f1c 	str.w	r1, [r0, #28]!
  vtp->func = NULL;
 8001c3a:	2400      	movs	r4, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001c3c:	4281      	cmp	r1, r0
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001c3e:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 8001c40:	60dc      	str	r4, [r3, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001c42:	d018      	beq.n	8001c76 <chVTDoResetI+0x76>
  ch.vtlist.next->delta += vtp->delta;
 8001c44:	689c      	ldr	r4, [r3, #8]
 8001c46:	688b      	ldr	r3, [r1, #8]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8001c48:	6a90      	ldr	r0, [r2, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8001c4a:	4423      	add	r3, r4
  return (systime_t)STM32_ST_TIM->CNT;
 8001c4c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001c50:	608b      	str	r3, [r1, #8]
 8001c52:	6a52      	ldr	r2, [r2, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8001c54:	1a12      	subs	r2, r2, r0
  if (nowdelta >= ch.vtlist.next->delta) {
 8001c56:	4293      	cmp	r3, r2
 8001c58:	d9ea      	bls.n	8001c30 <chVTDoResetI+0x30>
  delta = ch.vtlist.next->delta - nowdelta;
 8001c5a:	1a99      	subs	r1, r3, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001c5c:	2901      	cmp	r1, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8001c5e:	bf98      	it	ls
 8001c60:	1c93      	addls	r3, r2, #2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001c62:	4418      	add	r0, r3
}
 8001c64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8001c68:	f7ff bfba 	b.w	8001be0 <stSetAlarm>
 8001c6c:	b672      	cpsid	i
 8001c6e:	4b04      	ldr	r3, [pc, #16]	; (8001c80 <chVTDoResetI+0x80>)
 8001c70:	4a04      	ldr	r2, [pc, #16]	; (8001c84 <chVTDoResetI+0x84>)
 8001c72:	62da      	str	r2, [r3, #44]	; 0x2c
 8001c74:	e7fe      	b.n	8001c74 <chVTDoResetI+0x74>
  STM32_ST_TIM->DIER = 0;
 8001c76:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001c7a:	60dc      	str	r4, [r3, #12]
 8001c7c:	bd10      	pop	{r4, pc}
 8001c7e:	bf00      	nop
 8001c80:	200011a0 	.word	0x200011a0
 8001c84:	0800bdd4 	.word	0x0800bdd4
	...

08001c90 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
 8001c90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001c94:	4605      	mov	r5, r0
 8001c96:	4690      	mov	r8, r2
 8001c98:	4618      	mov	r0, r3
  chDbgCheckClassI();
 8001c9a:	f7fe ffa1 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8001c9e:	b329      	cbz	r1, 8001cec <chVTDoSetI+0x5c>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001ca0:	4e29      	ldr	r6, [pc, #164]	; (8001d48 <chVTDoSetI+0xb8>)
  vtp->par = par;
 8001ca2:	6128      	str	r0, [r5, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001ca4:	4637      	mov	r7, r6
 8001ca6:	2902      	cmp	r1, #2
 8001ca8:	f857 4f1c 	ldr.w	r4, [r7, #28]!
  vtp->func = vtfunc;
 8001cac:	f8c5 800c 	str.w	r8, [r5, #12]
  return (systime_t)STM32_ST_TIM->CNT;
 8001cb0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8001cb4:	bf38      	it	cc
 8001cb6:	2102      	movcc	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001cb8:	42bc      	cmp	r4, r7
 8001cba:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001cbc:	d02f      	beq.n	8001d1e <chVTDoSetI+0x8e>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8001cbe:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 8001cc0:	68a2      	ldr	r2, [r4, #8]
 8001cc2:	1a1b      	subs	r3, r3, r0
 8001cc4:	185b      	adds	r3, r3, r1
 8001cc6:	4619      	mov	r1, r3
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8001cc8:	d323      	bcc.n	8001d12 <chVTDoSetI+0x82>
      p = p->next;
 8001cca:	6824      	ldr	r4, [r4, #0]
      delta -= p->delta;
 8001ccc:	1a99      	subs	r1, r3, r2
  while (p->delta < delta) {
 8001cce:	68a3      	ldr	r3, [r4, #8]
 8001cd0:	428b      	cmp	r3, r1
 8001cd2:	d305      	bcc.n	8001ce0 <chVTDoSetI+0x50>
 8001cd4:	e00f      	b.n	8001cf6 <chVTDoSetI+0x66>
    p = p->next;
 8001cd6:	6824      	ldr	r4, [r4, #0]
    delta -= p->delta;
 8001cd8:	1ac9      	subs	r1, r1, r3
  while (p->delta < delta) {
 8001cda:	68a3      	ldr	r3, [r4, #8]
 8001cdc:	428b      	cmp	r3, r1
 8001cde:	d20a      	bcs.n	8001cf6 <chVTDoSetI+0x66>
    chDbgAssert(p != vtp, "timer already armed");
 8001ce0:	42a5      	cmp	r5, r4
 8001ce2:	d1f8      	bne.n	8001cd6 <chVTDoSetI+0x46>
 8001ce4:	b672      	cpsid	i
 8001ce6:	4b19      	ldr	r3, [pc, #100]	; (8001d4c <chVTDoSetI+0xbc>)
 8001ce8:	62f3      	str	r3, [r6, #44]	; 0x2c
 8001cea:	e7fe      	b.n	8001cea <chVTDoSetI+0x5a>
 8001cec:	b672      	cpsid	i
 8001cee:	4b16      	ldr	r3, [pc, #88]	; (8001d48 <chVTDoSetI+0xb8>)
 8001cf0:	4a16      	ldr	r2, [pc, #88]	; (8001d4c <chVTDoSetI+0xbc>)
 8001cf2:	62da      	str	r2, [r3, #44]	; 0x2c
 8001cf4:	e7fe      	b.n	8001cf4 <chVTDoSetI+0x64>
  vtp->prev = vtp->next->prev;
 8001cf6:	6863      	ldr	r3, [r4, #4]
 8001cf8:	e9c5 4300 	strd	r4, r3, [r5]
  vtp->prev->next = vtp;
 8001cfc:	601d      	str	r5, [r3, #0]
  p->prev = vtp;
 8001cfe:	6065      	str	r5, [r4, #4]
  vtp->delta = delta;
 8001d00:	60a9      	str	r1, [r5, #8]
  p->delta -= delta;
 8001d02:	68a3      	ldr	r3, [r4, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8001d04:	f04f 32ff 	mov.w	r2, #4294967295
  p->delta -= delta;
 8001d08:	1a5b      	subs	r3, r3, r1
 8001d0a:	60a3      	str	r3, [r4, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8001d0c:	6272      	str	r2, [r6, #36]	; 0x24
}
 8001d0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if (delta < p->delta) {
 8001d12:	4293      	cmp	r3, r2
 8001d14:	d2db      	bcs.n	8001cce <chVTDoSetI+0x3e>
 8001d16:	4418      	add	r0, r3
 8001d18:	f7ff ff62 	bl	8001be0 <stSetAlarm>
 8001d1c:	e7d7      	b.n	8001cce <chVTDoSetI+0x3e>
      ch.vtlist.lasttime = now;
 8001d1e:	62b3      	str	r3, [r6, #40]	; 0x28
      ch.vtlist.prev = vtp;
 8001d20:	e9c6 5507 	strd	r5, r5, [r6, #28]
      vtp->delta = delay;
 8001d24:	60a9      	str	r1, [r5, #8]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001d26:	68c2      	ldr	r2, [r0, #12]
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8001d28:	f012 0202 	ands.w	r2, r2, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8001d2c:	e9c5 4400 	strd	r4, r4, [r5]
  return systime + (systime_t)interval;
 8001d30:	440b      	add	r3, r1
 8001d32:	d104      	bne.n	8001d3e <chVTDoSetI+0xae>
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001d34:	2102      	movs	r1, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001d36:	6343      	str	r3, [r0, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001d38:	6102      	str	r2, [r0, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001d3a:	60c1      	str	r1, [r0, #12]
 8001d3c:	e7e7      	b.n	8001d0e <chVTDoSetI+0x7e>
 8001d3e:	b672      	cpsid	i
 8001d40:	4b03      	ldr	r3, [pc, #12]	; (8001d50 <chVTDoSetI+0xc0>)
 8001d42:	62f3      	str	r3, [r6, #44]	; 0x2c
 8001d44:	e7fe      	b.n	8001d44 <chVTDoSetI+0xb4>
 8001d46:	bf00      	nop
 8001d48:	200011a0 	.word	0x200011a0
 8001d4c:	0800bd6c 	.word	0x0800bd6c
 8001d50:	0800bfdc 	.word	0x0800bfdc
	...

08001d60 <chCondSignalI.constprop.49>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8001d60:	b510      	push	{r4, lr}

  chDbgCheckClassI();
 8001d62:	f7fe ff3d 	bl	8000be0 <chDbgCheckClassI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8001d66:	4b07      	ldr	r3, [pc, #28]	; (8001d84 <chCondSignalI.constprop.49+0x24>)
 8001d68:	681a      	ldr	r2, [r3, #0]
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
 8001d6a:	429a      	cmp	r2, r3
 8001d6c:	d009      	beq.n	8001d82 <chCondSignalI.constprop.49+0x22>
  tqp->next             = tp->queue.next;
 8001d6e:	6811      	ldr	r1, [r2, #0]
 8001d70:	6019      	str	r1, [r3, #0]
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
 8001d72:	2400      	movs	r4, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8001d74:	604b      	str	r3, [r1, #4]
    (void) chSchReadyI(tp);
 8001d76:	4610      	mov	r0, r2
    tp->u.rdymsg = MSG_OK;
 8001d78:	6254      	str	r4, [r2, #36]	; 0x24
  }
}
 8001d7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    (void) chSchReadyI(tp);
 8001d7e:	f7fe bfef 	b.w	8000d60 <chSchReadyI>
}
 8001d82:	bd10      	pop	{r4, pc}
 8001d84:	20000c04 	.word	0x20000c04
	...

08001d90 <chMBResetI.constprop.29>:
void chMBResetI(mailbox_t *mbp) {
 8001d90:	b510      	push	{r4, lr}
  mbp->wrptr = mbp->buffer;
 8001d92:	4c0a      	ldr	r4, [pc, #40]	; (8001dbc <chMBResetI.constprop.29+0x2c>)
  chDbgCheckClassI();
 8001d94:	f7fe ff24 	bl	8000be0 <chDbgCheckClassI>
  mbp->wrptr = mbp->buffer;
 8001d98:	6823      	ldr	r3, [r4, #0]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8001d9a:	f104 0018 	add.w	r0, r4, #24
  mbp->cnt   = (size_t)0;
 8001d9e:	2100      	movs	r1, #0
  mbp->reset = true;
 8001da0:	2201      	movs	r2, #1
  mbp->cnt   = (size_t)0;
 8001da2:	6121      	str	r1, [r4, #16]
  mbp->reset = true;
 8001da4:	7522      	strb	r2, [r4, #20]
  mbp->rdptr = mbp->buffer;
 8001da6:	e9c4 3302 	strd	r3, r3, [r4, #8]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8001daa:	f7ff f849 	bl	8000e40 <chThdDequeueAllI.constprop.89>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8001dae:	f104 0020 	add.w	r0, r4, #32
}
 8001db2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8001db6:	f7ff b843 	b.w	8000e40 <chThdDequeueAllI.constprop.89>
 8001dba:	bf00      	nop
 8001dbc:	20000c58 	.word	0x20000c58

08001dc0 <chMBPostI.constprop.25>:
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8001dc0:	b570      	push	{r4, r5, r6, lr}
  if (mbp->reset) {
 8001dc2:	4912      	ldr	r1, [pc, #72]	; (8001e0c <chMBPostI.constprop.25+0x4c>)
  chDbgCheckClassI();
 8001dc4:	f7fe ff0c 	bl	8000be0 <chDbgCheckClassI>
  if (mbp->reset) {
 8001dc8:	7d0b      	ldrb	r3, [r1, #20]
 8001dca:	b9cb      	cbnz	r3, 8001e00 <chMBPostI.constprop.25+0x40>
 *
 * @iclass
 */
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();
 8001dcc:	f7fe ff08 	bl	8000be0 <chDbgCheckClassI>
 8001dd0:	e9d1 6400 	ldrd	r6, r4, [r1]
  chDbgCheckClassI();
 8001dd4:	f7fe ff04 	bl	8000be0 <chDbgCheckClassI>
  return mbp->cnt;
 8001dd8:	690b      	ldr	r3, [r1, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8001dda:	1ba2      	subs	r2, r4, r6
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8001ddc:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
 8001de0:	d011      	beq.n	8001e06 <chMBPostI.constprop.25+0x46>
    *mbp->wrptr++ = msg;
 8001de2:	688d      	ldr	r5, [r1, #8]
 8001de4:	1d2a      	adds	r2, r5, #4
 8001de6:	608a      	str	r2, [r1, #8]
    if (mbp->wrptr >= mbp->top) {
 8001de8:	4294      	cmp	r4, r2
    *mbp->wrptr++ = msg;
 8001dea:	6028      	str	r0, [r5, #0]
    mbp->cnt++;
 8001dec:	f103 0301 	add.w	r3, r3, #1
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001df0:	4807      	ldr	r0, [pc, #28]	; (8001e10 <chMBPostI.constprop.25+0x50>)
      mbp->wrptr = mbp->buffer;
 8001df2:	bf98      	it	ls
 8001df4:	608e      	strls	r6, [r1, #8]
    mbp->cnt++;
 8001df6:	610b      	str	r3, [r1, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001df8:	f7fe ffda 	bl	8000db0 <chThdDequeueNextI.constprop.87>
    return MSG_OK;
 8001dfc:	2000      	movs	r0, #0
}
 8001dfe:	bd70      	pop	{r4, r5, r6, pc}
    return MSG_RESET;
 8001e00:	f06f 0001 	mvn.w	r0, #1
}
 8001e04:	bd70      	pop	{r4, r5, r6, pc}
  return MSG_TIMEOUT;
 8001e06:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001e0a:	bd70      	pop	{r4, r5, r6, pc}
 8001e0c:	20000c58 	.word	0x20000c58
 8001e10:	20000c78 	.word	0x20000c78
	...

08001e20 <chMBPostAheadI.constprop.22>:
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8001e20:	b538      	push	{r3, r4, r5, lr}
  if (mbp->reset) {
 8001e22:	4912      	ldr	r1, [pc, #72]	; (8001e6c <chMBPostAheadI.constprop.22+0x4c>)
  chDbgCheckClassI();
 8001e24:	f7fe fedc 	bl	8000be0 <chDbgCheckClassI>
  if (mbp->reset) {
 8001e28:	7d0b      	ldrb	r3, [r1, #20]
 8001e2a:	b9c3      	cbnz	r3, 8001e5e <chMBPostAheadI.constprop.22+0x3e>
  chDbgCheckClassI();
 8001e2c:	f7fe fed8 	bl	8000be0 <chDbgCheckClassI>
 8001e30:	e9d1 4500 	ldrd	r4, r5, [r1]
  chDbgCheckClassI();
 8001e34:	f7fe fed4 	bl	8000be0 <chDbgCheckClassI>
  return mbp->cnt;
 8001e38:	690a      	ldr	r2, [r1, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8001e3a:	1b2b      	subs	r3, r5, r4
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8001e3c:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8001e40:	d010      	beq.n	8001e64 <chMBPostAheadI.constprop.22+0x44>
    if (--mbp->rdptr < mbp->buffer) {
 8001e42:	68cb      	ldr	r3, [r1, #12]
 8001e44:	3b04      	subs	r3, #4
 8001e46:	429c      	cmp	r4, r3
      mbp->rdptr = mbp->top - 1;
 8001e48:	bf88      	it	hi
 8001e4a:	1f2b      	subhi	r3, r5, #4
 8001e4c:	60cb      	str	r3, [r1, #12]
    mbp->cnt++;
 8001e4e:	3201      	adds	r2, #1
    *mbp->rdptr = msg;
 8001e50:	6018      	str	r0, [r3, #0]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001e52:	4807      	ldr	r0, [pc, #28]	; (8001e70 <chMBPostAheadI.constprop.22+0x50>)
    mbp->cnt++;
 8001e54:	610a      	str	r2, [r1, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001e56:	f7fe ffab 	bl	8000db0 <chThdDequeueNextI.constprop.87>
    return MSG_OK;
 8001e5a:	2000      	movs	r0, #0
}
 8001e5c:	bd38      	pop	{r3, r4, r5, pc}
    return MSG_RESET;
 8001e5e:	f06f 0001 	mvn.w	r0, #1
}
 8001e62:	bd38      	pop	{r3, r4, r5, pc}
  return MSG_TIMEOUT;
 8001e64:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001e68:	bd38      	pop	{r3, r4, r5, pc}
 8001e6a:	bf00      	nop
 8001e6c:	20000c58 	.word	0x20000c58
 8001e70:	20000c78 	.word	0x20000c78
	...

08001e80 <oslib_test_002_001_setup>:
  mp->next = NULL;
 8001e80:	4b03      	ldr	r3, [pc, #12]	; (8001e90 <oslib_test_002_001_setup+0x10>)
 8001e82:	2100      	movs	r1, #0
  mp->object_size = size;
 8001e84:	2204      	movs	r2, #4
  mp->next = NULL;
 8001e86:	6019      	str	r1, [r3, #0]
  mp->provider = provider;
 8001e88:	60d9      	str	r1, [r3, #12]
  mp->align = align;
 8001e8a:	e9c3 2201 	strd	r2, r2, [r3, #4]
}
 8001e8e:	4770      	bx	lr
 8001e90:	20000c80 	.word	0x20000c80
	...

08001ea0 <rt_test_010_012_execute>:
 * - [10.12.8] The size of an event listener is printed.
 * - [10.12.9] The size of a mailbox is printed.
 * .
 */

static void rt_test_010_012_execute(void) {
 8001ea0:	b570      	push	{r4, r5, r6, lr}

  /* [10.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8001ea2:	4d33      	ldr	r5, [pc, #204]	; (8001f70 <rt_test_010_012_execute+0xd0>)
  {
    test_print("--- System: ");
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
 8001ea4:	4c33      	ldr	r4, [pc, #204]	; (8001f74 <rt_test_010_012_execute+0xd4>)
    test_print("--- System: ");
 8001ea6:	4834      	ldr	r0, [pc, #208]	; (8001f78 <rt_test_010_012_execute+0xd8>)
  test_set_step(1);
 8001ea8:	2301      	movs	r3, #1
 8001eaa:	602b      	str	r3, [r5, #0]
    test_print("--- System: ");
 8001eac:	f7fe fdc0 	bl	8000a30 <test_print>
 8001eb0:	2080      	movs	r0, #128	; 0x80
 8001eb2:	f7fe fd5d 	bl	8000970 <test_printn.part.0>
    test_println(" bytes");
 8001eb6:	4620      	mov	r0, r4
 8001eb8:	f7fe fd9a 	bl	80009f0 <test_println>
  }

  /* [10.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 8001ebc:	2302      	movs	r3, #2
  {
    test_print("--- Thread: ");
 8001ebe:	482f      	ldr	r0, [pc, #188]	; (8001f7c <rt_test_010_012_execute+0xdc>)
  test_set_step(2);
 8001ec0:	602b      	str	r3, [r5, #0]
    test_print("--- Thread: ");
 8001ec2:	f7fe fdb5 	bl	8000a30 <test_print>
 8001ec6:	2044      	movs	r0, #68	; 0x44
 8001ec8:	f7fe fd52 	bl	8000970 <test_printn.part.0>
    test_printn(sizeof(thread_t));
    test_println(" bytes");
 8001ecc:	4620      	mov	r0, r4
 8001ece:	f7fe fd8f 	bl	80009f0 <test_println>
  }

  /* [10.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8001ed2:	2303      	movs	r3, #3
  {
    test_print("--- Timer : ");
 8001ed4:	482a      	ldr	r0, [pc, #168]	; (8001f80 <rt_test_010_012_execute+0xe0>)
  test_set_step(3);
 8001ed6:	602b      	str	r3, [r5, #0]
    test_print("--- Timer : ");
 8001ed8:	f7fe fdaa 	bl	8000a30 <test_print>
 8001edc:	2014      	movs	r0, #20
 8001ede:	f7fe fd47 	bl	8000970 <test_printn.part.0>
    test_printn(sizeof(virtual_timer_t));
    test_println(" bytes");
 8001ee2:	4620      	mov	r0, r4
 8001ee4:	f7fe fd84 	bl	80009f0 <test_println>
  }

  /* [10.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8001ee8:	2604      	movs	r6, #4
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 8001eea:	4826      	ldr	r0, [pc, #152]	; (8001f84 <rt_test_010_012_execute+0xe4>)
  test_set_step(4);
 8001eec:	602e      	str	r6, [r5, #0]
    test_print("--- Semaph: ");
 8001eee:	f7fe fd9f 	bl	8000a30 <test_print>
 8001ef2:	200c      	movs	r0, #12
 8001ef4:	f7fe fd3c 	bl	8000970 <test_printn.part.0>
    test_printn(sizeof(semaphore_t));
    test_println(" bytes");
 8001ef8:	4620      	mov	r0, r4
 8001efa:	f7fe fd79 	bl	80009f0 <test_println>
#endif
  }

  /* [10.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8001efe:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8001f00:	4821      	ldr	r0, [pc, #132]	; (8001f88 <rt_test_010_012_execute+0xe8>)
  test_set_step(5);
 8001f02:	602b      	str	r3, [r5, #0]
    test_print("--- Mutex : ");
 8001f04:	f7fe fd94 	bl	8000a30 <test_print>
 8001f08:	2010      	movs	r0, #16
 8001f0a:	f7fe fd31 	bl	8000970 <test_printn.part.0>
    test_printn(sizeof(mutex_t));
    test_println(" bytes");
 8001f0e:	4620      	mov	r0, r4
 8001f10:	f7fe fd6e 	bl	80009f0 <test_println>
#endif
  }

  /* [10.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8001f14:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8001f16:	481d      	ldr	r0, [pc, #116]	; (8001f8c <rt_test_010_012_execute+0xec>)
  test_set_step(6);
 8001f18:	602b      	str	r3, [r5, #0]
    test_print("--- CondV.: ");
 8001f1a:	f7fe fd89 	bl	8000a30 <test_print>
 8001f1e:	2008      	movs	r0, #8
 8001f20:	f7fe fd26 	bl	8000970 <test_printn.part.0>
    test_printn(sizeof(condition_variable_t));
    test_println(" bytes");
 8001f24:	4620      	mov	r0, r4
 8001f26:	f7fe fd63 	bl	80009f0 <test_println>
#endif
  }

  /* [10.12.7] The size of an event source is printed.*/
  test_set_step(7);
 8001f2a:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8001f2c:	4818      	ldr	r0, [pc, #96]	; (8001f90 <rt_test_010_012_execute+0xf0>)
  test_set_step(7);
 8001f2e:	602b      	str	r3, [r5, #0]
    test_print("--- EventS: ");
 8001f30:	f7fe fd7e 	bl	8000a30 <test_print>
 8001f34:	4630      	mov	r0, r6
 8001f36:	f7fe fd1b 	bl	8000970 <test_printn.part.0>
    test_printn(sizeof(event_source_t));
    test_println(" bytes");
 8001f3a:	4620      	mov	r0, r4
 8001f3c:	f7fe fd58 	bl	80009f0 <test_println>
#endif
  }

  /* [10.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8001f40:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8001f42:	4814      	ldr	r0, [pc, #80]	; (8001f94 <rt_test_010_012_execute+0xf4>)
  test_set_step(8);
 8001f44:	602b      	str	r3, [r5, #0]
    test_print("--- EventL: ");
 8001f46:	f7fe fd73 	bl	8000a30 <test_print>
 8001f4a:	2014      	movs	r0, #20
 8001f4c:	f7fe fd10 	bl	8000970 <test_printn.part.0>
    test_printn(sizeof(event_listener_t));
    test_println(" bytes");
 8001f50:	4620      	mov	r0, r4
 8001f52:	f7fe fd4d 	bl	80009f0 <test_println>
#endif
  }

  /* [10.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8001f56:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8001f58:	480f      	ldr	r0, [pc, #60]	; (8001f98 <rt_test_010_012_execute+0xf8>)
  test_set_step(9);
 8001f5a:	602b      	str	r3, [r5, #0]
    test_print("--- MailB.: ");
 8001f5c:	f7fe fd68 	bl	8000a30 <test_print>
 8001f60:	2028      	movs	r0, #40	; 0x28
 8001f62:	f7fe fd05 	bl	8000970 <test_printn.part.0>
    test_printn(sizeof(mailbox_t));
    test_println(" bytes");
 8001f66:	4620      	mov	r0, r4
#endif
  }
}
 8001f68:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_println(" bytes");
 8001f6c:	f7fe bd40 	b.w	80009f0 <test_println>
 8001f70:	20001b3c 	.word	0x20001b3c
 8001f74:	0800da8c 	.word	0x0800da8c
 8001f78:	0800da7c 	.word	0x0800da7c
 8001f7c:	0800da94 	.word	0x0800da94
 8001f80:	0800daa4 	.word	0x0800daa4
 8001f84:	0800dab4 	.word	0x0800dab4
 8001f88:	0800dac4 	.word	0x0800dac4
 8001f8c:	0800dad4 	.word	0x0800dad4
 8001f90:	0800dae4 	.word	0x0800dae4
 8001f94:	0800daf4 	.word	0x0800daf4
 8001f98:	0800db04 	.word	0x0800db04
 8001f9c:	00000000 	.word	0x00000000

08001fa0 <rt_test_010_011_setup>:
  tqp->next = (thread_t *)tqp;
 8001fa0:	4b02      	ldr	r3, [pc, #8]	; (8001fac <rt_test_010_011_setup+0xc>)
  mp->owner = NULL;
 8001fa2:	2200      	movs	r2, #0
  tqp->prev = (thread_t *)tqp;
 8001fa4:	e9c3 3300 	strd	r3, r3, [r3]
 8001fa8:	609a      	str	r2, [r3, #8]
}
 8001faa:	4770      	bx	lr
 8001fac:	200013e8 	.word	0x200013e8

08001fb0 <rt_test_010_010_setup>:
  tqp->next = (thread_t *)tqp;
 8001fb0:	4b02      	ldr	r3, [pc, #8]	; (8001fbc <rt_test_010_010_setup+0xc>)
  sp->cnt = n;
 8001fb2:	2201      	movs	r2, #1
  tqp->prev = (thread_t *)tqp;
 8001fb4:	e9c3 3300 	strd	r3, r3, [r3]
 8001fb8:	609a      	str	r2, [r3, #8]
}
 8001fba:	4770      	bx	lr
 8001fbc:	20001414 	.word	0x20001414

08001fc0 <rt_test_010_007_setup>:
  tqp->next = (thread_t *)tqp;
 8001fc0:	4b02      	ldr	r3, [pc, #8]	; (8001fcc <rt_test_010_007_setup+0xc>)
 8001fc2:	2200      	movs	r2, #0
  tqp->prev = (thread_t *)tqp;
 8001fc4:	e9c3 3300 	strd	r3, r3, [r3]
 8001fc8:	609a      	str	r2, [r3, #8]
}
 8001fca:	4770      	bx	lr
 8001fcc:	20001414 	.word	0x20001414

08001fd0 <rt_test_009_002_setup>:
  mp->next = NULL;
 8001fd0:	4b04      	ldr	r3, [pc, #16]	; (8001fe4 <rt_test_009_002_setup+0x14>)
 8001fd2:	2200      	movs	r2, #0
  mp->object_size = size;
 8001fd4:	f44f 70a4 	mov.w	r0, #328	; 0x148
  mp->align = align;
 8001fd8:	2104      	movs	r1, #4
 8001fda:	e9c3 0101 	strd	r0, r1, [r3, #4]
  mp->next = NULL;
 8001fde:	601a      	str	r2, [r3, #0]
  mp->provider = provider;
 8001fe0:	60da      	str	r2, [r3, #12]
 * .
 */

static void rt_test_009_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 8001fe2:	4770      	bx	lr
 8001fe4:	200013d8 	.word	0x200013d8
	...

08001ff0 <rt_test_008_002_execute>:

static void rt_test_008_002_execute(void) {

  /* [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 8001ff0:	4a12      	ldr	r2, [pc, #72]	; (800203c <rt_test_008_002_execute+0x4c>)
static void rt_test_008_002_execute(void) {
 8001ff2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8001ff4:	2601      	movs	r6, #1
 8001ff6:	4f12      	ldr	r7, [pc, #72]	; (8002040 <rt_test_008_002_execute+0x50>)
 8001ff8:	6016      	str	r6, [r2, #0]
 8001ffa:	2507      	movs	r5, #7
 8001ffc:	2400      	movs	r4, #0

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8001ffe:	fa25 f304 	lsr.w	r3, r5, r4
 8002002:	f013 0f01 	tst.w	r3, #1
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8002006:	fa06 f204 	lsl.w	r2, r6, r4
      handlers[eid](eid);
 800200a:	4620      	mov	r0, r4
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 800200c:	d00e      	beq.n	800202c <rt_test_008_002_execute+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
 800200e:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      events &= ~EVENT_MASK(eid);
 8002012:	ea25 0502 	bic.w	r5, r5, r2
      chDbgAssert(handlers[eid] != NULL, "null handler");
 8002016:	b15b      	cbz	r3, 8002030 <rt_test_008_002_execute+0x40>
      handlers[eid](eid);
 8002018:	4798      	blx	r3
    }
    eid++;
 800201a:	3401      	adds	r4, #1
  while (events != (eventmask_t)0) {
 800201c:	2d00      	cmp	r5, #0
 800201e:	d1ee      	bne.n	8001ffe <rt_test_008_002_execute+0xe>
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 8002020:	4908      	ldr	r1, [pc, #32]	; (8002044 <rt_test_008_002_execute+0x54>)
 8002022:	4809      	ldr	r0, [pc, #36]	; (8002048 <rt_test_008_002_execute+0x58>)
  }
}
 8002024:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
 8002028:	f7fe bd1a 	b.w	8000a60 <_test_assert_sequence>
    eid++;
 800202c:	3401      	adds	r4, #1
 800202e:	e7e6      	b.n	8001ffe <rt_test_008_002_execute+0xe>
 8002030:	b672      	cpsid	i
 8002032:	4b06      	ldr	r3, [pc, #24]	; (800204c <rt_test_008_002_execute+0x5c>)
 8002034:	4a06      	ldr	r2, [pc, #24]	; (8002050 <rt_test_008_002_execute+0x60>)
 8002036:	62da      	str	r2, [r3, #44]	; 0x2c
 8002038:	e7fe      	b.n	8002038 <rt_test_008_002_execute+0x48>
 800203a:	bf00      	nop
 800203c:	20001b3c 	.word	0x20001b3c
 8002040:	0800c508 	.word	0x0800c508
 8002044:	0800d774 	.word	0x0800d774
 8002048:	0800d788 	.word	0x0800d788
 800204c:	200011a0 	.word	0x200011a0
 8002050:	0800bf50 	.word	0x0800bf50
	...

08002060 <rt_test_006_009_setup>:
  tqp->next = (thread_t *)tqp;
 8002060:	4906      	ldr	r1, [pc, #24]	; (800207c <rt_test_006_009_setup+0x1c>)
 8002062:	4a07      	ldr	r2, [pc, #28]	; (8002080 <rt_test_006_009_setup+0x20>)
 8002064:	4b07      	ldr	r3, [pc, #28]	; (8002084 <rt_test_006_009_setup+0x24>)
 8002066:	6009      	str	r1, [r1, #0]
 8002068:	2000      	movs	r0, #0
  tqp->prev = (thread_t *)tqp;
 800206a:	6049      	str	r1, [r1, #4]
 800206c:	e9c2 2200 	strd	r2, r2, [r2]
 8002070:	6090      	str	r0, [r2, #8]
 8002072:	6098      	str	r0, [r3, #8]
 8002074:	e9c3 3300 	strd	r3, r3, [r3]

static void rt_test_006_009_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8002078:	4770      	bx	lr
 800207a:	bf00      	nop
 800207c:	20000c04 	.word	0x20000c04
 8002080:	20000c38 	.word	0x20000c38
 8002084:	20000c48 	.word	0x20000c48
	...

08002090 <rt_test_006_008_setup>:
  tqp->next = (thread_t *)tqp;
 8002090:	4a04      	ldr	r2, [pc, #16]	; (80020a4 <rt_test_006_008_setup+0x14>)
 8002092:	4b05      	ldr	r3, [pc, #20]	; (80020a8 <rt_test_006_008_setup+0x18>)
 8002094:	6012      	str	r2, [r2, #0]
 8002096:	2100      	movs	r1, #0
  tqp->prev = (thread_t *)tqp;
 8002098:	6052      	str	r2, [r2, #4]
 800209a:	e9c3 3300 	strd	r3, r3, [r3]
 800209e:	6099      	str	r1, [r3, #8]
}
 80020a0:	4770      	bx	lr
 80020a2:	bf00      	nop
 80020a4:	20000c04 	.word	0x20000c04
 80020a8:	20000c38 	.word	0x20000c38
 80020ac:	00000000 	.word	0x00000000

080020b0 <rt_test_006_007_setup>:
 80020b0:	f7ff bfee 	b.w	8002090 <rt_test_006_008_setup>
	...

080020c0 <rt_test_006_005_setup>:
  tqp->next = (thread_t *)tqp;
 80020c0:	4b02      	ldr	r3, [pc, #8]	; (80020cc <rt_test_006_005_setup+0xc>)
 80020c2:	2200      	movs	r2, #0
  tqp->prev = (thread_t *)tqp;
 80020c4:	e9c3 3300 	strd	r3, r3, [r3]
 80020c8:	609a      	str	r2, [r3, #8]
}
 80020ca:	4770      	bx	lr
 80020cc:	20000c38 	.word	0x20000c38

080020d0 <rt_test_006_001_setup>:
 80020d0:	f7ff bff6 	b.w	80020c0 <rt_test_006_005_setup>
	...

080020e0 <rt_test_006_004_setup>:
  tqp->next = (thread_t *)tqp;
 80020e0:	4a04      	ldr	r2, [pc, #16]	; (80020f4 <rt_test_006_004_setup+0x14>)
 80020e2:	4b05      	ldr	r3, [pc, #20]	; (80020f8 <rt_test_006_004_setup+0x18>)
 80020e4:	6012      	str	r2, [r2, #0]
 80020e6:	2100      	movs	r1, #0
 80020e8:	e9c2 2101 	strd	r2, r1, [r2, #4]
 80020ec:	6099      	str	r1, [r3, #8]
  tqp->prev = (thread_t *)tqp;
 80020ee:	e9c3 3300 	strd	r3, r3, [r3]
}
 80020f2:	4770      	bx	lr
 80020f4:	20000c38 	.word	0x20000c38
 80020f8:	20000c48 	.word	0x20000c48
 80020fc:	00000000 	.word	0x00000000

08002100 <rt_test_005_005_setup>:
  tqp->next = (thread_t *)tqp;
 8002100:	4b02      	ldr	r3, [pc, #8]	; (800210c <rt_test_005_005_setup+0xc>)
 8002102:	2200      	movs	r2, #0
  tqp->prev = (thread_t *)tqp;
 8002104:	e9c3 3300 	strd	r3, r3, [r3]
 8002108:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_005_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 800210a:	4770      	bx	lr
 800210c:	20001408 	.word	0x20001408

08002110 <rt_test_005_004_setup>:
 8002110:	f7ff bff6 	b.w	8002100 <rt_test_005_005_setup>
	...

08002120 <rt_test_005_003_setup>:
 8002120:	f7ff bfee 	b.w	8002100 <rt_test_005_005_setup>
	...

08002130 <rt_test_005_002_setup>:
 8002130:	f7ff bfe6 	b.w	8002100 <rt_test_005_005_setup>
	...

08002140 <rt_test_005_001_setup>:
  tqp->next = (thread_t *)tqp;
 8002140:	4b02      	ldr	r3, [pc, #8]	; (800214c <rt_test_005_001_setup+0xc>)
 8002142:	2201      	movs	r2, #1
  tqp->prev = (thread_t *)tqp;
 8002144:	e9c3 3300 	strd	r3, r3, [r3]
 8002148:	609a      	str	r2, [r3, #8]
}
 800214a:	4770      	bx	lr
 800214c:	20001408 	.word	0x20001408

08002150 <rt_test_001_003_execute>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void rt_test_001_003_execute(void) {
 8002150:	b538      	push	{r3, r4, r5, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 8002152:	4bc9      	ldr	r3, [pc, #804]	; (8002478 <rt_test_001_003_execute+0x328>)
  {
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
    test_printn(CH_CFG_ST_RESOLUTION);
    test_println("");
 8002154:	4cc9      	ldr	r4, [pc, #804]	; (800247c <rt_test_001_003_execute+0x32c>)
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
 8002156:	48ca      	ldr	r0, [pc, #808]	; (8002480 <rt_test_001_003_execute+0x330>)
  test_set_step(1);
 8002158:	2501      	movs	r5, #1
 800215a:	601d      	str	r5, [r3, #0]
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
 800215c:	f7fe fc68 	bl	8000a30 <test_print>
 8002160:	2020      	movs	r0, #32
 8002162:	f7fe fc05 	bl	8000970 <test_printn.part.0>
    test_println("");
 8002166:	4620      	mov	r0, r4
 8002168:	f7fe fc42 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_ST_FREQUENCY:                ");
 800216c:	48c5      	ldr	r0, [pc, #788]	; (8002484 <rt_test_001_003_execute+0x334>)
 800216e:	f7fe fc5f 	bl	8000a30 <test_print>
 8002172:	f242 7010 	movw	r0, #10000	; 0x2710
 8002176:	f7fe fbfb 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_ST_FREQUENCY);
    test_println("");
 800217a:	4620      	mov	r0, r4
 800217c:	f7fe fc38 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_INTERVALS_SIZE:              ");
 8002180:	48c1      	ldr	r0, [pc, #772]	; (8002488 <rt_test_001_003_execute+0x338>)
 8002182:	f7fe fc55 	bl	8000a30 <test_print>
 8002186:	2020      	movs	r0, #32
 8002188:	f7fe fbf2 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_INTERVALS_SIZE);
    test_println("");
 800218c:	4620      	mov	r0, r4
 800218e:	f7fe fc2f 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_TIME_TYPES_SIZE:             ");
 8002192:	48be      	ldr	r0, [pc, #760]	; (800248c <rt_test_001_003_execute+0x33c>)
 8002194:	f7fe fc4c 	bl	8000a30 <test_print>
 8002198:	2020      	movs	r0, #32
 800219a:	f7fe fbe9 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_TIME_TYPES_SIZE);
    test_println("");
 800219e:	4620      	mov	r0, r4
 80021a0:	f7fe fc26 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_ST_TIMEDELTA:                ");
 80021a4:	48ba      	ldr	r0, [pc, #744]	; (8002490 <rt_test_001_003_execute+0x340>)
 80021a6:	f7fe fc43 	bl	8000a30 <test_print>
 80021aa:	2002      	movs	r0, #2
 80021ac:	f7fe fbe0 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_ST_TIMEDELTA);
    test_println("");
 80021b0:	4620      	mov	r0, r4
 80021b2:	f7fe fc1d 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_TIME_QUANTUM:                ");
 80021b6:	48b7      	ldr	r0, [pc, #732]	; (8002494 <rt_test_001_003_execute+0x344>)
 80021b8:	f7fe fc3a 	bl	8000a30 <test_print>
    test_printn(CH_CFG_TIME_QUANTUM);
 80021bc:	2000      	movs	r0, #0
 80021be:	f7fe fc07 	bl	80009d0 <test_printn>
    test_println("");
 80021c2:	4620      	mov	r0, r4
 80021c4:	f7fe fc14 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_MEMCORE_SIZE:                ");
 80021c8:	48b3      	ldr	r0, [pc, #716]	; (8002498 <rt_test_001_003_execute+0x348>)
 80021ca:	f7fe fc31 	bl	8000a30 <test_print>
    test_printn(CH_CFG_MEMCORE_SIZE);
 80021ce:	2000      	movs	r0, #0
 80021d0:	f7fe fbfe 	bl	80009d0 <test_printn>
    test_println("");
 80021d4:	4620      	mov	r0, r4
 80021d6:	f7fe fc0b 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_NO_IDLE_THREAD:              ");
 80021da:	48b0      	ldr	r0, [pc, #704]	; (800249c <rt_test_001_003_execute+0x34c>)
 80021dc:	f7fe fc28 	bl	8000a30 <test_print>
    test_printn(CH_CFG_NO_IDLE_THREAD);
 80021e0:	2000      	movs	r0, #0
 80021e2:	f7fe fbf5 	bl	80009d0 <test_printn>
    test_println("");
 80021e6:	4620      	mov	r0, r4
 80021e8:	f7fe fc02 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:              ");
 80021ec:	48ac      	ldr	r0, [pc, #688]	; (80024a0 <rt_test_001_003_execute+0x350>)
 80021ee:	f7fe fc1f 	bl	8000a30 <test_print>
 80021f2:	4628      	mov	r0, r5
 80021f4:	f7fe fbbc 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
    test_println("");
 80021f8:	4620      	mov	r0, r4
 80021fa:	f7fe fbf9 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_TM:                      ");
 80021fe:	48a9      	ldr	r0, [pc, #676]	; (80024a4 <rt_test_001_003_execute+0x354>)
 8002200:	f7fe fc16 	bl	8000a30 <test_print>
 8002204:	4628      	mov	r0, r5
 8002206:	f7fe fbb3 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_TM);
    test_println("");
 800220a:	4620      	mov	r0, r4
 800220c:	f7fe fbf0 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_REGISTRY:                ");
 8002210:	48a5      	ldr	r0, [pc, #660]	; (80024a8 <rt_test_001_003_execute+0x358>)
 8002212:	f7fe fc0d 	bl	8000a30 <test_print>
 8002216:	4628      	mov	r0, r5
 8002218:	f7fe fbaa 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_REGISTRY);
    test_println("");
 800221c:	4620      	mov	r0, r4
 800221e:	f7fe fbe7 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_WAITEXIT:                ");
 8002222:	48a2      	ldr	r0, [pc, #648]	; (80024ac <rt_test_001_003_execute+0x35c>)
 8002224:	f7fe fc04 	bl	8000a30 <test_print>
 8002228:	4628      	mov	r0, r5
 800222a:	f7fe fba1 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_WAITEXIT);
    test_println("");
 800222e:	4620      	mov	r0, r4
 8002230:	f7fe fbde 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES:              ");
 8002234:	489e      	ldr	r0, [pc, #632]	; (80024b0 <rt_test_001_003_execute+0x360>)
 8002236:	f7fe fbfb 	bl	8000a30 <test_print>
 800223a:	4628      	mov	r0, r5
 800223c:	f7fe fb98 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_SEMAPHORES);
    test_println("");
 8002240:	4620      	mov	r0, r4
 8002242:	f7fe fbd5 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRI:          ");
 8002246:	489b      	ldr	r0, [pc, #620]	; (80024b4 <rt_test_001_003_execute+0x364>)
 8002248:	f7fe fbf2 	bl	8000a30 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
 800224c:	2000      	movs	r0, #0
 800224e:	f7fe fbbf 	bl	80009d0 <test_printn>
    test_println("");
 8002252:	4620      	mov	r0, r4
 8002254:	f7fe fbcc 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES:                 ");
 8002258:	4897      	ldr	r0, [pc, #604]	; (80024b8 <rt_test_001_003_execute+0x368>)
 800225a:	f7fe fbe9 	bl	8000a30 <test_print>
 800225e:	4628      	mov	r0, r5
 8002260:	f7fe fb86 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_MUTEXES);
    test_println("");
 8002264:	4620      	mov	r0, r4
 8002266:	f7fe fbc3 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES_RECURS:          ");
 800226a:	4894      	ldr	r0, [pc, #592]	; (80024bc <rt_test_001_003_execute+0x36c>)
 800226c:	f7fe fbe0 	bl	8000a30 <test_print>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
 8002270:	2000      	movs	r0, #0
 8002272:	f7fe fbad 	bl	80009d0 <test_printn>
    test_println("");   
 8002276:	4620      	mov	r0, r4
 8002278:	f7fe fbba 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS:                ");
 800227c:	4890      	ldr	r0, [pc, #576]	; (80024c0 <rt_test_001_003_execute+0x370>)
 800227e:	f7fe fbd7 	bl	8000a30 <test_print>
 8002282:	4628      	mov	r0, r5
 8002284:	f7fe fb74 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_CONDVARS);
    test_println("");
 8002288:	4620      	mov	r0, r4
 800228a:	f7fe fbb1 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEO:          ");
 800228e:	488d      	ldr	r0, [pc, #564]	; (80024c4 <rt_test_001_003_execute+0x374>)
 8002290:	f7fe fbce 	bl	8000a30 <test_print>
 8002294:	4628      	mov	r0, r5
 8002296:	f7fe fb6b 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
    test_println("");
 800229a:	4620      	mov	r0, r4
 800229c:	f7fe fba8 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_EVENTS:                  ");
 80022a0:	4889      	ldr	r0, [pc, #548]	; (80024c8 <rt_test_001_003_execute+0x378>)
 80022a2:	f7fe fbc5 	bl	8000a30 <test_print>
 80022a6:	4628      	mov	r0, r5
 80022a8:	f7fe fb62 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_EVENTS);
    test_println("");
 80022ac:	4620      	mov	r0, r4
 80022ae:	f7fe fb9f 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT:          ");
 80022b2:	4886      	ldr	r0, [pc, #536]	; (80024cc <rt_test_001_003_execute+0x37c>)
 80022b4:	f7fe fbbc 	bl	8000a30 <test_print>
 80022b8:	4628      	mov	r0, r5
 80022ba:	f7fe fb59 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
    test_println("");
 80022be:	4620      	mov	r0, r4
 80022c0:	f7fe fb96 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES:                ");
 80022c4:	4882      	ldr	r0, [pc, #520]	; (80024d0 <rt_test_001_003_execute+0x380>)
 80022c6:	f7fe fbb3 	bl	8000a30 <test_print>
 80022ca:	4628      	mov	r0, r5
 80022cc:	f7fe fb50 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_MESSAGES);
    test_println("");
 80022d0:	4620      	mov	r0, r4
 80022d2:	f7fe fb8d 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES_PRI:            ");
 80022d6:	487f      	ldr	r0, [pc, #508]	; (80024d4 <rt_test_001_003_execute+0x384>)
 80022d8:	f7fe fbaa 	bl	8000a30 <test_print>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
 80022dc:	2000      	movs	r0, #0
 80022de:	f7fe fb77 	bl	80009d0 <test_printn>
    test_println("");
 80022e2:	4620      	mov	r0, r4
 80022e4:	f7fe fb84 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
 80022e8:	487b      	ldr	r0, [pc, #492]	; (80024d8 <rt_test_001_003_execute+0x388>)
 80022ea:	f7fe fba1 	bl	8000a30 <test_print>
 80022ee:	4628      	mov	r0, r5
 80022f0:	f7fe fb3e 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_MAILBOXES);
    test_println("");
 80022f4:	4620      	mov	r0, r4
 80022f6:	f7fe fb7b 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_MEMCORE:                 ");
 80022fa:	4878      	ldr	r0, [pc, #480]	; (80024dc <rt_test_001_003_execute+0x38c>)
 80022fc:	f7fe fb98 	bl	8000a30 <test_print>
 8002300:	4628      	mov	r0, r5
 8002302:	f7fe fb35 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_MEMCORE);
    test_println("");
 8002306:	4620      	mov	r0, r4
 8002308:	f7fe fb72 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_HEAP:                    ");
 800230c:	4874      	ldr	r0, [pc, #464]	; (80024e0 <rt_test_001_003_execute+0x390>)
 800230e:	f7fe fb8f 	bl	8000a30 <test_print>
 8002312:	4628      	mov	r0, r5
 8002314:	f7fe fb2c 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_HEAP);
    test_println("");
 8002318:	4620      	mov	r0, r4
 800231a:	f7fe fb69 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_MEMPOOLS:                ");
 800231e:	4871      	ldr	r0, [pc, #452]	; (80024e4 <rt_test_001_003_execute+0x394>)
 8002320:	f7fe fb86 	bl	8000a30 <test_print>
 8002324:	4628      	mov	r0, r5
 8002326:	f7fe fb23 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_MEMPOOLS);
    test_println("");
 800232a:	4620      	mov	r0, r4
 800232c:	f7fe fb60 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_OBJ_FIFOS:               ");
 8002330:	486d      	ldr	r0, [pc, #436]	; (80024e8 <rt_test_001_003_execute+0x398>)
 8002332:	f7fe fb7d 	bl	8000a30 <test_print>
 8002336:	4628      	mov	r0, r5
 8002338:	f7fe fb1a 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_OBJ_FIFOS);
    test_println("");
 800233c:	4620      	mov	r0, r4
 800233e:	f7fe fb57 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_DYNAMIC:                 ");
 8002342:	486a      	ldr	r0, [pc, #424]	; (80024ec <rt_test_001_003_execute+0x39c>)
 8002344:	f7fe fb74 	bl	8000a30 <test_print>
 8002348:	4628      	mov	r0, r5
 800234a:	f7fe fb11 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_DYNAMIC);
    test_println("");
 800234e:	4620      	mov	r0, r4
 8002350:	f7fe fb4e 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_USE_FACTORY:                 ");
 8002354:	4866      	ldr	r0, [pc, #408]	; (80024f0 <rt_test_001_003_execute+0x3a0>)
 8002356:	f7fe fb6b 	bl	8000a30 <test_print>
 800235a:	4628      	mov	r0, r5
 800235c:	f7fe fb08 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_USE_FACTORY);
    test_println("");
 8002360:	4620      	mov	r0, r4
 8002362:	f7fe fb45 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_FACTORY_MAX_NAMES_LENGTH:    ");
 8002366:	4863      	ldr	r0, [pc, #396]	; (80024f4 <rt_test_001_003_execute+0x3a4>)
 8002368:	f7fe fb62 	bl	8000a30 <test_print>
 800236c:	2008      	movs	r0, #8
 800236e:	f7fe faff 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_MAX_NAMES_LENGTH);
    test_println("");
 8002372:	4620      	mov	r0, r4
 8002374:	f7fe fb3c 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJECTS_REGISTRY:    ");
 8002378:	485f      	ldr	r0, [pc, #380]	; (80024f8 <rt_test_001_003_execute+0x3a8>)
 800237a:	f7fe fb59 	bl	8000a30 <test_print>
 800237e:	4628      	mov	r0, r5
 8002380:	f7fe faf6 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_OBJECTS_REGISTRY);
    test_println("");
 8002384:	4620      	mov	r0, r4
 8002386:	f7fe fb33 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_FACTORY_GENERIC_BUFFERS:     ");
 800238a:	485c      	ldr	r0, [pc, #368]	; (80024fc <rt_test_001_003_execute+0x3ac>)
 800238c:	f7fe fb50 	bl	8000a30 <test_print>
 8002390:	4628      	mov	r0, r5
 8002392:	f7fe faed 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_GENERIC_BUFFERS);
    test_println("");
 8002396:	4620      	mov	r0, r4
 8002398:	f7fe fb2a 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_FACTORY_SEMAPHORES:          ");
 800239c:	4858      	ldr	r0, [pc, #352]	; (8002500 <rt_test_001_003_execute+0x3b0>)
 800239e:	f7fe fb47 	bl	8000a30 <test_print>
 80023a2:	4628      	mov	r0, r5
 80023a4:	f7fe fae4 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_SEMAPHORES);
    test_println("");
 80023a8:	4620      	mov	r0, r4
 80023aa:	f7fe fb21 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_FACTORY_MAILBOXES:           ");
 80023ae:	4855      	ldr	r0, [pc, #340]	; (8002504 <rt_test_001_003_execute+0x3b4>)
 80023b0:	f7fe fb3e 	bl	8000a30 <test_print>
 80023b4:	4628      	mov	r0, r5
 80023b6:	f7fe fadb 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_MAILBOXES);
    test_println("");
 80023ba:	4620      	mov	r0, r4
 80023bc:	f7fe fb18 	bl	80009f0 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJ_FIFOS:           ");
 80023c0:	4851      	ldr	r0, [pc, #324]	; (8002508 <rt_test_001_003_execute+0x3b8>)
 80023c2:	f7fe fb35 	bl	8000a30 <test_print>
 80023c6:	4628      	mov	r0, r5
 80023c8:	f7fe fad2 	bl	8000970 <test_printn.part.0>
    test_printn(CH_CFG_FACTORY_OBJ_FIFOS);
    test_println("");
 80023cc:	4620      	mov	r0, r4
 80023ce:	f7fe fb0f 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_STATISTICS:                  ");
 80023d2:	484e      	ldr	r0, [pc, #312]	; (800250c <rt_test_001_003_execute+0x3bc>)
 80023d4:	f7fe fb2c 	bl	8000a30 <test_print>
    test_printn(CH_DBG_STATISTICS);
 80023d8:	2000      	movs	r0, #0
 80023da:	f7fe faf9 	bl	80009d0 <test_printn>
    test_println("");
 80023de:	4620      	mov	r0, r4
 80023e0:	f7fe fb06 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK:          ");
 80023e4:	484a      	ldr	r0, [pc, #296]	; (8002510 <rt_test_001_003_execute+0x3c0>)
 80023e6:	f7fe fb23 	bl	8000a30 <test_print>
 80023ea:	4628      	mov	r0, r5
 80023ec:	f7fe fac0 	bl	8000970 <test_printn.part.0>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
    test_println("");
 80023f0:	4620      	mov	r0, r4
 80023f2:	f7fe fafd 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_ENABLE_CHECKS:               ");
 80023f6:	4847      	ldr	r0, [pc, #284]	; (8002514 <rt_test_001_003_execute+0x3c4>)
 80023f8:	f7fe fb1a 	bl	8000a30 <test_print>
 80023fc:	4628      	mov	r0, r5
 80023fe:	f7fe fab7 	bl	8000970 <test_printn.part.0>
    test_printn(CH_DBG_ENABLE_CHECKS);
    test_println("");
 8002402:	4620      	mov	r0, r4
 8002404:	f7fe faf4 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_ENABLE_ASSERTS:              ");
 8002408:	4843      	ldr	r0, [pc, #268]	; (8002518 <rt_test_001_003_execute+0x3c8>)
 800240a:	f7fe fb11 	bl	8000a30 <test_print>
 800240e:	4628      	mov	r0, r5
 8002410:	f7fe faae 	bl	8000970 <test_printn.part.0>
    test_printn(CH_DBG_ENABLE_ASSERTS);
    test_println("");
 8002414:	4620      	mov	r0, r4
 8002416:	f7fe faeb 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_TRACE_MASK:                  ");
 800241a:	4840      	ldr	r0, [pc, #256]	; (800251c <rt_test_001_003_execute+0x3cc>)
 800241c:	f7fe fb08 	bl	8000a30 <test_print>
 8002420:	20ff      	movs	r0, #255	; 0xff
 8002422:	f7fe faa5 	bl	8000970 <test_printn.part.0>
    test_printn(CH_DBG_TRACE_MASK);
    test_println("");
 8002426:	4620      	mov	r0, r4
 8002428:	f7fe fae2 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:           ");
 800242c:	483c      	ldr	r0, [pc, #240]	; (8002520 <rt_test_001_003_execute+0x3d0>)
 800242e:	f7fe faff 	bl	8000a30 <test_print>
 8002432:	2080      	movs	r0, #128	; 0x80
 8002434:	f7fe fa9c 	bl	8000970 <test_printn.part.0>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
    test_println("");
 8002438:	4620      	mov	r0, r4
 800243a:	f7fe fad9 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK:          ");
 800243e:	4839      	ldr	r0, [pc, #228]	; (8002524 <rt_test_001_003_execute+0x3d4>)
 8002440:	f7fe faf6 	bl	8000a30 <test_print>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
 8002444:	2000      	movs	r0, #0
 8002446:	f7fe fac3 	bl	80009d0 <test_printn>
    test_println("");
 800244a:	4620      	mov	r0, r4
 800244c:	f7fe fad0 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_FILL_THREADS:                ");
 8002450:	4835      	ldr	r0, [pc, #212]	; (8002528 <rt_test_001_003_execute+0x3d8>)
 8002452:	f7fe faed 	bl	8000a30 <test_print>
    test_printn(CH_DBG_FILL_THREADS);
 8002456:	2000      	movs	r0, #0
 8002458:	f7fe faba 	bl	80009d0 <test_printn>
    test_println("");
 800245c:	4620      	mov	r0, r4
 800245e:	f7fe fac7 	bl	80009f0 <test_println>
    test_print("--- CH_DBG_THREADS_PROFILING:           ");
 8002462:	4832      	ldr	r0, [pc, #200]	; (800252c <rt_test_001_003_execute+0x3dc>)
 8002464:	f7fe fae4 	bl	8000a30 <test_print>
    test_printn(CH_DBG_THREADS_PROFILING);
 8002468:	2000      	movs	r0, #0
 800246a:	f7fe fab1 	bl	80009d0 <test_printn>
    test_println("");
 800246e:	4620      	mov	r0, r4
  }
}
 8002470:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println("");
 8002474:	f7fe babc 	b.w	80009f0 <test_println>
 8002478:	20001b3c 	.word	0x20001b3c
 800247c:	0800dcec 	.word	0x0800dcec
 8002480:	0800cc38 	.word	0x0800cc38
 8002484:	0800cc64 	.word	0x0800cc64
 8002488:	0800cc90 	.word	0x0800cc90
 800248c:	0800ccbc 	.word	0x0800ccbc
 8002490:	0800cce8 	.word	0x0800cce8
 8002494:	0800cd14 	.word	0x0800cd14
 8002498:	0800cd40 	.word	0x0800cd40
 800249c:	0800cd6c 	.word	0x0800cd6c
 80024a0:	0800cd98 	.word	0x0800cd98
 80024a4:	0800cdc4 	.word	0x0800cdc4
 80024a8:	0800cdf0 	.word	0x0800cdf0
 80024ac:	0800ce1c 	.word	0x0800ce1c
 80024b0:	0800ce48 	.word	0x0800ce48
 80024b4:	0800ce74 	.word	0x0800ce74
 80024b8:	0800cea0 	.word	0x0800cea0
 80024bc:	0800cecc 	.word	0x0800cecc
 80024c0:	0800cef8 	.word	0x0800cef8
 80024c4:	0800cf24 	.word	0x0800cf24
 80024c8:	0800cf50 	.word	0x0800cf50
 80024cc:	0800cf7c 	.word	0x0800cf7c
 80024d0:	0800cfa8 	.word	0x0800cfa8
 80024d4:	0800cfd4 	.word	0x0800cfd4
 80024d8:	0800d000 	.word	0x0800d000
 80024dc:	0800d02c 	.word	0x0800d02c
 80024e0:	0800d058 	.word	0x0800d058
 80024e4:	0800d084 	.word	0x0800d084
 80024e8:	0800d0b0 	.word	0x0800d0b0
 80024ec:	0800d0dc 	.word	0x0800d0dc
 80024f0:	0800d108 	.word	0x0800d108
 80024f4:	0800d134 	.word	0x0800d134
 80024f8:	0800d160 	.word	0x0800d160
 80024fc:	0800d18c 	.word	0x0800d18c
 8002500:	0800d1b8 	.word	0x0800d1b8
 8002504:	0800d1e4 	.word	0x0800d1e4
 8002508:	0800d210 	.word	0x0800d210
 800250c:	0800d23c 	.word	0x0800d23c
 8002510:	0800d268 	.word	0x0800d268
 8002514:	0800d294 	.word	0x0800d294
 8002518:	0800d2c0 	.word	0x0800d2c0
 800251c:	0800d2ec 	.word	0x0800d2ec
 8002520:	0800d318 	.word	0x0800d318
 8002524:	0800d344 	.word	0x0800d344
 8002528:	0800d370 	.word	0x0800d370
 800252c:	0800d39c 	.word	0x0800d39c

08002530 <rt_test_001_002_execute>:
  test_set_step(1);
 8002530:	4b19      	ldr	r3, [pc, #100]	; (8002598 <rt_test_001_002_execute+0x68>)
    test_println("--- Product:                            ChibiOS/RT");
 8002532:	481a      	ldr	r0, [pc, #104]	; (800259c <rt_test_001_002_execute+0x6c>)
static void rt_test_001_002_execute(void) {
 8002534:	b510      	push	{r4, lr}
  test_set_step(1);
 8002536:	2201      	movs	r2, #1
 8002538:	601a      	str	r2, [r3, #0]
    test_println("");
 800253a:	4c19      	ldr	r4, [pc, #100]	; (80025a0 <rt_test_001_002_execute+0x70>)
    test_println("--- Product:                            ChibiOS/RT");
 800253c:	f7fe fa58 	bl	80009f0 <test_println>
    test_print("--- Stable Flag:                        ");
 8002540:	4818      	ldr	r0, [pc, #96]	; (80025a4 <rt_test_001_002_execute+0x74>)
 8002542:	f7fe fa75 	bl	8000a30 <test_print>
    test_printn(CH_KERNEL_STABLE);
 8002546:	2000      	movs	r0, #0
 8002548:	f7fe fa42 	bl	80009d0 <test_printn>
    test_println("");
 800254c:	4620      	mov	r0, r4
 800254e:	f7fe fa4f 	bl	80009f0 <test_println>
    test_print("--- Version String:                     ");
 8002552:	4815      	ldr	r0, [pc, #84]	; (80025a8 <rt_test_001_002_execute+0x78>)
 8002554:	f7fe fa6c 	bl	8000a30 <test_print>
    test_println(CH_KERNEL_VERSION);
 8002558:	4814      	ldr	r0, [pc, #80]	; (80025ac <rt_test_001_002_execute+0x7c>)
 800255a:	f7fe fa49 	bl	80009f0 <test_println>
    test_print("--- Major Number:                       ");
 800255e:	4814      	ldr	r0, [pc, #80]	; (80025b0 <rt_test_001_002_execute+0x80>)
 8002560:	f7fe fa66 	bl	8000a30 <test_print>
 8002564:	2005      	movs	r0, #5
 8002566:	f7fe fa03 	bl	8000970 <test_printn.part.0>
    test_println("");
 800256a:	4620      	mov	r0, r4
 800256c:	f7fe fa40 	bl	80009f0 <test_println>
    test_print("--- Minor Number:                       ");
 8002570:	4810      	ldr	r0, [pc, #64]	; (80025b4 <rt_test_001_002_execute+0x84>)
 8002572:	f7fe fa5d 	bl	8000a30 <test_print>
    test_printn(CH_KERNEL_MINOR);
 8002576:	2000      	movs	r0, #0
 8002578:	f7fe fa2a 	bl	80009d0 <test_printn>
    test_println("");
 800257c:	4620      	mov	r0, r4
 800257e:	f7fe fa37 	bl	80009f0 <test_println>
    test_print("--- Patch Number:                       ");
 8002582:	480d      	ldr	r0, [pc, #52]	; (80025b8 <rt_test_001_002_execute+0x88>)
 8002584:	f7fe fa54 	bl	8000a30 <test_print>
    test_printn(CH_KERNEL_PATCH);
 8002588:	2000      	movs	r0, #0
 800258a:	f7fe fa21 	bl	80009d0 <test_printn>
    test_println("");
 800258e:	4620      	mov	r0, r4
}
 8002590:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    test_println("");
 8002594:	f7fe ba2c 	b.w	80009f0 <test_println>
 8002598:	20001b3c 	.word	0x20001b3c
 800259c:	0800cb10 	.word	0x0800cb10
 80025a0:	0800dcec 	.word	0x0800dcec
 80025a4:	0800cb44 	.word	0x0800cb44
 80025a8:	0800cb70 	.word	0x0800cb70
 80025ac:	0800cb9c 	.word	0x0800cb9c
 80025b0:	0800cba4 	.word	0x0800cba4
 80025b4:	0800cbd0 	.word	0x0800cbd0
 80025b8:	0800cbfc 	.word	0x0800cbfc
 80025bc:	00000000 	.word	0x00000000

080025c0 <rt_test_001_001_execute>:
  test_set_step(1);
 80025c0:	4b1c      	ldr	r3, [pc, #112]	; (8002634 <rt_test_001_001_execute+0x74>)
    test_print("--- Architecture:                       ");
 80025c2:	481d      	ldr	r0, [pc, #116]	; (8002638 <rt_test_001_001_execute+0x78>)
static void rt_test_001_001_execute(void) {
 80025c4:	b510      	push	{r4, lr}
  test_set_step(1);
 80025c6:	2201      	movs	r2, #1
 80025c8:	601a      	str	r2, [r3, #0]
    test_print("--- Architecture:                       ");
 80025ca:	f7fe fa31 	bl	8000a30 <test_print>
    test_println(PORT_ARCHITECTURE_NAME);
 80025ce:	481b      	ldr	r0, [pc, #108]	; (800263c <rt_test_001_001_execute+0x7c>)
    test_println("");
 80025d0:	4c1b      	ldr	r4, [pc, #108]	; (8002640 <rt_test_001_001_execute+0x80>)
    test_println(PORT_ARCHITECTURE_NAME);
 80025d2:	f7fe fa0d 	bl	80009f0 <test_println>
    test_print("--- Core Variant:                       ");
 80025d6:	481b      	ldr	r0, [pc, #108]	; (8002644 <rt_test_001_001_execute+0x84>)
 80025d8:	f7fe fa2a 	bl	8000a30 <test_print>
    test_println(PORT_CORE_VARIANT_NAME);
 80025dc:	481a      	ldr	r0, [pc, #104]	; (8002648 <rt_test_001_001_execute+0x88>)
 80025de:	f7fe fa07 	bl	80009f0 <test_println>
    test_print("--- Compiler:                           ");
 80025e2:	481a      	ldr	r0, [pc, #104]	; (800264c <rt_test_001_001_execute+0x8c>)
 80025e4:	f7fe fa24 	bl	8000a30 <test_print>
    test_println(PORT_COMPILER_NAME);
 80025e8:	4819      	ldr	r0, [pc, #100]	; (8002650 <rt_test_001_001_execute+0x90>)
 80025ea:	f7fe fa01 	bl	80009f0 <test_println>
    test_print("--- Port Info:                          ");
 80025ee:	4819      	ldr	r0, [pc, #100]	; (8002654 <rt_test_001_001_execute+0x94>)
 80025f0:	f7fe fa1e 	bl	8000a30 <test_print>
    test_println(PORT_INFO);
 80025f4:	4818      	ldr	r0, [pc, #96]	; (8002658 <rt_test_001_001_execute+0x98>)
 80025f6:	f7fe f9fb 	bl	80009f0 <test_println>
    test_print("--- Natural alignment:                  ");
 80025fa:	4818      	ldr	r0, [pc, #96]	; (800265c <rt_test_001_001_execute+0x9c>)
 80025fc:	f7fe fa18 	bl	8000a30 <test_print>
 8002600:	2004      	movs	r0, #4
 8002602:	f7fe f9b5 	bl	8000970 <test_printn.part.0>
    test_println("");
 8002606:	4620      	mov	r0, r4
 8002608:	f7fe f9f2 	bl	80009f0 <test_println>
    test_print("--- Stack alignment:                    ");
 800260c:	4814      	ldr	r0, [pc, #80]	; (8002660 <rt_test_001_001_execute+0xa0>)
 800260e:	f7fe fa0f 	bl	8000a30 <test_print>
 8002612:	2008      	movs	r0, #8
 8002614:	f7fe f9ac 	bl	8000970 <test_printn.part.0>
    test_println("");
 8002618:	4620      	mov	r0, r4
 800261a:	f7fe f9e9 	bl	80009f0 <test_println>
    test_print("--- Working area alignment:             ");
 800261e:	4811      	ldr	r0, [pc, #68]	; (8002664 <rt_test_001_001_execute+0xa4>)
 8002620:	f7fe fa06 	bl	8000a30 <test_print>
 8002624:	2008      	movs	r0, #8
 8002626:	f7fe f9a3 	bl	8000970 <test_printn.part.0>
    test_println("");
 800262a:	4620      	mov	r0, r4
}
 800262c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    test_println("");
 8002630:	f7fe b9de 	b.w	80009f0 <test_println>
 8002634:	20001b3c 	.word	0x20001b3c
 8002638:	0800c954 	.word	0x0800c954
 800263c:	0800c980 	.word	0x0800c980
 8002640:	0800dcec 	.word	0x0800dcec
 8002644:	0800c98c 	.word	0x0800c98c
 8002648:	0800c9b8 	.word	0x0800c9b8
 800264c:	0800c9c4 	.word	0x0800c9c4
 8002650:	0800c9f0 	.word	0x0800c9f0
 8002654:	0800ca38 	.word	0x0800ca38
 8002658:	0800ca64 	.word	0x0800ca64
 800265c:	0800ca7c 	.word	0x0800ca7c
 8002660:	0800caa8 	.word	0x0800caa8
 8002664:	0800cad4 	.word	0x0800cad4
	...

08002670 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
 8002670:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002674:	4614      	mov	r4, r2
  osalDbgCheckClassI();
 8002676:	f7fe fab3 	bl	8000be0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 800267a:	b198      	cbz	r0, 80026a4 <usbInitEndpointI+0x34>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 800267c:	7803      	ldrb	r3, [r0, #0]
 800267e:	2b04      	cmp	r3, #4
 8002680:	d10b      	bne.n	800269a <usbInitEndpointI+0x2a>
 8002682:	b20e      	sxth	r6, r1
 8002684:	eb00 0886 	add.w	r8, r0, r6, lsl #2
 8002688:	460d      	mov	r5, r1
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 800268a:	f8d8 100c 	ldr.w	r1, [r8, #12]
 800268e:	b171      	cbz	r1, 80026ae <usbInitEndpointI+0x3e>
 8002690:	b672      	cpsid	i
 8002692:	4b62      	ldr	r3, [pc, #392]	; (800281c <usbInitEndpointI+0x1ac>)
 8002694:	4a62      	ldr	r2, [pc, #392]	; (8002820 <usbInitEndpointI+0x1b0>)
 8002696:	62da      	str	r2, [r3, #44]	; 0x2c
 8002698:	e7fe      	b.n	8002698 <usbInitEndpointI+0x28>
 800269a:	b672      	cpsid	i
 800269c:	4b5f      	ldr	r3, [pc, #380]	; (800281c <usbInitEndpointI+0x1ac>)
 800269e:	4a60      	ldr	r2, [pc, #384]	; (8002820 <usbInitEndpointI+0x1b0>)
 80026a0:	62da      	str	r2, [r3, #44]	; 0x2c
 80026a2:	e7fe      	b.n	80026a2 <usbInitEndpointI+0x32>
 80026a4:	b672      	cpsid	i
 80026a6:	4b5d      	ldr	r3, [pc, #372]	; (800281c <usbInitEndpointI+0x1ac>)
 80026a8:	4a5d      	ldr	r2, [pc, #372]	; (8002820 <usbInitEndpointI+0x1b0>)
 80026aa:	62da      	str	r2, [r3, #44]	; 0x2c
 80026ac:	e7fe      	b.n	80026ac <usbInitEndpointI+0x3c>
  if (epcp->in_state != NULL) {
 80026ae:	6963      	ldr	r3, [r4, #20]
  usbp->epc[ep] = epcp;
 80026b0:	f8c8 400c 	str.w	r4, [r8, #12]
  if (epcp->in_state != NULL) {
 80026b4:	b11b      	cbz	r3, 80026be <usbInitEndpointI+0x4e>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 80026b6:	6019      	str	r1, [r3, #0]
 80026b8:	6059      	str	r1, [r3, #4]
 80026ba:	6099      	str	r1, [r3, #8]
 80026bc:	60d9      	str	r1, [r3, #12]
  if (epcp->out_state != NULL) {
 80026be:	69a3      	ldr	r3, [r4, #24]
 80026c0:	b123      	cbz	r3, 80026cc <usbInitEndpointI+0x5c>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80026c2:	2200      	movs	r2, #0
 80026c4:	601a      	str	r2, [r3, #0]
 80026c6:	605a      	str	r2, [r3, #4]
 80026c8:	609a      	str	r2, [r3, #8]
 80026ca:	60da      	str	r2, [r3, #12]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80026cc:	f8d8 200c 	ldr.w	r2, [r8, #12]
  stm32_otg_t *otgp = usbp->otg;
 80026d0:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80026d2:	6813      	ldr	r3, [r2, #0]
 80026d4:	f003 0303 	and.w	r3, r3, #3
 80026d8:	2b02      	cmp	r3, #2
 80026da:	d063      	beq.n	80027a4 <usbInitEndpointI+0x134>
 80026dc:	2b03      	cmp	r3, #3
 80026de:	f000 809a 	beq.w	8002816 <usbInitEndpointI+0x1a6>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 80026e2:	4f50      	ldr	r7, [pc, #320]	; (8002824 <usbInitEndpointI+0x1b4>)
 80026e4:	4950      	ldr	r1, [pc, #320]	; (8002828 <usbInitEndpointI+0x1b8>)
 80026e6:	2b01      	cmp	r3, #1
 80026e8:	bf18      	it	ne
 80026ea:	460f      	movne	r7, r1
  otgp->oe[ep].DOEPTSIZ = 0;
 80026ec:	016b      	lsls	r3, r5, #5
 80026ee:	18e1      	adds	r1, r4, r3
 80026f0:	f04f 0e00 	mov.w	lr, #0
  if (usbp->epc[ep]->out_state != NULL) {
 80026f4:	f8d2 c018 	ldr.w	ip, [r2, #24]
  otgp->oe[ep].DOEPTSIZ = 0;
 80026f8:	f8c1 eb10 	str.w	lr, [r1, #2832]	; 0xb10
 80026fc:	f105 0110 	add.w	r1, r5, #16
 8002700:	f04f 0e01 	mov.w	lr, #1
 8002704:	fa0e f101 	lsl.w	r1, lr, r1
  if (usbp->epc[ep]->out_state != NULL) {
 8002708:	f1bc 0f00 	cmp.w	ip, #0
 800270c:	d074      	beq.n	80027f8 <usbInitEndpointI+0x188>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 800270e:	f8b2 e012 	ldrh.w	lr, [r2, #18]
 8002712:	f105 0c58 	add.w	ip, r5, #88	; 0x58
 8002716:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
 800271a:	ea4e 0e07 	orr.w	lr, lr, r7
 800271e:	f844 e00c 	str.w	lr, [r4, ip]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8002722:	f8d4 c81c 	ldr.w	ip, [r4, #2076]	; 0x81c
 8002726:	ea4c 0101 	orr.w	r1, ip, r1
 800272a:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
 800272e:	4423      	add	r3, r4
  if (usbp->epc[ep]->in_state != NULL) {
 8002730:	6951      	ldr	r1, [r2, #20]
  otgp->ie[ep].DIEPTSIZ = 0;
 8002732:	f04f 0c00 	mov.w	ip, #0
 8002736:	f8c3 c910 	str.w	ip, [r3, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 800273a:	2900      	cmp	r1, #0
 800273c:	d039      	beq.n	80027b2 <usbInitEndpointI+0x142>
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800273e:	8a13      	ldrh	r3, [r2, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8002740:	8b92      	ldrh	r2, [r2, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8002742:	089b      	lsrs	r3, r3, #2
    if (usbp->epc[ep]->in_multiplier > 1)
 8002744:	2a01      	cmp	r2, #1
      fsize *= usbp->epc[ep]->in_multiplier;
 8002746:	bf88      	it	hi
 8002748:	4353      	mulhi	r3, r2
 800274a:	e9d0 211c 	ldrd	r2, r1, [r0, #112]	; 0x70
  usbp->pmnext += size;
 800274e:	185e      	adds	r6, r3, r1
 8002750:	6746      	str	r6, [r0, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8002752:	6852      	ldr	r2, [r2, #4]
 8002754:	4296      	cmp	r6, r2
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8002756:	ea4f 4303 	mov.w	r3, r3, lsl #16
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800275a:	d825      	bhi.n	80027a8 <usbInitEndpointI+0x138>
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800275c:	f105 023f 	add.w	r2, r5, #63	; 0x3f
 8002760:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8002762:	430b      	orrs	r3, r1
 8002764:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8002768:	01a9      	lsls	r1, r5, #6
 800276a:	f041 0120 	orr.w	r1, r1, #32
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800276e:	6053      	str	r3, [r2, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8002770:	6101      	str	r1, [r0, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8002772:	6903      	ldr	r3, [r0, #16]
 8002774:	069a      	lsls	r2, r3, #26
 8002776:	d4fc      	bmi.n	8002772 <usbInitEndpointI+0x102>
  chSysPolledDelayX(cycles);
 8002778:	2012      	movs	r0, #18
 800277a:	f7fe fd31 	bl	80011e0 <chSysPolledDelayX>
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 800277e:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8002782:	8a1b      	ldrh	r3, [r3, #16]
    otgp->ie[ep].DIEPCTL = ctl |
 8002784:	f105 0248 	add.w	r2, r5, #72	; 0x48
                           DIEPCTL_TXFNUM(ep) |
 8002788:	ea43 5385 	orr.w	r3, r3, r5, lsl #22
    otgp->ie[ep].DIEPCTL = ctl |
 800278c:	0152      	lsls	r2, r2, #5
                           DIEPCTL_TXFNUM(ep) |
 800278e:	431f      	orrs	r7, r3
    otgp->ie[ep].DIEPCTL = ctl |
 8002790:	50a7      	str	r7, [r4, r2]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8002792:	2301      	movs	r3, #1
 8002794:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 8002798:	40ab      	lsls	r3, r5
 800279a:	4313      	orrs	r3, r2
 800279c:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
}
 80027a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 80027a4:	4f21      	ldr	r7, [pc, #132]	; (800282c <usbInitEndpointI+0x1bc>)
 80027a6:	e7a1      	b.n	80026ec <usbInitEndpointI+0x7c>
 80027a8:	b672      	cpsid	i
 80027aa:	4b1c      	ldr	r3, [pc, #112]	; (800281c <usbInitEndpointI+0x1ac>)
 80027ac:	4a20      	ldr	r2, [pc, #128]	; (8002830 <usbInitEndpointI+0x1c0>)
 80027ae:	62da      	str	r2, [r3, #44]	; 0x2c
 80027b0:	e7fe      	b.n	80027b0 <usbInitEndpointI+0x140>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80027b2:	f105 033f 	add.w	r3, r5, #63	; 0x3f
 80027b6:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 80027b8:	481e      	ldr	r0, [pc, #120]	; (8002834 <usbInitEndpointI+0x1c4>)
 80027ba:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80027be:	01aa      	lsls	r2, r5, #6
 80027c0:	f042 0220 	orr.w	r2, r2, #32
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80027c4:	6058      	str	r0, [r3, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80027c6:	610a      	str	r2, [r1, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80027c8:	690b      	ldr	r3, [r1, #16]
 80027ca:	069b      	lsls	r3, r3, #26
 80027cc:	d4fc      	bmi.n	80027c8 <usbInitEndpointI+0x158>
 80027ce:	eb04 1646 	add.w	r6, r4, r6, lsl #5
 80027d2:	2012      	movs	r0, #18
 80027d4:	f7fe fd04 	bl	80011e0 <chSysPolledDelayX>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80027d8:	f8d6 3900 	ldr.w	r3, [r6, #2304]	; 0x900
 80027dc:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80027e0:	f8c6 3900 	str.w	r3, [r6, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80027e4:	f8d4 381c 	ldr.w	r3, [r4, #2076]	; 0x81c
 80027e8:	2201      	movs	r2, #1
 80027ea:	fa02 f505 	lsl.w	r5, r2, r5
 80027ee:	ea23 0305 	bic.w	r3, r3, r5
 80027f2:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
 80027f6:	e7d3      	b.n	80027a0 <usbInitEndpointI+0x130>
 80027f8:	eb04 1e46 	add.w	lr, r4, r6, lsl #5
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 80027fc:	f8de cb00 	ldr.w	ip, [lr, #2816]	; 0xb00
 8002800:	f42c 4c00 	bic.w	ip, ip, #32768	; 0x8000
 8002804:	f8ce cb00 	str.w	ip, [lr, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8002808:	f8d4 c81c 	ldr.w	ip, [r4, #2076]	; 0x81c
 800280c:	ea2c 0101 	bic.w	r1, ip, r1
 8002810:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
 8002814:	e78b      	b.n	800272e <usbInitEndpointI+0xbe>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8002816:	4f08      	ldr	r7, [pc, #32]	; (8002838 <usbInitEndpointI+0x1c8>)
 8002818:	e768      	b.n	80026ec <usbInitEndpointI+0x7c>
 800281a:	bf00      	nop
 800281c:	200011a0 	.word	0x200011a0
 8002820:	0800c0a8 	.word	0x0800c0a8
 8002824:	10048000 	.word	0x10048000
 8002828:	10008000 	.word	0x10008000
 800282c:	10088000 	.word	0x10088000
 8002830:	0800c060 	.word	0x0800c060
 8002834:	02000400 	.word	0x02000400
 8002838:	100c8000 	.word	0x100c8000
 800283c:	00000000 	.word	0x00000000

08002840 <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8002840:	b538      	push	{r3, r4, r5, lr}
  switch (event) {
 8002842:	2905      	cmp	r1, #5
 8002844:	d816      	bhi.n	8002874 <usb_event+0x34>
 8002846:	e8df f001 	tbb	[pc, r1]
 800284a:	154f      	.short	0x154f
 800284c:	034f4f16 	.word	0x034f4f16
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002850:	2320      	movs	r3, #32
 8002852:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 8002856:	4d32      	ldr	r5, [pc, #200]	; (8002920 <usb_event+0xe0>)
  _dbg_check_lock_from_isr();
 8002858:	f7fe fc32 	bl	80010c0 <_dbg_check_lock_from_isr>
  bqResumeX(&sdup->ibqueue);
 800285c:	2400      	movs	r4, #0
 800285e:	1d28      	adds	r0, r5, #4
 8002860:	2101      	movs	r1, #1
 8002862:	f7fe fb3d 	bl	8000ee0 <chEvtBroadcastFlagsI>
 8002866:	752c      	strb	r4, [r5, #20]
  bqResumeX(&sdup->obqueue);
 8002868:	f885 404c 	strb.w	r4, [r5, #76]	; 0x4c
  _dbg_check_unlock_from_isr();
 800286c:	f7fe fc10 	bl	8001090 <_dbg_check_unlock_from_isr>
 8002870:	f384 8811 	msr	BASEPRI, r4
}
 8002874:	bd38      	pop	{r3, r4, r5, pc}
 8002876:	4605      	mov	r5, r0
 8002878:	2320      	movs	r3, #32
 800287a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800287e:	f7fe fc1f 	bl	80010c0 <_dbg_check_lock_from_isr>
  ibqp->bcounter  = 0;
 8002882:	4c27      	ldr	r4, [pc, #156]	; (8002920 <usb_event+0xe0>)
    usbInitEndpointI(usbp, USB1_DATA_REQUEST_EP, &ep1config);
 8002884:	4a27      	ldr	r2, [pc, #156]	; (8002924 <usb_event+0xe4>)
 8002886:	2101      	movs	r1, #1
 8002888:	f7ff fef2 	bl	8002670 <usbInitEndpointI>
    usbInitEndpointI(usbp, USB1_INTERRUPT_REQUEST_EP, &ep2config);
 800288c:	2102      	movs	r1, #2
 800288e:	4a26      	ldr	r2, [pc, #152]	; (8002928 <usb_event+0xe8>)
 8002890:	4628      	mov	r0, r5
 8002892:	f7ff feed 	bl	8002670 <usbInitEndpointI>
 8002896:	2500      	movs	r5, #0
  osalDbgCheckClassI();
 8002898:	f7fe f9a2 	bl	8000be0 <chDbgCheckClassI>
  ibqp->brdptr    = ibqp->buffers;
 800289c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800289e:	6223      	str	r3, [r4, #32]
  chThdDequeueAllI(tqp, msg);
 80028a0:	f104 000c 	add.w	r0, r4, #12
  ibqp->bwrptr    = ibqp->buffers;
 80028a4:	61e3      	str	r3, [r4, #28]
  ibqp->bcounter  = 0;
 80028a6:	61a5      	str	r5, [r4, #24]
  ibqp->top       = NULL;
 80028a8:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 80028ac:	f7fe fac8 	bl	8000e40 <chThdDequeueAllI.constprop.89>
  bqResumeX(&sdup->ibqueue);
 80028b0:	7525      	strb	r5, [r4, #20]
  osalDbgCheckClassI();
 80028b2:	f7fe f995 	bl	8000be0 <chDbgCheckClassI>
  obqp->brdptr    = obqp->buffers;
 80028b6:	e9d4 2319 	ldrd	r2, r3, [r4, #100]	; 0x64
 80028ba:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->bcounter  = bqSizeX(obqp);
 80028be:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->bwrptr    = obqp->buffers;
 80028c0:	e9c4 3315 	strd	r3, r3, [r4, #84]	; 0x54
  obqp->ptr       = NULL;
 80028c4:	66e5      	str	r5, [r4, #108]	; 0x6c
  obqp->top       = NULL;
 80028c6:	6725      	str	r5, [r4, #112]	; 0x70
 80028c8:	f7fe faba 	bl	8000e40 <chThdDequeueAllI.constprop.89>
  chEvtBroadcastFlagsI(esp, flags);
 80028cc:	2101      	movs	r1, #1
 80028ce:	1d20      	adds	r0, r4, #4
  bqResumeX(&sdup->obqueue);
 80028d0:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 80028d4:	f7fe fb04 	bl	8000ee0 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 80028d8:	4620      	mov	r0, r4
 80028da:	f7fe ffa9 	bl	8001830 <sdu_start_receive>
  _dbg_check_unlock_from_isr();
 80028de:	f7fe fbd7 	bl	8001090 <_dbg_check_unlock_from_isr>
 80028e2:	f385 8811 	msr	BASEPRI, r5
}
 80028e6:	bd38      	pop	{r3, r4, r5, pc}
 80028e8:	2320      	movs	r3, #32
 80028ea:	f383 8811 	msr	BASEPRI, r3
 80028ee:	4c0c      	ldr	r4, [pc, #48]	; (8002920 <usb_event+0xe0>)
  _dbg_check_lock_from_isr();
 80028f0:	f7fe fbe6 	bl	80010c0 <_dbg_check_lock_from_isr>
 80028f4:	2102      	movs	r1, #2
 80028f6:	1d20      	adds	r0, r4, #4
 80028f8:	f7fe faf2 	bl	8000ee0 <chEvtBroadcastFlagsI>
  bqSuspendI(&sdup->ibqueue);
 80028fc:	2501      	movs	r5, #1
  chThdDequeueAllI(tqp, msg);
 80028fe:	f104 000c 	add.w	r0, r4, #12
 8002902:	7525      	strb	r5, [r4, #20]
 8002904:	f7fe fa9c 	bl	8000e40 <chThdDequeueAllI.constprop.89>
 8002908:	f104 0044 	add.w	r0, r4, #68	; 0x44
  bqSuspendI(&sdup->obqueue);
 800290c:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8002910:	f7fe fa96 	bl	8000e40 <chThdDequeueAllI.constprop.89>
  _dbg_check_unlock_from_isr();
 8002914:	f7fe fbbc 	bl	8001090 <_dbg_check_unlock_from_isr>
 8002918:	2300      	movs	r3, #0
 800291a:	f383 8811 	msr	BASEPRI, r3
 800291e:	bd38      	pop	{r3, r4, r5, pc}
 8002920:	20000c98 	.word	0x20000c98
 8002924:	0800c4c0 	.word	0x0800c4c0
 8002928:	0800c4e4 	.word	0x0800c4e4
 800292c:	00000000 	.word	0x00000000

08002930 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
 8002930:	b570      	push	{r4, r5, r6, lr}
 8002932:	460e      	mov	r6, r1
  char *p;

  if (str != NULL)
 8002934:	b1f0      	cbz	r0, 8002974 <parse_arguments+0x44>
 8002936:	4604      	mov	r4, r0
    *saveptr = str;
 8002938:	6030      	str	r0, [r6, #0]
  if (!p) {
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
 800293a:	4911      	ldr	r1, [pc, #68]	; (8002980 <parse_arguments+0x50>)
 800293c:	4620      	mov	r0, r4
 800293e:	f009 f927 	bl	800bb90 <strspn>

  if (*p == '"') {
 8002942:	5c21      	ldrb	r1, [r4, r0]
 8002944:	2922      	cmp	r1, #34	; 0x22
  p += strspn(p, " \t");
 8002946:	eb04 0500 	add.w	r5, r4, r0
  if (*p == '"') {
 800294a:	d00d      	beq.n	8002968 <parse_arguments+0x38>
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
 800294c:	490c      	ldr	r1, [pc, #48]	; (8002980 <parse_arguments+0x50>)
 800294e:	4628      	mov	r0, r5
 8002950:	f009 f8fc 	bl	800bb4c <strpbrk>
 8002954:	6030      	str	r0, [r6, #0]
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
 8002956:	b118      	cbz	r0, 8002960 <parse_arguments+0x30>
    *(*saveptr)++ = '\0';
 8002958:	1c42      	adds	r2, r0, #1
 800295a:	2300      	movs	r3, #0
 800295c:	6032      	str	r2, [r6, #0]
 800295e:	7003      	strb	r3, [r0, #0]
  }

  return *p != '\0' ? p : NULL;
 8002960:	782b      	ldrb	r3, [r5, #0]
 8002962:	b153      	cbz	r3, 800297a <parse_arguments+0x4a>
}
 8002964:	4628      	mov	r0, r5
 8002966:	bd70      	pop	{r4, r5, r6, pc}
    p++;
 8002968:	3501      	adds	r5, #1
    *saveptr = strpbrk(p, "\"");
 800296a:	4628      	mov	r0, r5
 800296c:	f008 fffc 	bl	800b968 <strchr>
 8002970:	6030      	str	r0, [r6, #0]
 8002972:	e7f0      	b.n	8002956 <parse_arguments+0x26>
  p = *saveptr;
 8002974:	680c      	ldr	r4, [r1, #0]
  if (!p) {
 8002976:	2c00      	cmp	r4, #0
 8002978:	d1df      	bne.n	800293a <parse_arguments+0xa>
  return *p != '\0' ? p : NULL;
 800297a:	2500      	movs	r5, #0
}
 800297c:	4628      	mov	r0, r5
 800297e:	bd70      	pop	{r4, r5, r6, pc}
 8002980:	0800c8c0 	.word	0x0800c8c0
	...

08002990 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8002990:	b40e      	push	{r1, r2, r3}
 8002992:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002996:	b086      	sub	sp, #24
 8002998:	af0f      	add	r7, sp, #60	; 0x3c
 800299a:	4604      	mov	r4, r0
 800299c:	f857 6b04 	ldr.w	r6, [r7], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80029a0:	9702      	str	r7, [sp, #8]
  int n = 0;
 80029a2:	f04f 0800 	mov.w	r8, #0
    c = *fmt++;
 80029a6:	7831      	ldrb	r1, [r6, #0]
 80029a8:	1c72      	adds	r2, r6, #1
    if (c == 0)
 80029aa:	b161      	cbz	r1, 80029c6 <chprintf+0x36>
    if (c != '%') {
 80029ac:	2925      	cmp	r1, #37	; 0x25
 80029ae:	d010      	beq.n	80029d2 <chprintf+0x42>
      streamPut(chp, (uint8_t)c);
 80029b0:	6823      	ldr	r3, [r4, #0]
    c = *fmt++;
 80029b2:	4616      	mov	r6, r2
      streamPut(chp, (uint8_t)c);
 80029b4:	68db      	ldr	r3, [r3, #12]
 80029b6:	4620      	mov	r0, r4
 80029b8:	4798      	blx	r3
    c = *fmt++;
 80029ba:	7831      	ldrb	r1, [r6, #0]
      n++;
 80029bc:	f108 0801 	add.w	r8, r8, #1
    c = *fmt++;
 80029c0:	1c72      	adds	r2, r6, #1
    if (c == 0)
 80029c2:	2900      	cmp	r1, #0
 80029c4:	d1f2      	bne.n	80029ac <chprintf+0x1c>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 80029c6:	4640      	mov	r0, r8
 80029c8:	b006      	add	sp, #24
 80029ca:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80029ce:	b003      	add	sp, #12
 80029d0:	4770      	bx	lr
    if (*fmt == '-') {
 80029d2:	7871      	ldrb	r1, [r6, #1]
 80029d4:	292d      	cmp	r1, #45	; 0x2d
 80029d6:	bf03      	ittte	eq
 80029d8:	78b1      	ldrbeq	r1, [r6, #2]
      fmt++;
 80029da:	1cb2      	addeq	r2, r6, #2
      left_align = TRUE;
 80029dc:	f04f 0c01 	moveq.w	ip, #1
    left_align = FALSE;
 80029e0:	f04f 0c00 	movne.w	ip, #0
    if (*fmt == '0') {
 80029e4:	2930      	cmp	r1, #48	; 0x30
 80029e6:	bf03      	ittte	eq
 80029e8:	7851      	ldrbeq	r1, [r2, #1]
      fmt++;
 80029ea:	3201      	addeq	r2, #1
      filler = '0';
 80029ec:	f04f 0a30 	moveq.w	sl, #48	; 0x30
    filler = ' ';
 80029f0:	f04f 0a20 	movne.w	sl, #32
 80029f4:	3201      	adds	r2, #1
    width = 0;
 80029f6:	2500      	movs	r5, #0
 80029f8:	e005      	b.n	8002a06 <chprintf+0x76>
        c = va_arg(ap, int);
 80029fa:	783b      	ldrb	r3, [r7, #0]
 80029fc:	3704      	adds	r7, #4
 80029fe:	f812 1b01 	ldrb.w	r1, [r2], #1
      width = width * 10 + c;
 8002a02:	eb03 0540 	add.w	r5, r3, r0, lsl #1
      if (c >= '0' && c <= '9')
 8002a06:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8002a0a:	b2db      	uxtb	r3, r3
 8002a0c:	2b09      	cmp	r3, #9
      c = *fmt++;
 8002a0e:	4696      	mov	lr, r2
      width = width * 10 + c;
 8002a10:	eb05 0085 	add.w	r0, r5, r5, lsl #2
      if (c >= '0' && c <= '9')
 8002a14:	d9f3      	bls.n	80029fe <chprintf+0x6e>
      else if (c == '*')
 8002a16:	292a      	cmp	r1, #42	; 0x2a
 8002a18:	d0ef      	beq.n	80029fa <chprintf+0x6a>
    if (c == '.') {
 8002a1a:	292e      	cmp	r1, #46	; 0x2e
    precision = 0;
 8002a1c:	f04f 0200 	mov.w	r2, #0
    if (c == '.') {
 8002a20:	d048      	beq.n	8002ab4 <chprintf+0x124>
    if (c == 'l' || c == 'L') {
 8002a22:	f001 03df 	and.w	r3, r1, #223	; 0xdf
 8002a26:	2b4c      	cmp	r3, #76	; 0x4c
 8002a28:	f10e 0601 	add.w	r6, lr, #1
 8002a2c:	d04e      	beq.n	8002acc <chprintf+0x13c>
      is_long = (c >= 'A') && (c <= 'Z');
 8002a2e:	f1a1 0341 	sub.w	r3, r1, #65	; 0x41
    switch (c) {
 8002a32:	f1a1 0044 	sub.w	r0, r1, #68	; 0x44
      is_long = (c >= 'A') && (c <= 'Z');
 8002a36:	b2db      	uxtb	r3, r3
    switch (c) {
 8002a38:	2834      	cmp	r0, #52	; 0x34
 8002a3a:	f200 8116 	bhi.w	8002c6a <chprintf+0x2da>
 8002a3e:	e8df f010 	tbh	[pc, r0, lsl #1]
 8002a42:	0165      	.short	0x0165
 8002a44:	01140114 	.word	0x01140114
 8002a48:	01140114 	.word	0x01140114
 8002a4c:	01140165 	.word	0x01140165
 8002a50:	01140114 	.word	0x01140114
 8002a54:	01140114 	.word	0x01140114
 8002a58:	01140110 	.word	0x01140110
 8002a5c:	01140114 	.word	0x01140114
 8002a60:	01140114 	.word	0x01140114
 8002a64:	011400e1 	.word	0x011400e1
 8002a68:	016e0114 	.word	0x016e0114
 8002a6c:	01140114 	.word	0x01140114
 8002a70:	01140114 	.word	0x01140114
 8002a74:	01140114 	.word	0x01140114
 8002a78:	01140114 	.word	0x01140114
 8002a7c:	01140114 	.word	0x01140114
 8002a80:	0165008f 	.word	0x0165008f
 8002a84:	01140114 	.word	0x01140114
 8002a88:	01140114 	.word	0x01140114
 8002a8c:	01140165 	.word	0x01140165
 8002a90:	01140114 	.word	0x01140114
 8002a94:	01140114 	.word	0x01140114
 8002a98:	01140110 	.word	0x01140110
 8002a9c:	01140114 	.word	0x01140114
 8002aa0:	0114006d 	.word	0x0114006d
 8002aa4:	011400e1 	.word	0x011400e1
 8002aa8:	016e0114 	.word	0x016e0114
          c = va_arg(ap, int);
 8002aac:	783b      	ldrb	r3, [r7, #0]
 8002aae:	3704      	adds	r7, #4
        precision += c;
 8002ab0:	eb03 0240 	add.w	r2, r3, r0, lsl #1
        c = *fmt++;
 8002ab4:	f81e 1b01 	ldrb.w	r1, [lr], #1
        if (c >= '0' && c <= '9')
 8002ab8:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8002abc:	b2db      	uxtb	r3, r3
 8002abe:	2b09      	cmp	r3, #9
        precision *= 10;
 8002ac0:	eb02 0082 	add.w	r0, r2, r2, lsl #2
        if (c >= '0' && c <= '9')
 8002ac4:	d9f4      	bls.n	8002ab0 <chprintf+0x120>
        else if (c == '*')
 8002ac6:	292a      	cmp	r1, #42	; 0x2a
 8002ac8:	d0f0      	beq.n	8002aac <chprintf+0x11c>
 8002aca:	e7aa      	b.n	8002a22 <chprintf+0x92>
      if (*fmt)
 8002acc:	f89e 3000 	ldrb.w	r3, [lr]
 8002ad0:	b30b      	cbz	r3, 8002b16 <chprintf+0x186>
    switch (c) {
 8002ad2:	f1a3 0144 	sub.w	r1, r3, #68	; 0x44
 8002ad6:	2934      	cmp	r1, #52	; 0x34
 8002ad8:	f200 80c9 	bhi.w	8002c6e <chprintf+0x2de>
 8002adc:	e8df f001 	tbb	[pc, r1]
 8002ae0:	c7c7c7d7 	.word	0xc7c7c7d7
 8002ae4:	c7c7d7c7 	.word	0xc7c7d7c7
 8002ae8:	c2c7c7c7 	.word	0xc2c7c7c7
 8002aec:	c7c7c7c7 	.word	0xc7c7c7c7
 8002af0:	c7c793c7 	.word	0xc7c793c7
 8002af4:	c7c7c7d4 	.word	0xc7c7c7d4
 8002af8:	c7c7c7c7 	.word	0xc7c7c7c7
 8002afc:	41c7c7c7 	.word	0x41c7c7c7
 8002b00:	c7c7c7d7 	.word	0xc7c7c7d7
 8002b04:	c7c7d7c7 	.word	0xc7c7d7c7
 8002b08:	c2c7c7c7 	.word	0xc2c7c7c7
 8002b0c:	1fc7c7c7 	.word	0x1fc7c7c7
 8002b10:	c7c793c7 	.word	0xc7c793c7
 8002b14:	d4          	.byte	0xd4
 8002b15:	00          	.byte	0x00
      if (*fmt)
 8002b16:	460b      	mov	r3, r1
 8002b18:	4676      	mov	r6, lr
 8002b1a:	e7da      	b.n	8002ad2 <chprintf+0x142>
    switch (c) {
 8002b1c:	4676      	mov	r6, lr
      if ((s = va_arg(ap, char *)) == 0)
 8002b1e:	f8d7 9000 	ldr.w	r9, [r7]
 8002b22:	3704      	adds	r7, #4
 8002b24:	f1b9 0f00 	cmp.w	r9, #0
 8002b28:	f000 80fd 	beq.w	8002d26 <chprintf+0x396>
 8002b2c:	f899 3000 	ldrb.w	r3, [r9]
 8002b30:	4648      	mov	r0, r9
      if (precision == 0)
 8002b32:	2a00      	cmp	r2, #0
 8002b34:	f040 80fe 	bne.w	8002d34 <chprintf+0x3a4>
      for (p = s; *p && (--precision >= 0); p++)
 8002b38:	2b00      	cmp	r3, #0
 8002b3a:	f000 810c 	beq.w	8002d56 <chprintf+0x3c6>
 8002b3e:	f647 72fe 	movw	r2, #32766	; 0x7ffe
 8002b42:	464b      	mov	r3, r9
 8002b44:	e001      	b.n	8002b4a <chprintf+0x1ba>
 8002b46:	3a01      	subs	r2, #1
 8002b48:	d403      	bmi.n	8002b52 <chprintf+0x1c2>
 8002b4a:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8002b4e:	2900      	cmp	r1, #0
 8002b50:	d1f9      	bne.n	8002b46 <chprintf+0x1b6>
 8002b52:	1a1b      	subs	r3, r3, r0
 8002b54:	1aed      	subs	r5, r5, r3
 8002b56:	3b01      	subs	r3, #1
 8002b58:	9300      	str	r3, [sp, #0]
      filler = ' ';
 8002b5a:	f04f 0a20 	mov.w	sl, #32
 8002b5e:	e00b      	b.n	8002b78 <chprintf+0x1e8>
    switch (c) {
 8002b60:	4676      	mov	r6, lr
      *p++ = va_arg(ap, int);
 8002b62:	f10d 0918 	add.w	r9, sp, #24
 8002b66:	683b      	ldr	r3, [r7, #0]
 8002b68:	f809 3d0c 	strb.w	r3, [r9, #-12]!
 8002b6c:	2300      	movs	r3, #0
 8002b6e:	3d01      	subs	r5, #1
 8002b70:	3704      	adds	r7, #4
 8002b72:	9300      	str	r3, [sp, #0]
      filler = ' ';
 8002b74:	f04f 0a20 	mov.w	sl, #32
    if ((width -= i) < 0)
 8002b78:	2d00      	cmp	r5, #0
 8002b7a:	db1e      	blt.n	8002bba <chprintf+0x22a>
    if (left_align == FALSE)
 8002b7c:	f1bc 0f00 	cmp.w	ip, #0
 8002b80:	d17e      	bne.n	8002c80 <chprintf+0x2f0>
      width = -width;
 8002b82:	426b      	negs	r3, r5
    if (width < 0) {
 8002b84:	2d00      	cmp	r5, #0
 8002b86:	d07a      	beq.n	8002c7e <chprintf+0x2ee>
      if (*s == '-' && filler == '0') {
 8002b88:	f899 1000 	ldrb.w	r1, [r9]
 8002b8c:	6822      	ldr	r2, [r4, #0]
 8002b8e:	292d      	cmp	r1, #45	; 0x2d
 8002b90:	68d2      	ldr	r2, [r2, #12]
 8002b92:	f000 80a8 	beq.w	8002ce6 <chprintf+0x356>
 8002b96:	469b      	mov	fp, r3
 8002b98:	e001      	b.n	8002b9e <chprintf+0x20e>
 8002b9a:	6823      	ldr	r3, [r4, #0]
 8002b9c:	68da      	ldr	r2, [r3, #12]
        streamPut(chp, (uint8_t)filler);
 8002b9e:	4651      	mov	r1, sl
 8002ba0:	4620      	mov	r0, r4
 8002ba2:	4790      	blx	r2
      } while (++width != 0);
 8002ba4:	f11b 0b01 	adds.w	fp, fp, #1
 8002ba8:	d1f7      	bne.n	8002b9a <chprintf+0x20a>
    while (--i >= 0) {
 8002baa:	9a00      	ldr	r2, [sp, #0]
 8002bac:	2a00      	cmp	r2, #0
 8002bae:	465b      	mov	r3, fp
 8002bb0:	44a8      	add	r8, r5
 8002bb2:	f6ff aef8 	blt.w	80029a6 <chprintf+0x16>
 8002bb6:	461d      	mov	r5, r3
 8002bb8:	e004      	b.n	8002bc4 <chprintf+0x234>
 8002bba:	9b00      	ldr	r3, [sp, #0]
 8002bbc:	2b00      	cmp	r3, #0
 8002bbe:	f6ff aef2 	blt.w	80029a6 <chprintf+0x16>
      width = 0;
 8002bc2:	2500      	movs	r5, #0
      width = -width;
 8002bc4:	f8dd b000 	ldr.w	fp, [sp]
      streamPut(chp, (uint8_t)*s++);
 8002bc8:	6823      	ldr	r3, [r4, #0]
 8002bca:	f819 1b01 	ldrb.w	r1, [r9], #1
 8002bce:	68db      	ldr	r3, [r3, #12]
    while (--i >= 0) {
 8002bd0:	f10b 3bff 	add.w	fp, fp, #4294967295
      streamPut(chp, (uint8_t)*s++);
 8002bd4:	4620      	mov	r0, r4
 8002bd6:	4798      	blx	r3
    while (--i >= 0) {
 8002bd8:	f1bb 3fff 	cmp.w	fp, #4294967295
 8002bdc:	d1f4      	bne.n	8002bc8 <chprintf+0x238>
 8002bde:	9b00      	ldr	r3, [sp, #0]
 8002be0:	f108 0801 	add.w	r8, r8, #1
 8002be4:	4443      	add	r3, r8
 8002be6:	4698      	mov	r8, r3
    while (width) {
 8002be8:	2d00      	cmp	r5, #0
 8002bea:	f43f aedc 	beq.w	80029a6 <chprintf+0x16>
 8002bee:	46a9      	mov	r9, r5
      streamPut(chp, (uint8_t)filler);
 8002bf0:	6823      	ldr	r3, [r4, #0]
 8002bf2:	4651      	mov	r1, sl
 8002bf4:	68db      	ldr	r3, [r3, #12]
 8002bf6:	4620      	mov	r0, r4
 8002bf8:	4798      	blx	r3
    while (width) {
 8002bfa:	f1b9 0901 	subs.w	r9, r9, #1
 8002bfe:	d1f7      	bne.n	8002bf0 <chprintf+0x260>
 8002c00:	44a8      	add	r8, r5
 8002c02:	e6d0      	b.n	80029a6 <chprintf+0x16>
    switch (c) {
 8002c04:	4676      	mov	r6, lr
    case 'U':
 8002c06:	f04f 090a 	mov.w	r9, #10
 8002c0a:	f857 2b04 	ldr.w	r2, [r7], #4
  q = p + MAX_FILLER;
 8002c0e:	f10d 0117 	add.w	r1, sp, #23
 8002c12:	e000      	b.n	8002c16 <chprintf+0x286>
  } while ((ll /= radix) != 0);
 8002c14:	4601      	mov	r1, r0
    i = (int)(l % radix);
 8002c16:	fbb2 fef9 	udiv	lr, r2, r9
 8002c1a:	fb09 221e 	mls	r2, r9, lr, r2
    i += '0';
 8002c1e:	f102 0330 	add.w	r3, r2, #48	; 0x30
    if (i > '9')
 8002c22:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8002c24:	bfc8      	it	gt
 8002c26:	f102 0337 	addgt.w	r3, r2, #55	; 0x37
    *--q = i;
 8002c2a:	b2db      	uxtb	r3, r3
    l /= radix;
 8002c2c:	4672      	mov	r2, lr
    *--q = i;
 8002c2e:	f801 3c01 	strb.w	r3, [r1, #-1]
 8002c32:	1e48      	subs	r0, r1, #1
  } while ((ll /= radix) != 0);
 8002c34:	2a00      	cmp	r2, #0
 8002c36:	d1ed      	bne.n	8002c14 <chprintf+0x284>
  i = (int)(p + MAX_FILLER - q);
 8002c38:	f10d 0217 	add.w	r2, sp, #23
 8002c3c:	eba2 0b00 	sub.w	fp, r2, r0
 8002c40:	f10d 090c 	add.w	r9, sp, #12
 8002c44:	464a      	mov	r2, r9
 8002c46:	4458      	add	r0, fp
 8002c48:	e001      	b.n	8002c4e <chprintf+0x2be>
 8002c4a:	f811 3b01 	ldrb.w	r3, [r1], #1
    *p++ = *q++;
 8002c4e:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
 8002c52:	4281      	cmp	r1, r0
 8002c54:	d1f9      	bne.n	8002c4a <chprintf+0x2ba>
 8002c56:	f10b 33ff 	add.w	r3, fp, #4294967295
 8002c5a:	eba5 050b 	sub.w	r5, r5, fp
 8002c5e:	9300      	str	r3, [sp, #0]
 8002c60:	e78a      	b.n	8002b78 <chprintf+0x1e8>
    switch (c) {
 8002c62:	4676      	mov	r6, lr
    case 'O':
 8002c64:	f04f 0908 	mov.w	r9, #8
 8002c68:	e7cf      	b.n	8002c0a <chprintf+0x27a>
    switch (c) {
 8002c6a:	4676      	mov	r6, lr
 8002c6c:	460b      	mov	r3, r1
      *p++ = c;
 8002c6e:	f10d 0918 	add.w	r9, sp, #24
 8002c72:	3d01      	subs	r5, #1
 8002c74:	f809 3d0c 	strb.w	r3, [r9, #-12]!
 8002c78:	2300      	movs	r3, #0
 8002c7a:	9300      	str	r3, [sp, #0]
 8002c7c:	e77c      	b.n	8002b78 <chprintf+0x1e8>
      width = -width;
 8002c7e:	461d      	mov	r5, r3
    while (--i >= 0) {
 8002c80:	9b00      	ldr	r3, [sp, #0]
 8002c82:	2b00      	cmp	r3, #0
 8002c84:	da9e      	bge.n	8002bc4 <chprintf+0x234>
 8002c86:	e7af      	b.n	8002be8 <chprintf+0x258>
    switch (c) {
 8002c88:	f04f 0910 	mov.w	r9, #16
 8002c8c:	e7bd      	b.n	8002c0a <chprintf+0x27a>
 8002c8e:	1d39      	adds	r1, r7, #4
        l = va_arg(ap, long);
 8002c90:	683a      	ldr	r2, [r7, #0]
 8002c92:	460f      	mov	r7, r1
      if (l < 0) {
 8002c94:	2a00      	cmp	r2, #0
 8002c96:	db55      	blt.n	8002d44 <chprintf+0x3b4>
    p = tmpbuf;
 8002c98:	f10d 090c 	add.w	r9, sp, #12
 8002c9c:	4648      	mov	r0, r9
  q = p + MAX_FILLER;
 8002c9e:	f100 030b 	add.w	r3, r0, #11
 8002ca2:	9300      	str	r3, [sp, #0]
 8002ca4:	4619      	mov	r1, r3
    i = (int)(l % radix);
 8002ca6:	4b2f      	ldr	r3, [pc, #188]	; (8002d64 <chprintf+0x3d4>)
 8002ca8:	fba3 e302 	umull	lr, r3, r3, r2
 8002cac:	08db      	lsrs	r3, r3, #3
 8002cae:	eb03 0b83 	add.w	fp, r3, r3, lsl #2
 8002cb2:	469e      	mov	lr, r3
 8002cb4:	eba2 034b 	sub.w	r3, r2, fp, lsl #1
    i += '0';
 8002cb8:	3330      	adds	r3, #48	; 0x30
    *--q = i;
 8002cba:	b2db      	uxtb	r3, r3
  } while ((ll /= radix) != 0);
 8002cbc:	4672      	mov	r2, lr
    *--q = i;
 8002cbe:	f801 3d01 	strb.w	r3, [r1, #-1]!
  } while ((ll /= radix) != 0);
 8002cc2:	2a00      	cmp	r2, #0
 8002cc4:	d1ef      	bne.n	8002ca6 <chprintf+0x316>
  i = (int)(p + MAX_FILLER - q);
 8002cc6:	9a00      	ldr	r2, [sp, #0]
 8002cc8:	1a52      	subs	r2, r2, r1
 8002cca:	4402      	add	r2, r0
 8002ccc:	e001      	b.n	8002cd2 <chprintf+0x342>
 8002cce:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    *p++ = *q++;
 8002cd2:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 8002cd6:	4290      	cmp	r0, r2
 8002cd8:	d1f9      	bne.n	8002cce <chprintf+0x33e>
 8002cda:	eba0 0009 	sub.w	r0, r0, r9
 8002cde:	1e43      	subs	r3, r0, #1
 8002ce0:	1a2d      	subs	r5, r5, r0
 8002ce2:	9300      	str	r3, [sp, #0]
 8002ce4:	e748      	b.n	8002b78 <chprintf+0x1e8>
      if (*s == '-' && filler == '0') {
 8002ce6:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
 8002cea:	f47f af54 	bne.w	8002b96 <chprintf+0x206>
        streamPut(chp, (uint8_t)*s++);
 8002cee:	4620      	mov	r0, r4
 8002cf0:	9301      	str	r3, [sp, #4]
 8002cf2:	4790      	blx	r2
 8002cf4:	9b00      	ldr	r3, [sp, #0]
 8002cf6:	6822      	ldr	r2, [r4, #0]
 8002cf8:	3b01      	subs	r3, #1
 8002cfa:	9300      	str	r3, [sp, #0]
 8002cfc:	9b01      	ldr	r3, [sp, #4]
 8002cfe:	68d2      	ldr	r2, [r2, #12]
 8002d00:	f108 0801 	add.w	r8, r8, #1
 8002d04:	f109 0901 	add.w	r9, r9, #1
 8002d08:	469b      	mov	fp, r3
 8002d0a:	e748      	b.n	8002b9e <chprintf+0x20e>
 8002d0c:	4639      	mov	r1, r7
      if (is_long)
 8002d0e:	2b19      	cmp	r3, #25
 8002d10:	f851 2b04 	ldr.w	r2, [r1], #4
 8002d14:	4676      	mov	r6, lr
        l = va_arg(ap, int);
 8002d16:	bf88      	it	hi
 8002d18:	460f      	movhi	r7, r1
      if (is_long)
 8002d1a:	d8bb      	bhi.n	8002c94 <chprintf+0x304>
 8002d1c:	e7b8      	b.n	8002c90 <chprintf+0x300>
    switch (c) {
 8002d1e:	4676      	mov	r6, lr
 8002d20:	f04f 0910 	mov.w	r9, #16
 8002d24:	e771      	b.n	8002c0a <chprintf+0x27a>
 8002d26:	4810      	ldr	r0, [pc, #64]	; (8002d68 <chprintf+0x3d8>)
      if (precision == 0)
 8002d28:	4681      	mov	r9, r0
 8002d2a:	2a00      	cmp	r2, #0
 8002d2c:	f43f af07 	beq.w	8002b3e <chprintf+0x1ae>
      for (p = s; *p && (--precision >= 0); p++)
 8002d30:	3a01      	subs	r2, #1
 8002d32:	e706      	b.n	8002b42 <chprintf+0x1b2>
 8002d34:	2b00      	cmp	r3, #0
 8002d36:	d1fb      	bne.n	8002d30 <chprintf+0x3a0>
 8002d38:	f04f 33ff 	mov.w	r3, #4294967295
 8002d3c:	9300      	str	r3, [sp, #0]
      filler = ' ';
 8002d3e:	f04f 0a20 	mov.w	sl, #32
 8002d42:	e719      	b.n	8002b78 <chprintf+0x1e8>
        *p++ = '-';
 8002d44:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8002d46:	4252      	negs	r2, r2
        *p++ = '-';
 8002d48:	f88d 300c 	strb.w	r3, [sp, #12]
 8002d4c:	f10d 000d 	add.w	r0, sp, #13
 8002d50:	f10d 090c 	add.w	r9, sp, #12
 8002d54:	e7a3      	b.n	8002c9e <chprintf+0x30e>
      for (p = s; *p && (--precision >= 0); p++)
 8002d56:	f04f 33ff 	mov.w	r3, #4294967295
 8002d5a:	9300      	str	r3, [sp, #0]
      filler = ' ';
 8002d5c:	f04f 0a20 	mov.w	sl, #32
 8002d60:	e70c      	b.n	8002b7c <chprintf+0x1ec>
 8002d62:	bf00      	nop
 8002d64:	cccccccd 	.word	0xcccccccd
 8002d68:	0800c21c 	.word	0x0800c21c
 8002d6c:	00000000 	.word	0x00000000

08002d70 <cmd_write>:
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

  (void)argv;
  if (argc > 0) {
 8002d70:	2900      	cmp	r1, #0
 8002d72:	dc18      	bgt.n	8002da6 <cmd_write+0x36>
static void cmd_write(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002d74:	b570      	push	{r4, r5, r6, lr}
 8002d76:	4604      	mov	r4, r0
  }

  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
#if 1
    /* Writing in channel mode.*/
    chnWrite(&PORTAB_SDU1, buf, sizeof buf - 1);
 8002d78:	4e0c      	ldr	r6, [pc, #48]	; (8002dac <cmd_write+0x3c>)
 8002d7a:	4d0d      	ldr	r5, [pc, #52]	; (8002db0 <cmd_write+0x40>)
 8002d7c:	e002      	b.n	8002d84 <cmd_write+0x14>
 8002d7e:	6833      	ldr	r3, [r6, #0]
 8002d80:	685b      	ldr	r3, [r3, #4]
 8002d82:	4798      	blx	r3
  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 8002d84:	6823      	ldr	r3, [r4, #0]
 8002d86:	2100      	movs	r1, #0
 8002d88:	699b      	ldr	r3, [r3, #24]
 8002d8a:	4620      	mov	r0, r4
 8002d8c:	4798      	blx	r3
 8002d8e:	3001      	adds	r0, #1
    chnWrite(&PORTAB_SDU1, buf, sizeof buf - 1);
 8002d90:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8002d94:	4629      	mov	r1, r5
 8002d96:	4805      	ldr	r0, [pc, #20]	; (8002dac <cmd_write+0x3c>)
  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 8002d98:	d0f1      	beq.n	8002d7e <cmd_write+0xe>
    (void) obqGetEmptyBufferTimeout(&PORTAB_SDU1.obqueue, TIME_INFINITE);
    memcpy(PORTAB_SDU1.obqueue.ptr, buf, SERIAL_USB_BUFFERS_SIZE);
    obqPostFullBuffer(&PORTAB_SDU1.obqueue, SERIAL_USB_BUFFERS_SIZE);
#endif
  }
  chprintf(chp, "\r\n\nstopped\r\n");
 8002d9a:	4620      	mov	r0, r4
 8002d9c:	4905      	ldr	r1, [pc, #20]	; (8002db4 <cmd_write+0x44>)
}
 8002d9e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chprintf(chp, "\r\n\nstopped\r\n");
 8002da2:	f7ff bdf5 	b.w	8002990 <chprintf>
    chprintf(chp, "Usage: write\r\n");
 8002da6:	4904      	ldr	r1, [pc, #16]	; (8002db8 <cmd_write+0x48>)
 8002da8:	f7ff bdf2 	b.w	8002990 <chprintf>
 8002dac:	20000c98 	.word	0x20000c98
 8002db0:	20000800 	.word	0x20000800
 8002db4:	0800c46c 	.word	0x0800c46c
 8002db8:	0800c47c 	.word	0x0800c47c
 8002dbc:	00000000 	.word	0x00000000

08002dc0 <cmd_echo>:

#if (SHELL_CMD_ECHO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_echo(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc != 1) {
 8002dc0:	2901      	cmp	r1, #1
 8002dc2:	d003      	beq.n	8002dcc <cmd_echo+0xc>
    shellUsage(chp, "echo \"message\"");
 8002dc4:	4a03      	ldr	r2, [pc, #12]	; (8002dd4 <cmd_echo+0x14>)
 8002dc6:	4904      	ldr	r1, [pc, #16]	; (8002dd8 <cmd_echo+0x18>)
 8002dc8:	f7ff bde2 	b.w	8002990 <chprintf>
    return;
  }
  chprintf(chp, "%s" SHELL_NEWLINE_STR, argv[0]);
 8002dcc:	6812      	ldr	r2, [r2, #0]
 8002dce:	4903      	ldr	r1, [pc, #12]	; (8002ddc <cmd_echo+0x1c>)
 8002dd0:	f7ff bdde 	b.w	8002990 <chprintf>
 8002dd4:	0800c224 	.word	0x0800c224
 8002dd8:	0800c234 	.word	0x0800c234
 8002ddc:	0800c240 	.word	0x0800c240

08002de0 <cmd_info>:
  if (argc > 0) {
 8002de0:	2900      	cmp	r1, #0
 8002de2:	dd03      	ble.n	8002dec <cmd_info+0xc>
    shellUsage(chp, "info");
 8002de4:	4a19      	ldr	r2, [pc, #100]	; (8002e4c <cmd_info+0x6c>)
 8002de6:	491a      	ldr	r1, [pc, #104]	; (8002e50 <cmd_info+0x70>)
 8002de8:	f7ff bdd2 	b.w	8002990 <chprintf>
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002dec:	b510      	push	{r4, lr}
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8002dee:	4a19      	ldr	r2, [pc, #100]	; (8002e54 <cmd_info+0x74>)
 8002df0:	4919      	ldr	r1, [pc, #100]	; (8002e58 <cmd_info+0x78>)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002df2:	b082      	sub	sp, #8
 8002df4:	4604      	mov	r4, r0
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8002df6:	f7ff fdcb 	bl	8002990 <chprintf>
  chprintf(chp, "Compiler:     %s" SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 8002dfa:	4a18      	ldr	r2, [pc, #96]	; (8002e5c <cmd_info+0x7c>)
 8002dfc:	4918      	ldr	r1, [pc, #96]	; (8002e60 <cmd_info+0x80>)
 8002dfe:	4620      	mov	r0, r4
 8002e00:	f7ff fdc6 	bl	8002990 <chprintf>
  chprintf(chp, "Architecture: %s" SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 8002e04:	4a17      	ldr	r2, [pc, #92]	; (8002e64 <cmd_info+0x84>)
 8002e06:	4918      	ldr	r1, [pc, #96]	; (8002e68 <cmd_info+0x88>)
 8002e08:	4620      	mov	r0, r4
 8002e0a:	f7ff fdc1 	bl	8002990 <chprintf>
  chprintf(chp, "Core Variant: %s" SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 8002e0e:	4a17      	ldr	r2, [pc, #92]	; (8002e6c <cmd_info+0x8c>)
 8002e10:	4917      	ldr	r1, [pc, #92]	; (8002e70 <cmd_info+0x90>)
 8002e12:	4620      	mov	r0, r4
 8002e14:	f7ff fdbc 	bl	8002990 <chprintf>
  chprintf(chp, "Port Info:    %s" SHELL_NEWLINE_STR, PORT_INFO);
 8002e18:	4a16      	ldr	r2, [pc, #88]	; (8002e74 <cmd_info+0x94>)
 8002e1a:	4917      	ldr	r1, [pc, #92]	; (8002e78 <cmd_info+0x98>)
 8002e1c:	4620      	mov	r0, r4
 8002e1e:	f7ff fdb7 	bl	8002990 <chprintf>
  chprintf(chp, "Platform:     %s" SHELL_NEWLINE_STR, PLATFORM_NAME);
 8002e22:	4a16      	ldr	r2, [pc, #88]	; (8002e7c <cmd_info+0x9c>)
 8002e24:	4916      	ldr	r1, [pc, #88]	; (8002e80 <cmd_info+0xa0>)
 8002e26:	4620      	mov	r0, r4
 8002e28:	f7ff fdb2 	bl	8002990 <chprintf>
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
 8002e2c:	4a15      	ldr	r2, [pc, #84]	; (8002e84 <cmd_info+0xa4>)
 8002e2e:	4916      	ldr	r1, [pc, #88]	; (8002e88 <cmd_info+0xa8>)
 8002e30:	4620      	mov	r0, r4
 8002e32:	f7ff fdad 	bl	8002990 <chprintf>
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8002e36:	4b15      	ldr	r3, [pc, #84]	; (8002e8c <cmd_info+0xac>)
 8002e38:	9300      	str	r3, [sp, #0]
 8002e3a:	4620      	mov	r0, r4
 8002e3c:	4b14      	ldr	r3, [pc, #80]	; (8002e90 <cmd_info+0xb0>)
 8002e3e:	4a15      	ldr	r2, [pc, #84]	; (8002e94 <cmd_info+0xb4>)
 8002e40:	4915      	ldr	r1, [pc, #84]	; (8002e98 <cmd_info+0xb8>)
 8002e42:	f7ff fda5 	bl	8002990 <chprintf>
}
 8002e46:	b002      	add	sp, #8
 8002e48:	bd10      	pop	{r4, pc}
 8002e4a:	bf00      	nop
 8002e4c:	0800c248 	.word	0x0800c248
 8002e50:	0800c234 	.word	0x0800c234
 8002e54:	0800cb9c 	.word	0x0800cb9c
 8002e58:	0800c250 	.word	0x0800c250
 8002e5c:	0800c9f0 	.word	0x0800c9f0
 8002e60:	0800c264 	.word	0x0800c264
 8002e64:	0800c980 	.word	0x0800c980
 8002e68:	0800c278 	.word	0x0800c278
 8002e6c:	0800c9b8 	.word	0x0800c9b8
 8002e70:	0800c28c 	.word	0x0800c28c
 8002e74:	0800ca64 	.word	0x0800ca64
 8002e78:	0800c2a0 	.word	0x0800c2a0
 8002e7c:	0800c2b4 	.word	0x0800c2b4
 8002e80:	0800c2d0 	.word	0x0800c2d0
 8002e84:	0800c2e4 	.word	0x0800c2e4
 8002e88:	0800c30c 	.word	0x0800c30c
 8002e8c:	0800c348 	.word	0x0800c348
 8002e90:	0800c320 	.word	0x0800c320
 8002e94:	0800c324 	.word	0x0800c324
 8002e98:	0800c330 	.word	0x0800c330
 8002e9c:	00000000 	.word	0x00000000

08002ea0 <dyn_find_object>:
    chPoolFree(mp, (void *)dep);
  }
}
#endif /* CH_FACTORY_REQUIRES_POOLS */

static dyn_element_t *dyn_find_object(const char *name, dyn_list_t *dlp) {
 8002ea0:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
 8002ea2:	680c      	ldr	r4, [r1, #0]
  while (p != (dyn_element_t *)dlp) {
 8002ea4:	42a1      	cmp	r1, r4
 8002ea6:	d012      	beq.n	8002ece <dyn_find_object+0x2e>
 8002ea8:	460d      	mov	r5, r1
 8002eaa:	4606      	mov	r6, r0
 8002eac:	e002      	b.n	8002eb4 <dyn_find_object+0x14>
    p = p->next;
 8002eae:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8002eb0:	42a5      	cmp	r5, r4
 8002eb2:	d00c      	beq.n	8002ece <dyn_find_object+0x2e>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8002eb4:	2208      	movs	r2, #8
 8002eb6:	4631      	mov	r1, r6
 8002eb8:	18a0      	adds	r0, r4, r2
 8002eba:	f008 fdc9 	bl	800ba50 <strncmp>
 8002ebe:	2800      	cmp	r0, #0
 8002ec0:	d1f5      	bne.n	8002eae <dyn_find_object+0xe>

  chDbgCheck(name != NULL);

  /* Checking if an object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
  if (dep != NULL) {
 8002ec2:	b114      	cbz	r4, 8002eca <dyn_find_object+0x2a>
    /* Increasing references counter.*/
    dep->refs++;
 8002ec4:	6863      	ldr	r3, [r4, #4]
 8002ec6:	3301      	adds	r3, #1
 8002ec8:	6063      	str	r3, [r4, #4]
  }

  return dep;
}
 8002eca:	4620      	mov	r0, r4
 8002ecc:	bd70      	pop	{r4, r5, r6, pc}
  return NULL;
 8002ece:	2400      	movs	r4, #0
}
 8002ed0:	4620      	mov	r0, r4
 8002ed2:	bd70      	pop	{r4, r5, r6, pc}
	...

08002ee0 <chSchWakeupS>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8002ee0:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8002ee2:	4d12      	ldr	r5, [pc, #72]	; (8002f2c <chSchWakeupS+0x4c>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8002ee4:	4604      	mov	r4, r0
  thread_t *otp = currp;
 8002ee6:	69a8      	ldr	r0, [r5, #24]
  chDbgCheckClassS();
 8002ee8:	f7fd fe6a 	bl	8000bc0 <chDbgCheckClassS>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002eec:	682a      	ldr	r2, [r5, #0]
 8002eee:	6883      	ldr	r3, [r0, #8]
 8002ef0:	42aa      	cmp	r2, r5
 8002ef2:	d002      	beq.n	8002efa <chSchWakeupS+0x1a>
 8002ef4:	6892      	ldr	r2, [r2, #8]
 8002ef6:	429a      	cmp	r2, r3
 8002ef8:	d814      	bhi.n	8002f24 <chSchWakeupS+0x44>
  if (ntp->prio <= otp->prio) {
 8002efa:	68a2      	ldr	r2, [r4, #8]
  ntp->u.rdymsg = msg;
 8002efc:	6261      	str	r1, [r4, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 8002efe:	429a      	cmp	r2, r3
 8002f00:	d90b      	bls.n	8002f1a <chSchWakeupS+0x3a>
    otp = chSchReadyI(otp);
 8002f02:	f7fd ff2d 	bl	8000d60 <chSchReadyI>
    ntp->state = CH_STATE_CURRENT;
 8002f06:	2301      	movs	r3, #1
 8002f08:	f884 3020 	strb.w	r3, [r4, #32]
    chSysSwitch(ntp, otp);
 8002f0c:	4601      	mov	r1, r0
    currp = ntp;
 8002f0e:	61ac      	str	r4, [r5, #24]
    chSysSwitch(ntp, otp);
 8002f10:	4620      	mov	r0, r4
}
 8002f12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    chSysSwitch(ntp, otp);
 8002f16:	f7fd b9b3 	b.w	8000280 <_port_switch>
    (void) chSchReadyI(ntp);
 8002f1a:	4620      	mov	r0, r4
}
 8002f1c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void) chSchReadyI(ntp);
 8002f20:	f7fd bf1e 	b.w	8000d60 <chSchReadyI>
  __ASM volatile ("cpsid i" : : : "memory");
 8002f24:	b672      	cpsid	i
 8002f26:	4b02      	ldr	r3, [pc, #8]	; (8002f30 <chSchWakeupS+0x50>)
 8002f28:	62eb      	str	r3, [r5, #44]	; 0x2c
 8002f2a:	e7fe      	b.n	8002f2a <chSchWakeupS+0x4a>
 8002f2c:	200011a0 	.word	0x200011a0
 8002f30:	0800be8c 	.word	0x0800be8c
	...

08002f40 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8002f40:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8002f42:	4c09      	ldr	r4, [pc, #36]	; (8002f68 <chSchGoSleepS+0x28>)
 8002f44:	69a1      	ldr	r1, [r4, #24]
  chDbgCheckClassS();
 8002f46:	f7fd fe3b 	bl	8000bc0 <chDbgCheckClassS>
  thread_t *tp = tqp->next;
 8002f4a:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8002f4c:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 8002f50:	681a      	ldr	r2, [r3, #0]
 8002f52:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8002f54:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8002f56:	6054      	str	r4, [r2, #4]
 8002f58:	f883 5020 	strb.w	r5, [r3, #32]
  chSysSwitch(currp, otp);
 8002f5c:	4618      	mov	r0, r3
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002f5e:	61a3      	str	r3, [r4, #24]
}
 8002f60:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8002f64:	f7fd b98c 	b.w	8000280 <_port_switch>
 8002f68:	200011a0 	.word	0x200011a0
 8002f6c:	00000000 	.word	0x00000000

08002f70 <chMtxLockS>:
void chMtxLockS(mutex_t *mp) {
 8002f70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8002f72:	4e3b      	ldr	r6, [pc, #236]	; (8003060 <chMtxLockS+0xf0>)
 8002f74:	69b4      	ldr	r4, [r6, #24]
  chDbgCheckClassS();
 8002f76:	f7fd fe23 	bl	8000bc0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8002f7a:	2800      	cmp	r0, #0
 8002f7c:	d033      	beq.n	8002fe6 <chMtxLockS+0x76>
 8002f7e:	4605      	mov	r5, r0
  if (mp->owner != NULL) {
 8002f80:	6880      	ldr	r0, [r0, #8]
 8002f82:	b358      	cbz	r0, 8002fdc <chMtxLockS+0x6c>
      while (tp->prio < ctp->prio) {
 8002f84:	68a2      	ldr	r2, [r4, #8]
 8002f86:	6883      	ldr	r3, [r0, #8]
 8002f88:	429a      	cmp	r2, r3
 8002f8a:	d907      	bls.n	8002f9c <chMtxLockS+0x2c>
        switch (tp->state) {
 8002f8c:	f890 3020 	ldrb.w	r3, [r0, #32]
        tp->prio = ctp->prio;
 8002f90:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 8002f92:	2b06      	cmp	r3, #6
 8002f94:	d04a      	beq.n	800302c <chMtxLockS+0xbc>
 8002f96:	2b07      	cmp	r3, #7
 8002f98:	d034      	beq.n	8003004 <chMtxLockS+0x94>
 8002f9a:	b343      	cbz	r3, 8002fee <chMtxLockS+0x7e>
      queue_prio_insert(ctp, &mp->queue);
 8002f9c:	462b      	mov	r3, r5
 8002f9e:	e003      	b.n	8002fa8 <chMtxLockS+0x38>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002fa0:	6899      	ldr	r1, [r3, #8]
 8002fa2:	68a2      	ldr	r2, [r4, #8]
 8002fa4:	4291      	cmp	r1, r2
 8002fa6:	d302      	bcc.n	8002fae <chMtxLockS+0x3e>
    cp = cp->queue.next;
 8002fa8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002faa:	429d      	cmp	r5, r3
 8002fac:	d1f8      	bne.n	8002fa0 <chMtxLockS+0x30>
  tp->queue.prev             = cp->queue.prev;
 8002fae:	685a      	ldr	r2, [r3, #4]
      chSchGoSleepS(CH_STATE_WTMTX);
 8002fb0:	2006      	movs	r0, #6
 8002fb2:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8002fb6:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002fb8:	605c      	str	r4, [r3, #4]
      ctp->u.wtmtxp = mp;
 8002fba:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8002fbc:	f7ff ffc0 	bl	8002f40 <chSchGoSleepS>
      chDbgAssert(mp->owner == ctp, "not owner");
 8002fc0:	68ab      	ldr	r3, [r5, #8]
 8002fc2:	42a3      	cmp	r3, r4
 8002fc4:	d003      	beq.n	8002fce <chMtxLockS+0x5e>
 8002fc6:	b672      	cpsid	i
 8002fc8:	4b26      	ldr	r3, [pc, #152]	; (8003064 <chMtxLockS+0xf4>)
 8002fca:	62f3      	str	r3, [r6, #44]	; 0x2c
 8002fcc:	e7fe      	b.n	8002fcc <chMtxLockS+0x5c>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8002fce:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002fd0:	42ab      	cmp	r3, r5
 8002fd2:	d007      	beq.n	8002fe4 <chMtxLockS+0x74>
 8002fd4:	b672      	cpsid	i
 8002fd6:	4b23      	ldr	r3, [pc, #140]	; (8003064 <chMtxLockS+0xf4>)
 8002fd8:	62f3      	str	r3, [r6, #44]	; 0x2c
 8002fda:	e7fe      	b.n	8002fda <chMtxLockS+0x6a>
    mp->next = ctp->mtxlist;
 8002fdc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002fde:	e9c5 4302 	strd	r4, r3, [r5, #8]
    ctp->mtxlist = mp;
 8002fe2:	63a5      	str	r5, [r4, #56]	; 0x38
}
 8002fe4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002fe6:	b672      	cpsid	i
 8002fe8:	4b1e      	ldr	r3, [pc, #120]	; (8003064 <chMtxLockS+0xf4>)
 8002fea:	62f3      	str	r3, [r6, #44]	; 0x2c
 8002fec:	e7fe      	b.n	8002fec <chMtxLockS+0x7c>
  tp->queue.prev->queue.next = tp->queue.next;
 8002fee:	e9d0 2300 	ldrd	r2, r3, [r0]
          tp->state = CH_STATE_CURRENT;
 8002ff2:	2101      	movs	r1, #1
 8002ff4:	f880 1020 	strb.w	r1, [r0, #32]
 8002ff8:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002ffa:	6802      	ldr	r2, [r0, #0]
 8002ffc:	6053      	str	r3, [r2, #4]
          (void) chSchReadyI(queue_dequeue(tp));
 8002ffe:	f7fd feaf 	bl	8000d60 <chSchReadyI>
 8003002:	e7cb      	b.n	8002f9c <chMtxLockS+0x2c>
  tp->queue.prev->queue.next = tp->queue.next;
 8003004:	e9d0 1300 	ldrd	r1, r3, [r0]
 8003008:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800300a:	6807      	ldr	r7, [r0, #0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800300c:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800300e:	607b      	str	r3, [r7, #4]
 8003010:	460b      	mov	r3, r1
 8003012:	e002      	b.n	800301a <chMtxLockS+0xaa>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8003014:	689f      	ldr	r7, [r3, #8]
 8003016:	4297      	cmp	r7, r2
 8003018:	d302      	bcc.n	8003020 <chMtxLockS+0xb0>
    cp = cp->queue.next;
 800301a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800301c:	4299      	cmp	r1, r3
 800301e:	d1f9      	bne.n	8003014 <chMtxLockS+0xa4>
  tp->queue.prev             = cp->queue.prev;
 8003020:	685a      	ldr	r2, [r3, #4]
 8003022:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8003026:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8003028:	6058      	str	r0, [r3, #4]
 800302a:	e7b7      	b.n	8002f9c <chMtxLockS+0x2c>
  tp->queue.prev->queue.next = tp->queue.next;
 800302c:	e9d0 1300 	ldrd	r1, r3, [r0]
 8003030:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8003032:	6807      	ldr	r7, [r0, #0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8003034:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8003036:	607b      	str	r3, [r7, #4]
 8003038:	460b      	mov	r3, r1
 800303a:	e002      	b.n	8003042 <chMtxLockS+0xd2>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800303c:	689f      	ldr	r7, [r3, #8]
 800303e:	4297      	cmp	r7, r2
 8003040:	d302      	bcc.n	8003048 <chMtxLockS+0xd8>
    cp = cp->queue.next;
 8003042:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8003044:	4299      	cmp	r1, r3
 8003046:	d1f9      	bne.n	800303c <chMtxLockS+0xcc>
  tp->queue.prev             = cp->queue.prev;
 8003048:	685a      	ldr	r2, [r3, #4]
 800304a:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 800304e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8003050:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8003052:	6888      	ldr	r0, [r1, #8]
      while (tp->prio < ctp->prio) {
 8003054:	68a2      	ldr	r2, [r4, #8]
 8003056:	6883      	ldr	r3, [r0, #8]
 8003058:	4293      	cmp	r3, r2
 800305a:	d397      	bcc.n	8002f8c <chMtxLockS+0x1c>
 800305c:	e79e      	b.n	8002f9c <chMtxLockS+0x2c>
 800305e:	bf00      	nop
 8003060:	200011a0 	.word	0x200011a0
 8003064:	0800bd78 	.word	0x0800bd78
	...

08003070 <chThdExitS>:
  thread_t *tp = currp;
 8003070:	4d11      	ldr	r5, [pc, #68]	; (80030b8 <chThdExitS+0x48>)
 8003072:	69ac      	ldr	r4, [r5, #24]
void chThdExitS(msg_t msg) {
 8003074:	b508      	push	{r3, lr}
  return (bool)(tlp->next != (thread_t *)tlp);
 8003076:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
 8003078:	6260      	str	r0, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 800307a:	f104 0628 	add.w	r6, r4, #40	; 0x28
 800307e:	42b3      	cmp	r3, r6
 8003080:	d007      	beq.n	8003092 <chThdExitS+0x22>
  tlp->next = tp->queue.next;
 8003082:	681a      	ldr	r2, [r3, #0]
 8003084:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8003086:	4618      	mov	r0, r3
 8003088:	f7fd fe6a 	bl	8000d60 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 800308c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 800308e:	42b3      	cmp	r3, r6
 8003090:	d1f7      	bne.n	8003082 <chThdExitS+0x12>
  if ((tp->refs == (trefs_t)0) &&
 8003092:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8003096:	b943      	cbnz	r3, 80030aa <chThdExitS+0x3a>
 8003098:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 800309c:	079b      	lsls	r3, r3, #30
 800309e:	d104      	bne.n	80030aa <chThdExitS+0x3a>
    REG_REMOVE(tp);
 80030a0:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
 80030a4:	611a      	str	r2, [r3, #16]
 80030a6:	6922      	ldr	r2, [r4, #16]
 80030a8:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 80030aa:	200f      	movs	r0, #15
 80030ac:	f7ff ff48 	bl	8002f40 <chSchGoSleepS>
 80030b0:	b672      	cpsid	i
 80030b2:	4b02      	ldr	r3, [pc, #8]	; (80030bc <chThdExitS+0x4c>)
 80030b4:	62eb      	str	r3, [r5, #44]	; 0x2c
 80030b6:	e7fe      	b.n	80030b6 <chThdExitS+0x46>
 80030b8:	200011a0 	.word	0x200011a0
 80030bc:	0800bf28 	.word	0x0800bf28

080030c0 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80030c0:	b530      	push	{r4, r5, lr}
 80030c2:	b087      	sub	sp, #28
 80030c4:	4605      	mov	r5, r0
  chDbgCheckClassS();
 80030c6:	f7fd fd7b 	bl	8000bc0 <chDbgCheckClassS>
  if (TIME_INFINITE != timeout) {
 80030ca:	1c4b      	adds	r3, r1, #1
 80030cc:	d013      	beq.n	80030f6 <chSchGoSleepTimeoutS+0x36>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 80030ce:	4c0d      	ldr	r4, [pc, #52]	; (8003104 <chSchGoSleepTimeoutS+0x44>)
 80030d0:	4a0d      	ldr	r2, [pc, #52]	; (8003108 <chSchGoSleepTimeoutS+0x48>)
 80030d2:	69a3      	ldr	r3, [r4, #24]
 80030d4:	a801      	add	r0, sp, #4
 80030d6:	f7fe fddb 	bl	8001c90 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80030da:	4628      	mov	r0, r5
 80030dc:	f7ff ff30 	bl	8002f40 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {

  chDbgCheckClassI();
 80030e0:	f7fd fd7e 	bl	8000be0 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 80030e4:	9b04      	ldr	r3, [sp, #16]
 80030e6:	b113      	cbz	r3, 80030ee <chSchGoSleepTimeoutS+0x2e>
      chVTDoResetI(&vt);
 80030e8:	a801      	add	r0, sp, #4
 80030ea:	f7fe fd89 	bl	8001c00 <chVTDoResetI>
  return currp->u.rdymsg;
 80030ee:	69a3      	ldr	r3, [r4, #24]
}
 80030f0:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80030f2:	b007      	add	sp, #28
 80030f4:	bd30      	pop	{r4, r5, pc}
 80030f6:	4c03      	ldr	r4, [pc, #12]	; (8003104 <chSchGoSleepTimeoutS+0x44>)
    chSchGoSleepS(newstate);
 80030f8:	f7ff ff22 	bl	8002f40 <chSchGoSleepS>
  return currp->u.rdymsg;
 80030fc:	69a3      	ldr	r3, [r4, #24]
}
 80030fe:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8003100:	b007      	add	sp, #28
 8003102:	bd30      	pop	{r4, r5, pc}
 8003104:	200011a0 	.word	0x200011a0
 8003108:	080010f1 	.word	0x080010f1
 800310c:	00000000 	.word	0x00000000

08003110 <chSemWaitTimeoutS>:
msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout) {
 8003110:	b510      	push	{r4, lr}
  chDbgCheckClassS();
 8003112:	f7fd fd55 	bl	8000bc0 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 8003116:	b198      	cbz	r0, 8003140 <chSemWaitTimeoutS+0x30>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8003118:	6883      	ldr	r3, [r0, #8]
 800311a:	6802      	ldr	r2, [r0, #0]
 800311c:	2b00      	cmp	r3, #0
 800311e:	4604      	mov	r4, r0
 8003120:	db06      	blt.n	8003130 <chSemWaitTimeoutS+0x20>
 8003122:	4282      	cmp	r2, r0
 8003124:	d006      	beq.n	8003134 <chSemWaitTimeoutS+0x24>
 8003126:	b672      	cpsid	i
 8003128:	4b11      	ldr	r3, [pc, #68]	; (8003170 <chSemWaitTimeoutS+0x60>)
 800312a:	4a12      	ldr	r2, [pc, #72]	; (8003174 <chSemWaitTimeoutS+0x64>)
 800312c:	62da      	str	r2, [r3, #44]	; 0x2c
 800312e:	e7fe      	b.n	800312e <chSemWaitTimeoutS+0x1e>
 8003130:	4282      	cmp	r2, r0
 8003132:	d0f8      	beq.n	8003126 <chSemWaitTimeoutS+0x16>
  if (--sp->cnt < (cnt_t)0) {
 8003134:	1e5a      	subs	r2, r3, #1
 8003136:	2a00      	cmp	r2, #0
 8003138:	60a2      	str	r2, [r4, #8]
 800313a:	db06      	blt.n	800314a <chSemWaitTimeoutS+0x3a>
  return MSG_OK;
 800313c:	2000      	movs	r0, #0
}
 800313e:	bd10      	pop	{r4, pc}
 8003140:	b672      	cpsid	i
 8003142:	4b0b      	ldr	r3, [pc, #44]	; (8003170 <chSemWaitTimeoutS+0x60>)
 8003144:	4a0b      	ldr	r2, [pc, #44]	; (8003174 <chSemWaitTimeoutS+0x64>)
 8003146:	62da      	str	r2, [r3, #44]	; 0x2c
 8003148:	e7fe      	b.n	8003148 <chSemWaitTimeoutS+0x38>
    if (TIME_IMMEDIATE == timeout) {
 800314a:	b161      	cbz	r1, 8003166 <chSemWaitTimeoutS+0x56>
    currp->u.wtsemp = sp;
 800314c:	4b08      	ldr	r3, [pc, #32]	; (8003170 <chSemWaitTimeoutS+0x60>)
 800314e:	699b      	ldr	r3, [r3, #24]
 8003150:	625c      	str	r4, [r3, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 8003152:	6862      	ldr	r2, [r4, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8003154:	2005      	movs	r0, #5
 8003156:	e9c3 4200 	strd	r4, r2, [r3]
  tp->queue.prev->queue.next = tp;
 800315a:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 800315c:	6063      	str	r3, [r4, #4]
}
 800315e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8003162:	f7ff bfad 	b.w	80030c0 <chSchGoSleepTimeoutS>
      sp->cnt++;
 8003166:	60a3      	str	r3, [r4, #8]
      return MSG_TIMEOUT;
 8003168:	f04f 30ff 	mov.w	r0, #4294967295
}
 800316c:	bd10      	pop	{r4, pc}
 800316e:	bf00      	nop
 8003170:	200011a0 	.word	0x200011a0
 8003174:	0800be6c 	.word	0x0800be6c
	...

08003180 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8003180:	b161      	cbz	r1, 800319c <chThdEnqueueTimeoutS+0x1c>
  queue_insert(currp, tqp);
 8003182:	4b08      	ldr	r3, [pc, #32]	; (80031a4 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8003184:	b410      	push	{r4}
 8003186:	4602      	mov	r2, r0
  tp->queue.prev             = tqp->prev;
 8003188:	6844      	ldr	r4, [r0, #4]
  queue_insert(currp, tqp);
 800318a:	699b      	ldr	r3, [r3, #24]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800318c:	2004      	movs	r0, #4
 800318e:	e9c3 2400 	strd	r2, r4, [r3]
  tp->queue.prev->queue.next = tp;
 8003192:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8003194:	6053      	str	r3, [r2, #4]
}
 8003196:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8003198:	f7ff bf92 	b.w	80030c0 <chSchGoSleepTimeoutS>
}
 800319c:	f04f 30ff 	mov.w	r0, #4294967295
 80031a0:	4770      	bx	lr
 80031a2:	bf00      	nop
 80031a4:	200011a0 	.word	0x200011a0
	...

080031b0 <obqGetEmptyBufferTimeoutS>:
                                sysinterval_t timeout) {
 80031b0:	b538      	push	{r3, r4, r5, lr}
 80031b2:	4604      	mov	r4, r0
 80031b4:	460d      	mov	r5, r1
  osalDbgCheckClassS();
 80031b6:	f7fd fd03 	bl	8000bc0 <chDbgCheckClassS>
 80031ba:	e005      	b.n	80031c8 <obqGetEmptyBufferTimeoutS+0x18>
    if (obqp->suspended) {
 80031bc:	7a23      	ldrb	r3, [r4, #8]
 80031be:	b993      	cbnz	r3, 80031e6 <obqGetEmptyBufferTimeoutS+0x36>
  return chThdEnqueueTimeoutS(tqp, timeout);
 80031c0:	f7ff ffde 	bl	8003180 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80031c4:	2800      	cmp	r0, #0
 80031c6:	db0d      	blt.n	80031e4 <obqGetEmptyBufferTimeoutS+0x34>
  while (obqIsFullI(obqp)) {
 80031c8:	68e3      	ldr	r3, [r4, #12]
 80031ca:	4629      	mov	r1, r5
 80031cc:	4620      	mov	r0, r4
 80031ce:	2b00      	cmp	r3, #0
 80031d0:	d0f4      	beq.n	80031bc <obqGetEmptyBufferTimeoutS+0xc>
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 80031d2:	68e3      	ldr	r3, [r4, #12]
 80031d4:	b153      	cbz	r3, 80031ec <obqGetEmptyBufferTimeoutS+0x3c>
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80031d6:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
 80031d8:	69e1      	ldr	r1, [r4, #28]
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80031da:	1d1a      	adds	r2, r3, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 80031dc:	440b      	add	r3, r1
 80031de:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
 80031e2:	2000      	movs	r0, #0
}
 80031e4:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 80031e6:	f06f 0001 	mvn.w	r0, #1
}
 80031ea:	bd38      	pop	{r3, r4, r5, pc}
 80031ec:	b672      	cpsid	i
 80031ee:	4b02      	ldr	r3, [pc, #8]	; (80031f8 <obqGetEmptyBufferTimeoutS+0x48>)
 80031f0:	4a02      	ldr	r2, [pc, #8]	; (80031fc <obqGetEmptyBufferTimeoutS+0x4c>)
 80031f2:	62da      	str	r2, [r3, #44]	; 0x2c
 80031f4:	e7fe      	b.n	80031f4 <obqGetEmptyBufferTimeoutS+0x44>
 80031f6:	bf00      	nop
 80031f8:	200011a0 	.word	0x200011a0
 80031fc:	0800c100 	.word	0x0800c100

08003200 <ibqGetFullBufferTimeoutS>:
                                 sysinterval_t timeout) {
 8003200:	b538      	push	{r3, r4, r5, lr}
 8003202:	4604      	mov	r4, r0
 8003204:	460d      	mov	r5, r1
  osalDbgCheckClassS();
 8003206:	f7fd fcdb 	bl	8000bc0 <chDbgCheckClassS>
 800320a:	e005      	b.n	8003218 <ibqGetFullBufferTimeoutS+0x18>
    if (ibqp->suspended) {
 800320c:	7a23      	ldrb	r3, [r4, #8]
 800320e:	b993      	cbnz	r3, 8003236 <ibqGetFullBufferTimeoutS+0x36>
 8003210:	f7ff ffb6 	bl	8003180 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8003214:	2800      	cmp	r0, #0
 8003216:	db0d      	blt.n	8003234 <ibqGetFullBufferTimeoutS+0x34>
  while (ibqIsEmptyI(ibqp)) {
 8003218:	68e3      	ldr	r3, [r4, #12]
 800321a:	4629      	mov	r1, r5
 800321c:	4620      	mov	r0, r4
 800321e:	2b00      	cmp	r3, #0
 8003220:	d0f4      	beq.n	800320c <ibqGetFullBufferTimeoutS+0xc>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8003222:	68e3      	ldr	r3, [r4, #12]
 8003224:	b153      	cbz	r3, 800323c <ibqGetFullBufferTimeoutS+0x3c>
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8003226:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003228:	681a      	ldr	r2, [r3, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800322a:	3304      	adds	r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 800322c:	441a      	add	r2, r3
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800322e:	e9c4 320a 	strd	r3, r2, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003232:	2000      	movs	r0, #0
}
 8003234:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 8003236:	f06f 0001 	mvn.w	r0, #1
}
 800323a:	bd38      	pop	{r3, r4, r5, pc}
 800323c:	b672      	cpsid	i
 800323e:	4b02      	ldr	r3, [pc, #8]	; (8003248 <ibqGetFullBufferTimeoutS+0x48>)
 8003240:	4a02      	ldr	r2, [pc, #8]	; (800324c <ibqGetFullBufferTimeoutS+0x4c>)
 8003242:	62da      	str	r2, [r3, #44]	; 0x2c
 8003244:	e7fe      	b.n	8003244 <ibqGetFullBufferTimeoutS+0x44>
 8003246:	bf00      	nop
 8003248:	200011a0 	.word	0x200011a0
 800324c:	0800c02c 	.word	0x0800c02c

08003250 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8003250:	b570      	push	{r4, r5, r6, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8003252:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8003256:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8003258:	b113      	cbz	r3, 8003260 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
 800325a:	2300      	movs	r3, #0
 800325c:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8003260:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  if ((usbp->config->requests_hook_cb == NULL) ||
 8003264:	6862      	ldr	r2, [r4, #4]
 8003266:	68cb      	ldr	r3, [r1, #12]
 8003268:	6a1b      	ldr	r3, [r3, #32]
 800326a:	6819      	ldr	r1, [r3, #0]
 800326c:	685b      	ldr	r3, [r3, #4]
 800326e:	6623      	str	r3, [r4, #96]	; 0x60
 8003270:	65e1      	str	r1, [r4, #92]	; 0x5c
 8003272:	6893      	ldr	r3, [r2, #8]
 8003274:	b343      	cbz	r3, 80032c8 <_usb_ep0setup+0x78>
      !(usbp->config->requests_hook_cb(usbp))) {
 8003276:	4620      	mov	r0, r4
 8003278:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800327a:	b328      	cbz	r0, 80032c8 <_usb_ep0setup+0x78>
 800327c:	6d61      	ldr	r1, [r4, #84]	; 0x54
 800327e:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
  hw |= (uint16_t)*p << 8U;
 8003282:	f894 0063 	ldrb.w	r0, [r4, #99]	; 0x63
 8003286:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
  max = (size_t)get_hword(&usbp->setup[6]);
 800328a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  if (usbp->ep0n > max) {
 800328e:	428a      	cmp	r2, r1
 8003290:	bf2c      	ite	cs
 8003292:	460a      	movcs	r2, r1
    usbp->ep0n = max;
 8003294:	6562      	strcc	r2, [r4, #84]	; 0x54
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8003296:	0619      	lsls	r1, r3, #24
 8003298:	f100 8098 	bmi.w	80033cc <_usb_ep0setup+0x17c>
    if (usbp->ep0n != 0U) {
 800329c:	2a00      	cmp	r2, #0
 800329e:	d06b      	beq.n	8003378 <_usb_ep0setup+0x128>
      usbp->ep0state = USB_EP0_OUT_RX;
 80032a0:	2315      	movs	r3, #21
 80032a2:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80032a6:	2320      	movs	r3, #32
 80032a8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80032ac:	f7fd ff08 	bl	80010c0 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 80032b0:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
 80032b4:	4620      	mov	r0, r4
 80032b6:	2100      	movs	r1, #0
 80032b8:	f7fe f9ca 	bl	8001650 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
 80032bc:	f7fd fee8 	bl	8001090 <_dbg_check_unlock_from_isr>
 80032c0:	2300      	movs	r3, #0
 80032c2:	f383 8811 	msr	BASEPRI, r3
}
 80032c6:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 80032c8:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 80032cc:	f013 0560 	ands.w	r5, r3, #96	; 0x60
 80032d0:	4619      	mov	r1, r3
 80032d2:	d016      	beq.n	8003302 <_usb_ep0setup+0xb2>
 80032d4:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80032d6:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80032da:	6861      	ldr	r1, [r4, #4]
 80032dc:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80032e0:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80032e4:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 80032e8:	680d      	ldr	r5, [r1, #0]
 80032ea:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80032ee:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 80032f2:	b115      	cbz	r5, 80032fa <_usb_ep0setup+0xaa>
 80032f4:	2106      	movs	r1, #6
 80032f6:	4620      	mov	r0, r4
 80032f8:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 80032fa:	2306      	movs	r3, #6
 80032fc:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 8003300:	bd70      	pop	{r4, r5, r6, pc}
           ((uint32_t)usbp->setup[1] << 8U))) {
 8003302:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003306:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 800330a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800330e:	f240 3002 	movw	r0, #770	; 0x302
 8003312:	4282      	cmp	r2, r0
 8003314:	f000 80d1 	beq.w	80034ba <_usb_ep0setup+0x26a>
 8003318:	d842      	bhi.n	80033a0 <_usb_ep0setup+0x150>
 800331a:	2a02      	cmp	r2, #2
 800331c:	f000 80b7 	beq.w	800348e <_usb_ep0setup+0x23e>
 8003320:	f240 80ad 	bls.w	800347e <_usb_ep0setup+0x22e>
 8003324:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
 8003328:	f000 80e4 	beq.w	80034f4 <_usb_ep0setup+0x2a4>
 800332c:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8003330:	d07d      	beq.n	800342e <_usb_ep0setup+0x1de>
 8003332:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8003336:	d1cd      	bne.n	80032d4 <_usb_ep0setup+0x84>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8003338:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 800333c:	2b01      	cmp	r3, #1
 800333e:	d1c9      	bne.n	80032d4 <_usb_ep0setup+0x84>
      usbp->status &= ~2U;
 8003340:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003344:	6525      	str	r5, [r4, #80]	; 0x50
      usbp->status &= ~2U;
 8003346:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800334a:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
      usbp->status &= ~2U;
 800334e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 8003352:	e00f      	b.n	8003374 <_usb_ep0setup+0x124>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003354:	f5b2 6fc0 	cmp.w	r2, #1536	; 0x600
 8003358:	d278      	bcs.n	800344c <_usb_ep0setup+0x1fc>
 800335a:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800335e:	d1b9      	bne.n	80032d4 <_usb_ep0setup+0x84>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8003360:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 8003364:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8003368:	f000 80e4 	beq.w	8003534 <_usb_ep0setup+0x2e4>
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800336c:	2300      	movs	r3, #0
 800336e:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
 8003372:	65a3      	str	r3, [r4, #88]	; 0x58
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8003374:	060b      	lsls	r3, r1, #24
 8003376:	d436      	bmi.n	80033e6 <_usb_ep0setup+0x196>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8003378:	230b      	movs	r3, #11
 800337a:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 800337e:	2320      	movs	r3, #32
 8003380:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8003384:	f7fd fe9c 	bl	80010c0 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8003388:	2300      	movs	r3, #0
 800338a:	4620      	mov	r0, r4
 800338c:	461a      	mov	r2, r3
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800338e:	2100      	movs	r1, #0
 8003390:	f7fe f8d6 	bl	8001540 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8003394:	f7fd fe7c 	bl	8001090 <_dbg_check_unlock_from_isr>
 8003398:	2300      	movs	r3, #0
 800339a:	f383 8811 	msr	BASEPRI, r3
}
 800339e:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80033a0:	f240 6001 	movw	r0, #1537	; 0x601
 80033a4:	4282      	cmp	r2, r0
 80033a6:	d9d5      	bls.n	8003354 <_usb_ep0setup+0x104>
 80033a8:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
 80033ac:	d027      	beq.n	80033fe <_usb_ep0setup+0x1ae>
 80033ae:	f640 4102 	movw	r1, #3074	; 0xc02
 80033b2:	428a      	cmp	r2, r1
 80033b4:	f000 809c 	beq.w	80034f0 <_usb_ep0setup+0x2a0>
 80033b8:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 80033bc:	d18a      	bne.n	80032d4 <_usb_ep0setup+0x84>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80033be:	f104 0267 	add.w	r2, r4, #103	; 0x67
 80033c2:	2101      	movs	r1, #1
 80033c4:	65a5      	str	r5, [r4, #88]	; 0x58
 80033c6:	e9c4 2114 	strd	r2, r1, [r4, #80]	; 0x50
 80033ca:	e75a      	b.n	8003282 <_usb_ep0setup+0x32>
    if (usbp->ep0n != 0U) {
 80033cc:	b15a      	cbz	r2, 80033e6 <_usb_ep0setup+0x196>
      usbp->ep0state = USB_EP0_IN_TX;
 80033ce:	2309      	movs	r3, #9
 80033d0:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 80033d4:	2320      	movs	r3, #32
 80033d6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80033da:	f7fd fe71 	bl	80010c0 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80033de:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
 80033e2:	4620      	mov	r0, r4
 80033e4:	e7d3      	b.n	800338e <_usb_ep0setup+0x13e>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 80033e6:	2314      	movs	r3, #20
 80033e8:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 80033ec:	2320      	movs	r3, #32
 80033ee:	f383 8811 	msr	BASEPRI, r3
 80033f2:	f7fd fe65 	bl	80010c0 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, NULL, 0);
 80033f6:	2300      	movs	r3, #0
 80033f8:	4620      	mov	r0, r4
 80033fa:	461a      	mov	r2, r3
 80033fc:	e75b      	b.n	80032b6 <_usb_ep0setup+0x66>
      if (usbp->state == USB_ACTIVE) {
 80033fe:	7823      	ldrb	r3, [r4, #0]
 8003400:	2b04      	cmp	r3, #4
 8003402:	f000 80af 	beq.w	8003564 <_usb_ep0setup+0x314>
      if (usbp->setup[2] != 0U) {
 8003406:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 800340a:	b14b      	cbz	r3, 8003420 <_usb_ep0setup+0x1d0>
        usbp->state = USB_ACTIVE;
 800340c:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800340e:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 8003410:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 8003414:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8003416:	6813      	ldr	r3, [r2, #0]
 8003418:	b113      	cbz	r3, 8003420 <_usb_ep0setup+0x1d0>
 800341a:	2102      	movs	r1, #2
 800341c:	4620      	mov	r0, r4
 800341e:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8003420:	2300      	movs	r3, #0
 8003422:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
 8003426:	65a3      	str	r3, [r4, #88]	; 0x58
 8003428:	f894 105c 	ldrb.w	r1, [r4, #92]	; 0x5c
 800342c:	e7a2      	b.n	8003374 <_usb_ep0setup+0x124>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800342e:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 8003432:	2b01      	cmp	r3, #1
 8003434:	f47f af4e 	bne.w	80032d4 <_usb_ep0setup+0x84>
      usbp->status |= 2U;
 8003438:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800343c:	6525      	str	r5, [r4, #80]	; 0x50
      usbp->status |= 2U;
 800343e:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003442:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
      usbp->status |= 2U;
 8003446:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 800344a:	e793      	b.n	8003374 <_usb_ep0setup+0x124>
  hw |= (uint16_t)*p << 8U;
 800344c:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8003450:	6861      	ldr	r1, [r4, #4]
  hw |= (uint16_t)*p << 8U;
 8003452:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8003456:	684e      	ldr	r6, [r1, #4]
 8003458:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 800345c:	f894 105f 	ldrb.w	r1, [r4, #95]	; 0x5f
 8003460:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8003464:	4620      	mov	r0, r4
 8003466:	47b0      	blx	r6
    if (dp == NULL) {
 8003468:	2800      	cmp	r0, #0
 800346a:	f43f af33 	beq.w	80032d4 <_usb_ep0setup+0x84>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800346e:	e9d0 1300 	ldrd	r1, r3, [r0]
 8003472:	65a5      	str	r5, [r4, #88]	; 0x58
 8003474:	e9c4 3114 	strd	r3, r1, [r4, #80]	; 0x50
 8003478:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 800347c:	e701      	b.n	8003282 <_usb_ep0setup+0x32>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800347e:	bba2      	cbnz	r2, 80034ea <_usb_ep0setup+0x29a>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8003480:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8003484:	2102      	movs	r1, #2
 8003486:	65a2      	str	r2, [r4, #88]	; 0x58
 8003488:	e9c4 0114 	strd	r0, r1, [r4, #80]	; 0x50
 800348c:	e6f9      	b.n	8003282 <_usb_ep0setup+0x32>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800348e:	f894 0060 	ldrb.w	r0, [r4, #96]	; 0x60
 8003492:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8003494:	0605      	lsls	r5, r0, #24
 8003496:	f000 010f 	and.w	r1, r0, #15
 800349a:	d444      	bmi.n	8003526 <_usb_ep0setup+0x2d6>
  ctl = usbp->otg->oe[ep].DOEPCTL;
 800349c:	3158      	adds	r1, #88	; 0x58
 800349e:	0149      	lsls	r1, r1, #5
 80034a0:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 80034a2:	040e      	lsls	r6, r1, #16
 80034a4:	f57f af17 	bpl.w	80032d6 <_usb_ep0setup+0x86>
  if (ctl & DIEPCTL_STALL)
 80034a8:	028a      	lsls	r2, r1, #10
 80034aa:	d53a      	bpl.n	8003522 <_usb_ep0setup+0x2d2>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 80034ac:	4a5a      	ldr	r2, [pc, #360]	; (8003618 <_usb_ep0setup+0x3c8>)
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 80034ae:	6522      	str	r2, [r4, #80]	; 0x50
 80034b0:	2102      	movs	r1, #2
 80034b2:	2200      	movs	r2, #0
 80034b4:	e9c4 1215 	strd	r1, r2, [r4, #84]	; 0x54
 80034b8:	e6e3      	b.n	8003282 <_usb_ep0setup+0x32>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80034ba:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 80034be:	2b00      	cmp	r3, #0
 80034c0:	f47f af08 	bne.w	80032d4 <_usb_ep0setup+0x84>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80034c4:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 80034c8:	f012 000f 	ands.w	r0, r2, #15
 80034cc:	f43f af4e 	beq.w	800336c <_usb_ep0setup+0x11c>
 80034d0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80034d2:	eb03 1340 	add.w	r3, r3, r0, lsl #5
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80034d6:	0610      	lsls	r0, r2, #24
 80034d8:	f100 808f 	bmi.w	80035fa <_usb_ep0setup+0x3aa>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80034dc:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80034e0:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80034e4:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 80034e8:	e740      	b.n	800336c <_usb_ep0setup+0x11c>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80034ea:	2a01      	cmp	r2, #1
 80034ec:	f47f aef2 	bne.w	80032d4 <_usb_ep0setup+0x84>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80034f0:	4a4a      	ldr	r2, [pc, #296]	; (800361c <_usb_ep0setup+0x3cc>)
 80034f2:	e7dc      	b.n	80034ae <_usb_ep0setup+0x25e>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80034f4:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 80034f8:	2b00      	cmp	r3, #0
 80034fa:	f47f aeeb 	bne.w	80032d4 <_usb_ep0setup+0x84>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80034fe:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 8003502:	f012 000f 	ands.w	r0, r2, #15
 8003506:	f43f af31 	beq.w	800336c <_usb_ep0setup+0x11c>
 800350a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800350c:	0615      	lsls	r5, r2, #24
 800350e:	eb03 1340 	add.w	r3, r3, r0, lsl #5
 8003512:	d479      	bmi.n	8003608 <_usb_ep0setup+0x3b8>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8003514:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8003518:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800351c:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8003520:	e724      	b.n	800336c <_usb_ep0setup+0x11c>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8003522:	4a3f      	ldr	r2, [pc, #252]	; (8003620 <_usb_ep0setup+0x3d0>)
 8003524:	e7c3      	b.n	80034ae <_usb_ep0setup+0x25e>
  ctl = usbp->otg->ie[ep].DIEPCTL;
 8003526:	3148      	adds	r1, #72	; 0x48
 8003528:	0149      	lsls	r1, r1, #5
 800352a:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 800352c:	0408      	lsls	r0, r1, #16
 800352e:	f57f aed2 	bpl.w	80032d6 <_usb_ep0setup+0x86>
 8003532:	e7b9      	b.n	80034a8 <_usb_ep0setup+0x258>
  usbp->address = usbp->setup[2];
 8003534:	f894 005e 	ldrb.w	r0, [r4, #94]	; 0x5e
  stm32_otg_t *otgp = usbp->otg;
 8003538:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 800353a:	f884 0066 	strb.w	r0, [r4, #102]	; 0x66
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800353e:	f8d1 3800 	ldr.w	r3, [r1, #2048]	; 0x800
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8003542:	6862      	ldr	r2, [r4, #4]
 8003544:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8003548:	6812      	ldr	r2, [r2, #0]
 800354a:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 800354e:	f8c1 3800 	str.w	r3, [r1, #2048]	; 0x800
 8003552:	b112      	cbz	r2, 800355a <_usb_ep0setup+0x30a>
 8003554:	2101      	movs	r1, #1
 8003556:	4620      	mov	r0, r4
 8003558:	4790      	blx	r2
  usbp->state = USB_SELECTED;
 800355a:	2303      	movs	r3, #3
 800355c:	f894 105c 	ldrb.w	r1, [r4, #92]	; 0x5c
 8003560:	7023      	strb	r3, [r4, #0]
 8003562:	e703      	b.n	800336c <_usb_ep0setup+0x11c>
 8003564:	2320      	movs	r3, #32
 8003566:	f383 8811 	msr	BASEPRI, r3
 800356a:	f7fd fda9 	bl	80010c0 <_dbg_check_lock_from_isr>
  osalDbgCheckClassI();
 800356e:	f7fd fb37 	bl	8000be0 <chDbgCheckClassI>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 8003572:	7823      	ldrb	r3, [r4, #0]
 8003574:	2b04      	cmp	r3, #4
 8003576:	d004      	beq.n	8003582 <_usb_ep0setup+0x332>
  __ASM volatile ("cpsid i" : : : "memory");
 8003578:	b672      	cpsid	i
 800357a:	4b2a      	ldr	r3, [pc, #168]	; (8003624 <_usb_ep0setup+0x3d4>)
 800357c:	4a2a      	ldr	r2, [pc, #168]	; (8003628 <_usb_ep0setup+0x3d8>)
 800357e:	62da      	str	r2, [r3, #44]	; 0x2c
 8003580:	e7fe      	b.n	8003580 <_usb_ep0setup+0x330>
 8003582:	6f22      	ldr	r2, [r4, #112]	; 0x70
  usbp->transmitting &= 1U;
 8003584:	8921      	ldrh	r1, [r4, #8]
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8003586:	6813      	ldr	r3, [r2, #0]
 8003588:	6763      	str	r3, [r4, #116]	; 0x74
  usbp->receiving    &= 1U;
 800358a:	8963      	ldrh	r3, [r4, #10]
 800358c:	6890      	ldr	r0, [r2, #8]
 800358e:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
    usbp->epc[i] = NULL;
 8003590:	6125      	str	r5, [r4, #16]
  usbp->transmitting &= 1U;
 8003592:	f001 0101 	and.w	r1, r1, #1
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003596:	462a      	mov	r2, r5
  usbp->receiving    &= 1U;
 8003598:	f003 0301 	and.w	r3, r3, #1
    usbp->epc[i] = NULL;
 800359c:	e9c4 5505 	strd	r5, r5, [r4, #20]
 80035a0:	e9c4 5507 	strd	r5, r5, [r4, #28]
  usbp->transmitting &= 1U;
 80035a4:	8121      	strh	r1, [r4, #8]
 80035a6:	1c45      	adds	r5, r0, #1
  usbp->receiving    &= 1U;
 80035a8:	8163      	strh	r3, [r4, #10]
    otgp->ie[i].DIEPCTL = 0;
 80035aa:	4610      	mov	r0, r2
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80035ac:	f04f 31ff 	mov.w	r1, #4294967295
 80035b0:	eb06 1342 	add.w	r3, r6, r2, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80035b4:	3201      	adds	r2, #1
 80035b6:	4295      	cmp	r5, r2
    otgp->ie[i].DIEPCTL = 0;
 80035b8:	f8c3 0900 	str.w	r0, [r3, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
 80035bc:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80035c0:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
 80035c4:	f8c3 0b00 	str.w	r0, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 80035c8:	f8c3 0b10 	str.w	r0, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80035cc:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80035d0:	d1ee      	bne.n	80035b0 <_usb_ep0setup+0x360>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80035d2:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80035d6:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
  _dbg_check_unlock_from_isr();
 80035da:	f7fd fd59 	bl	8001090 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80035de:	f380 8811 	msr	BASEPRI, r0
        usbp->state = USB_SELECTED;
 80035e2:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80035e4:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
 80035e6:	f884 0067 	strb.w	r0, [r4, #103]	; 0x67
        usbp->state = USB_SELECTED;
 80035ea:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80035ec:	681b      	ldr	r3, [r3, #0]
 80035ee:	2b00      	cmp	r3, #0
 80035f0:	f43f af09 	beq.w	8003406 <_usb_ep0setup+0x1b6>
 80035f4:	4620      	mov	r0, r4
 80035f6:	4798      	blx	r3
 80035f8:	e705      	b.n	8003406 <_usb_ep0setup+0x1b6>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80035fa:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80035fe:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003602:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8003606:	e6b1      	b.n	800336c <_usb_ep0setup+0x11c>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8003608:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800360c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8003610:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8003614:	e6aa      	b.n	800336c <_usb_ep0setup+0x11c>
 8003616:	bf00      	nop
 8003618:	0800c520 	.word	0x0800c520
 800361c:	0800e8f0 	.word	0x0800e8f0
 8003620:	0800c1c0 	.word	0x0800c1c0
 8003624:	200011a0 	.word	0x200011a0
 8003628:	0800c0bc 	.word	0x0800c0bc
 800362c:	00000000 	.word	0x00000000

08003630 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003630:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
 8003634:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8003636:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800363a:	2300      	movs	r3, #0
 800363c:	f383 8811 	msr	BASEPRI, r3
}
 8003640:	4770      	bx	lr
 8003642:	bf00      	nop
	...

08003650 <chSchDoReschedule>:
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 8003650:	4817      	ldr	r0, [pc, #92]	; (80036b0 <chSchDoReschedule+0x60>)
  thread_t *tp = tqp->next;
 8003652:	6803      	ldr	r3, [r0, #0]
 8003654:	6981      	ldr	r1, [r0, #24]
void chSchDoRescheduleAhead(void) {
 8003656:	b510      	push	{r4, lr}
  tqp->next             = tp->queue.next;
 8003658:	681c      	ldr	r4, [r3, #0]
 800365a:	6004      	str	r4, [r0, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800365c:	2201      	movs	r2, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800365e:	6060      	str	r0, [r4, #4]
 8003660:	f883 2020 	strb.w	r2, [r3, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8003664:	6183      	str	r3, [r0, #24]
  chDbgCheckClassI();
 8003666:	f7fd fabb 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800366a:	b1e9      	cbz	r1, 80036a8 <chSchDoReschedule+0x58>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800366c:	f891 3020 	ldrb.w	r3, [r1, #32]
 8003670:	b1b3      	cbz	r3, 80036a0 <chSchDoReschedule+0x50>
 8003672:	2b0f      	cmp	r3, #15
 8003674:	d014      	beq.n	80036a0 <chSchDoReschedule+0x50>
  tp->state = CH_STATE_READY;
 8003676:	2300      	movs	r3, #0
 8003678:	f881 3020 	strb.w	r3, [r1, #32]
  } while (cp->prio > tp->prio);
 800367c:	688a      	ldr	r2, [r1, #8]
 800367e:	68a3      	ldr	r3, [r4, #8]
 8003680:	4293      	cmp	r3, r2
 8003682:	d903      	bls.n	800368c <chSchDoReschedule+0x3c>
 8003684:	6824      	ldr	r4, [r4, #0]
 8003686:	68a3      	ldr	r3, [r4, #8]
 8003688:	4293      	cmp	r3, r2
 800368a:	d8fb      	bhi.n	8003684 <chSchDoReschedule+0x34>
  tp->queue.prev             = cp->queue.prev;
 800368c:	6863      	ldr	r3, [r4, #4]
 800368e:	e9c1 4300 	strd	r4, r3, [r1]
  tp->queue.prev->queue.next = tp;
 8003692:	6019      	str	r1, [r3, #0]
  cp->queue.prev             = tp;
 8003694:	6061      	str	r1, [r4, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8003696:	6980      	ldr	r0, [r0, #24]
}
 8003698:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chSysSwitch(currp, otp);
 800369c:	f7fc bdf0 	b.w	8000280 <_port_switch>
  __ASM volatile ("cpsid i" : : : "memory");
 80036a0:	b672      	cpsid	i
 80036a2:	4b04      	ldr	r3, [pc, #16]	; (80036b4 <chSchDoReschedule+0x64>)
 80036a4:	62c3      	str	r3, [r0, #44]	; 0x2c
 80036a6:	e7fe      	b.n	80036a6 <chSchDoReschedule+0x56>
 80036a8:	b672      	cpsid	i
 80036aa:	4b02      	ldr	r3, [pc, #8]	; (80036b4 <chSchDoReschedule+0x64>)
 80036ac:	62c3      	str	r3, [r0, #44]	; 0x2c
 80036ae:	e7fe      	b.n	80036ae <chSchDoReschedule+0x5e>
 80036b0:	200011a0 	.word	0x200011a0
 80036b4:	0800bda0 	.word	0x0800bda0
	...

080036c0 <chSchRescheduleS>:
void chSchRescheduleS(void) {
 80036c0:	b508      	push	{r3, lr}
  chDbgCheckClassS();
 80036c2:	f7fd fa7d 	bl	8000bc0 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 80036c6:	f7fd fa8b 	bl	8000be0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 80036ca:	4b06      	ldr	r3, [pc, #24]	; (80036e4 <chSchRescheduleS+0x24>)
 80036cc:	681a      	ldr	r2, [r3, #0]
 80036ce:	699b      	ldr	r3, [r3, #24]
  if (chSchIsRescRequiredI()) {
 80036d0:	6892      	ldr	r2, [r2, #8]
 80036d2:	689b      	ldr	r3, [r3, #8]
 80036d4:	429a      	cmp	r2, r3
 80036d6:	d800      	bhi.n	80036da <chSchRescheduleS+0x1a>
}
 80036d8:	bd08      	pop	{r3, pc}
 80036da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    chSchDoRescheduleAhead();
 80036de:	f7ff bfb7 	b.w	8003650 <chSchDoReschedule>
 80036e2:	bf00      	nop
 80036e4:	200011a0 	.word	0x200011a0
	...

080036f0 <_dbg_check_unlock>:
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80036f0:	4b05      	ldr	r3, [pc, #20]	; (8003708 <_dbg_check_unlock+0x18>)
 80036f2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80036f4:	b922      	cbnz	r2, 8003700 <_dbg_check_unlock+0x10>
 80036f6:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80036f8:	2900      	cmp	r1, #0
 80036fa:	dd01      	ble.n	8003700 <_dbg_check_unlock+0x10>
  _dbg_leave_lock();
 80036fc:	635a      	str	r2, [r3, #52]	; 0x34
}
 80036fe:	4770      	bx	lr
 8003700:	b672      	cpsid	i
 8003702:	4a02      	ldr	r2, [pc, #8]	; (800370c <_dbg_check_unlock+0x1c>)
 8003704:	62da      	str	r2, [r3, #44]	; 0x2c
 8003706:	e7fe      	b.n	8003706 <_dbg_check_unlock+0x16>
 8003708:	200011a0 	.word	0x200011a0
 800370c:	0800c19c 	.word	0x0800c19c

08003710 <chSysUnlock.lto_priv.103>:
static inline void chSysUnlock(void) {
 8003710:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8003712:	f7ff ffed 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003716:	4b08      	ldr	r3, [pc, #32]	; (8003738 <chSysUnlock.lto_priv.103+0x28>)
 8003718:	681a      	ldr	r2, [r3, #0]
 800371a:	429a      	cmp	r2, r3
 800371c:	d004      	beq.n	8003728 <chSysUnlock.lto_priv.103+0x18>
 800371e:	6999      	ldr	r1, [r3, #24]
 8003720:	6892      	ldr	r2, [r2, #8]
 8003722:	6889      	ldr	r1, [r1, #8]
 8003724:	4291      	cmp	r1, r2
 8003726:	d303      	bcc.n	8003730 <chSysUnlock.lto_priv.103+0x20>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003728:	2300      	movs	r3, #0
 800372a:	f383 8811 	msr	BASEPRI, r3
}
 800372e:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003730:	b672      	cpsid	i
 8003732:	4a02      	ldr	r2, [pc, #8]	; (800373c <chSysUnlock.lto_priv.103+0x2c>)
 8003734:	62da      	str	r2, [r3, #44]	; 0x2c
 8003736:	e7fe      	b.n	8003736 <chSysUnlock.lto_priv.103+0x26>
 8003738:	200011a0 	.word	0x200011a0
 800373c:	0800bc14 	.word	0x0800bc14

08003740 <chSysUnlock.lto_priv.119>:
static inline void chSysUnlock(void) {
 8003740:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8003742:	f7ff ffd5 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003746:	4b08      	ldr	r3, [pc, #32]	; (8003768 <chSysUnlock.lto_priv.119+0x28>)
 8003748:	681a      	ldr	r2, [r3, #0]
 800374a:	429a      	cmp	r2, r3
 800374c:	d004      	beq.n	8003758 <chSysUnlock.lto_priv.119+0x18>
 800374e:	6999      	ldr	r1, [r3, #24]
 8003750:	6892      	ldr	r2, [r2, #8]
 8003752:	6889      	ldr	r1, [r1, #8]
 8003754:	4291      	cmp	r1, r2
 8003756:	d303      	bcc.n	8003760 <chSysUnlock.lto_priv.119+0x20>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003758:	2300      	movs	r3, #0
 800375a:	f383 8811 	msr	BASEPRI, r3
}
 800375e:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003760:	b672      	cpsid	i
 8003762:	4a02      	ldr	r2, [pc, #8]	; (800376c <chSysUnlock.lto_priv.119+0x2c>)
 8003764:	62da      	str	r2, [r3, #44]	; 0x2c
 8003766:	e7fe      	b.n	8003766 <chSysUnlock.lto_priv.119+0x26>
 8003768:	200011a0 	.word	0x200011a0
 800376c:	0800bcc8 	.word	0x0800bcc8

08003770 <chSysRestoreStatusX.part.2>:
void chSysRestoreStatusX(syssts_t sts) {
 8003770:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003772:	f3ef 8305 	mrs	r3, IPSR
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 8003776:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (port_is_isr_context()) {
 800377a:	b9a3      	cbnz	r3, 80037a6 <chSysRestoreStatusX.part.2+0x36>
      chSchRescheduleS();
 800377c:	f7ff ffa0 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8003780:	f7ff ffb6 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003784:	4b0b      	ldr	r3, [pc, #44]	; (80037b4 <chSysRestoreStatusX.part.2+0x44>)
 8003786:	681a      	ldr	r2, [r3, #0]
 8003788:	429a      	cmp	r2, r3
 800378a:	d008      	beq.n	800379e <chSysRestoreStatusX.part.2+0x2e>
 800378c:	6999      	ldr	r1, [r3, #24]
 800378e:	6892      	ldr	r2, [r2, #8]
 8003790:	6889      	ldr	r1, [r1, #8]
 8003792:	4291      	cmp	r1, r2
 8003794:	d203      	bcs.n	800379e <chSysRestoreStatusX.part.2+0x2e>
  __ASM volatile ("cpsid i" : : : "memory");
 8003796:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 8003798:	4a07      	ldr	r2, [pc, #28]	; (80037b8 <chSysRestoreStatusX.part.2+0x48>)
 800379a:	62da      	str	r2, [r3, #44]	; 0x2c
 800379c:	e7fe      	b.n	800379c <chSysRestoreStatusX.part.2+0x2c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800379e:	2300      	movs	r3, #0
 80037a0:	f383 8811 	msr	BASEPRI, r3
}
 80037a4:	bd08      	pop	{r3, pc}
  _dbg_check_unlock_from_isr();
 80037a6:	f7fd fc73 	bl	8001090 <_dbg_check_unlock_from_isr>
 80037aa:	2300      	movs	r3, #0
 80037ac:	f383 8811 	msr	BASEPRI, r3
 80037b0:	bd08      	pop	{r3, pc}
 80037b2:	bf00      	nop
 80037b4:	200011a0 	.word	0x200011a0
 80037b8:	0800bbd8 	.word	0x0800bbd8
 80037bc:	00000000 	.word	0x00000000

080037c0 <_dbg_check_lock>:
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80037c0:	4b05      	ldr	r3, [pc, #20]	; (80037d8 <_dbg_check_lock+0x18>)
 80037c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80037c4:	b90a      	cbnz	r2, 80037ca <_dbg_check_lock+0xa>
 80037c6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80037c8:	b11a      	cbz	r2, 80037d2 <_dbg_check_lock+0x12>
  __ASM volatile ("cpsid i" : : : "memory");
 80037ca:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 80037cc:	4a03      	ldr	r2, [pc, #12]	; (80037dc <_dbg_check_lock+0x1c>)
 80037ce:	62da      	str	r2, [r3, #44]	; 0x2c
 80037d0:	e7fe      	b.n	80037d0 <_dbg_check_lock+0x10>
  _dbg_enter_lock();
 80037d2:	2201      	movs	r2, #1
 80037d4:	635a      	str	r2, [r3, #52]	; 0x34
}
 80037d6:	4770      	bx	lr
 80037d8:	200011a0 	.word	0x200011a0
 80037dc:	0800c184 	.word	0x0800c184

080037e0 <chSemSignalWait.constprop.55>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 80037e0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80037e2:	2320      	movs	r3, #32
 80037e4:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));

  chSysLock();
  chDbgAssert(((sps->cnt >= (cnt_t)0) && queue_isempty(&sps->queue)) ||
 80037e8:	4c21      	ldr	r4, [pc, #132]	; (8003870 <chSemSignalWait.constprop.55+0x90>)
  _dbg_check_lock();
 80037ea:	f7ff ffe9 	bl	80037c0 <_dbg_check_lock>
 80037ee:	68a3      	ldr	r3, [r4, #8]
 80037f0:	6822      	ldr	r2, [r4, #0]
 80037f2:	2b00      	cmp	r3, #0
 80037f4:	db06      	blt.n	8003804 <chSemSignalWait.constprop.55+0x24>
 80037f6:	42a2      	cmp	r2, r4
 80037f8:	d006      	beq.n	8003808 <chSemSignalWait.constprop.55+0x28>
  __ASM volatile ("cpsid i" : : : "memory");
 80037fa:	b672      	cpsid	i
 80037fc:	4b1d      	ldr	r3, [pc, #116]	; (8003874 <chSemSignalWait.constprop.55+0x94>)
 80037fe:	4a1e      	ldr	r2, [pc, #120]	; (8003878 <chSemSignalWait.constprop.55+0x98>)
 8003800:	62da      	str	r2, [r3, #44]	; 0x2c
 8003802:	e7fe      	b.n	8003802 <chSemSignalWait.constprop.55+0x22>
 8003804:	42a2      	cmp	r2, r4
 8003806:	d0f8      	beq.n	80037fa <chSemSignalWait.constprop.55+0x1a>
              ((sps->cnt < (cnt_t)0) && queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
 8003808:	3301      	adds	r3, #1
 800380a:	2b00      	cmp	r3, #0
 800380c:	60a3      	str	r3, [r4, #8]
 800380e:	dc07      	bgt.n	8003820 <chSemSignalWait.constprop.55+0x40>
  thread_t *tp = tqp->next;
 8003810:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 8003812:	6803      	ldr	r3, [r0, #0]
 8003814:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003816:	605c      	str	r4, [r3, #4]
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 8003818:	f7fd faa2 	bl	8000d60 <chSchReadyI>
 800381c:	2300      	movs	r3, #0
 800381e:	6243      	str	r3, [r0, #36]	; 0x24
  }
  if (--spw->cnt < (cnt_t)0) {
 8003820:	68a3      	ldr	r3, [r4, #8]
 8003822:	3b01      	subs	r3, #1
 8003824:	2b00      	cmp	r3, #0
 8003826:	60a3      	str	r3, [r4, #8]
 8003828:	db11      	blt.n	800384e <chSemSignalWait.constprop.55+0x6e>
 800382a:	4d12      	ldr	r5, [pc, #72]	; (8003874 <chSemSignalWait.constprop.55+0x94>)
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 800382c:	f7ff ff48 	bl	80036c0 <chSchRescheduleS>
    msg = MSG_OK;
 8003830:	2000      	movs	r0, #0
  _dbg_check_unlock();
 8003832:	f7ff ff5d 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003836:	682b      	ldr	r3, [r5, #0]
 8003838:	42ab      	cmp	r3, r5
 800383a:	d004      	beq.n	8003846 <chSemSignalWait.constprop.55+0x66>
 800383c:	69aa      	ldr	r2, [r5, #24]
 800383e:	689b      	ldr	r3, [r3, #8]
 8003840:	6892      	ldr	r2, [r2, #8]
 8003842:	429a      	cmp	r2, r3
 8003844:	d310      	bcc.n	8003868 <chSemSignalWait.constprop.55+0x88>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003846:	2300      	movs	r3, #0
 8003848:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 800384c:	bd70      	pop	{r4, r5, r6, pc}
    thread_t *ctp = currp;
 800384e:	4d09      	ldr	r5, [pc, #36]	; (8003874 <chSemSignalWait.constprop.55+0x94>)
  tp->queue.prev             = tqp->prev;
 8003850:	6863      	ldr	r3, [r4, #4]
 8003852:	69ae      	ldr	r6, [r5, #24]
    chSchGoSleepS(CH_STATE_WTSEM);
 8003854:	2005      	movs	r0, #5
 8003856:	e9c6 4300 	strd	r4, r3, [r6]
  tp->queue.prev->queue.next = tp;
 800385a:	601e      	str	r6, [r3, #0]
    ctp->u.wtsemp = spw;
 800385c:	6274      	str	r4, [r6, #36]	; 0x24
  tqp->prev                  = tp;
 800385e:	6066      	str	r6, [r4, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 8003860:	f7ff fb6e 	bl	8002f40 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8003864:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8003866:	e7e4      	b.n	8003832 <chSemSignalWait.constprop.55+0x52>
  __ASM volatile ("cpsid i" : : : "memory");
 8003868:	b672      	cpsid	i
 800386a:	4b04      	ldr	r3, [pc, #16]	; (800387c <chSemSignalWait.constprop.55+0x9c>)
 800386c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800386e:	e7fe      	b.n	800386e <chSemSignalWait.constprop.55+0x8e>
 8003870:	20001408 	.word	0x20001408
 8003874:	200011a0 	.word	0x200011a0
 8003878:	0800bf34 	.word	0x0800bf34
 800387c:	0800bbf0 	.word	0x0800bbf0

08003880 <chMtxTryLock.constprop.52>:
bool chMtxTryLock(mutex_t *mp) {
 8003880:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003882:	2320      	movs	r3, #32
 8003884:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003888:	f7ff ff9a 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassS();
 800388c:	f7fd f998 	bl	8000bc0 <chDbgCheckClassS>
  if (mp->owner != NULL) {
 8003890:	4b0e      	ldr	r3, [pc, #56]	; (80038cc <chMtxTryLock.constprop.52+0x4c>)
 8003892:	4c0f      	ldr	r4, [pc, #60]	; (80038d0 <chMtxTryLock.constprop.52+0x50>)
 8003894:	689a      	ldr	r2, [r3, #8]
 8003896:	b172      	cbz	r2, 80038b6 <chMtxTryLock.constprop.52+0x36>
    return false;
 8003898:	2000      	movs	r0, #0
  _dbg_check_unlock();
 800389a:	f7ff ff29 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800389e:	6823      	ldr	r3, [r4, #0]
 80038a0:	42a3      	cmp	r3, r4
 80038a2:	d004      	beq.n	80038ae <chMtxTryLock.constprop.52+0x2e>
 80038a4:	69a2      	ldr	r2, [r4, #24]
 80038a6:	689b      	ldr	r3, [r3, #8]
 80038a8:	6892      	ldr	r2, [r2, #8]
 80038aa:	429a      	cmp	r2, r3
 80038ac:	d30a      	bcc.n	80038c4 <chMtxTryLock.constprop.52+0x44>
 80038ae:	2300      	movs	r3, #0
 80038b0:	f383 8811 	msr	BASEPRI, r3
}
 80038b4:	bd10      	pop	{r4, pc}
  mp->owner = currp;
 80038b6:	69a2      	ldr	r2, [r4, #24]
 80038b8:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 80038ba:	6b91      	ldr	r1, [r2, #56]	; 0x38
 80038bc:	60d9      	str	r1, [r3, #12]
  currp->mtxlist = mp;
 80038be:	6393      	str	r3, [r2, #56]	; 0x38
 80038c0:	2001      	movs	r0, #1
 80038c2:	e7ea      	b.n	800389a <chMtxTryLock.constprop.52+0x1a>
  __ASM volatile ("cpsid i" : : : "memory");
 80038c4:	b672      	cpsid	i
 80038c6:	4b03      	ldr	r3, [pc, #12]	; (80038d4 <chMtxTryLock.constprop.52+0x54>)
 80038c8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80038ca:	e7fe      	b.n	80038ca <chMtxTryLock.constprop.52+0x4a>
 80038cc:	20000c38 	.word	0x20000c38
 80038d0:	200011a0 	.word	0x200011a0
 80038d4:	0800bbfc 	.word	0x0800bbfc
	...

080038e0 <chCondSignal.constprop.50>:
void chCondSignal(condition_variable_t *cp) {
 80038e0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80038e2:	2320      	movs	r3, #32
 80038e4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80038e8:	f7ff ff6a 	bl	80037c0 <_dbg_check_lock>
  return (bool)(tqp->next != (const thread_t *)tqp);
 80038ec:	4b0e      	ldr	r3, [pc, #56]	; (8003928 <chCondSignal.constprop.50+0x48>)
 80038ee:	6818      	ldr	r0, [r3, #0]
  if (queue_notempty(&cp->queue)) {
 80038f0:	4298      	cmp	r0, r3
 80038f2:	d005      	beq.n	8003900 <chCondSignal.constprop.50+0x20>
  tqp->next             = tp->queue.next;
 80038f4:	6802      	ldr	r2, [r0, #0]
 80038f6:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80038f8:	6053      	str	r3, [r2, #4]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 80038fa:	2100      	movs	r1, #0
 80038fc:	f7ff faf0 	bl	8002ee0 <chSchWakeupS>
  _dbg_check_unlock();
 8003900:	f7ff fef6 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003904:	4b09      	ldr	r3, [pc, #36]	; (800392c <chCondSignal.constprop.50+0x4c>)
 8003906:	681a      	ldr	r2, [r3, #0]
 8003908:	429a      	cmp	r2, r3
 800390a:	d004      	beq.n	8003916 <chCondSignal.constprop.50+0x36>
 800390c:	6999      	ldr	r1, [r3, #24]
 800390e:	6892      	ldr	r2, [r2, #8]
 8003910:	6889      	ldr	r1, [r1, #8]
 8003912:	4291      	cmp	r1, r2
 8003914:	d303      	bcc.n	800391e <chCondSignal.constprop.50+0x3e>
 8003916:	2300      	movs	r3, #0
 8003918:	f383 8811 	msr	BASEPRI, r3
}
 800391c:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800391e:	b672      	cpsid	i
 8003920:	4a03      	ldr	r2, [pc, #12]	; (8003930 <chCondSignal.constprop.50+0x50>)
 8003922:	62da      	str	r2, [r3, #44]	; 0x2c
 8003924:	e7fe      	b.n	8003924 <chCondSignal.constprop.50+0x44>
 8003926:	bf00      	nop
 8003928:	20000c04 	.word	0x20000c04
 800392c:	200011a0 	.word	0x200011a0
 8003930:	0800bc08 	.word	0x0800bc08
	...

08003940 <chEvtGetAndClearEvents.constprop.41>:
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8003940:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003942:	2320      	movs	r3, #32
 8003944:	f383 8811 	msr	BASEPRI, r3
  m = currp->epending & events;
 8003948:	4c0c      	ldr	r4, [pc, #48]	; (800397c <chEvtGetAndClearEvents.constprop.41+0x3c>)
  _dbg_check_lock();
 800394a:	f7ff ff39 	bl	80037c0 <_dbg_check_lock>
 800394e:	69a3      	ldr	r3, [r4, #24]
  currp->epending &= ~events;
 8003950:	2200      	movs	r2, #0
  m = currp->epending & events;
 8003952:	6b58      	ldr	r0, [r3, #52]	; 0x34
  currp->epending &= ~events;
 8003954:	635a      	str	r2, [r3, #52]	; 0x34
  _dbg_check_unlock();
 8003956:	f7ff fecb 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800395a:	6823      	ldr	r3, [r4, #0]
 800395c:	42a3      	cmp	r3, r4
 800395e:	d004      	beq.n	800396a <chEvtGetAndClearEvents.constprop.41+0x2a>
 8003960:	69a2      	ldr	r2, [r4, #24]
 8003962:	689b      	ldr	r3, [r3, #8]
 8003964:	6892      	ldr	r2, [r2, #8]
 8003966:	429a      	cmp	r2, r3
 8003968:	d303      	bcc.n	8003972 <chEvtGetAndClearEvents.constprop.41+0x32>
 800396a:	2300      	movs	r3, #0
 800396c:	f383 8811 	msr	BASEPRI, r3
}
 8003970:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003972:	b672      	cpsid	i
 8003974:	4b02      	ldr	r3, [pc, #8]	; (8003980 <chEvtGetAndClearEvents.constprop.41+0x40>)
 8003976:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003978:	e7fe      	b.n	8003978 <chEvtGetAndClearEvents.constprop.41+0x38>
 800397a:	bf00      	nop
 800397c:	200011a0 	.word	0x200011a0
 8003980:	0800bc14 	.word	0x0800bc14
	...

08003990 <rt_test_008_007_setup>:
 *   has been emptied.
 * - [8.7.4] Unregistering from the Event Sources.
 * .
 */

static void rt_test_008_007_setup(void) {
 8003990:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8003992:	f7ff ffd5 	bl	8003940 <chEvtGetAndClearEvents.constprop.41>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8003996:	4a02      	ldr	r2, [pc, #8]	; (80039a0 <rt_test_008_007_setup+0x10>)
 8003998:	4b02      	ldr	r3, [pc, #8]	; (80039a4 <rt_test_008_007_setup+0x14>)
 800399a:	6012      	str	r2, [r2, #0]
 800399c:	601b      	str	r3, [r3, #0]
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}
 800399e:	bd08      	pop	{r3, pc}
 80039a0:	20000c0c 	.word	0x20000c0c
 80039a4:	20000c10 	.word	0x20000c10
	...

080039b0 <rt_test_008_006_setup>:
  chEvtGetAndClearEvents(ALL_EVENTS);
 80039b0:	f7ff bfc6 	b.w	8003940 <chEvtGetAndClearEvents.constprop.41>
	...

080039c0 <rt_test_008_005_setup>:
 80039c0:	f7ff bff6 	b.w	80039b0 <rt_test_008_006_setup>
	...

080039d0 <rt_test_008_004_setup>:
 80039d0:	f7ff bfee 	b.w	80039b0 <rt_test_008_006_setup>
	...

080039e0 <rt_test_008_003_setup>:
 80039e0:	f7ff bfe6 	b.w	80039b0 <rt_test_008_006_setup>
	...

080039f0 <rt_test_008_002_setup>:
 80039f0:	f7ff bfde 	b.w	80039b0 <rt_test_008_006_setup>
	...

08003a00 <chEvtWaitOne.constprop.37>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8003a00:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8003a02:	4c14      	ldr	r4, [pc, #80]	; (8003a54 <chEvtWaitOne.constprop.37+0x54>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003a04:	2320      	movs	r3, #32
 8003a06:	69a5      	ldr	r5, [r4, #24]
 8003a08:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003a0c:	f7ff fed8 	bl	80037c0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8003a10:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003a12:	b193      	cbz	r3, 8003a3a <chEvtWaitOne.constprop.37+0x3a>
    ctp->u.ewmask = events;
    chSchGoSleepS(CH_STATE_WTOREVT);
    m = ctp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8003a14:	4258      	negs	r0, r3
 8003a16:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8003a18:	ea23 0300 	bic.w	r3, r3, r0
 8003a1c:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
 8003a1e:	f7ff fe67 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003a22:	6823      	ldr	r3, [r4, #0]
 8003a24:	42a3      	cmp	r3, r4
 8003a26:	d004      	beq.n	8003a32 <chEvtWaitOne.constprop.37+0x32>
 8003a28:	69a2      	ldr	r2, [r4, #24]
 8003a2a:	689b      	ldr	r3, [r3, #8]
 8003a2c:	6892      	ldr	r2, [r2, #8]
 8003a2e:	429a      	cmp	r2, r3
 8003a30:	d30b      	bcc.n	8003a4a <chEvtWaitOne.constprop.37+0x4a>
 8003a32:	2300      	movs	r3, #0
 8003a34:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8003a38:	bd38      	pop	{r3, r4, r5, pc}
    ctp->u.ewmask = events;
 8003a3a:	f04f 33ff 	mov.w	r3, #4294967295
 8003a3e:	626b      	str	r3, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8003a40:	200a      	movs	r0, #10
 8003a42:	f7ff fa7d 	bl	8002f40 <chSchGoSleepS>
    m = ctp->epending & events;
 8003a46:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8003a48:	e7e4      	b.n	8003a14 <chEvtWaitOne.constprop.37+0x14>
  __ASM volatile ("cpsid i" : : : "memory");
 8003a4a:	b672      	cpsid	i
 8003a4c:	4b02      	ldr	r3, [pc, #8]	; (8003a58 <chEvtWaitOne.constprop.37+0x58>)
 8003a4e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003a50:	e7fe      	b.n	8003a50 <chEvtWaitOne.constprop.37+0x50>
 8003a52:	bf00      	nop
 8003a54:	200011a0 	.word	0x200011a0
 8003a58:	0800bc14 	.word	0x0800bc14
 8003a5c:	00000000 	.word	0x00000000

08003a60 <chEvtWaitAny.constprop.36>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8003a60:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8003a62:	4c12      	ldr	r4, [pc, #72]	; (8003aac <chEvtWaitAny.constprop.36+0x4c>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003a64:	2320      	movs	r3, #32
 8003a66:	69a5      	ldr	r5, [r4, #24]
 8003a68:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003a6c:	f7ff fea8 	bl	80037c0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8003a70:	6b68      	ldr	r0, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003a72:	b178      	cbz	r0, 8003a94 <chEvtWaitAny.constprop.36+0x34>
    ctp->u.ewmask = events;
    chSchGoSleepS(CH_STATE_WTOREVT);
    m = ctp->epending & events;
  }
  ctp->epending &= ~m;
 8003a74:	2300      	movs	r3, #0
 8003a76:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
 8003a78:	f7ff fe3a 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003a7c:	6823      	ldr	r3, [r4, #0]
 8003a7e:	42a3      	cmp	r3, r4
 8003a80:	d004      	beq.n	8003a8c <chEvtWaitAny.constprop.36+0x2c>
 8003a82:	69a2      	ldr	r2, [r4, #24]
 8003a84:	689b      	ldr	r3, [r3, #8]
 8003a86:	6892      	ldr	r2, [r2, #8]
 8003a88:	429a      	cmp	r2, r3
 8003a8a:	d30b      	bcc.n	8003aa4 <chEvtWaitAny.constprop.36+0x44>
 8003a8c:	2300      	movs	r3, #0
 8003a8e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8003a92:	bd38      	pop	{r3, r4, r5, pc}
    ctp->u.ewmask = events;
 8003a94:	f04f 33ff 	mov.w	r3, #4294967295
    chSchGoSleepS(CH_STATE_WTOREVT);
 8003a98:	200a      	movs	r0, #10
    ctp->u.ewmask = events;
 8003a9a:	626b      	str	r3, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8003a9c:	f7ff fa50 	bl	8002f40 <chSchGoSleepS>
    m = ctp->epending & events;
 8003aa0:	6b68      	ldr	r0, [r5, #52]	; 0x34
 8003aa2:	e7e7      	b.n	8003a74 <chEvtWaitAny.constprop.36+0x14>
  __ASM volatile ("cpsid i" : : : "memory");
 8003aa4:	b672      	cpsid	i
 8003aa6:	4b02      	ldr	r3, [pc, #8]	; (8003ab0 <chEvtWaitAny.constprop.36+0x50>)
 8003aa8:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003aaa:	e7fe      	b.n	8003aaa <chEvtWaitAny.constprop.36+0x4a>
 8003aac:	200011a0 	.word	0x200011a0
 8003ab0:	0800bc14 	.word	0x0800bc14
	...

08003ac0 <chEvtWaitAll.constprop.35>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8003ac0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8003ac2:	4c14      	ldr	r4, [pc, #80]	; (8003b14 <chEvtWaitAll.constprop.35+0x54>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003ac4:	2320      	movs	r3, #32
 8003ac6:	69a5      	ldr	r5, [r4, #24]
 8003ac8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003acc:	f7ff fe78 	bl	80037c0 <_dbg_check_lock>

  chSysLock();
  if ((ctp->epending & events) != events) {
 8003ad0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8003ad2:	f003 0205 	and.w	r2, r3, #5
 8003ad6:	2a05      	cmp	r2, #5
 8003ad8:	d005      	beq.n	8003ae6 <chEvtWaitAll.constprop.35+0x26>
    ctp->u.ewmask = events;
 8003ada:	2305      	movs	r3, #5
 8003adc:	626b      	str	r3, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8003ade:	200b      	movs	r0, #11
 8003ae0:	f7ff fa2e 	bl	8002f40 <chSchGoSleepS>
 8003ae4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  ctp->epending &= ~events;
 8003ae6:	f023 0305 	bic.w	r3, r3, #5
 8003aea:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
 8003aec:	f7ff fe00 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003af0:	6823      	ldr	r3, [r4, #0]
 8003af2:	42a3      	cmp	r3, r4
 8003af4:	d004      	beq.n	8003b00 <chEvtWaitAll.constprop.35+0x40>
 8003af6:	69a2      	ldr	r2, [r4, #24]
 8003af8:	689b      	ldr	r3, [r3, #8]
 8003afa:	6892      	ldr	r2, [r2, #8]
 8003afc:	429a      	cmp	r2, r3
 8003afe:	d304      	bcc.n	8003b0a <chEvtWaitAll.constprop.35+0x4a>
 8003b00:	2300      	movs	r3, #0
 8003b02:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 8003b06:	2005      	movs	r0, #5
 8003b08:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003b0a:	b672      	cpsid	i
 8003b0c:	4b02      	ldr	r3, [pc, #8]	; (8003b18 <chEvtWaitAll.constprop.35+0x58>)
 8003b0e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003b10:	e7fe      	b.n	8003b10 <chEvtWaitAll.constprop.35+0x50>
 8003b12:	bf00      	nop
 8003b14:	200011a0 	.word	0x200011a0
 8003b18:	0800bc14 	.word	0x0800bc14
 8003b1c:	00000000 	.word	0x00000000

08003b20 <chEvtWaitOneTimeout.constprop.34>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
 8003b20:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8003b22:	4c25      	ldr	r4, [pc, #148]	; (8003bb8 <chEvtWaitOneTimeout.constprop.34+0x98>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003b24:	2320      	movs	r3, #32
 8003b26:	69a5      	ldr	r5, [r4, #24]
 8003b28:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003b2c:	f7ff fe48 	bl	80037c0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8003b30:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003b32:	b953      	cbnz	r3, 8003b4a <chEvtWaitOneTimeout.constprop.34+0x2a>
 8003b34:	4601      	mov	r1, r0
    if (TIME_IMMEDIATE == timeout) {
 8003b36:	b1d8      	cbz	r0, 8003b70 <chEvtWaitOneTimeout.constprop.34+0x50>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8003b38:	f04f 33ff 	mov.w	r3, #4294967295
 8003b3c:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8003b3e:	200a      	movs	r0, #10
 8003b40:	f7ff fabe 	bl	80030c0 <chSchGoSleepTimeoutS>
 8003b44:	2800      	cmp	r0, #0
 8003b46:	db25      	blt.n	8003b94 <chEvtWaitOneTimeout.constprop.34+0x74>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 8003b48:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 8003b4a:	4258      	negs	r0, r3
 8003b4c:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8003b4e:	ea23 0300 	bic.w	r3, r3, r0
 8003b52:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
 8003b54:	f7ff fdcc 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003b58:	6823      	ldr	r3, [r4, #0]
 8003b5a:	42a3      	cmp	r3, r4
 8003b5c:	d004      	beq.n	8003b68 <chEvtWaitOneTimeout.constprop.34+0x48>
 8003b5e:	69a2      	ldr	r2, [r4, #24]
 8003b60:	689b      	ldr	r3, [r3, #8]
 8003b62:	6892      	ldr	r2, [r2, #8]
 8003b64:	429a      	cmp	r2, r3
 8003b66:	d311      	bcc.n	8003b8c <chEvtWaitOneTimeout.constprop.34+0x6c>
 8003b68:	2300      	movs	r3, #0
 8003b6a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8003b6e:	bd38      	pop	{r3, r4, r5, pc}
  _dbg_check_unlock();
 8003b70:	f7ff fdbe 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003b74:	6823      	ldr	r3, [r4, #0]
 8003b76:	42a3      	cmp	r3, r4
 8003b78:	d004      	beq.n	8003b84 <chEvtWaitOneTimeout.constprop.34+0x64>
 8003b7a:	69a2      	ldr	r2, [r4, #24]
 8003b7c:	689b      	ldr	r3, [r3, #8]
 8003b7e:	6892      	ldr	r2, [r2, #8]
 8003b80:	429a      	cmp	r2, r3
 8003b82:	d315      	bcc.n	8003bb0 <chEvtWaitOneTimeout.constprop.34+0x90>
 8003b84:	2000      	movs	r0, #0
 8003b86:	f380 8811 	msr	BASEPRI, r0
 8003b8a:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003b8c:	b672      	cpsid	i
 8003b8e:	4b0b      	ldr	r3, [pc, #44]	; (8003bbc <chEvtWaitOneTimeout.constprop.34+0x9c>)
 8003b90:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003b92:	e7fe      	b.n	8003b92 <chEvtWaitOneTimeout.constprop.34+0x72>
  _dbg_check_unlock();
 8003b94:	f7ff fdac 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003b98:	6823      	ldr	r3, [r4, #0]
 8003b9a:	42a3      	cmp	r3, r4
 8003b9c:	d0f2      	beq.n	8003b84 <chEvtWaitOneTimeout.constprop.34+0x64>
 8003b9e:	69a2      	ldr	r2, [r4, #24]
 8003ba0:	689b      	ldr	r3, [r3, #8]
 8003ba2:	6892      	ldr	r2, [r2, #8]
 8003ba4:	429a      	cmp	r2, r3
 8003ba6:	d2ed      	bcs.n	8003b84 <chEvtWaitOneTimeout.constprop.34+0x64>
 8003ba8:	b672      	cpsid	i
 8003baa:	4b04      	ldr	r3, [pc, #16]	; (8003bbc <chEvtWaitOneTimeout.constprop.34+0x9c>)
 8003bac:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003bae:	e7fe      	b.n	8003bae <chEvtWaitOneTimeout.constprop.34+0x8e>
 8003bb0:	b672      	cpsid	i
 8003bb2:	4b02      	ldr	r3, [pc, #8]	; (8003bbc <chEvtWaitOneTimeout.constprop.34+0x9c>)
 8003bb4:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003bb6:	e7fe      	b.n	8003bb6 <chEvtWaitOneTimeout.constprop.34+0x96>
 8003bb8:	200011a0 	.word	0x200011a0
 8003bbc:	0800bc14 	.word	0x0800bc14

08003bc0 <chMBReset.constprop.28>:
void chMBReset(mailbox_t *mbp) {
 8003bc0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003bc2:	2320      	movs	r3, #32
 8003bc4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003bc8:	f7ff fdfa 	bl	80037c0 <_dbg_check_lock>
  chMBResetI(mbp);
 8003bcc:	f7fe f8e0 	bl	8001d90 <chMBResetI.constprop.29>
  chSchRescheduleS();
 8003bd0:	f7ff fd76 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8003bd4:	f7ff fd8c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003bd8:	4b08      	ldr	r3, [pc, #32]	; (8003bfc <chMBReset.constprop.28+0x3c>)
 8003bda:	681a      	ldr	r2, [r3, #0]
 8003bdc:	429a      	cmp	r2, r3
 8003bde:	d004      	beq.n	8003bea <chMBReset.constprop.28+0x2a>
 8003be0:	6999      	ldr	r1, [r3, #24]
 8003be2:	6892      	ldr	r2, [r2, #8]
 8003be4:	6889      	ldr	r1, [r1, #8]
 8003be6:	4291      	cmp	r1, r2
 8003be8:	d303      	bcc.n	8003bf2 <chMBReset.constprop.28+0x32>
 8003bea:	2300      	movs	r3, #0
 8003bec:	f383 8811 	msr	BASEPRI, r3
}
 8003bf0:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003bf2:	b672      	cpsid	i
 8003bf4:	4a02      	ldr	r2, [pc, #8]	; (8003c00 <chMBReset.constprop.28+0x40>)
 8003bf6:	62da      	str	r2, [r3, #44]	; 0x2c
 8003bf8:	e7fe      	b.n	8003bf8 <chMBReset.constprop.28+0x38>
 8003bfa:	bf00      	nop
 8003bfc:	200011a0 	.word	0x200011a0
 8003c00:	0800bc38 	.word	0x0800bc38
	...

08003c10 <oslib_test_001_003_teardown>:

static void oslib_test_001_003_teardown(void) {
  chMBReset(&mb1);
 8003c10:	f7ff bfd6 	b.w	8003bc0 <chMBReset.constprop.28>
	...

08003c20 <oslib_test_001_002_teardown>:
 8003c20:	f7ff bff6 	b.w	8003c10 <oslib_test_001_003_teardown>
	...

08003c30 <oslib_test_001_001_teardown>:
 8003c30:	f7ff bfee 	b.w	8003c10 <oslib_test_001_003_teardown>
	...

08003c40 <chMBPostTimeout.constprop.26>:
msg_t chMBPostTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8003c40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003c44:	4681      	mov	r9, r0
 8003c46:	4688      	mov	r8, r1
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003c48:	2320      	movs	r3, #32
 8003c4a:	f383 8811 	msr	BASEPRI, r3
 8003c4e:	4c22      	ldr	r4, [pc, #136]	; (8003cd8 <chMBPostTimeout.constprop.26+0x98>)
  _dbg_check_lock();
 8003c50:	f7ff fdb6 	bl	80037c0 <_dbg_check_lock>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8003c54:	f104 0718 	add.w	r7, r4, #24
  chDbgCheckClassS();
 8003c58:	f7fc ffb2 	bl	8000bc0 <chDbgCheckClassS>
 8003c5c:	e010      	b.n	8003c80 <chMBPostTimeout.constprop.26+0x40>
  chDbgCheckClassI();
 8003c5e:	f7fc ffbf 	bl	8000be0 <chDbgCheckClassI>
 8003c62:	e9d4 5600 	ldrd	r5, r6, [r4]
  chDbgCheckClassI();
 8003c66:	f7fc ffbb 	bl	8000be0 <chDbgCheckClassI>
  return mbp->cnt;
 8003c6a:	6923      	ldr	r3, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8003c6c:	1b72      	subs	r2, r6, r5
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8003c6e:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8003c72:	4641      	mov	r1, r8
 8003c74:	4638      	mov	r0, r7
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8003c76:	d11d      	bne.n	8003cb4 <chMBPostTimeout.constprop.26+0x74>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8003c78:	f7ff fa82 	bl	8003180 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8003c7c:	4605      	mov	r5, r0
 8003c7e:	b920      	cbnz	r0, 8003c8a <chMBPostTimeout.constprop.26+0x4a>
    if (mbp->reset) {
 8003c80:	7d23      	ldrb	r3, [r4, #20]
 8003c82:	2b00      	cmp	r3, #0
 8003c84:	d0eb      	beq.n	8003c5e <chMBPostTimeout.constprop.26+0x1e>
      return MSG_RESET;
 8003c86:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
 8003c8a:	f7ff fd31 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003c8e:	4b13      	ldr	r3, [pc, #76]	; (8003cdc <chMBPostTimeout.constprop.26+0x9c>)
 8003c90:	681a      	ldr	r2, [r3, #0]
 8003c92:	429a      	cmp	r2, r3
 8003c94:	d004      	beq.n	8003ca0 <chMBPostTimeout.constprop.26+0x60>
 8003c96:	6999      	ldr	r1, [r3, #24]
 8003c98:	6892      	ldr	r2, [r2, #8]
 8003c9a:	6889      	ldr	r1, [r1, #8]
 8003c9c:	4291      	cmp	r1, r2
 8003c9e:	d305      	bcc.n	8003cac <chMBPostTimeout.constprop.26+0x6c>
 8003ca0:	2300      	movs	r3, #0
 8003ca2:	f383 8811 	msr	BASEPRI, r3
}
 8003ca6:	4628      	mov	r0, r5
 8003ca8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003cac:	b672      	cpsid	i
 8003cae:	4a0c      	ldr	r2, [pc, #48]	; (8003ce0 <chMBPostTimeout.constprop.26+0xa0>)
 8003cb0:	62da      	str	r2, [r3, #44]	; 0x2c
 8003cb2:	e7fe      	b.n	8003cb2 <chMBPostTimeout.constprop.26+0x72>
      *mbp->wrptr++ = msg;
 8003cb4:	68a1      	ldr	r1, [r4, #8]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8003cb6:	480b      	ldr	r0, [pc, #44]	; (8003ce4 <chMBPostTimeout.constprop.26+0xa4>)
      *mbp->wrptr++ = msg;
 8003cb8:	1d0a      	adds	r2, r1, #4
 8003cba:	60a2      	str	r2, [r4, #8]
      if (mbp->wrptr >= mbp->top) {
 8003cbc:	4296      	cmp	r6, r2
      *mbp->wrptr++ = msg;
 8003cbe:	f8c1 9000 	str.w	r9, [r1]
      mbp->cnt++;
 8003cc2:	f103 0301 	add.w	r3, r3, #1
        mbp->wrptr = mbp->buffer;
 8003cc6:	bf98      	it	ls
 8003cc8:	60a5      	strls	r5, [r4, #8]
      mbp->cnt++;
 8003cca:	6123      	str	r3, [r4, #16]
      return MSG_OK;
 8003ccc:	2500      	movs	r5, #0
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8003cce:	f7fd f86f 	bl	8000db0 <chThdDequeueNextI.constprop.87>
      chSchRescheduleS();
 8003cd2:	f7ff fcf5 	bl	80036c0 <chSchRescheduleS>
 8003cd6:	e7d8      	b.n	8003c8a <chMBPostTimeout.constprop.26+0x4a>
 8003cd8:	20000c58 	.word	0x20000c58
 8003cdc:	200011a0 	.word	0x200011a0
 8003ce0:	0800bc38 	.word	0x0800bc38
 8003ce4:	20000c78 	.word	0x20000c78
	...

08003cf0 <chMBPostAheadTimeout.constprop.23>:
msg_t chMBPostAheadTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8003cf0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003cf4:	4607      	mov	r7, r0
 8003cf6:	4689      	mov	r9, r1
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003cf8:	2320      	movs	r3, #32
 8003cfa:	f383 8811 	msr	BASEPRI, r3
 8003cfe:	4c21      	ldr	r4, [pc, #132]	; (8003d84 <chMBPostAheadTimeout.constprop.23+0x94>)
  _dbg_check_lock();
 8003d00:	f7ff fd5e 	bl	80037c0 <_dbg_check_lock>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8003d04:	f104 0818 	add.w	r8, r4, #24
  chDbgCheckClassS();
 8003d08:	f7fc ff5a 	bl	8000bc0 <chDbgCheckClassS>
 8003d0c:	e010      	b.n	8003d30 <chMBPostAheadTimeout.constprop.23+0x40>
  chDbgCheckClassI();
 8003d0e:	f7fc ff67 	bl	8000be0 <chDbgCheckClassI>
 8003d12:	e9d4 6500 	ldrd	r6, r5, [r4]
  chDbgCheckClassI();
 8003d16:	f7fc ff63 	bl	8000be0 <chDbgCheckClassI>
  return mbp->cnt;
 8003d1a:	6922      	ldr	r2, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8003d1c:	1bab      	subs	r3, r5, r6
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8003d1e:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8003d22:	4649      	mov	r1, r9
 8003d24:	4640      	mov	r0, r8
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8003d26:	d11d      	bne.n	8003d64 <chMBPostAheadTimeout.constprop.23+0x74>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8003d28:	f7ff fa2a 	bl	8003180 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8003d2c:	4605      	mov	r5, r0
 8003d2e:	b920      	cbnz	r0, 8003d3a <chMBPostAheadTimeout.constprop.23+0x4a>
    if (mbp->reset) {
 8003d30:	7d23      	ldrb	r3, [r4, #20]
 8003d32:	2b00      	cmp	r3, #0
 8003d34:	d0eb      	beq.n	8003d0e <chMBPostAheadTimeout.constprop.23+0x1e>
      return MSG_RESET;
 8003d36:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
 8003d3a:	f7ff fcd9 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003d3e:	4b12      	ldr	r3, [pc, #72]	; (8003d88 <chMBPostAheadTimeout.constprop.23+0x98>)
 8003d40:	681a      	ldr	r2, [r3, #0]
 8003d42:	429a      	cmp	r2, r3
 8003d44:	d004      	beq.n	8003d50 <chMBPostAheadTimeout.constprop.23+0x60>
 8003d46:	6999      	ldr	r1, [r3, #24]
 8003d48:	6892      	ldr	r2, [r2, #8]
 8003d4a:	6889      	ldr	r1, [r1, #8]
 8003d4c:	4291      	cmp	r1, r2
 8003d4e:	d305      	bcc.n	8003d5c <chMBPostAheadTimeout.constprop.23+0x6c>
 8003d50:	2300      	movs	r3, #0
 8003d52:	f383 8811 	msr	BASEPRI, r3
}
 8003d56:	4628      	mov	r0, r5
 8003d58:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003d5c:	b672      	cpsid	i
 8003d5e:	4a0b      	ldr	r2, [pc, #44]	; (8003d8c <chMBPostAheadTimeout.constprop.23+0x9c>)
 8003d60:	62da      	str	r2, [r3, #44]	; 0x2c
 8003d62:	e7fe      	b.n	8003d62 <chMBPostAheadTimeout.constprop.23+0x72>
      if (--mbp->rdptr < mbp->buffer) {
 8003d64:	68e3      	ldr	r3, [r4, #12]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8003d66:	480a      	ldr	r0, [pc, #40]	; (8003d90 <chMBPostAheadTimeout.constprop.23+0xa0>)
      if (--mbp->rdptr < mbp->buffer) {
 8003d68:	3b04      	subs	r3, #4
 8003d6a:	429e      	cmp	r6, r3
        mbp->rdptr = mbp->top - 1;
 8003d6c:	bf88      	it	hi
 8003d6e:	1f2b      	subhi	r3, r5, #4
 8003d70:	60e3      	str	r3, [r4, #12]
      mbp->cnt++;
 8003d72:	3201      	adds	r2, #1
      *mbp->rdptr = msg;
 8003d74:	601f      	str	r7, [r3, #0]
      return MSG_OK;
 8003d76:	2500      	movs	r5, #0
      mbp->cnt++;
 8003d78:	6122      	str	r2, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8003d7a:	f7fd f819 	bl	8000db0 <chThdDequeueNextI.constprop.87>
      chSchRescheduleS();
 8003d7e:	f7ff fc9f 	bl	80036c0 <chSchRescheduleS>
 8003d82:	e7da      	b.n	8003d3a <chMBPostAheadTimeout.constprop.23+0x4a>
 8003d84:	20000c58 	.word	0x20000c58
 8003d88:	200011a0 	.word	0x200011a0
 8003d8c:	0800bc38 	.word	0x0800bc38
 8003d90:	20000c78 	.word	0x20000c78
	...

08003da0 <chMBFetchTimeout.constprop.20>:
msg_t chMBFetchTimeout(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8003da0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003da4:	2320      	movs	r3, #32
 8003da6:	4606      	mov	r6, r0
 8003da8:	4688      	mov	r8, r1
 8003daa:	f383 8811 	msr	BASEPRI, r3
 8003dae:	4c20      	ldr	r4, [pc, #128]	; (8003e30 <chMBFetchTimeout.constprop.20+0x90>)
  _dbg_check_lock();
 8003db0:	f7ff fd06 	bl	80037c0 <_dbg_check_lock>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8003db4:	f104 0720 	add.w	r7, r4, #32
  chDbgCheckClassS();
 8003db8:	f7fc ff02 	bl	8000bc0 <chDbgCheckClassS>
 8003dbc:	e009      	b.n	8003dd2 <chMBFetchTimeout.constprop.20+0x32>
  chDbgCheckClassI();
 8003dbe:	f7fc ff0f 	bl	8000be0 <chDbgCheckClassI>
  return mbp->cnt;
 8003dc2:	6922      	ldr	r2, [r4, #16]
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8003dc4:	4641      	mov	r1, r8
 8003dc6:	4638      	mov	r0, r7
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8003dc8:	b9ca      	cbnz	r2, 8003dfe <chMBFetchTimeout.constprop.20+0x5e>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8003dca:	f7ff f9d9 	bl	8003180 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8003dce:	4605      	mov	r5, r0
 8003dd0:	b920      	cbnz	r0, 8003ddc <chMBFetchTimeout.constprop.20+0x3c>
    if (mbp->reset) {
 8003dd2:	7d23      	ldrb	r3, [r4, #20]
 8003dd4:	2b00      	cmp	r3, #0
 8003dd6:	d0f2      	beq.n	8003dbe <chMBFetchTimeout.constprop.20+0x1e>
      return MSG_RESET;
 8003dd8:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
 8003ddc:	f7ff fc88 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003de0:	4b14      	ldr	r3, [pc, #80]	; (8003e34 <chMBFetchTimeout.constprop.20+0x94>)
 8003de2:	681a      	ldr	r2, [r3, #0]
 8003de4:	429a      	cmp	r2, r3
 8003de6:	d004      	beq.n	8003df2 <chMBFetchTimeout.constprop.20+0x52>
 8003de8:	6999      	ldr	r1, [r3, #24]
 8003dea:	6892      	ldr	r2, [r2, #8]
 8003dec:	6889      	ldr	r1, [r1, #8]
 8003dee:	4291      	cmp	r1, r2
 8003df0:	d31a      	bcc.n	8003e28 <chMBFetchTimeout.constprop.20+0x88>
 8003df2:	2300      	movs	r3, #0
 8003df4:	f383 8811 	msr	BASEPRI, r3
}
 8003df8:	4628      	mov	r0, r5
 8003dfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *msgp = *mbp->rdptr++;
 8003dfe:	68e3      	ldr	r3, [r4, #12]
      if (mbp->rdptr >= mbp->top) {
 8003e00:	6861      	ldr	r1, [r4, #4]
      *msgp = *mbp->rdptr++;
 8003e02:	6818      	ldr	r0, [r3, #0]
 8003e04:	3304      	adds	r3, #4
      if (mbp->rdptr >= mbp->top) {
 8003e06:	428b      	cmp	r3, r1
      *msgp = *mbp->rdptr++;
 8003e08:	60e3      	str	r3, [r4, #12]
      mbp->cnt--;
 8003e0a:	f102 32ff 	add.w	r2, r2, #4294967295
      *msgp = *mbp->rdptr++;
 8003e0e:	6030      	str	r0, [r6, #0]
        mbp->rdptr = mbp->buffer;
 8003e10:	bf28      	it	cs
 8003e12:	6823      	ldrcs	r3, [r4, #0]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8003e14:	4808      	ldr	r0, [pc, #32]	; (8003e38 <chMBFetchTimeout.constprop.20+0x98>)
        mbp->rdptr = mbp->buffer;
 8003e16:	bf28      	it	cs
 8003e18:	60e3      	strcs	r3, [r4, #12]
      mbp->cnt--;
 8003e1a:	6122      	str	r2, [r4, #16]
      return MSG_OK;
 8003e1c:	2500      	movs	r5, #0
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8003e1e:	f7fc ffc7 	bl	8000db0 <chThdDequeueNextI.constprop.87>
      chSchRescheduleS();
 8003e22:	f7ff fc4d 	bl	80036c0 <chSchRescheduleS>
 8003e26:	e7d9      	b.n	8003ddc <chMBFetchTimeout.constprop.20+0x3c>
  __ASM volatile ("cpsid i" : : : "memory");
 8003e28:	b672      	cpsid	i
 8003e2a:	4a04      	ldr	r2, [pc, #16]	; (8003e3c <chMBFetchTimeout.constprop.20+0x9c>)
 8003e2c:	62da      	str	r2, [r3, #44]	; 0x2c
 8003e2e:	e7fe      	b.n	8003e2e <chMBFetchTimeout.constprop.20+0x8e>
 8003e30:	20000c58 	.word	0x20000c58
 8003e34:	200011a0 	.word	0x200011a0
 8003e38:	20000c70 	.word	0x20000c70
 8003e3c:	0800bc38 	.word	0x0800bc38

08003e40 <chGuardedPoolAllocTimeout.constprop.15>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
 8003e40:	b510      	push	{r4, lr}
 8003e42:	4601      	mov	r1, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003e44:	2320      	movs	r3, #32
 8003e46:	f383 8811 	msr	BASEPRI, r3
  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 8003e4a:	4c14      	ldr	r4, [pc, #80]	; (8003e9c <chGuardedPoolAllocTimeout.constprop.15+0x5c>)
  _dbg_check_lock();
 8003e4c:	f7ff fcb8 	bl	80037c0 <_dbg_check_lock>
 8003e50:	4620      	mov	r0, r4
 8003e52:	f7ff f95d 	bl	8003110 <chSemWaitTimeoutS>
  if (msg != MSG_OK) {
 8003e56:	b9a0      	cbnz	r0, 8003e82 <chGuardedPoolAllocTimeout.constprop.15+0x42>
  chDbgCheckClassI();
 8003e58:	f7fc fec2 	bl	8000be0 <chDbgCheckClassI>
  objp = mp->next;
 8003e5c:	68e0      	ldr	r0, [r4, #12]
  if (objp != NULL) {
 8003e5e:	b1b0      	cbz	r0, 8003e8e <chGuardedPoolAllocTimeout.constprop.15+0x4e>
    mp->next = mp->next->next;
 8003e60:	6803      	ldr	r3, [r0, #0]
 8003e62:	60e3      	str	r3, [r4, #12]
  _dbg_check_unlock();
 8003e64:	f7ff fc44 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003e68:	4b0d      	ldr	r3, [pc, #52]	; (8003ea0 <chGuardedPoolAllocTimeout.constprop.15+0x60>)
 8003e6a:	681a      	ldr	r2, [r3, #0]
 8003e6c:	429a      	cmp	r2, r3
 8003e6e:	d004      	beq.n	8003e7a <chGuardedPoolAllocTimeout.constprop.15+0x3a>
 8003e70:	6999      	ldr	r1, [r3, #24]
 8003e72:	6892      	ldr	r2, [r2, #8]
 8003e74:	6889      	ldr	r1, [r1, #8]
 8003e76:	4291      	cmp	r1, r2
 8003e78:	d305      	bcc.n	8003e86 <chGuardedPoolAllocTimeout.constprop.15+0x46>
 8003e7a:	2300      	movs	r3, #0
 8003e7c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 8003e80:	bd10      	pop	{r4, pc}
    return NULL;
 8003e82:	2000      	movs	r0, #0
 8003e84:	e7ee      	b.n	8003e64 <chGuardedPoolAllocTimeout.constprop.15+0x24>
  __ASM volatile ("cpsid i" : : : "memory");
 8003e86:	b672      	cpsid	i
 8003e88:	4a06      	ldr	r2, [pc, #24]	; (8003ea4 <chGuardedPoolAllocTimeout.constprop.15+0x64>)
 8003e8a:	62da      	str	r2, [r3, #44]	; 0x2c
 8003e8c:	e7fe      	b.n	8003e8c <chGuardedPoolAllocTimeout.constprop.15+0x4c>
  else if (mp->provider != NULL) {
 8003e8e:	69a3      	ldr	r3, [r4, #24]
 8003e90:	2b00      	cmp	r3, #0
 8003e92:	d0e7      	beq.n	8003e64 <chGuardedPoolAllocTimeout.constprop.15+0x24>
    objp = mp->provider(mp->object_size, mp->align);
 8003e94:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 8003e98:	4798      	blx	r3
 8003e9a:	e7e3      	b.n	8003e64 <chGuardedPoolAllocTimeout.constprop.15+0x24>
 8003e9c:	20000c14 	.word	0x20000c14
 8003ea0:	200011a0 	.word	0x200011a0
 8003ea4:	0800bc50 	.word	0x0800bc50
	...

08003eb0 <oslib_test_002_003_execute>:

static void oslib_test_002_003_execute(void) {
 8003eb0:	b508      	push	{r3, lr}

  /* [2.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8003eb2:	4b07      	ldr	r3, [pc, #28]	; (8003ed0 <oslib_test_002_003_execute+0x20>)
 8003eb4:	2201      	movs	r2, #1
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 8003eb6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(1);
 8003eba:	601a      	str	r2, [r3, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 8003ebc:	f7ff ffc0 	bl	8003e40 <chGuardedPoolAllocTimeout.constprop.15>
 8003ec0:	fab0 f080 	clz	r0, r0
 8003ec4:	0940      	lsrs	r0, r0, #5
 8003ec6:	4903      	ldr	r1, [pc, #12]	; (8003ed4 <oslib_test_002_003_execute+0x24>)
  }
}
 8003ec8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 8003ecc:	f7fc bd28 	b.w	8000920 <_test_assert>
 8003ed0:	20001b3c 	.word	0x20001b3c
 8003ed4:	0800c6b0 	.word	0x0800c6b0
	...

08003ee0 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8003ee0:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003ee2:	2320      	movs	r3, #32
 8003ee4:	4614      	mov	r4, r2
 8003ee6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003eea:	f7ff fc69 	bl	80037c0 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 8003eee:	4622      	mov	r2, r4
 8003ef0:	f7fc fea6 	bl	8000c40 <chCoreAllocAlignedWithOffsetI>
  _dbg_check_unlock();
 8003ef4:	f7ff fbfc 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003ef8:	4b08      	ldr	r3, [pc, #32]	; (8003f1c <chCoreAllocAlignedWithOffset+0x3c>)
 8003efa:	681a      	ldr	r2, [r3, #0]
 8003efc:	429a      	cmp	r2, r3
 8003efe:	d004      	beq.n	8003f0a <chCoreAllocAlignedWithOffset+0x2a>
 8003f00:	6999      	ldr	r1, [r3, #24]
 8003f02:	6892      	ldr	r2, [r2, #8]
 8003f04:	6889      	ldr	r1, [r1, #8]
 8003f06:	4291      	cmp	r1, r2
 8003f08:	d303      	bcc.n	8003f12 <chCoreAllocAlignedWithOffset+0x32>
 8003f0a:	2300      	movs	r3, #0
 8003f0c:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
 8003f10:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8003f12:	b672      	cpsid	i
 8003f14:	4a02      	ldr	r2, [pc, #8]	; (8003f20 <chCoreAllocAlignedWithOffset+0x40>)
 8003f16:	62da      	str	r2, [r3, #44]	; 0x2c
 8003f18:	e7fe      	b.n	8003f18 <chCoreAllocAlignedWithOffset+0x38>
 8003f1a:	bf00      	nop
 8003f1c:	200011a0 	.word	0x200011a0
 8003f20:	0800bc44 	.word	0x0800bc44
	...

08003f30 <oslib_test_001_003_execute>:
}

static void oslib_test_001_003_execute(void) {
 8003f30:	b570      	push	{r4, r5, r6, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [1.3.1] Filling the mailbox.*/
  test_set_step(1);
 8003f32:	4d57      	ldr	r5, [pc, #348]	; (8004090 <oslib_test_001_003_execute+0x160>)
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003f34:	4e57      	ldr	r6, [pc, #348]	; (8004094 <oslib_test_001_003_execute+0x164>)
  test_set_step(1);
 8003f36:	2301      	movs	r3, #1
static void oslib_test_001_003_execute(void) {
 8003f38:	b082      	sub	sp, #8
  test_set_step(1);
 8003f3a:	602b      	str	r3, [r5, #0]
 8003f3c:	2442      	movs	r4, #66	; 0x42
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8003f3e:	f04f 31ff 	mov.w	r1, #4294967295
 8003f42:	4620      	mov	r0, r4
 8003f44:	f7ff fe7c 	bl	8003c40 <chMBPostTimeout.constprop.26>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003f48:	fab0 f080 	clz	r0, r0
 8003f4c:	4631      	mov	r1, r6
 8003f4e:	0940      	lsrs	r0, r0, #5
 8003f50:	f7fc fce6 	bl	8000920 <_test_assert>
 8003f54:	3401      	adds	r4, #1
 8003f56:	b980      	cbnz	r0, 8003f7a <oslib_test_001_003_execute+0x4a>
    for (i = 0; i < MB_SIZE; i++) {
 8003f58:	2c46      	cmp	r4, #70	; 0x46
 8003f5a:	d1f0      	bne.n	8003f3e <oslib_test_001_003_execute+0xe>
    }
  }

  /* [1.3.2] Testing chMBPostTimeout(), chMBPostI(),
     chMBPostAheadTimeout() and chMBPostAheadI() timeout.*/
  test_set_step(2);
 8003f5c:	2302      	movs	r3, #2
  {
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
 8003f5e:	2101      	movs	r1, #1
 8003f60:	2058      	movs	r0, #88	; 0x58
  test_set_step(2);
 8003f62:	602b      	str	r3, [r5, #0]
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
 8003f64:	f7ff fe6c 	bl	8003c40 <chMBPostTimeout.constprop.26>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003f68:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8003f6c:	fab0 f080 	clz	r0, r0
 8003f70:	4948      	ldr	r1, [pc, #288]	; (8004094 <oslib_test_001_003_execute+0x164>)
 8003f72:	0940      	lsrs	r0, r0, #5
 8003f74:	f7fc fcd4 	bl	8000920 <_test_assert>
 8003f78:	b108      	cbz	r0, 8003f7e <oslib_test_001_003_execute+0x4e>
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
}
 8003f7a:	b002      	add	sp, #8
 8003f7c:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003f7e:	2320      	movs	r3, #32
 8003f80:	f383 8811 	msr	BASEPRI, r3
 8003f84:	4c44      	ldr	r4, [pc, #272]	; (8004098 <oslib_test_001_003_execute+0x168>)
  _dbg_check_lock();
 8003f86:	f7ff fc1b 	bl	80037c0 <_dbg_check_lock>
    msg1 = chMBPostI(&mb1, 'X');
 8003f8a:	2058      	movs	r0, #88	; 0x58
 8003f8c:	f7fd ff18 	bl	8001dc0 <chMBPostI.constprop.25>
  _dbg_check_unlock();
 8003f90:	f7ff fbae 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003f94:	6823      	ldr	r3, [r4, #0]
 8003f96:	42a3      	cmp	r3, r4
 8003f98:	d004      	beq.n	8003fa4 <oslib_test_001_003_execute+0x74>
 8003f9a:	69a2      	ldr	r2, [r4, #24]
 8003f9c:	689b      	ldr	r3, [r3, #8]
 8003f9e:	6892      	ldr	r2, [r2, #8]
 8003fa0:	429a      	cmp	r2, r3
 8003fa2:	d368      	bcc.n	8004076 <oslib_test_001_003_execute+0x146>
 8003fa4:	2300      	movs	r3, #0
 8003fa6:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003faa:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8003fae:	fab0 f080 	clz	r0, r0
 8003fb2:	4938      	ldr	r1, [pc, #224]	; (8004094 <oslib_test_001_003_execute+0x164>)
 8003fb4:	0940      	lsrs	r0, r0, #5
 8003fb6:	f7fc fcb3 	bl	8000920 <_test_assert>
 8003fba:	2800      	cmp	r0, #0
 8003fbc:	d1dd      	bne.n	8003f7a <oslib_test_001_003_execute+0x4a>
    msg1 = chMBPostAheadTimeout(&mb1, 'X', 1);
 8003fbe:	2101      	movs	r1, #1
 8003fc0:	2058      	movs	r0, #88	; 0x58
 8003fc2:	f7ff fe95 	bl	8003cf0 <chMBPostAheadTimeout.constprop.23>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003fc6:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8003fca:	fab0 f080 	clz	r0, r0
 8003fce:	4931      	ldr	r1, [pc, #196]	; (8004094 <oslib_test_001_003_execute+0x164>)
 8003fd0:	0940      	lsrs	r0, r0, #5
 8003fd2:	f7fc fca5 	bl	8000920 <_test_assert>
 8003fd6:	2800      	cmp	r0, #0
 8003fd8:	d1cf      	bne.n	8003f7a <oslib_test_001_003_execute+0x4a>
 8003fda:	2320      	movs	r3, #32
 8003fdc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003fe0:	f7ff fbee 	bl	80037c0 <_dbg_check_lock>
    msg1 = chMBPostAheadI(&mb1, 'X');
 8003fe4:	2058      	movs	r0, #88	; 0x58
 8003fe6:	f7fd ff1b 	bl	8001e20 <chMBPostAheadI.constprop.22>
  _dbg_check_unlock();
 8003fea:	f7ff fb81 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003fee:	6823      	ldr	r3, [r4, #0]
 8003ff0:	42a3      	cmp	r3, r4
 8003ff2:	d004      	beq.n	8003ffe <oslib_test_001_003_execute+0xce>
 8003ff4:	69a2      	ldr	r2, [r4, #24]
 8003ff6:	689b      	ldr	r3, [r3, #8]
 8003ff8:	6892      	ldr	r2, [r2, #8]
 8003ffa:	429a      	cmp	r2, r3
 8003ffc:	d343      	bcc.n	8004086 <oslib_test_001_003_execute+0x156>
 8003ffe:	2300      	movs	r3, #0
 8004000:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004004:	1c46      	adds	r6, r0, #1
 8004006:	4270      	negs	r0, r6
 8004008:	4170      	adcs	r0, r6
 800400a:	4922      	ldr	r1, [pc, #136]	; (8004094 <oslib_test_001_003_execute+0x164>)
 800400c:	f7fc fc88 	bl	8000920 <_test_assert>
 8004010:	4606      	mov	r6, r0
 8004012:	2800      	cmp	r0, #0
 8004014:	d1b1      	bne.n	8003f7a <oslib_test_001_003_execute+0x4a>
  test_set_step(3);
 8004016:	2303      	movs	r3, #3
 8004018:	602b      	str	r3, [r5, #0]
    chMBReset(&mb1);
 800401a:	f7ff fdd1 	bl	8003bc0 <chMBReset.constprop.28>
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
 800401e:	4b1f      	ldr	r3, [pc, #124]	; (800409c <oslib_test_001_003_execute+0x16c>)
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
 8004020:	2101      	movs	r1, #1
 8004022:	751e      	strb	r6, [r3, #20]
 8004024:	a801      	add	r0, sp, #4
  test_set_step(4);
 8004026:	2304      	movs	r3, #4
 8004028:	602b      	str	r3, [r5, #0]
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
 800402a:	f7ff feb9 	bl	8003da0 <chMBFetchTimeout.constprop.20>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800402e:	1c42      	adds	r2, r0, #1
 8004030:	4250      	negs	r0, r2
 8004032:	4150      	adcs	r0, r2
 8004034:	4917      	ldr	r1, [pc, #92]	; (8004094 <oslib_test_001_003_execute+0x164>)
 8004036:	f7fc fc73 	bl	8000920 <_test_assert>
 800403a:	2800      	cmp	r0, #0
 800403c:	d19d      	bne.n	8003f7a <oslib_test_001_003_execute+0x4a>
 800403e:	2320      	movs	r3, #32
 8004040:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004044:	f7ff fbbc 	bl	80037c0 <_dbg_check_lock>
    msg1 = chMBFetchI(&mb1, &msg2);
 8004048:	a801      	add	r0, sp, #4
 800404a:	f7fc fed1 	bl	8000df0 <chMBFetchI.constprop.19>
  _dbg_check_unlock();
 800404e:	f7ff fb4f 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004052:	6823      	ldr	r3, [r4, #0]
 8004054:	42a3      	cmp	r3, r4
 8004056:	d004      	beq.n	8004062 <oslib_test_001_003_execute+0x132>
 8004058:	69a2      	ldr	r2, [r4, #24]
 800405a:	689b      	ldr	r3, [r3, #8]
 800405c:	6892      	ldr	r2, [r2, #8]
 800405e:	429a      	cmp	r2, r3
 8004060:	d30d      	bcc.n	800407e <oslib_test_001_003_execute+0x14e>
 8004062:	2300      	movs	r3, #0
 8004064:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004068:	1c43      	adds	r3, r0, #1
 800406a:	4258      	negs	r0, r3
 800406c:	4909      	ldr	r1, [pc, #36]	; (8004094 <oslib_test_001_003_execute+0x164>)
 800406e:	4158      	adcs	r0, r3
 8004070:	f7fc fc56 	bl	8000920 <_test_assert>
 8004074:	e781      	b.n	8003f7a <oslib_test_001_003_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
 8004076:	b672      	cpsid	i
 8004078:	4b09      	ldr	r3, [pc, #36]	; (80040a0 <oslib_test_001_003_execute+0x170>)
 800407a:	62e3      	str	r3, [r4, #44]	; 0x2c
 800407c:	e7fe      	b.n	800407c <oslib_test_001_003_execute+0x14c>
 800407e:	b672      	cpsid	i
 8004080:	4b07      	ldr	r3, [pc, #28]	; (80040a0 <oslib_test_001_003_execute+0x170>)
 8004082:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004084:	e7fe      	b.n	8004084 <oslib_test_001_003_execute+0x154>
 8004086:	b672      	cpsid	i
 8004088:	4b05      	ldr	r3, [pc, #20]	; (80040a0 <oslib_test_001_003_execute+0x170>)
 800408a:	62e3      	str	r3, [r4, #44]	; 0x2c
 800408c:	e7fe      	b.n	800408c <oslib_test_001_003_execute+0x15c>
 800408e:	bf00      	nop
 8004090:	20001b3c 	.word	0x20001b3c
 8004094:	0800c640 	.word	0x0800c640
 8004098:	200011a0 	.word	0x200011a0
 800409c:	20000c58 	.word	0x20000c58
 80040a0:	0800bcc8 	.word	0x0800bcc8
	...

080040b0 <bmk_thread4>:
static THD_FUNCTION(bmk_thread4, p) {
 80040b0:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 80040b2:	4c0f      	ldr	r4, [pc, #60]	; (80040f0 <bmk_thread4+0x40>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80040b4:	2320      	movs	r3, #32
 80040b6:	69a5      	ldr	r5, [r4, #24]
 80040b8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80040bc:	f7ff fb80 	bl	80037c0 <_dbg_check_lock>
    chSchGoSleepS(CH_STATE_SUSPENDED);
 80040c0:	2003      	movs	r0, #3
 80040c2:	f7fe ff3d 	bl	8002f40 <chSchGoSleepS>
  } while (msg == MSG_OK);
 80040c6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80040c8:	2b00      	cmp	r3, #0
 80040ca:	d0f9      	beq.n	80040c0 <bmk_thread4+0x10>
  _dbg_check_unlock();
 80040cc:	f7ff fb10 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80040d0:	6823      	ldr	r3, [r4, #0]
 80040d2:	42a3      	cmp	r3, r4
 80040d4:	d004      	beq.n	80040e0 <bmk_thread4+0x30>
 80040d6:	69a2      	ldr	r2, [r4, #24]
 80040d8:	689b      	ldr	r3, [r3, #8]
 80040da:	6892      	ldr	r2, [r2, #8]
 80040dc:	429a      	cmp	r2, r3
 80040de:	d303      	bcc.n	80040e8 <bmk_thread4+0x38>
 80040e0:	2300      	movs	r3, #0
 80040e2:	f383 8811 	msr	BASEPRI, r3
}
 80040e6:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80040e8:	b672      	cpsid	i
 80040ea:	4b02      	ldr	r3, [pc, #8]	; (80040f4 <bmk_thread4+0x44>)
 80040ec:	62e3      	str	r3, [r4, #44]	; 0x2c
 80040ee:	e7fe      	b.n	80040ee <bmk_thread4+0x3e>
 80040f0:	200011a0 	.word	0x200011a0
 80040f4:	0800bcbc 	.word	0x0800bcbc
	...

08004100 <rt_test_008_006_execute>:
static void rt_test_008_006_execute(void) {
 8004100:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8004102:	4d75      	ldr	r5, [pc, #468]	; (80042d8 <rt_test_008_006_execute+0x1d8>)
 8004104:	2301      	movs	r3, #1
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8004106:	2000      	movs	r0, #0
  test_set_step(1);
 8004108:	602b      	str	r3, [r5, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800410a:	f7ff fd09 	bl	8003b20 <chEvtWaitOneTimeout.constprop.34>
    test_assert(m == 0, "spurious event");
 800410e:	fab0 f080 	clz	r0, r0
 8004112:	0940      	lsrs	r0, r0, #5
 8004114:	4971      	ldr	r1, [pc, #452]	; (80042dc <rt_test_008_006_execute+0x1dc>)
 8004116:	f7fc fc03 	bl	8000920 <_test_assert>
 800411a:	b100      	cbz	r0, 800411e <rt_test_008_006_execute+0x1e>
}
 800411c:	bd70      	pop	{r4, r5, r6, pc}
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 800411e:	4c70      	ldr	r4, [pc, #448]	; (80042e0 <rt_test_008_006_execute+0x1e0>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004120:	2320      	movs	r3, #32
 8004122:	69a1      	ldr	r1, [r4, #24]
 8004124:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004128:	f7ff fb4a 	bl	80037c0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
 800412c:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800412e:	2b00      	cmp	r3, #0
 8004130:	f040 8099 	bne.w	8004266 <rt_test_008_006_execute+0x166>
  _dbg_check_unlock();
 8004134:	f7ff fadc 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004138:	6823      	ldr	r3, [r4, #0]
 800413a:	42a3      	cmp	r3, r4
 800413c:	d005      	beq.n	800414a <rt_test_008_006_execute+0x4a>
 800413e:	69a2      	ldr	r2, [r4, #24]
 8004140:	689b      	ldr	r3, [r3, #8]
 8004142:	6892      	ldr	r2, [r2, #8]
 8004144:	429a      	cmp	r2, r3
 8004146:	f0c0 808a 	bcc.w	800425e <rt_test_008_006_execute+0x15e>
 800414a:	2300      	movs	r3, #0
 800414c:	f383 8811 	msr	BASEPRI, r3
 8004150:	2001      	movs	r0, #1
    test_assert(m == 0, "spurious event");
 8004152:	4962      	ldr	r1, [pc, #392]	; (80042dc <rt_test_008_006_execute+0x1dc>)
 8004154:	f7fc fbe4 	bl	8000920 <_test_assert>
 8004158:	2800      	cmp	r0, #0
 800415a:	d1df      	bne.n	800411c <rt_test_008_006_execute+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 800415c:	69a6      	ldr	r6, [r4, #24]
 800415e:	2320      	movs	r3, #32
 8004160:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004164:	f7ff fb2c 	bl	80037c0 <_dbg_check_lock>

  chSysLock();
  if ((ctp->epending & events) != events) {
 8004168:	6b73      	ldr	r3, [r6, #52]	; 0x34
 800416a:	3301      	adds	r3, #1
 800416c:	f000 808e 	beq.w	800428c <rt_test_008_006_execute+0x18c>
  _dbg_check_unlock();
 8004170:	f7ff fabe 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004174:	6823      	ldr	r3, [r4, #0]
 8004176:	42a3      	cmp	r3, r4
 8004178:	d005      	beq.n	8004186 <rt_test_008_006_execute+0x86>
 800417a:	69a2      	ldr	r2, [r4, #24]
 800417c:	689b      	ldr	r3, [r3, #8]
 800417e:	6892      	ldr	r2, [r2, #8]
 8004180:	429a      	cmp	r2, r3
 8004182:	f0c0 8092 	bcc.w	80042aa <rt_test_008_006_execute+0x1aa>
 8004186:	2300      	movs	r3, #0
 8004188:	f383 8811 	msr	BASEPRI, r3
 800418c:	2001      	movs	r0, #1
    test_assert(m == 0, "spurious event");
 800418e:	4953      	ldr	r1, [pc, #332]	; (80042dc <rt_test_008_006_execute+0x1dc>)
 8004190:	f7fc fbc6 	bl	8000920 <_test_assert>
 8004194:	2800      	cmp	r0, #0
 8004196:	d1c1      	bne.n	800411c <rt_test_008_006_execute+0x1c>
  test_set_step(2);
 8004198:	2302      	movs	r3, #2
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
 800419a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  test_set_step(2);
 800419e:	602b      	str	r3, [r5, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
 80041a0:	f7ff fcbe 	bl	8003b20 <chEvtWaitOneTimeout.constprop.34>
    test_assert(m == 0, "spurious event");
 80041a4:	fab0 f080 	clz	r0, r0
 80041a8:	0940      	lsrs	r0, r0, #5
 80041aa:	494c      	ldr	r1, [pc, #304]	; (80042dc <rt_test_008_006_execute+0x1dc>)
 80041ac:	f7fc fbb8 	bl	8000920 <_test_assert>
 80041b0:	2800      	cmp	r0, #0
 80041b2:	d1b3      	bne.n	800411c <rt_test_008_006_execute+0x1c>
  thread_t *ctp = currp;
 80041b4:	69a5      	ldr	r5, [r4, #24]
 80041b6:	2320      	movs	r3, #32
 80041b8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80041bc:	f7ff fb00 	bl	80037c0 <_dbg_check_lock>
  m = ctp->epending & events;
 80041c0:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80041c2:	b956      	cbnz	r6, 80041da <rt_test_008_006_execute+0xda>
    ctp->u.ewmask = events;
 80041c4:	f04f 33ff 	mov.w	r3, #4294967295
 80041c8:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 80041ca:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80041ce:	200a      	movs	r0, #10
 80041d0:	f7fe ff76 	bl	80030c0 <chSchGoSleepTimeoutS>
 80041d4:	2800      	cmp	r0, #0
 80041d6:	db70      	blt.n	80042ba <rt_test_008_006_execute+0x1ba>
    m = ctp->epending & events;
 80041d8:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  ctp->epending &= ~m;
 80041da:	2300      	movs	r3, #0
 80041dc:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
 80041de:	f7ff fa87 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80041e2:	6823      	ldr	r3, [r4, #0]
 80041e4:	42a3      	cmp	r3, r4
 80041e6:	d004      	beq.n	80041f2 <rt_test_008_006_execute+0xf2>
 80041e8:	69a2      	ldr	r2, [r4, #24]
 80041ea:	689b      	ldr	r3, [r3, #8]
 80041ec:	6892      	ldr	r2, [r2, #8]
 80041ee:	429a      	cmp	r2, r3
 80041f0:	d366      	bcc.n	80042c0 <rt_test_008_006_execute+0x1c0>
 80041f2:	2300      	movs	r3, #0
 80041f4:	f383 8811 	msr	BASEPRI, r3
    test_assert(m == 0, "spurious event");
 80041f8:	fab6 f086 	clz	r0, r6
 80041fc:	0940      	lsrs	r0, r0, #5
 80041fe:	4937      	ldr	r1, [pc, #220]	; (80042dc <rt_test_008_006_execute+0x1dc>)
 8004200:	f7fc fb8e 	bl	8000920 <_test_assert>
 8004204:	4605      	mov	r5, r0
 8004206:	2800      	cmp	r0, #0
 8004208:	d188      	bne.n	800411c <rt_test_008_006_execute+0x1c>
  thread_t *ctp = currp;
 800420a:	69a6      	ldr	r6, [r4, #24]
 800420c:	2320      	movs	r3, #32
 800420e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004212:	f7ff fad5 	bl	80037c0 <_dbg_check_lock>
  if ((ctp->epending & events) != events) {
 8004216:	6b73      	ldr	r3, [r6, #52]	; 0x34
 8004218:	3301      	adds	r3, #1
 800421a:	d009      	beq.n	8004230 <rt_test_008_006_execute+0x130>
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 800421c:	f04f 33ff 	mov.w	r3, #4294967295
 8004220:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
 8004222:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8004226:	200b      	movs	r0, #11
 8004228:	f7fe ff4a 	bl	80030c0 <chSchGoSleepTimeoutS>
 800422c:	2800      	cmp	r0, #0
 800422e:	db4b      	blt.n	80042c8 <rt_test_008_006_execute+0x1c8>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 8004230:	2300      	movs	r3, #0
 8004232:	6373      	str	r3, [r6, #52]	; 0x34
  _dbg_check_unlock();
 8004234:	f7ff fa5c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004238:	6823      	ldr	r3, [r4, #0]
 800423a:	42a3      	cmp	r3, r4
 800423c:	d004      	beq.n	8004248 <rt_test_008_006_execute+0x148>
 800423e:	69a2      	ldr	r2, [r4, #24]
 8004240:	689b      	ldr	r3, [r3, #8]
 8004242:	6892      	ldr	r2, [r2, #8]
 8004244:	429a      	cmp	r2, r3
 8004246:	d343      	bcc.n	80042d0 <rt_test_008_006_execute+0x1d0>
 8004248:	2300      	movs	r3, #0
 800424a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
 800424e:	f04f 30ff 	mov.w	r0, #4294967295
    test_assert(m == 0, "spurious event");
 8004252:	3001      	adds	r0, #1
 8004254:	4921      	ldr	r1, [pc, #132]	; (80042dc <rt_test_008_006_execute+0x1dc>)
}
 8004256:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(m == 0, "spurious event");
 800425a:	f7fc bb61 	b.w	8000920 <_test_assert>
  __ASM volatile ("cpsid i" : : : "memory");
 800425e:	b672      	cpsid	i
 8004260:	4b20      	ldr	r3, [pc, #128]	; (80042e4 <rt_test_008_006_execute+0x1e4>)
 8004262:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004264:	e7fe      	b.n	8004264 <rt_test_008_006_execute+0x164>
  ctp->epending &= ~m;
 8004266:	6348      	str	r0, [r1, #52]	; 0x34
  _dbg_check_unlock();
 8004268:	f7ff fa42 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800426c:	6823      	ldr	r3, [r4, #0]
 800426e:	42a3      	cmp	r3, r4
 8004270:	d004      	beq.n	800427c <rt_test_008_006_execute+0x17c>
 8004272:	69a2      	ldr	r2, [r4, #24]
 8004274:	689b      	ldr	r3, [r3, #8]
 8004276:	6892      	ldr	r2, [r2, #8]
 8004278:	429a      	cmp	r2, r3
 800427a:	d303      	bcc.n	8004284 <rt_test_008_006_execute+0x184>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800427c:	2000      	movs	r0, #0
 800427e:	f380 8811 	msr	BASEPRI, r0
 8004282:	e766      	b.n	8004152 <rt_test_008_006_execute+0x52>
  __ASM volatile ("cpsid i" : : : "memory");
 8004284:	b672      	cpsid	i
 8004286:	4b17      	ldr	r3, [pc, #92]	; (80042e4 <rt_test_008_006_execute+0x1e4>)
 8004288:	62e3      	str	r3, [r4, #44]	; 0x2c
 800428a:	e7fe      	b.n	800428a <rt_test_008_006_execute+0x18a>
  ctp->epending &= ~events;
 800428c:	6370      	str	r0, [r6, #52]	; 0x34
  _dbg_check_unlock();
 800428e:	f7ff fa2f 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004292:	6823      	ldr	r3, [r4, #0]
 8004294:	42a3      	cmp	r3, r4
 8004296:	d004      	beq.n	80042a2 <rt_test_008_006_execute+0x1a2>
 8004298:	69a2      	ldr	r2, [r4, #24]
 800429a:	689b      	ldr	r3, [r3, #8]
 800429c:	6892      	ldr	r2, [r2, #8]
 800429e:	429a      	cmp	r2, r3
 80042a0:	d307      	bcc.n	80042b2 <rt_test_008_006_execute+0x1b2>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80042a2:	2300      	movs	r3, #0
 80042a4:	f383 8811 	msr	BASEPRI, r3
 80042a8:	e771      	b.n	800418e <rt_test_008_006_execute+0x8e>
  __ASM volatile ("cpsid i" : : : "memory");
 80042aa:	b672      	cpsid	i
 80042ac:	4b0d      	ldr	r3, [pc, #52]	; (80042e4 <rt_test_008_006_execute+0x1e4>)
 80042ae:	62e3      	str	r3, [r4, #44]	; 0x2c
 80042b0:	e7fe      	b.n	80042b0 <rt_test_008_006_execute+0x1b0>
 80042b2:	b672      	cpsid	i
 80042b4:	4b0b      	ldr	r3, [pc, #44]	; (80042e4 <rt_test_008_006_execute+0x1e4>)
 80042b6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80042b8:	e7fe      	b.n	80042b8 <rt_test_008_006_execute+0x1b8>
      chSysUnlock();
 80042ba:	f7ff fa29 	bl	8003710 <chSysUnlock.lto_priv.103>
 80042be:	e79b      	b.n	80041f8 <rt_test_008_006_execute+0xf8>
 80042c0:	b672      	cpsid	i
 80042c2:	4b08      	ldr	r3, [pc, #32]	; (80042e4 <rt_test_008_006_execute+0x1e4>)
 80042c4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80042c6:	e7fe      	b.n	80042c6 <rt_test_008_006_execute+0x1c6>
      chSysUnlock();
 80042c8:	f7ff fa22 	bl	8003710 <chSysUnlock.lto_priv.103>
      return (eventmask_t)0;
 80042cc:	4628      	mov	r0, r5
 80042ce:	e7c0      	b.n	8004252 <rt_test_008_006_execute+0x152>
 80042d0:	b672      	cpsid	i
 80042d2:	4b04      	ldr	r3, [pc, #16]	; (80042e4 <rt_test_008_006_execute+0x1e4>)
 80042d4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80042d6:	e7fe      	b.n	80042d6 <rt_test_008_006_execute+0x1d6>
 80042d8:	20001b3c 	.word	0x20001b3c
 80042dc:	0800d820 	.word	0x0800d820
 80042e0:	200011a0 	.word	0x200011a0
 80042e4:	0800bc14 	.word	0x0800bc14
	...

080042f0 <thread4>:
static THD_FUNCTION(thread4, p) {
 80042f0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80042f2:	2320      	movs	r3, #32
 80042f4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80042f8:	f7ff fa62 	bl	80037c0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 80042fc:	f7fc fc70 	bl	8000be0 <chDbgCheckClassI>

  if (bsp->sem.cnt < (cnt_t)1) {
 8004300:	6883      	ldr	r3, [r0, #8]
 8004302:	2b00      	cmp	r3, #0
 8004304:	dd10      	ble.n	8004328 <thread4+0x38>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8004306:	f7ff f9db 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 800430a:	f7ff f9f1 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800430e:	4b0a      	ldr	r3, [pc, #40]	; (8004338 <thread4+0x48>)
 8004310:	681a      	ldr	r2, [r3, #0]
 8004312:	429a      	cmp	r2, r3
 8004314:	d004      	beq.n	8004320 <thread4+0x30>
 8004316:	6999      	ldr	r1, [r3, #24]
 8004318:	6892      	ldr	r2, [r2, #8]
 800431a:	6889      	ldr	r1, [r1, #8]
 800431c:	4291      	cmp	r1, r2
 800431e:	d306      	bcc.n	800432e <thread4+0x3e>
 8004320:	2300      	movs	r3, #0
 8004322:	f383 8811 	msr	BASEPRI, r3
}
 8004326:	bd08      	pop	{r3, pc}
    chSemSignalI(&bsp->sem);
 8004328:	f7fc fe52 	bl	8000fd0 <chSemSignalI>
 800432c:	e7eb      	b.n	8004306 <thread4+0x16>
  __ASM volatile ("cpsid i" : : : "memory");
 800432e:	b672      	cpsid	i
 8004330:	4a02      	ldr	r2, [pc, #8]	; (800433c <thread4+0x4c>)
 8004332:	62da      	str	r2, [r3, #44]	; 0x2c
 8004334:	e7fe      	b.n	8004334 <thread4+0x44>
 8004336:	bf00      	nop
 8004338:	200011a0 	.word	0x200011a0
 800433c:	0800bc98 	.word	0x0800bc98

08004340 <rt_test_002_001_execute>:
static void rt_test_002_001_execute(void) {
 8004340:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 8004342:	4d46      	ldr	r5, [pc, #280]	; (800445c <rt_test_002_001_execute+0x11c>)
 8004344:	2001      	movs	r0, #1
 8004346:	6028      	str	r0, [r5, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004348:	2320      	movs	r3, #32
 800434a:	f383 8811 	msr	BASEPRI, r3
 800434e:	4c44      	ldr	r4, [pc, #272]	; (8004460 <rt_test_002_001_execute+0x120>)
  _dbg_check_lock();
 8004350:	f7ff fa36 	bl	80037c0 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8004354:	f7fc ff54 	bl	8001200 <chSysIntegrityCheckI>
  _dbg_check_unlock();
 8004358:	f7ff f9ca 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800435c:	6823      	ldr	r3, [r4, #0]
 800435e:	42a3      	cmp	r3, r4
 8004360:	d004      	beq.n	800436c <rt_test_002_001_execute+0x2c>
 8004362:	69a2      	ldr	r2, [r4, #24]
 8004364:	689b      	ldr	r3, [r3, #8]
 8004366:	6892      	ldr	r2, [r2, #8]
 8004368:	429a      	cmp	r2, r3
 800436a:	d366      	bcc.n	800443a <rt_test_002_001_execute+0xfa>
 800436c:	2300      	movs	r3, #0
 800436e:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "ready list check failed");
 8004372:	f080 0001 	eor.w	r0, r0, #1
 8004376:	b2c0      	uxtb	r0, r0
 8004378:	493a      	ldr	r1, [pc, #232]	; (8004464 <rt_test_002_001_execute+0x124>)
 800437a:	f7fc fad1 	bl	8000920 <_test_assert>
 800437e:	b100      	cbz	r0, 8004382 <rt_test_002_001_execute+0x42>
}
 8004380:	bd38      	pop	{r3, r4, r5, pc}
  test_set_step(2);
 8004382:	2002      	movs	r0, #2
 8004384:	6028      	str	r0, [r5, #0]
 8004386:	2320      	movs	r3, #32
 8004388:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800438c:	f7ff fa18 	bl	80037c0 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8004390:	f7fc ff36 	bl	8001200 <chSysIntegrityCheckI>
  _dbg_check_unlock();
 8004394:	f7ff f9ac 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004398:	6823      	ldr	r3, [r4, #0]
 800439a:	42a3      	cmp	r3, r4
 800439c:	d004      	beq.n	80043a8 <rt_test_002_001_execute+0x68>
 800439e:	69a2      	ldr	r2, [r4, #24]
 80043a0:	689b      	ldr	r3, [r3, #8]
 80043a2:	6892      	ldr	r2, [r2, #8]
 80043a4:	429a      	cmp	r2, r3
 80043a6:	d34c      	bcc.n	8004442 <rt_test_002_001_execute+0x102>
 80043a8:	2300      	movs	r3, #0
 80043aa:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "virtual timers list check failed");
 80043ae:	f080 0001 	eor.w	r0, r0, #1
 80043b2:	b2c0      	uxtb	r0, r0
 80043b4:	492c      	ldr	r1, [pc, #176]	; (8004468 <rt_test_002_001_execute+0x128>)
 80043b6:	f7fc fab3 	bl	8000920 <_test_assert>
 80043ba:	2800      	cmp	r0, #0
 80043bc:	d1e0      	bne.n	8004380 <rt_test_002_001_execute+0x40>
  test_set_step(3);
 80043be:	2303      	movs	r3, #3
 80043c0:	602b      	str	r3, [r5, #0]
 80043c2:	2320      	movs	r3, #32
 80043c4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80043c8:	f7ff f9fa 	bl	80037c0 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 80043cc:	2004      	movs	r0, #4
 80043ce:	f7fc ff17 	bl	8001200 <chSysIntegrityCheckI>
  _dbg_check_unlock();
 80043d2:	f7ff f98d 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80043d6:	6823      	ldr	r3, [r4, #0]
 80043d8:	42a3      	cmp	r3, r4
 80043da:	d004      	beq.n	80043e6 <rt_test_002_001_execute+0xa6>
 80043dc:	69a2      	ldr	r2, [r4, #24]
 80043de:	689b      	ldr	r3, [r3, #8]
 80043e0:	6892      	ldr	r2, [r2, #8]
 80043e2:	429a      	cmp	r2, r3
 80043e4:	d331      	bcc.n	800444a <rt_test_002_001_execute+0x10a>
 80043e6:	2300      	movs	r3, #0
 80043e8:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "registry list check failed");
 80043ec:	f080 0001 	eor.w	r0, r0, #1
 80043f0:	b2c0      	uxtb	r0, r0
 80043f2:	491e      	ldr	r1, [pc, #120]	; (800446c <rt_test_002_001_execute+0x12c>)
 80043f4:	f7fc fa94 	bl	8000920 <_test_assert>
 80043f8:	2800      	cmp	r0, #0
 80043fa:	d1c1      	bne.n	8004380 <rt_test_002_001_execute+0x40>
  test_set_step(4);
 80043fc:	2304      	movs	r3, #4
 80043fe:	602b      	str	r3, [r5, #0]
 8004400:	2320      	movs	r3, #32
 8004402:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004406:	f7ff f9db 	bl	80037c0 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 800440a:	2008      	movs	r0, #8
 800440c:	f7fc fef8 	bl	8001200 <chSysIntegrityCheckI>
  _dbg_check_unlock();
 8004410:	f7ff f96e 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004414:	6823      	ldr	r3, [r4, #0]
 8004416:	42a3      	cmp	r3, r4
 8004418:	d004      	beq.n	8004424 <rt_test_002_001_execute+0xe4>
 800441a:	69a2      	ldr	r2, [r4, #24]
 800441c:	689b      	ldr	r3, [r3, #8]
 800441e:	6892      	ldr	r2, [r2, #8]
 8004420:	429a      	cmp	r2, r3
 8004422:	d316      	bcc.n	8004452 <rt_test_002_001_execute+0x112>
 8004424:	2300      	movs	r3, #0
 8004426:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "port layer check failed");
 800442a:	f080 0001 	eor.w	r0, r0, #1
 800442e:	b2c0      	uxtb	r0, r0
 8004430:	490f      	ldr	r1, [pc, #60]	; (8004470 <rt_test_002_001_execute+0x130>)
}
 8004432:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert(result == false, "port layer check failed");
 8004436:	f7fc ba73 	b.w	8000920 <_test_assert>
  __ASM volatile ("cpsid i" : : : "memory");
 800443a:	b672      	cpsid	i
 800443c:	4b0d      	ldr	r3, [pc, #52]	; (8004474 <rt_test_002_001_execute+0x134>)
 800443e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004440:	e7fe      	b.n	8004440 <rt_test_002_001_execute+0x100>
 8004442:	b672      	cpsid	i
 8004444:	4b0b      	ldr	r3, [pc, #44]	; (8004474 <rt_test_002_001_execute+0x134>)
 8004446:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004448:	e7fe      	b.n	8004448 <rt_test_002_001_execute+0x108>
 800444a:	b672      	cpsid	i
 800444c:	4b09      	ldr	r3, [pc, #36]	; (8004474 <rt_test_002_001_execute+0x134>)
 800444e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004450:	e7fe      	b.n	8004450 <rt_test_002_001_execute+0x110>
 8004452:	b672      	cpsid	i
 8004454:	4b07      	ldr	r3, [pc, #28]	; (8004474 <rt_test_002_001_execute+0x134>)
 8004456:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004458:	e7fe      	b.n	8004458 <rt_test_002_001_execute+0x118>
 800445a:	bf00      	nop
 800445c:	20001b3c 	.word	0x20001b3c
 8004460:	200011a0 	.word	0x200011a0
 8004464:	0800d3d8 	.word	0x0800d3d8
 8004468:	0800d3f0 	.word	0x0800d3f0
 800446c:	0800d414 	.word	0x0800d414
 8004470:	0800d430 	.word	0x0800d430
 8004474:	0800bc74 	.word	0x0800bc74
	...

08004480 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8004480:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004482:	4c13      	ldr	r4, [pc, #76]	; (80044d0 <test_terminate_threads+0x50>)
 8004484:	4813      	ldr	r0, [pc, #76]	; (80044d4 <test_terminate_threads+0x54>)
 8004486:	f104 0714 	add.w	r7, r4, #20
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800448a:	2620      	movs	r6, #32
 800448c:	2500      	movs	r5, #0
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 800448e:	f854 1b04 	ldr.w	r1, [r4], #4
 8004492:	b1a9      	cbz	r1, 80044c0 <test_terminate_threads+0x40>
 8004494:	f386 8811 	msr	BASEPRI, r6
  _dbg_check_lock();
 8004498:	f7ff f992 	bl	80037c0 <_dbg_check_lock>
  tp->flags |= CH_FLAG_TERMINATE;
 800449c:	f891 3021 	ldrb.w	r3, [r1, #33]	; 0x21
 80044a0:	f043 0304 	orr.w	r3, r3, #4
 80044a4:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21
  _dbg_check_unlock();
 80044a8:	f7ff f922 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80044ac:	6803      	ldr	r3, [r0, #0]
 80044ae:	4283      	cmp	r3, r0
 80044b0:	d004      	beq.n	80044bc <test_terminate_threads+0x3c>
 80044b2:	6982      	ldr	r2, [r0, #24]
 80044b4:	689b      	ldr	r3, [r3, #8]
 80044b6:	6892      	ldr	r2, [r2, #8]
 80044b8:	429a      	cmp	r2, r3
 80044ba:	d304      	bcc.n	80044c6 <test_terminate_threads+0x46>
 80044bc:	f385 8811 	msr	BASEPRI, r5
  for (i = 0; i < MAX_THREADS; i++)
 80044c0:	42bc      	cmp	r4, r7
 80044c2:	d1e4      	bne.n	800448e <test_terminate_threads+0xe>
      chThdTerminate(threads[i]);
}
 80044c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80044c6:	b672      	cpsid	i
 80044c8:	4b03      	ldr	r3, [pc, #12]	; (80044d8 <test_terminate_threads+0x58>)
 80044ca:	62c3      	str	r3, [r0, #44]	; 0x2c
 80044cc:	e7fe      	b.n	80044cc <test_terminate_threads+0x4c>
 80044ce:	bf00      	nop
 80044d0:	20001b54 	.word	0x20001b54
 80044d4:	200011a0 	.word	0x200011a0
 80044d8:	0800bbe4 	.word	0x0800bbe4
 80044dc:	00000000 	.word	0x00000000

080044e0 <test_emit_token>:
 *
 * @param[in] token     the token as a char
 *
 * @api
 */
void test_emit_token(char token) {
 80044e0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80044e2:	2320      	movs	r3, #32
 80044e4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80044e8:	f7ff f96a 	bl	80037c0 <_dbg_check_lock>

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 80044ec:	4a0d      	ldr	r2, [pc, #52]	; (8004524 <test_emit_token+0x44>)
 80044ee:	490e      	ldr	r1, [pc, #56]	; (8004528 <test_emit_token+0x48>)
 80044f0:	6813      	ldr	r3, [r2, #0]
 80044f2:	428b      	cmp	r3, r1
 80044f4:	d202      	bcs.n	80044fc <test_emit_token+0x1c>
    *test_tokp++ = token;
 80044f6:	1c59      	adds	r1, r3, #1
 80044f8:	7018      	strb	r0, [r3, #0]
 80044fa:	6011      	str	r1, [r2, #0]
  _dbg_check_unlock();
 80044fc:	f7ff f8f8 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004500:	4b0a      	ldr	r3, [pc, #40]	; (800452c <test_emit_token+0x4c>)
 8004502:	681a      	ldr	r2, [r3, #0]
 8004504:	429a      	cmp	r2, r3
 8004506:	d004      	beq.n	8004512 <test_emit_token+0x32>
 8004508:	6999      	ldr	r1, [r3, #24]
 800450a:	6892      	ldr	r2, [r2, #8]
 800450c:	6889      	ldr	r1, [r1, #8]
 800450e:	4291      	cmp	r1, r2
 8004510:	d303      	bcc.n	800451a <test_emit_token+0x3a>
 8004512:	2300      	movs	r3, #0
 8004514:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 8004518:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800451a:	b672      	cpsid	i
 800451c:	4a04      	ldr	r2, [pc, #16]	; (8004530 <test_emit_token+0x50>)
 800451e:	62da      	str	r2, [r3, #44]	; 0x2c
 8004520:	e7fe      	b.n	8004520 <test_emit_token+0x40>
 8004522:	bf00      	nop
 8004524:	20001b50 	.word	0x20001b50
 8004528:	20001b50 	.word	0x20001b50
 800452c:	200011a0 	.word	0x200011a0
 8004530:	0800bc5c 	.word	0x0800bc5c
	...

08004540 <oslib_test_001_002_execute>:
static void oslib_test_001_002_execute(void) {
 8004540:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(1);
 8004544:	4e5a      	ldr	r6, [pc, #360]	; (80046b0 <oslib_test_001_002_execute+0x170>)
 8004546:	2301      	movs	r3, #1
static void oslib_test_001_002_execute(void) {
 8004548:	b082      	sub	sp, #8
  test_set_step(1);
 800454a:	6033      	str	r3, [r6, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800454c:	2320      	movs	r3, #32
 800454e:	f383 8811 	msr	BASEPRI, r3
  return (size_t)(mbp->top - mbp->buffer);
 8004552:	4d58      	ldr	r5, [pc, #352]	; (80046b4 <oslib_test_001_002_execute+0x174>)
  _dbg_check_lock();
 8004554:	f7ff f934 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004558:	f7fc fb42 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 800455c:	f7fc fb40 	bl	8000be0 <chDbgCheckClassI>
  return (size_t)(mbp->top - mbp->buffer);
 8004560:	e9d5 0200 	ldrd	r0, r2, [r5]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004564:	692b      	ldr	r3, [r5, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8004566:	4954      	ldr	r1, [pc, #336]	; (80046b8 <oslib_test_001_002_execute+0x178>)
  return (size_t)(mbp->top - mbp->buffer);
 8004568:	1a12      	subs	r2, r2, r0
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800456a:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 800456e:	f1a3 0004 	sub.w	r0, r3, #4
 8004572:	fab0 f080 	clz	r0, r0
 8004576:	0940      	lsrs	r0, r0, #5
 8004578:	f7fc f9d2 	bl	8000920 <_test_assert>
 800457c:	2800      	cmp	r0, #0
 800457e:	d168      	bne.n	8004652 <oslib_test_001_002_execute+0x112>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004580:	4c4e      	ldr	r4, [pc, #312]	; (80046bc <oslib_test_001_002_execute+0x17c>)
  _dbg_check_unlock();
 8004582:	f7ff f8b5 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004586:	6823      	ldr	r3, [r4, #0]
 8004588:	42a3      	cmp	r3, r4
 800458a:	d004      	beq.n	8004596 <oslib_test_001_002_execute+0x56>
 800458c:	69a2      	ldr	r2, [r4, #24]
 800458e:	689b      	ldr	r3, [r3, #8]
 8004590:	6892      	ldr	r2, [r2, #8]
 8004592:	429a      	cmp	r2, r3
 8004594:	d37c      	bcc.n	8004690 <oslib_test_001_002_execute+0x150>
 8004596:	2300      	movs	r3, #0
 8004598:	f383 8811 	msr	BASEPRI, r3
  test_set_step(2);
 800459c:	2302      	movs	r3, #2
 800459e:	6033      	str	r3, [r6, #0]
 80045a0:	2320      	movs	r3, #32
 80045a2:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80045a6:	f7ff f90b 	bl	80037c0 <_dbg_check_lock>
    chMBResetI(&mb1);
 80045aa:	f7fd fbf1 	bl	8001d90 <chMBResetI.constprop.29>
  _dbg_check_unlock();
 80045ae:	f7ff f89f 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80045b2:	6823      	ldr	r3, [r4, #0]
 80045b4:	42a3      	cmp	r3, r4
 80045b6:	d004      	beq.n	80045c2 <oslib_test_001_002_execute+0x82>
 80045b8:	69a2      	ldr	r2, [r4, #24]
 80045ba:	689b      	ldr	r3, [r3, #8]
 80045bc:	6892      	ldr	r2, [r2, #8]
 80045be:	429a      	cmp	r2, r3
 80045c0:	d36a      	bcc.n	8004698 <oslib_test_001_002_execute+0x158>
 80045c2:	2300      	movs	r3, #0
 80045c4:	f383 8811 	msr	BASEPRI, r3
 80045c8:	2320      	movs	r3, #32
 80045ca:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80045ce:	f7ff f8f7 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 80045d2:	f7fc fb05 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 80045d6:	f7fc fb03 	bl	8000be0 <chDbgCheckClassI>
  return (size_t)(mbp->top - mbp->buffer);
 80045da:	e9d5 1200 	ldrd	r1, r2, [r5]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80045de:	692b      	ldr	r3, [r5, #16]
  return (size_t)(mbp->top - mbp->buffer);
 80045e0:	1a52      	subs	r2, r2, r1
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80045e2:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80045e6:	f1a3 0004 	sub.w	r0, r3, #4
 80045ea:	fab0 f080 	clz	r0, r0
 80045ee:	0940      	lsrs	r0, r0, #5
 80045f0:	4933      	ldr	r1, [pc, #204]	; (80046c0 <oslib_test_001_002_execute+0x180>)
 80045f2:	f7fc f995 	bl	8000920 <_test_assert>
 80045f6:	2800      	cmp	r0, #0
 80045f8:	d13a      	bne.n	8004670 <oslib_test_001_002_execute+0x130>
  _dbg_check_unlock();
 80045fa:	f7ff f879 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80045fe:	6823      	ldr	r3, [r4, #0]
 8004600:	42a3      	cmp	r3, r4
 8004602:	d004      	beq.n	800460e <oslib_test_001_002_execute+0xce>
 8004604:	69a2      	ldr	r2, [r4, #24]
 8004606:	689b      	ldr	r3, [r3, #8]
 8004608:	6892      	ldr	r2, [r2, #8]
 800460a:	429a      	cmp	r2, r3
 800460c:	d348      	bcc.n	80046a0 <oslib_test_001_002_execute+0x160>
 800460e:	2300      	movs	r3, #0
 8004610:	f383 8811 	msr	BASEPRI, r3
 8004614:	2320      	movs	r3, #32
 8004616:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800461a:	f7ff f8d1 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 800461e:	f7fc fadf 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8004622:	6928      	ldr	r0, [r5, #16]
 8004624:	4927      	ldr	r1, [pc, #156]	; (80046c4 <oslib_test_001_002_execute+0x184>)
 8004626:	fab0 f080 	clz	r0, r0
 800462a:	0940      	lsrs	r0, r0, #5
 800462c:	f7fc f978 	bl	8000920 <_test_assert>
 8004630:	2800      	cmp	r0, #0
 8004632:	f040 822b 	bne.w	8004a8c <oslib_test_001_002_execute+0x54c>
  _dbg_check_unlock();
 8004636:	f7ff f85b 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800463a:	6823      	ldr	r3, [r4, #0]
 800463c:	42a3      	cmp	r3, r4
 800463e:	d045      	beq.n	80046cc <oslib_test_001_002_execute+0x18c>
 8004640:	69a2      	ldr	r2, [r4, #24]
 8004642:	689b      	ldr	r3, [r3, #8]
 8004644:	6892      	ldr	r2, [r2, #8]
 8004646:	429a      	cmp	r2, r3
 8004648:	d240      	bcs.n	80046cc <oslib_test_001_002_execute+0x18c>
  __ASM volatile ("cpsid i" : : : "memory");
 800464a:	b672      	cpsid	i
 800464c:	4b1e      	ldr	r3, [pc, #120]	; (80046c8 <oslib_test_001_002_execute+0x188>)
 800464e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004650:	e7fe      	b.n	8004650 <oslib_test_001_002_execute+0x110>
  _dbg_check_unlock();
 8004652:	f7ff f84d 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004656:	4b19      	ldr	r3, [pc, #100]	; (80046bc <oslib_test_001_002_execute+0x17c>)
 8004658:	681a      	ldr	r2, [r3, #0]
 800465a:	429a      	cmp	r2, r3
 800465c:	d012      	beq.n	8004684 <oslib_test_001_002_execute+0x144>
 800465e:	6999      	ldr	r1, [r3, #24]
 8004660:	6892      	ldr	r2, [r2, #8]
 8004662:	6889      	ldr	r1, [r1, #8]
 8004664:	4291      	cmp	r1, r2
 8004666:	d20d      	bcs.n	8004684 <oslib_test_001_002_execute+0x144>
 8004668:	b672      	cpsid	i
 800466a:	4a17      	ldr	r2, [pc, #92]	; (80046c8 <oslib_test_001_002_execute+0x188>)
 800466c:	62da      	str	r2, [r3, #44]	; 0x2c
 800466e:	e7fe      	b.n	800466e <oslib_test_001_002_execute+0x12e>
  _dbg_check_unlock();
 8004670:	f7ff f83e 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004674:	6823      	ldr	r3, [r4, #0]
 8004676:	42a3      	cmp	r3, r4
 8004678:	d004      	beq.n	8004684 <oslib_test_001_002_execute+0x144>
 800467a:	69a2      	ldr	r2, [r4, #24]
 800467c:	689b      	ldr	r3, [r3, #8]
 800467e:	6892      	ldr	r2, [r2, #8]
 8004680:	429a      	cmp	r2, r3
 8004682:	d311      	bcc.n	80046a8 <oslib_test_001_002_execute+0x168>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004684:	2300      	movs	r3, #0
 8004686:	f383 8811 	msr	BASEPRI, r3
}
 800468a:	b002      	add	sp, #8
 800468c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8004690:	b672      	cpsid	i
 8004692:	4b0d      	ldr	r3, [pc, #52]	; (80046c8 <oslib_test_001_002_execute+0x188>)
 8004694:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004696:	e7fe      	b.n	8004696 <oslib_test_001_002_execute+0x156>
 8004698:	b672      	cpsid	i
 800469a:	4b0b      	ldr	r3, [pc, #44]	; (80046c8 <oslib_test_001_002_execute+0x188>)
 800469c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800469e:	e7fe      	b.n	800469e <oslib_test_001_002_execute+0x15e>
 80046a0:	b672      	cpsid	i
 80046a2:	4b09      	ldr	r3, [pc, #36]	; (80046c8 <oslib_test_001_002_execute+0x188>)
 80046a4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80046a6:	e7fe      	b.n	80046a6 <oslib_test_001_002_execute+0x166>
 80046a8:	b672      	cpsid	i
 80046aa:	4b07      	ldr	r3, [pc, #28]	; (80046c8 <oslib_test_001_002_execute+0x188>)
 80046ac:	62e3      	str	r3, [r4, #44]	; 0x2c
 80046ae:	e7fe      	b.n	80046ae <oslib_test_001_002_execute+0x16e>
 80046b0:	20001b3c 	.word	0x20001b3c
 80046b4:	20000c58 	.word	0x20000c58
 80046b8:	0800c578 	.word	0x0800c578
 80046bc:	200011a0 	.word	0x200011a0
 80046c0:	0800c584 	.word	0x0800c584
 80046c4:	0800c590 	.word	0x0800c590
 80046c8:	0800bcc8 	.word	0x0800bcc8
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80046cc:	2300      	movs	r3, #0
 80046ce:	f383 8811 	msr	BASEPRI, r3
 80046d2:	2320      	movs	r3, #32
 80046d4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80046d8:	f7ff f872 	bl	80037c0 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80046dc:	6828      	ldr	r0, [r5, #0]
 80046de:	68ab      	ldr	r3, [r5, #8]
 80046e0:	49c1      	ldr	r1, [pc, #772]	; (80049e8 <oslib_test_001_002_execute+0x4a8>)
 80046e2:	eba0 0803 	sub.w	r8, r0, r3
 80046e6:	f1d8 0000 	rsbs	r0, r8, #0
 80046ea:	eb40 0008 	adc.w	r0, r0, r8
 80046ee:	f7fc f917 	bl	8000920 <_test_assert>
 80046f2:	2800      	cmp	r0, #0
 80046f4:	f040 81b6 	bne.w	8004a64 <oslib_test_001_002_execute+0x524>
  _dbg_check_unlock();
 80046f8:	f7fe fffa 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80046fc:	6823      	ldr	r3, [r4, #0]
 80046fe:	42a3      	cmp	r3, r4
 8004700:	d005      	beq.n	800470e <oslib_test_001_002_execute+0x1ce>
 8004702:	69a2      	ldr	r2, [r4, #24]
 8004704:	689b      	ldr	r3, [r3, #8]
 8004706:	6892      	ldr	r2, [r2, #8]
 8004708:	429a      	cmp	r2, r3
 800470a:	f0c0 81bb 	bcc.w	8004a84 <oslib_test_001_002_execute+0x544>
 800470e:	2300      	movs	r3, #0
 8004710:	f383 8811 	msr	BASEPRI, r3
 8004714:	2320      	movs	r3, #32
 8004716:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800471a:	f7ff f851 	bl	80037c0 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800471e:	6828      	ldr	r0, [r5, #0]
 8004720:	68eb      	ldr	r3, [r5, #12]
 8004722:	49b2      	ldr	r1, [pc, #712]	; (80049ec <oslib_test_001_002_execute+0x4ac>)
 8004724:	eba0 0e03 	sub.w	lr, r0, r3
 8004728:	f1de 0000 	rsbs	r0, lr, #0
 800472c:	eb40 000e 	adc.w	r0, r0, lr
 8004730:	f7fc f8f6 	bl	8000920 <_test_assert>
 8004734:	2800      	cmp	r0, #0
 8004736:	f040 81b9 	bne.w	8004aac <oslib_test_001_002_execute+0x56c>
  _dbg_check_unlock();
 800473a:	f7fe ffd9 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800473e:	6823      	ldr	r3, [r4, #0]
 8004740:	42a3      	cmp	r3, r4
 8004742:	d005      	beq.n	8004750 <oslib_test_001_002_execute+0x210>
 8004744:	69a2      	ldr	r2, [r4, #24]
 8004746:	689b      	ldr	r3, [r3, #8]
 8004748:	6892      	ldr	r2, [r2, #8]
 800474a:	429a      	cmp	r2, r3
 800474c:	f0c0 81be 	bcc.w	8004acc <oslib_test_001_002_execute+0x58c>
 8004750:	2300      	movs	r3, #0
 8004752:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 8004756:	2203      	movs	r2, #3
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004758:	f8df 9294 	ldr.w	r9, [pc, #660]	; 80049f0 <oslib_test_001_002_execute+0x4b0>
  mbp->reset = false;
 800475c:	752b      	strb	r3, [r5, #20]
 800475e:	4698      	mov	r8, r3
  test_set_step(3);
 8004760:	6032      	str	r2, [r6, #0]
 8004762:	2742      	movs	r7, #66	; 0x42
 8004764:	f04f 0a20 	mov.w	sl, #32
 8004768:	f38a 8811 	msr	BASEPRI, sl
  _dbg_check_lock();
 800476c:	f7ff f828 	bl	80037c0 <_dbg_check_lock>
      msg1 = chMBPostI(&mb1, 'B' + i);
 8004770:	4638      	mov	r0, r7
 8004772:	f7fd fb25 	bl	8001dc0 <chMBPostI.constprop.25>
  _dbg_check_unlock();
 8004776:	f7fe ffbb 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800477a:	6823      	ldr	r3, [r4, #0]
 800477c:	42a3      	cmp	r3, r4
 800477e:	d005      	beq.n	800478c <oslib_test_001_002_execute+0x24c>
 8004780:	69a2      	ldr	r2, [r4, #24]
 8004782:	689b      	ldr	r3, [r3, #8]
 8004784:	6892      	ldr	r2, [r2, #8]
 8004786:	429a      	cmp	r2, r3
 8004788:	f0c0 8122 	bcc.w	80049d0 <oslib_test_001_002_execute+0x490>
 800478c:	f388 8811 	msr	BASEPRI, r8
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004790:	fab0 f080 	clz	r0, r0
 8004794:	0940      	lsrs	r0, r0, #5
 8004796:	4649      	mov	r1, r9
 8004798:	f7fc f8c2 	bl	8000920 <_test_assert>
 800479c:	3701      	adds	r7, #1
 800479e:	2800      	cmp	r0, #0
 80047a0:	f47f af73 	bne.w	800468a <oslib_test_001_002_execute+0x14a>
    for (i = 0; i < MB_SIZE - 1; i++) {
 80047a4:	2f45      	cmp	r7, #69	; 0x45
 80047a6:	d1df      	bne.n	8004768 <oslib_test_001_002_execute+0x228>
 80047a8:	2320      	movs	r3, #32
 80047aa:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80047ae:	f7ff f807 	bl	80037c0 <_dbg_check_lock>
    msg1 = chMBPostAheadI(&mb1, 'A');
 80047b2:	2041      	movs	r0, #65	; 0x41
 80047b4:	f7fd fb34 	bl	8001e20 <chMBPostAheadI.constprop.22>
  _dbg_check_unlock();
 80047b8:	f7fe ff9a 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80047bc:	6823      	ldr	r3, [r4, #0]
 80047be:	42a3      	cmp	r3, r4
 80047c0:	d005      	beq.n	80047ce <oslib_test_001_002_execute+0x28e>
 80047c2:	69a2      	ldr	r2, [r4, #24]
 80047c4:	689b      	ldr	r3, [r3, #8]
 80047c6:	6892      	ldr	r2, [r2, #8]
 80047c8:	429a      	cmp	r2, r3
 80047ca:	f0c0 8183 	bcc.w	8004ad4 <oslib_test_001_002_execute+0x594>
 80047ce:	2300      	movs	r3, #0
 80047d0:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80047d4:	fab0 f080 	clz	r0, r0
 80047d8:	0940      	lsrs	r0, r0, #5
 80047da:	4985      	ldr	r1, [pc, #532]	; (80049f0 <oslib_test_001_002_execute+0x4b0>)
 80047dc:	f7fc f8a0 	bl	8000920 <_test_assert>
 80047e0:	2800      	cmp	r0, #0
 80047e2:	f47f af52 	bne.w	800468a <oslib_test_001_002_execute+0x14a>
  test_set_step(4);
 80047e6:	2304      	movs	r3, #4
 80047e8:	6033      	str	r3, [r6, #0]
 80047ea:	2320      	movs	r3, #32
 80047ec:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80047f0:	f7fe ffe6 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 80047f4:	f7fc f9f4 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 80047f8:	f7fc f9f2 	bl	8000be0 <chDbgCheckClassI>
  return (size_t)(mbp->top - mbp->buffer);
 80047fc:	e9d5 1300 	ldrd	r1, r3, [r5]
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8004800:	692a      	ldr	r2, [r5, #16]
 8004802:	1a5b      	subs	r3, r3, r1
 8004804:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8004808:	bf0c      	ite	eq
 800480a:	2001      	moveq	r0, #1
 800480c:	2000      	movne	r0, #0
 800480e:	4979      	ldr	r1, [pc, #484]	; (80049f4 <oslib_test_001_002_execute+0x4b4>)
 8004810:	f7fc f886 	bl	8000920 <_test_assert>
 8004814:	2800      	cmp	r0, #0
 8004816:	f040 80fd 	bne.w	8004a14 <oslib_test_001_002_execute+0x4d4>
  _dbg_check_unlock();
 800481a:	f7fe ff69 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800481e:	6823      	ldr	r3, [r4, #0]
 8004820:	42a3      	cmp	r3, r4
 8004822:	d005      	beq.n	8004830 <oslib_test_001_002_execute+0x2f0>
 8004824:	69a2      	ldr	r2, [r4, #24]
 8004826:	689b      	ldr	r3, [r3, #8]
 8004828:	6892      	ldr	r2, [r2, #8]
 800482a:	429a      	cmp	r2, r3
 800482c:	f0c0 8156 	bcc.w	8004adc <oslib_test_001_002_execute+0x59c>
 8004830:	2300      	movs	r3, #0
 8004832:	f383 8811 	msr	BASEPRI, r3
 8004836:	2320      	movs	r3, #32
 8004838:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800483c:	f7fe ffc0 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004840:	f7fc f9ce 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8004844:	6928      	ldr	r0, [r5, #16]
 8004846:	496c      	ldr	r1, [pc, #432]	; (80049f8 <oslib_test_001_002_execute+0x4b8>)
 8004848:	f1a0 0c04 	sub.w	ip, r0, #4
 800484c:	f1dc 0000 	rsbs	r0, ip, #0
 8004850:	eb40 000c 	adc.w	r0, r0, ip
 8004854:	f7fc f864 	bl	8000920 <_test_assert>
 8004858:	2800      	cmp	r0, #0
 800485a:	f040 80ef 	bne.w	8004a3c <oslib_test_001_002_execute+0x4fc>
  _dbg_check_unlock();
 800485e:	f7fe ff47 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004862:	6823      	ldr	r3, [r4, #0]
 8004864:	42a3      	cmp	r3, r4
 8004866:	d005      	beq.n	8004874 <oslib_test_001_002_execute+0x334>
 8004868:	69a2      	ldr	r2, [r4, #24]
 800486a:	689b      	ldr	r3, [r3, #8]
 800486c:	6892      	ldr	r2, [r2, #8]
 800486e:	429a      	cmp	r2, r3
 8004870:	f0c0 80e0 	bcc.w	8004a34 <oslib_test_001_002_execute+0x4f4>
 8004874:	2300      	movs	r3, #0
 8004876:	f383 8811 	msr	BASEPRI, r3
 800487a:	2320      	movs	r3, #32
 800487c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004880:	f7fe ff9e 	bl	80037c0 <_dbg_check_lock>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8004884:	e9d5 3002 	ldrd	r3, r0, [r5, #8]
 8004888:	1ac7      	subs	r7, r0, r3
 800488a:	4278      	negs	r0, r7
 800488c:	4178      	adcs	r0, r7
 800488e:	495b      	ldr	r1, [pc, #364]	; (80049fc <oslib_test_001_002_execute+0x4bc>)
 8004890:	f7fc f846 	bl	8000920 <_test_assert>
 8004894:	2800      	cmp	r0, #0
 8004896:	f040 809f 	bne.w	80049d8 <oslib_test_001_002_execute+0x498>
  _dbg_check_unlock();
 800489a:	f7fe ff29 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800489e:	6823      	ldr	r3, [r4, #0]
 80048a0:	42a3      	cmp	r3, r4
 80048a2:	d005      	beq.n	80048b0 <oslib_test_001_002_execute+0x370>
 80048a4:	69a2      	ldr	r2, [r4, #24]
 80048a6:	689b      	ldr	r3, [r3, #8]
 80048a8:	6892      	ldr	r2, [r2, #8]
 80048aa:	429a      	cmp	r2, r3
 80048ac:	f0c0 80d6 	bcc.w	8004a5c <oslib_test_001_002_execute+0x51c>
 80048b0:	2300      	movs	r3, #0
 80048b2:	f383 8811 	msr	BASEPRI, r3
  test_set_step(5);
 80048b6:	2205      	movs	r2, #5
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80048b8:	f8df 9134 	ldr.w	r9, [pc, #308]	; 80049f0 <oslib_test_001_002_execute+0x4b0>
  test_set_step(5);
 80048bc:	6032      	str	r2, [r6, #0]
 80048be:	4698      	mov	r8, r3
 80048c0:	2704      	movs	r7, #4
 80048c2:	f04f 0a20 	mov.w	sl, #32
 80048c6:	f38a 8811 	msr	BASEPRI, sl
  _dbg_check_lock();
 80048ca:	f7fe ff79 	bl	80037c0 <_dbg_check_lock>
      msg1 = chMBFetchI(&mb1, &msg2);
 80048ce:	a801      	add	r0, sp, #4
 80048d0:	f7fc fa8e 	bl	8000df0 <chMBFetchI.constprop.19>
  _dbg_check_unlock();
 80048d4:	f7fe ff0c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80048d8:	6823      	ldr	r3, [r4, #0]
 80048da:	42a3      	cmp	r3, r4
 80048dc:	d004      	beq.n	80048e8 <oslib_test_001_002_execute+0x3a8>
 80048de:	69a2      	ldr	r2, [r4, #24]
 80048e0:	689b      	ldr	r3, [r3, #8]
 80048e2:	6892      	ldr	r2, [r2, #8]
 80048e4:	429a      	cmp	r2, r3
 80048e6:	d37a      	bcc.n	80049de <oslib_test_001_002_execute+0x49e>
 80048e8:	f388 8811 	msr	BASEPRI, r8
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80048ec:	fab0 f080 	clz	r0, r0
 80048f0:	0940      	lsrs	r0, r0, #5
 80048f2:	4649      	mov	r1, r9
 80048f4:	f7fc f814 	bl	8000920 <_test_assert>
 80048f8:	2800      	cmp	r0, #0
 80048fa:	f47f aec6 	bne.w	800468a <oslib_test_001_002_execute+0x14a>
      test_emit_token(msg2);
 80048fe:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8004902:	f7ff fded 	bl	80044e0 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8004906:	3f01      	subs	r7, #1
 8004908:	d1dd      	bne.n	80048c6 <oslib_test_001_002_execute+0x386>
    test_assert_sequence("ABCD", "wrong get sequence");
 800490a:	493d      	ldr	r1, [pc, #244]	; (8004a00 <oslib_test_001_002_execute+0x4c0>)
 800490c:	483d      	ldr	r0, [pc, #244]	; (8004a04 <oslib_test_001_002_execute+0x4c4>)
 800490e:	f7fc f8a7 	bl	8000a60 <_test_assert_sequence>
 8004912:	2800      	cmp	r0, #0
 8004914:	f47f aeb9 	bne.w	800468a <oslib_test_001_002_execute+0x14a>
  test_set_step(6);
 8004918:	2306      	movs	r3, #6
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 800491a:	f04f 31ff 	mov.w	r1, #4294967295
 800491e:	2046      	movs	r0, #70	; 0x46
  test_set_step(6);
 8004920:	6033      	str	r3, [r6, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8004922:	f7ff f98d 	bl	8003c40 <chMBPostTimeout.constprop.26>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004926:	fab0 f080 	clz	r0, r0
 800492a:	0940      	lsrs	r0, r0, #5
 800492c:	4930      	ldr	r1, [pc, #192]	; (80049f0 <oslib_test_001_002_execute+0x4b0>)
 800492e:	f7fb fff7 	bl	8000920 <_test_assert>
 8004932:	2800      	cmp	r0, #0
 8004934:	f47f aea9 	bne.w	800468a <oslib_test_001_002_execute+0x14a>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8004938:	f04f 31ff 	mov.w	r1, #4294967295
 800493c:	a801      	add	r0, sp, #4
 800493e:	f7ff fa2f 	bl	8003da0 <chMBFetchTimeout.constprop.20>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004942:	fab0 f080 	clz	r0, r0
 8004946:	0940      	lsrs	r0, r0, #5
 8004948:	4929      	ldr	r1, [pc, #164]	; (80049f0 <oslib_test_001_002_execute+0x4b0>)
 800494a:	f7fb ffe9 	bl	8000920 <_test_assert>
 800494e:	2800      	cmp	r0, #0
 8004950:	f47f ae9b 	bne.w	800468a <oslib_test_001_002_execute+0x14a>
  test_set_step(7);
 8004954:	2307      	movs	r3, #7
 8004956:	6033      	str	r3, [r6, #0]
 8004958:	2420      	movs	r4, #32
 800495a:	f384 8811 	msr	BASEPRI, r4
  _dbg_check_lock();
 800495e:	f7fe ff2f 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004962:	f7fc f93d 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8004966:	f7fc f93b 	bl	8000be0 <chDbgCheckClassI>
  return (size_t)(mbp->top - mbp->buffer);
 800496a:	e9d5 0200 	ldrd	r0, r2, [r5]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800496e:	692b      	ldr	r3, [r5, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004970:	4925      	ldr	r1, [pc, #148]	; (8004a08 <oslib_test_001_002_execute+0x4c8>)
  return (size_t)(mbp->top - mbp->buffer);
 8004972:	1a12      	subs	r2, r2, r0
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004974:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8004978:	1f1e      	subs	r6, r3, #4
 800497a:	4270      	negs	r0, r6
 800497c:	4170      	adcs	r0, r6
 800497e:	f7fb ffcf 	bl	8000920 <_test_assert>
 8004982:	bb48      	cbnz	r0, 80049d8 <oslib_test_001_002_execute+0x498>
  chSysUnlock();
 8004984:	f7fe fedc 	bl	8003740 <chSysUnlock.lto_priv.119>
 8004988:	f384 8811 	msr	BASEPRI, r4
 800498c:	f7fe ff18 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004990:	f7fc f926 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8004994:	6928      	ldr	r0, [r5, #16]
 8004996:	491d      	ldr	r1, [pc, #116]	; (8004a0c <oslib_test_001_002_execute+0x4cc>)
 8004998:	fab0 f080 	clz	r0, r0
 800499c:	0940      	lsrs	r0, r0, #5
 800499e:	f7fb ffbf 	bl	8000920 <_test_assert>
 80049a2:	b9c8      	cbnz	r0, 80049d8 <oslib_test_001_002_execute+0x498>
 80049a4:	f7fe fecc 	bl	8003740 <chSysUnlock.lto_priv.119>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80049a8:	6828      	ldr	r0, [r5, #0]
 80049aa:	68ab      	ldr	r3, [r5, #8]
 80049ac:	490e      	ldr	r1, [pc, #56]	; (80049e8 <oslib_test_001_002_execute+0x4a8>)
 80049ae:	1ac2      	subs	r2, r0, r3
 80049b0:	4250      	negs	r0, r2
 80049b2:	4150      	adcs	r0, r2
 80049b4:	f7fb ffb4 	bl	8000920 <_test_assert>
 80049b8:	2800      	cmp	r0, #0
 80049ba:	f47f ae66 	bne.w	800468a <oslib_test_001_002_execute+0x14a>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80049be:	6828      	ldr	r0, [r5, #0]
 80049c0:	68eb      	ldr	r3, [r5, #12]
 80049c2:	490a      	ldr	r1, [pc, #40]	; (80049ec <oslib_test_001_002_execute+0x4ac>)
 80049c4:	1ac3      	subs	r3, r0, r3
 80049c6:	4258      	negs	r0, r3
 80049c8:	4158      	adcs	r0, r3
 80049ca:	f7fb ffa9 	bl	8000920 <_test_assert>
 80049ce:	e65c      	b.n	800468a <oslib_test_001_002_execute+0x14a>
  __ASM volatile ("cpsid i" : : : "memory");
 80049d0:	b672      	cpsid	i
 80049d2:	4b0f      	ldr	r3, [pc, #60]	; (8004a10 <oslib_test_001_002_execute+0x4d0>)
 80049d4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80049d6:	e7fe      	b.n	80049d6 <oslib_test_001_002_execute+0x496>
 80049d8:	f7fe feb2 	bl	8003740 <chSysUnlock.lto_priv.119>
 80049dc:	e655      	b.n	800468a <oslib_test_001_002_execute+0x14a>
 80049de:	b672      	cpsid	i
 80049e0:	4b0b      	ldr	r3, [pc, #44]	; (8004a10 <oslib_test_001_002_execute+0x4d0>)
 80049e2:	62e3      	str	r3, [r4, #44]	; 0x2c
 80049e4:	e7fe      	b.n	80049e4 <oslib_test_001_002_execute+0x4a4>
 80049e6:	bf00      	nop
 80049e8:	0800c59c 	.word	0x0800c59c
 80049ec:	0800c5c0 	.word	0x0800c5c0
 80049f0:	0800c640 	.word	0x0800c640
 80049f4:	0800c5e4 	.word	0x0800c5e4
 80049f8:	0800c5f0 	.word	0x0800c5f0
 80049fc:	0800c5fc 	.word	0x0800c5fc
 8004a00:	0800c614 	.word	0x0800c614
 8004a04:	0800c628 	.word	0x0800c628
 8004a08:	0800c584 	.word	0x0800c584
 8004a0c:	0800c590 	.word	0x0800c590
 8004a10:	0800bcc8 	.word	0x0800bcc8
  _dbg_check_unlock();
 8004a14:	f7fe fe6c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004a18:	6823      	ldr	r3, [r4, #0]
 8004a1a:	42a3      	cmp	r3, r4
 8004a1c:	f43f ae32 	beq.w	8004684 <oslib_test_001_002_execute+0x144>
 8004a20:	69a2      	ldr	r2, [r4, #24]
 8004a22:	689b      	ldr	r3, [r3, #8]
 8004a24:	6892      	ldr	r2, [r2, #8]
 8004a26:	429a      	cmp	r2, r3
 8004a28:	f4bf ae2c 	bcs.w	8004684 <oslib_test_001_002_execute+0x144>
 8004a2c:	b672      	cpsid	i
 8004a2e:	4b2d      	ldr	r3, [pc, #180]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004a30:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004a32:	e7fe      	b.n	8004a32 <oslib_test_001_002_execute+0x4f2>
 8004a34:	b672      	cpsid	i
 8004a36:	4b2b      	ldr	r3, [pc, #172]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004a38:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004a3a:	e7fe      	b.n	8004a3a <oslib_test_001_002_execute+0x4fa>
  _dbg_check_unlock();
 8004a3c:	f7fe fe58 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004a40:	6823      	ldr	r3, [r4, #0]
 8004a42:	42a3      	cmp	r3, r4
 8004a44:	f43f ae1e 	beq.w	8004684 <oslib_test_001_002_execute+0x144>
 8004a48:	69a2      	ldr	r2, [r4, #24]
 8004a4a:	689b      	ldr	r3, [r3, #8]
 8004a4c:	6892      	ldr	r2, [r2, #8]
 8004a4e:	429a      	cmp	r2, r3
 8004a50:	f4bf ae18 	bcs.w	8004684 <oslib_test_001_002_execute+0x144>
 8004a54:	b672      	cpsid	i
 8004a56:	4b23      	ldr	r3, [pc, #140]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004a58:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004a5a:	e7fe      	b.n	8004a5a <oslib_test_001_002_execute+0x51a>
 8004a5c:	b672      	cpsid	i
 8004a5e:	4b21      	ldr	r3, [pc, #132]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004a60:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004a62:	e7fe      	b.n	8004a62 <oslib_test_001_002_execute+0x522>
  _dbg_check_unlock();
 8004a64:	f7fe fe44 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004a68:	6823      	ldr	r3, [r4, #0]
 8004a6a:	42a3      	cmp	r3, r4
 8004a6c:	f43f ae0a 	beq.w	8004684 <oslib_test_001_002_execute+0x144>
 8004a70:	69a2      	ldr	r2, [r4, #24]
 8004a72:	689b      	ldr	r3, [r3, #8]
 8004a74:	6892      	ldr	r2, [r2, #8]
 8004a76:	429a      	cmp	r2, r3
 8004a78:	f4bf ae04 	bcs.w	8004684 <oslib_test_001_002_execute+0x144>
 8004a7c:	b672      	cpsid	i
 8004a7e:	4b19      	ldr	r3, [pc, #100]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004a80:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004a82:	e7fe      	b.n	8004a82 <oslib_test_001_002_execute+0x542>
 8004a84:	b672      	cpsid	i
 8004a86:	4b17      	ldr	r3, [pc, #92]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004a88:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004a8a:	e7fe      	b.n	8004a8a <oslib_test_001_002_execute+0x54a>
  _dbg_check_unlock();
 8004a8c:	f7fe fe30 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004a90:	6823      	ldr	r3, [r4, #0]
 8004a92:	42a3      	cmp	r3, r4
 8004a94:	f43f adf6 	beq.w	8004684 <oslib_test_001_002_execute+0x144>
 8004a98:	69a2      	ldr	r2, [r4, #24]
 8004a9a:	689b      	ldr	r3, [r3, #8]
 8004a9c:	6892      	ldr	r2, [r2, #8]
 8004a9e:	429a      	cmp	r2, r3
 8004aa0:	f4bf adf0 	bcs.w	8004684 <oslib_test_001_002_execute+0x144>
 8004aa4:	b672      	cpsid	i
 8004aa6:	4b0f      	ldr	r3, [pc, #60]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004aa8:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004aaa:	e7fe      	b.n	8004aaa <oslib_test_001_002_execute+0x56a>
  _dbg_check_unlock();
 8004aac:	f7fe fe20 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004ab0:	6823      	ldr	r3, [r4, #0]
 8004ab2:	42a3      	cmp	r3, r4
 8004ab4:	f43f ade6 	beq.w	8004684 <oslib_test_001_002_execute+0x144>
 8004ab8:	69a2      	ldr	r2, [r4, #24]
 8004aba:	689b      	ldr	r3, [r3, #8]
 8004abc:	6892      	ldr	r2, [r2, #8]
 8004abe:	429a      	cmp	r2, r3
 8004ac0:	f4bf ade0 	bcs.w	8004684 <oslib_test_001_002_execute+0x144>
 8004ac4:	b672      	cpsid	i
 8004ac6:	4b07      	ldr	r3, [pc, #28]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004ac8:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004aca:	e7fe      	b.n	8004aca <oslib_test_001_002_execute+0x58a>
 8004acc:	b672      	cpsid	i
 8004ace:	4b05      	ldr	r3, [pc, #20]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004ad0:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004ad2:	e7fe      	b.n	8004ad2 <oslib_test_001_002_execute+0x592>
 8004ad4:	b672      	cpsid	i
 8004ad6:	4b03      	ldr	r3, [pc, #12]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004ad8:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004ada:	e7fe      	b.n	8004ada <oslib_test_001_002_execute+0x59a>
 8004adc:	b672      	cpsid	i
 8004ade:	4b01      	ldr	r3, [pc, #4]	; (8004ae4 <oslib_test_001_002_execute+0x5a4>)
 8004ae0:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004ae2:	e7fe      	b.n	8004ae2 <oslib_test_001_002_execute+0x5a2>
 8004ae4:	0800bcc8 	.word	0x0800bcc8
	...

08004af0 <oslib_test_001_001_execute>:
static void oslib_test_001_001_execute(void) {
 8004af0:	b5f0      	push	{r4, r5, r6, r7, lr}
  test_set_step(1);
 8004af2:	4ec4      	ldr	r6, [pc, #784]	; (8004e04 <oslib_test_001_001_execute+0x314>)
 8004af4:	2301      	movs	r3, #1
static void oslib_test_001_001_execute(void) {
 8004af6:	b083      	sub	sp, #12
  test_set_step(1);
 8004af8:	6033      	str	r3, [r6, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004afa:	2320      	movs	r3, #32
 8004afc:	f383 8811 	msr	BASEPRI, r3
  return (size_t)(mbp->top - mbp->buffer);
 8004b00:	4dc1      	ldr	r5, [pc, #772]	; (8004e08 <oslib_test_001_001_execute+0x318>)
  _dbg_check_lock();
 8004b02:	f7fe fe5d 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004b06:	f7fc f86b 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8004b0a:	f7fc f869 	bl	8000be0 <chDbgCheckClassI>
  return (size_t)(mbp->top - mbp->buffer);
 8004b0e:	e9d5 0200 	ldrd	r0, r2, [r5]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004b12:	692b      	ldr	r3, [r5, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8004b14:	49bd      	ldr	r1, [pc, #756]	; (8004e0c <oslib_test_001_001_execute+0x31c>)
  return (size_t)(mbp->top - mbp->buffer);
 8004b16:	1a12      	subs	r2, r2, r0
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004b18:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8004b1c:	f1a3 0004 	sub.w	r0, r3, #4
 8004b20:	fab0 f080 	clz	r0, r0
 8004b24:	0940      	lsrs	r0, r0, #5
 8004b26:	f7fb fefb 	bl	8000920 <_test_assert>
 8004b2a:	2800      	cmp	r0, #0
 8004b2c:	f040 81c7 	bne.w	8004ebe <oslib_test_001_001_execute+0x3ce>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004b30:	4cb7      	ldr	r4, [pc, #732]	; (8004e10 <oslib_test_001_001_execute+0x320>)
  _dbg_check_unlock();
 8004b32:	f7fe fddd 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004b36:	6823      	ldr	r3, [r4, #0]
 8004b38:	42a3      	cmp	r3, r4
 8004b3a:	d005      	beq.n	8004b48 <oslib_test_001_001_execute+0x58>
 8004b3c:	69a2      	ldr	r2, [r4, #24]
 8004b3e:	689b      	ldr	r3, [r3, #8]
 8004b40:	6892      	ldr	r2, [r2, #8]
 8004b42:	429a      	cmp	r2, r3
 8004b44:	f0c0 81d9 	bcc.w	8004efa <oslib_test_001_001_execute+0x40a>
 8004b48:	2300      	movs	r3, #0
 8004b4a:	f383 8811 	msr	BASEPRI, r3
  test_set_step(2);
 8004b4e:	2302      	movs	r3, #2
 8004b50:	6033      	str	r3, [r6, #0]
    chMBReset(&mb1);
 8004b52:	f7ff f835 	bl	8003bc0 <chMBReset.constprop.28>
 8004b56:	2320      	movs	r3, #32
 8004b58:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004b5c:	f7fe fe30 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004b60:	f7fc f83e 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8004b64:	f7fc f83c 	bl	8000be0 <chDbgCheckClassI>
  return (size_t)(mbp->top - mbp->buffer);
 8004b68:	e9d5 1200 	ldrd	r1, r2, [r5]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004b6c:	692b      	ldr	r3, [r5, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8004b6e:	1a52      	subs	r2, r2, r1
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004b70:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004b74:	f1a3 0004 	sub.w	r0, r3, #4
 8004b78:	fab0 f080 	clz	r0, r0
 8004b7c:	0940      	lsrs	r0, r0, #5
 8004b7e:	49a5      	ldr	r1, [pc, #660]	; (8004e14 <oslib_test_001_001_execute+0x324>)
 8004b80:	f7fb fece 	bl	8000920 <_test_assert>
 8004b84:	2800      	cmp	r0, #0
 8004b86:	f040 81a9 	bne.w	8004edc <oslib_test_001_001_execute+0x3ec>
  _dbg_check_unlock();
 8004b8a:	f7fe fdb1 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004b8e:	6823      	ldr	r3, [r4, #0]
 8004b90:	42a3      	cmp	r3, r4
 8004b92:	d005      	beq.n	8004ba0 <oslib_test_001_001_execute+0xb0>
 8004b94:	69a2      	ldr	r2, [r4, #24]
 8004b96:	689b      	ldr	r3, [r3, #8]
 8004b98:	6892      	ldr	r2, [r2, #8]
 8004b9a:	429a      	cmp	r2, r3
 8004b9c:	f0c0 81b1 	bcc.w	8004f02 <oslib_test_001_001_execute+0x412>
 8004ba0:	2300      	movs	r3, #0
 8004ba2:	f383 8811 	msr	BASEPRI, r3
 8004ba6:	2320      	movs	r3, #32
 8004ba8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004bac:	f7fe fe08 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004bb0:	f7fc f816 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8004bb4:	6928      	ldr	r0, [r5, #16]
 8004bb6:	4998      	ldr	r1, [pc, #608]	; (8004e18 <oslib_test_001_001_execute+0x328>)
 8004bb8:	fab0 f080 	clz	r0, r0
 8004bbc:	0940      	lsrs	r0, r0, #5
 8004bbe:	f7fb feaf 	bl	8000920 <_test_assert>
 8004bc2:	2800      	cmp	r0, #0
 8004bc4:	f040 81b7 	bne.w	8004f36 <oslib_test_001_001_execute+0x446>
  _dbg_check_unlock();
 8004bc8:	f7fe fd92 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004bcc:	6823      	ldr	r3, [r4, #0]
 8004bce:	42a3      	cmp	r3, r4
 8004bd0:	d005      	beq.n	8004bde <oslib_test_001_001_execute+0xee>
 8004bd2:	69a2      	ldr	r2, [r4, #24]
 8004bd4:	689b      	ldr	r3, [r3, #8]
 8004bd6:	6892      	ldr	r2, [r2, #8]
 8004bd8:	429a      	cmp	r2, r3
 8004bda:	f0c0 819a 	bcc.w	8004f12 <oslib_test_001_001_execute+0x422>
 8004bde:	2300      	movs	r3, #0
 8004be0:	f383 8811 	msr	BASEPRI, r3
 8004be4:	2320      	movs	r3, #32
 8004be6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004bea:	f7fe fde9 	bl	80037c0 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8004bee:	6828      	ldr	r0, [r5, #0]
 8004bf0:	68ab      	ldr	r3, [r5, #8]
 8004bf2:	498a      	ldr	r1, [pc, #552]	; (8004e1c <oslib_test_001_001_execute+0x32c>)
 8004bf4:	eba0 0c03 	sub.w	ip, r0, r3
 8004bf8:	f1dc 0000 	rsbs	r0, ip, #0
 8004bfc:	eb40 000c 	adc.w	r0, r0, ip
 8004c00:	f7fb fe8e 	bl	8000920 <_test_assert>
 8004c04:	2800      	cmp	r0, #0
 8004c06:	f040 81a8 	bne.w	8004f5a <oslib_test_001_001_execute+0x46a>
  _dbg_check_unlock();
 8004c0a:	f7fe fd71 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004c0e:	6823      	ldr	r3, [r4, #0]
 8004c10:	42a3      	cmp	r3, r4
 8004c12:	d005      	beq.n	8004c20 <oslib_test_001_001_execute+0x130>
 8004c14:	69a2      	ldr	r2, [r4, #24]
 8004c16:	689b      	ldr	r3, [r3, #8]
 8004c18:	6892      	ldr	r2, [r2, #8]
 8004c1a:	429a      	cmp	r2, r3
 8004c1c:	f0c0 8199 	bcc.w	8004f52 <oslib_test_001_001_execute+0x462>
 8004c20:	2300      	movs	r3, #0
 8004c22:	f383 8811 	msr	BASEPRI, r3
 8004c26:	2320      	movs	r3, #32
 8004c28:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004c2c:	f7fe fdc8 	bl	80037c0 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8004c30:	6828      	ldr	r0, [r5, #0]
 8004c32:	68eb      	ldr	r3, [r5, #12]
 8004c34:	497a      	ldr	r1, [pc, #488]	; (8004e20 <oslib_test_001_001_execute+0x330>)
 8004c36:	1ac7      	subs	r7, r0, r3
 8004c38:	4278      	negs	r0, r7
 8004c3a:	4178      	adcs	r0, r7
 8004c3c:	f7fb fe70 	bl	8000920 <_test_assert>
 8004c40:	2800      	cmp	r0, #0
 8004c42:	f040 816a 	bne.w	8004f1a <oslib_test_001_001_execute+0x42a>
  _dbg_check_unlock();
 8004c46:	f7fe fd53 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004c4a:	6823      	ldr	r3, [r4, #0]
 8004c4c:	42a3      	cmp	r3, r4
 8004c4e:	d005      	beq.n	8004c5c <oslib_test_001_001_execute+0x16c>
 8004c50:	69a2      	ldr	r2, [r4, #24]
 8004c52:	689b      	ldr	r3, [r3, #8]
 8004c54:	6892      	ldr	r2, [r2, #8]
 8004c56:	429a      	cmp	r2, r3
 8004c58:	f0c0 818d 	bcc.w	8004f76 <oslib_test_001_001_execute+0x486>
 8004c5c:	2000      	movs	r0, #0
 8004c5e:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 8004c62:	2303      	movs	r3, #3
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 8004c64:	f04f 31ff 	mov.w	r1, #4294967295
  test_set_step(3);
 8004c68:	6033      	str	r3, [r6, #0]
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 8004c6a:	f7fe ffe9 	bl	8003c40 <chMBPostTimeout.constprop.26>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8004c6e:	1c84      	adds	r4, r0, #2
 8004c70:	bf14      	ite	ne
 8004c72:	2000      	movne	r0, #0
 8004c74:	2001      	moveq	r0, #1
 8004c76:	496b      	ldr	r1, [pc, #428]	; (8004e24 <oslib_test_001_001_execute+0x334>)
 8004c78:	f7fb fe52 	bl	8000920 <_test_assert>
 8004c7c:	2800      	cmp	r0, #0
 8004c7e:	f040 813a 	bne.w	8004ef6 <oslib_test_001_001_execute+0x406>
    msg1 = chMBPostAheadTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 8004c82:	f04f 31ff 	mov.w	r1, #4294967295
 8004c86:	f7ff f833 	bl	8003cf0 <chMBPostAheadTimeout.constprop.23>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8004c8a:	1c82      	adds	r2, r0, #2
 8004c8c:	bf14      	ite	ne
 8004c8e:	2000      	movne	r0, #0
 8004c90:	2001      	moveq	r0, #1
 8004c92:	4964      	ldr	r1, [pc, #400]	; (8004e24 <oslib_test_001_001_execute+0x334>)
 8004c94:	f7fb fe44 	bl	8000920 <_test_assert>
 8004c98:	2800      	cmp	r0, #0
 8004c9a:	f040 812c 	bne.w	8004ef6 <oslib_test_001_001_execute+0x406>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8004c9e:	f04f 31ff 	mov.w	r1, #4294967295
 8004ca2:	a801      	add	r0, sp, #4
 8004ca4:	f7ff f87c 	bl	8003da0 <chMBFetchTimeout.constprop.20>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8004ca8:	1c83      	adds	r3, r0, #2
 8004caa:	bf14      	ite	ne
 8004cac:	2000      	movne	r0, #0
 8004cae:	2001      	moveq	r0, #1
 8004cb0:	495c      	ldr	r1, [pc, #368]	; (8004e24 <oslib_test_001_001_execute+0x334>)
 8004cb2:	f7fb fe35 	bl	8000920 <_test_assert>
 8004cb6:	2800      	cmp	r0, #0
 8004cb8:	f040 811d 	bne.w	8004ef6 <oslib_test_001_001_execute+0x406>
  test_set_step(4);
 8004cbc:	2304      	movs	r3, #4
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004cbe:	4f5a      	ldr	r7, [pc, #360]	; (8004e28 <oslib_test_001_001_execute+0x338>)
  mbp->reset = false;
 8004cc0:	7528      	strb	r0, [r5, #20]
  test_set_step(4);
 8004cc2:	6033      	str	r3, [r6, #0]
 8004cc4:	2442      	movs	r4, #66	; 0x42
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8004cc6:	f04f 31ff 	mov.w	r1, #4294967295
 8004cca:	4620      	mov	r0, r4
 8004ccc:	f7fe ffb8 	bl	8003c40 <chMBPostTimeout.constprop.26>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004cd0:	fab0 f080 	clz	r0, r0
 8004cd4:	4639      	mov	r1, r7
 8004cd6:	0940      	lsrs	r0, r0, #5
 8004cd8:	f7fb fe22 	bl	8000920 <_test_assert>
 8004cdc:	3401      	adds	r4, #1
 8004cde:	2800      	cmp	r0, #0
 8004ce0:	f040 8109 	bne.w	8004ef6 <oslib_test_001_001_execute+0x406>
    for (i = 0; i < MB_SIZE - 1; i++) {
 8004ce4:	2c45      	cmp	r4, #69	; 0x45
 8004ce6:	d1ee      	bne.n	8004cc6 <oslib_test_001_001_execute+0x1d6>
    msg1 = chMBPostAheadTimeout(&mb1, 'A', TIME_INFINITE);
 8004ce8:	f04f 31ff 	mov.w	r1, #4294967295
 8004cec:	2041      	movs	r0, #65	; 0x41
 8004cee:	f7fe ffff 	bl	8003cf0 <chMBPostAheadTimeout.constprop.23>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004cf2:	fab0 f080 	clz	r0, r0
 8004cf6:	0940      	lsrs	r0, r0, #5
 8004cf8:	494b      	ldr	r1, [pc, #300]	; (8004e28 <oslib_test_001_001_execute+0x338>)
 8004cfa:	f7fb fe11 	bl	8000920 <_test_assert>
 8004cfe:	2800      	cmp	r0, #0
 8004d00:	f040 80f9 	bne.w	8004ef6 <oslib_test_001_001_execute+0x406>
  test_set_step(5);
 8004d04:	2305      	movs	r3, #5
 8004d06:	6033      	str	r3, [r6, #0]
 8004d08:	2420      	movs	r4, #32
 8004d0a:	f384 8811 	msr	BASEPRI, r4
  _dbg_check_lock();
 8004d0e:	f7fe fd57 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004d12:	f7fb ff65 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8004d16:	f7fb ff63 	bl	8000be0 <chDbgCheckClassI>
  return (size_t)(mbp->top - mbp->buffer);
 8004d1a:	e9d5 1300 	ldrd	r1, r3, [r5]
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8004d1e:	692a      	ldr	r2, [r5, #16]
 8004d20:	1a5b      	subs	r3, r3, r1
 8004d22:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8004d26:	bf0c      	ite	eq
 8004d28:	2001      	moveq	r0, #1
 8004d2a:	2000      	movne	r0, #0
 8004d2c:	493f      	ldr	r1, [pc, #252]	; (8004e2c <oslib_test_001_001_execute+0x33c>)
 8004d2e:	f7fb fdf7 	bl	8000920 <_test_assert>
 8004d32:	2800      	cmp	r0, #0
 8004d34:	f040 8123 	bne.w	8004f7e <oslib_test_001_001_execute+0x48e>
 8004d38:	f7fe fd02 	bl	8003740 <chSysUnlock.lto_priv.119>
 8004d3c:	f384 8811 	msr	BASEPRI, r4
 8004d40:	f7fe fd3e 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004d44:	f7fb ff4c 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8004d48:	6928      	ldr	r0, [r5, #16]
 8004d4a:	4939      	ldr	r1, [pc, #228]	; (8004e30 <oslib_test_001_001_execute+0x340>)
 8004d4c:	f1a0 0c04 	sub.w	ip, r0, #4
 8004d50:	f1dc 0000 	rsbs	r0, ip, #0
 8004d54:	eb40 000c 	adc.w	r0, r0, ip
 8004d58:	f7fb fde2 	bl	8000920 <_test_assert>
 8004d5c:	2800      	cmp	r0, #0
 8004d5e:	f040 810e 	bne.w	8004f7e <oslib_test_001_001_execute+0x48e>
 8004d62:	f7fe fced 	bl	8003740 <chSysUnlock.lto_priv.119>
 8004d66:	f384 8811 	msr	BASEPRI, r4
 8004d6a:	f7fe fd29 	bl	80037c0 <_dbg_check_lock>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8004d6e:	e9d5 3002 	ldrd	r3, r0, [r5, #8]
 8004d72:	1ac7      	subs	r7, r0, r3
 8004d74:	4278      	negs	r0, r7
 8004d76:	4178      	adcs	r0, r7
 8004d78:	492e      	ldr	r1, [pc, #184]	; (8004e34 <oslib_test_001_001_execute+0x344>)
 8004d7a:	f7fb fdd1 	bl	8000920 <_test_assert>
 8004d7e:	2800      	cmp	r0, #0
 8004d80:	f040 80fd 	bne.w	8004f7e <oslib_test_001_001_execute+0x48e>
 8004d84:	f7fe fcdc 	bl	8003740 <chSysUnlock.lto_priv.119>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004d88:	4f27      	ldr	r7, [pc, #156]	; (8004e28 <oslib_test_001_001_execute+0x338>)
  test_set_step(6);
 8004d8a:	2306      	movs	r3, #6
 8004d8c:	6033      	str	r3, [r6, #0]
 8004d8e:	2404      	movs	r4, #4
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8004d90:	f04f 31ff 	mov.w	r1, #4294967295
 8004d94:	a801      	add	r0, sp, #4
 8004d96:	f7ff f803 	bl	8003da0 <chMBFetchTimeout.constprop.20>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004d9a:	fab0 f080 	clz	r0, r0
 8004d9e:	4639      	mov	r1, r7
 8004da0:	0940      	lsrs	r0, r0, #5
 8004da2:	f7fb fdbd 	bl	8000920 <_test_assert>
 8004da6:	2800      	cmp	r0, #0
 8004da8:	f040 80a5 	bne.w	8004ef6 <oslib_test_001_001_execute+0x406>
      test_emit_token(msg2);
 8004dac:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8004db0:	f7ff fb96 	bl	80044e0 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8004db4:	3c01      	subs	r4, #1
 8004db6:	d1eb      	bne.n	8004d90 <oslib_test_001_001_execute+0x2a0>
    test_assert_sequence("ABCD", "wrong get sequence");
 8004db8:	491f      	ldr	r1, [pc, #124]	; (8004e38 <oslib_test_001_001_execute+0x348>)
 8004dba:	4820      	ldr	r0, [pc, #128]	; (8004e3c <oslib_test_001_001_execute+0x34c>)
 8004dbc:	f7fb fe50 	bl	8000a60 <_test_assert_sequence>
 8004dc0:	2800      	cmp	r0, #0
 8004dc2:	f040 8098 	bne.w	8004ef6 <oslib_test_001_001_execute+0x406>
  test_set_step(7);
 8004dc6:	2307      	movs	r3, #7
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8004dc8:	f04f 31ff 	mov.w	r1, #4294967295
 8004dcc:	2046      	movs	r0, #70	; 0x46
  test_set_step(7);
 8004dce:	6033      	str	r3, [r6, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8004dd0:	f7fe ff36 	bl	8003c40 <chMBPostTimeout.constprop.26>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004dd4:	fab0 f080 	clz	r0, r0
 8004dd8:	0940      	lsrs	r0, r0, #5
 8004dda:	4913      	ldr	r1, [pc, #76]	; (8004e28 <oslib_test_001_001_execute+0x338>)
 8004ddc:	f7fb fda0 	bl	8000920 <_test_assert>
 8004de0:	2800      	cmp	r0, #0
 8004de2:	f040 8088 	bne.w	8004ef6 <oslib_test_001_001_execute+0x406>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8004de6:	f04f 31ff 	mov.w	r1, #4294967295
 8004dea:	a801      	add	r0, sp, #4
 8004dec:	f7fe ffd8 	bl	8003da0 <chMBFetchTimeout.constprop.20>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004df0:	fab0 f080 	clz	r0, r0
 8004df4:	0940      	lsrs	r0, r0, #5
 8004df6:	490c      	ldr	r1, [pc, #48]	; (8004e28 <oslib_test_001_001_execute+0x338>)
 8004df8:	f7fb fd92 	bl	8000920 <_test_assert>
 8004dfc:	2800      	cmp	r0, #0
 8004dfe:	d17a      	bne.n	8004ef6 <oslib_test_001_001_execute+0x406>
 8004e00:	e01e      	b.n	8004e40 <oslib_test_001_001_execute+0x350>
 8004e02:	bf00      	nop
 8004e04:	20001b3c 	.word	0x20001b3c
 8004e08:	20000c58 	.word	0x20000c58
 8004e0c:	0800c578 	.word	0x0800c578
 8004e10:	200011a0 	.word	0x200011a0
 8004e14:	0800c584 	.word	0x0800c584
 8004e18:	0800c590 	.word	0x0800c590
 8004e1c:	0800c59c 	.word	0x0800c59c
 8004e20:	0800c5c0 	.word	0x0800c5c0
 8004e24:	0800c554 	.word	0x0800c554
 8004e28:	0800c640 	.word	0x0800c640
 8004e2c:	0800c5e4 	.word	0x0800c5e4
 8004e30:	0800c5f0 	.word	0x0800c5f0
 8004e34:	0800c5fc 	.word	0x0800c5fc
 8004e38:	0800c614 	.word	0x0800c614
 8004e3c:	0800c628 	.word	0x0800c628
  test_set_step(8);
 8004e40:	2308      	movs	r3, #8
 8004e42:	6033      	str	r3, [r6, #0]
 8004e44:	2420      	movs	r4, #32
 8004e46:	f384 8811 	msr	BASEPRI, r4
 8004e4a:	f7fe fcb9 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004e4e:	f7fb fec7 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8004e52:	f7fb fec5 	bl	8000be0 <chDbgCheckClassI>
  return (size_t)(mbp->top - mbp->buffer);
 8004e56:	e9d5 0200 	ldrd	r0, r2, [r5]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004e5a:	692b      	ldr	r3, [r5, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004e5c:	4949      	ldr	r1, [pc, #292]	; (8004f84 <oslib_test_001_001_execute+0x494>)
  return (size_t)(mbp->top - mbp->buffer);
 8004e5e:	1a12      	subs	r2, r2, r0
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004e60:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8004e64:	1f1e      	subs	r6, r3, #4
 8004e66:	4270      	negs	r0, r6
 8004e68:	4170      	adcs	r0, r6
 8004e6a:	f7fb fd59 	bl	8000920 <_test_assert>
 8004e6e:	2800      	cmp	r0, #0
 8004e70:	f040 8085 	bne.w	8004f7e <oslib_test_001_001_execute+0x48e>
 8004e74:	f7fe fc64 	bl	8003740 <chSysUnlock.lto_priv.119>
 8004e78:	f384 8811 	msr	BASEPRI, r4
 8004e7c:	f7fe fca0 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8004e80:	f7fb feae 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8004e84:	6928      	ldr	r0, [r5, #16]
 8004e86:	4940      	ldr	r1, [pc, #256]	; (8004f88 <oslib_test_001_001_execute+0x498>)
 8004e88:	fab0 f080 	clz	r0, r0
 8004e8c:	0940      	lsrs	r0, r0, #5
 8004e8e:	f7fb fd47 	bl	8000920 <_test_assert>
 8004e92:	2800      	cmp	r0, #0
 8004e94:	d173      	bne.n	8004f7e <oslib_test_001_001_execute+0x48e>
 8004e96:	f7fe fc53 	bl	8003740 <chSysUnlock.lto_priv.119>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8004e9a:	6828      	ldr	r0, [r5, #0]
 8004e9c:	68ab      	ldr	r3, [r5, #8]
 8004e9e:	493b      	ldr	r1, [pc, #236]	; (8004f8c <oslib_test_001_001_execute+0x49c>)
 8004ea0:	1ac2      	subs	r2, r0, r3
 8004ea2:	4250      	negs	r0, r2
 8004ea4:	4150      	adcs	r0, r2
 8004ea6:	f7fb fd3b 	bl	8000920 <_test_assert>
 8004eaa:	bb20      	cbnz	r0, 8004ef6 <oslib_test_001_001_execute+0x406>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8004eac:	6828      	ldr	r0, [r5, #0]
 8004eae:	68eb      	ldr	r3, [r5, #12]
 8004eb0:	4937      	ldr	r1, [pc, #220]	; (8004f90 <oslib_test_001_001_execute+0x4a0>)
 8004eb2:	1ac3      	subs	r3, r0, r3
 8004eb4:	4258      	negs	r0, r3
 8004eb6:	4158      	adcs	r0, r3
 8004eb8:	f7fb fd32 	bl	8000920 <_test_assert>
 8004ebc:	e01b      	b.n	8004ef6 <oslib_test_001_001_execute+0x406>
  _dbg_check_unlock();
 8004ebe:	f7fe fc17 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004ec2:	4b34      	ldr	r3, [pc, #208]	; (8004f94 <oslib_test_001_001_execute+0x4a4>)
 8004ec4:	681a      	ldr	r2, [r3, #0]
 8004ec6:	429a      	cmp	r2, r3
 8004ec8:	d012      	beq.n	8004ef0 <oslib_test_001_001_execute+0x400>
 8004eca:	6999      	ldr	r1, [r3, #24]
 8004ecc:	6892      	ldr	r2, [r2, #8]
 8004ece:	6889      	ldr	r1, [r1, #8]
 8004ed0:	4291      	cmp	r1, r2
 8004ed2:	d20d      	bcs.n	8004ef0 <oslib_test_001_001_execute+0x400>
  __ASM volatile ("cpsid i" : : : "memory");
 8004ed4:	b672      	cpsid	i
 8004ed6:	4a30      	ldr	r2, [pc, #192]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004ed8:	62da      	str	r2, [r3, #44]	; 0x2c
 8004eda:	e7fe      	b.n	8004eda <oslib_test_001_001_execute+0x3ea>
  _dbg_check_unlock();
 8004edc:	f7fe fc08 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004ee0:	6823      	ldr	r3, [r4, #0]
 8004ee2:	42a3      	cmp	r3, r4
 8004ee4:	d004      	beq.n	8004ef0 <oslib_test_001_001_execute+0x400>
 8004ee6:	69a2      	ldr	r2, [r4, #24]
 8004ee8:	689b      	ldr	r3, [r3, #8]
 8004eea:	6892      	ldr	r2, [r2, #8]
 8004eec:	429a      	cmp	r2, r3
 8004eee:	d30c      	bcc.n	8004f0a <oslib_test_001_001_execute+0x41a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004ef0:	2300      	movs	r3, #0
 8004ef2:	f383 8811 	msr	BASEPRI, r3
}
 8004ef6:	b003      	add	sp, #12
 8004ef8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8004efa:	b672      	cpsid	i
 8004efc:	4b26      	ldr	r3, [pc, #152]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004efe:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f00:	e7fe      	b.n	8004f00 <oslib_test_001_001_execute+0x410>
 8004f02:	b672      	cpsid	i
 8004f04:	4b24      	ldr	r3, [pc, #144]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004f06:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f08:	e7fe      	b.n	8004f08 <oslib_test_001_001_execute+0x418>
 8004f0a:	b672      	cpsid	i
 8004f0c:	4b22      	ldr	r3, [pc, #136]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004f0e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f10:	e7fe      	b.n	8004f10 <oslib_test_001_001_execute+0x420>
 8004f12:	b672      	cpsid	i
 8004f14:	4b20      	ldr	r3, [pc, #128]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004f16:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f18:	e7fe      	b.n	8004f18 <oslib_test_001_001_execute+0x428>
  _dbg_check_unlock();
 8004f1a:	f7fe fbe9 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004f1e:	6823      	ldr	r3, [r4, #0]
 8004f20:	42a3      	cmp	r3, r4
 8004f22:	d0e5      	beq.n	8004ef0 <oslib_test_001_001_execute+0x400>
 8004f24:	69a2      	ldr	r2, [r4, #24]
 8004f26:	689b      	ldr	r3, [r3, #8]
 8004f28:	6892      	ldr	r2, [r2, #8]
 8004f2a:	429a      	cmp	r2, r3
 8004f2c:	d2e0      	bcs.n	8004ef0 <oslib_test_001_001_execute+0x400>
 8004f2e:	b672      	cpsid	i
 8004f30:	4b19      	ldr	r3, [pc, #100]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004f32:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f34:	e7fe      	b.n	8004f34 <oslib_test_001_001_execute+0x444>
  _dbg_check_unlock();
 8004f36:	f7fe fbdb 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004f3a:	6823      	ldr	r3, [r4, #0]
 8004f3c:	42a3      	cmp	r3, r4
 8004f3e:	d0d7      	beq.n	8004ef0 <oslib_test_001_001_execute+0x400>
 8004f40:	69a2      	ldr	r2, [r4, #24]
 8004f42:	689b      	ldr	r3, [r3, #8]
 8004f44:	6892      	ldr	r2, [r2, #8]
 8004f46:	429a      	cmp	r2, r3
 8004f48:	d2d2      	bcs.n	8004ef0 <oslib_test_001_001_execute+0x400>
 8004f4a:	b672      	cpsid	i
 8004f4c:	4b12      	ldr	r3, [pc, #72]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004f4e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f50:	e7fe      	b.n	8004f50 <oslib_test_001_001_execute+0x460>
 8004f52:	b672      	cpsid	i
 8004f54:	4b10      	ldr	r3, [pc, #64]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004f56:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f58:	e7fe      	b.n	8004f58 <oslib_test_001_001_execute+0x468>
  _dbg_check_unlock();
 8004f5a:	f7fe fbc9 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004f5e:	6823      	ldr	r3, [r4, #0]
 8004f60:	42a3      	cmp	r3, r4
 8004f62:	d0c5      	beq.n	8004ef0 <oslib_test_001_001_execute+0x400>
 8004f64:	69a2      	ldr	r2, [r4, #24]
 8004f66:	689b      	ldr	r3, [r3, #8]
 8004f68:	6892      	ldr	r2, [r2, #8]
 8004f6a:	429a      	cmp	r2, r3
 8004f6c:	d2c0      	bcs.n	8004ef0 <oslib_test_001_001_execute+0x400>
 8004f6e:	b672      	cpsid	i
 8004f70:	4b09      	ldr	r3, [pc, #36]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004f72:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f74:	e7fe      	b.n	8004f74 <oslib_test_001_001_execute+0x484>
 8004f76:	b672      	cpsid	i
 8004f78:	4b07      	ldr	r3, [pc, #28]	; (8004f98 <oslib_test_001_001_execute+0x4a8>)
 8004f7a:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004f7c:	e7fe      	b.n	8004f7c <oslib_test_001_001_execute+0x48c>
 8004f7e:	f7fe fbdf 	bl	8003740 <chSysUnlock.lto_priv.119>
 8004f82:	e7b8      	b.n	8004ef6 <oslib_test_001_001_execute+0x406>
 8004f84:	0800c584 	.word	0x0800c584
 8004f88:	0800c590 	.word	0x0800c590
 8004f8c:	0800c59c 	.word	0x0800c59c
 8004f90:	0800c5c0 	.word	0x0800c5c0
 8004f94:	200011a0 	.word	0x200011a0
 8004f98:	0800bcc8 	.word	0x0800bcc8
 8004f9c:	00000000 	.word	0x00000000

08004fa0 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8004fa0:	2043      	movs	r0, #67	; 0x43
 8004fa2:	f7ff ba9d 	b.w	80044e0 <test_emit_token>
 8004fa6:	bf00      	nop
	...

08004fb0 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8004fb0:	2042      	movs	r0, #66	; 0x42
 8004fb2:	f7ff ba95 	b.w	80044e0 <test_emit_token>
 8004fb6:	bf00      	nop
	...

08004fc0 <h1>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8004fc0:	2041      	movs	r0, #65	; 0x41
 8004fc2:	f7ff ba8d 	b.w	80044e0 <test_emit_token>
 8004fc6:	bf00      	nop
	...

08004fd0 <thread1.lto_priv.177>:
static THD_FUNCTION(thread1, p) {
 8004fd0:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004fd2:	2320      	movs	r3, #32
 8004fd4:	4604      	mov	r4, r0
 8004fd6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004fda:	f7fe fbf1 	bl	80037c0 <_dbg_check_lock>
  if (*trp != NULL) {
 8004fde:	4b15      	ldr	r3, [pc, #84]	; (8005034 <thread1.lto_priv.177+0x64>)
 8004fe0:	6818      	ldr	r0, [r3, #0]
 8004fe2:	b168      	cbz	r0, 8005000 <thread1.lto_priv.177+0x30>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004fe4:	f890 2020 	ldrb.w	r2, [r0, #32]
 8004fe8:	2a03      	cmp	r2, #3
 8004fea:	d004      	beq.n	8004ff6 <thread1.lto_priv.177+0x26>
  __ASM volatile ("cpsid i" : : : "memory");
 8004fec:	b672      	cpsid	i
 8004fee:	4b12      	ldr	r3, [pc, #72]	; (8005038 <thread1.lto_priv.177+0x68>)
 8004ff0:	4a12      	ldr	r2, [pc, #72]	; (800503c <thread1.lto_priv.177+0x6c>)
 8004ff2:	62da      	str	r2, [r3, #44]	; 0x2c
 8004ff4:	e7fe      	b.n	8004ff4 <thread1.lto_priv.177+0x24>
    *trp = NULL;
 8004ff6:	2200      	movs	r2, #0
    tp->u.rdymsg = msg;
 8004ff8:	6242      	str	r2, [r0, #36]	; 0x24
    *trp = NULL;
 8004ffa:	601a      	str	r2, [r3, #0]
    (void) chSchReadyI(tp);
 8004ffc:	f7fb feb0 	bl	8000d60 <chSchReadyI>
  chSchRescheduleS();
 8005000:	f7fe fb5e 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8005004:	f7fe fb74 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005008:	4b0b      	ldr	r3, [pc, #44]	; (8005038 <thread1.lto_priv.177+0x68>)
 800500a:	681a      	ldr	r2, [r3, #0]
 800500c:	429a      	cmp	r2, r3
 800500e:	d004      	beq.n	800501a <thread1.lto_priv.177+0x4a>
 8005010:	6999      	ldr	r1, [r3, #24]
 8005012:	6892      	ldr	r2, [r2, #8]
 8005014:	6889      	ldr	r1, [r1, #8]
 8005016:	4291      	cmp	r1, r2
 8005018:	d307      	bcc.n	800502a <thread1.lto_priv.177+0x5a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800501a:	2300      	movs	r3, #0
 800501c:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 8005020:	7820      	ldrb	r0, [r4, #0]
}
 8005022:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
 8005026:	f7ff ba5b 	b.w	80044e0 <test_emit_token>
  __ASM volatile ("cpsid i" : : : "memory");
 800502a:	b672      	cpsid	i
 800502c:	4a04      	ldr	r2, [pc, #16]	; (8005040 <thread1.lto_priv.177+0x70>)
 800502e:	62da      	str	r2, [r3, #44]	; 0x2c
 8005030:	e7fe      	b.n	8005030 <thread1.lto_priv.177+0x60>
 8005032:	bf00      	nop
 8005034:	20001b68 	.word	0x20001b68
 8005038:	200011a0 	.word	0x200011a0
 800503c:	0800bf8c 	.word	0x0800bf8c
 8005040:	0800bc8c 	.word	0x0800bc8c
	...

08005050 <thread>:
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8005050:	7800      	ldrb	r0, [r0, #0]
 8005052:	f7ff ba45 	b.w	80044e0 <test_emit_token>
 8005056:	bf00      	nop
	...

08005060 <dyn_thread1>:
 8005060:	f7ff bff6 	b.w	8005050 <thread>
	...

08005070 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8005070:	2900      	cmp	r1, #0
 8005072:	dd03      	ble.n	800507c <cmd_systime+0xc>
    shellUsage(chp, "systime");
 8005074:	4a12      	ldr	r2, [pc, #72]	; (80050c0 <cmd_systime+0x50>)
 8005076:	4913      	ldr	r1, [pc, #76]	; (80050c4 <cmd_systime+0x54>)
 8005078:	f7fd bc8a 	b.w	8002990 <chprintf>
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 800507c:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800507e:	2320      	movs	r3, #32
 8005080:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005084:	f7fe fb9c 	bl	80037c0 <_dbg_check_lock>
  return (systime_t)STM32_ST_TIM->CNT;
 8005088:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800508c:	6a5c      	ldr	r4, [r3, #36]	; 0x24
  _dbg_check_unlock();
 800508e:	f7fe fb2f 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005092:	4b0d      	ldr	r3, [pc, #52]	; (80050c8 <cmd_systime+0x58>)
 8005094:	6819      	ldr	r1, [r3, #0]
 8005096:	4299      	cmp	r1, r3
 8005098:	d004      	beq.n	80050a4 <cmd_systime+0x34>
 800509a:	699d      	ldr	r5, [r3, #24]
 800509c:	688a      	ldr	r2, [r1, #8]
 800509e:	68a9      	ldr	r1, [r5, #8]
 80050a0:	4291      	cmp	r1, r2
 80050a2:	d308      	bcc.n	80050b6 <cmd_systime+0x46>
 80050a4:	2300      	movs	r3, #0
 80050a6:	f383 8811 	msr	BASEPRI, r3
    return;
  }
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 80050aa:	4908      	ldr	r1, [pc, #32]	; (80050cc <cmd_systime+0x5c>)
 80050ac:	4622      	mov	r2, r4
}
 80050ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 80050b2:	f7fd bc6d 	b.w	8002990 <chprintf>
  __ASM volatile ("cpsid i" : : : "memory");
 80050b6:	b672      	cpsid	i
 80050b8:	4a05      	ldr	r2, [pc, #20]	; (80050d0 <cmd_systime+0x60>)
 80050ba:	62da      	str	r2, [r3, #44]	; 0x2c
 80050bc:	e7fe      	b.n	80050bc <cmd_systime+0x4c>
 80050be:	bf00      	nop
 80050c0:	0800c3d0 	.word	0x0800c3d0
 80050c4:	0800c234 	.word	0x0800c234
 80050c8:	200011a0 	.word	0x200011a0
 80050cc:	0800c3d8 	.word	0x0800c3d8
 80050d0:	0800bd18 	.word	0x0800bd18
	...

080050e0 <shellThread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
 80050e0:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  int n;
  ShellConfig *scfg = p;
  BaseSequentialStream *chp = scfg->sc_channel;
  const ShellCommand *scp = scfg->sc_commands;
 80050e4:	e9d0 7300 	ldrd	r7, r3, [r0]
THD_FUNCTION(shellThread, p) {
 80050e8:	b09b      	sub	sp, #108	; 0x6c
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
 80050ea:	4973      	ldr	r1, [pc, #460]	; (80052b8 <shellThread+0x1d8>)
  const ShellCommand *scp = scfg->sc_commands;
 80050ec:	9301      	str	r3, [sp, #4]
THD_FUNCTION(shellThread, p) {
 80050ee:	4681      	mov	r9, r0
  chprintf(chp, SHELL_NEWLINE_STR);
 80050f0:	4638      	mov	r0, r7
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
 80050f2:	468b      	mov	fp, r1
  chprintf(chp, SHELL_NEWLINE_STR);
 80050f4:	f7fd fc4c 	bl	8002990 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 80050f8:	4638      	mov	r0, r7
 80050fa:	4970      	ldr	r1, [pc, #448]	; (80052bc <shellThread+0x1dc>)
    chprintf(chp, SHELL_PROMPT_STR);
 80050fc:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 80052f0 <shellThread+0x210>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 8005100:	f7fd fc46 	bl	8002990 <chprintf>
 8005104:	ae0a      	add	r6, sp, #40	; 0x28
    chprintf(chp, SHELL_PROMPT_STR);
 8005106:	4651      	mov	r1, sl
 8005108:	4638      	mov	r0, r7
 800510a:	f7fd fc41 	bl	8002990 <chprintf>
  BaseSequentialStream *chp = scfg->sc_channel;
 800510e:	f8d9 4000 	ldr.w	r4, [r9]
 8005112:	6823      	ldr	r3, [r4, #0]
  char *p = line;
 8005114:	4635      	mov	r5, r6
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8005116:	689b      	ldr	r3, [r3, #8]
 8005118:	2201      	movs	r2, #1
 800511a:	f10d 010f 	add.w	r1, sp, #15
 800511e:	4620      	mov	r0, r4
 8005120:	4798      	blx	r3
 8005122:	2800      	cmp	r0, #0
 8005124:	d069      	beq.n	80051fa <shellThread+0x11a>
    if (c == 4) {
 8005126:	f89d 100f 	ldrb.w	r1, [sp, #15]
 800512a:	2904      	cmp	r1, #4
 800512c:	d061      	beq.n	80051f2 <shellThread+0x112>
    if ((c == 8) || (c == 127)) {
 800512e:	2908      	cmp	r1, #8
 8005130:	d013      	beq.n	800515a <shellThread+0x7a>
 8005132:	297f      	cmp	r1, #127	; 0x7f
 8005134:	d011      	beq.n	800515a <shellThread+0x7a>
    if (c == '\r') {
 8005136:	290d      	cmp	r1, #13
 8005138:	d023      	beq.n	8005182 <shellThread+0xa2>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
 800513a:	291f      	cmp	r1, #31
 800513c:	6823      	ldr	r3, [r4, #0]
 800513e:	d9ea      	bls.n	8005116 <shellThread+0x36>
      continue;
    if (p < line + size - 1) {
 8005140:	f10d 0267 	add.w	r2, sp, #103	; 0x67
 8005144:	4295      	cmp	r5, r2
 8005146:	d2e6      	bcs.n	8005116 <shellThread+0x36>
      streamPut(chp, c);
 8005148:	68db      	ldr	r3, [r3, #12]
 800514a:	4620      	mov	r0, r4
 800514c:	4798      	blx	r3
      *p++ = (char)c;
 800514e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005152:	702b      	strb	r3, [r5, #0]
 8005154:	6823      	ldr	r3, [r4, #0]
 8005156:	3501      	adds	r5, #1
 8005158:	e7dd      	b.n	8005116 <shellThread+0x36>
      if (p != line) {
 800515a:	42b5      	cmp	r5, r6
 800515c:	6823      	ldr	r3, [r4, #0]
 800515e:	d0da      	beq.n	8005116 <shellThread+0x36>
        streamPut(chp, 0x08);
 8005160:	68db      	ldr	r3, [r3, #12]
 8005162:	2108      	movs	r1, #8
 8005164:	4620      	mov	r0, r4
 8005166:	4798      	blx	r3
        streamPut(chp, 0x20);
 8005168:	6823      	ldr	r3, [r4, #0]
 800516a:	2120      	movs	r1, #32
 800516c:	68db      	ldr	r3, [r3, #12]
 800516e:	4620      	mov	r0, r4
 8005170:	4798      	blx	r3
        streamPut(chp, 0x08);
 8005172:	6823      	ldr	r3, [r4, #0]
 8005174:	2108      	movs	r1, #8
 8005176:	68db      	ldr	r3, [r3, #12]
 8005178:	4620      	mov	r0, r4
 800517a:	4798      	blx	r3
        p--;
 800517c:	3d01      	subs	r5, #1
 800517e:	6823      	ldr	r3, [r4, #0]
 8005180:	e7c9      	b.n	8005116 <shellThread+0x36>
      chprintf(chp, SHELL_NEWLINE_STR);
 8005182:	4620      	mov	r0, r4
 8005184:	4659      	mov	r1, fp
      *p = 0;
 8005186:	2400      	movs	r4, #0
      chprintf(chp, SHELL_NEWLINE_STR);
 8005188:	f7fd fc02 	bl	8002990 <chprintf>
    lp = parse_arguments(line, &tokp);
 800518c:	a904      	add	r1, sp, #16
      *p = 0;
 800518e:	702c      	strb	r4, [r5, #0]
    lp = parse_arguments(line, &tokp);
 8005190:	4630      	mov	r0, r6
 8005192:	f7fd fbcd 	bl	8002930 <parse_arguments>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8005196:	a904      	add	r1, sp, #16
    lp = parse_arguments(line, &tokp);
 8005198:	4680      	mov	r8, r0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800519a:	2000      	movs	r0, #0
 800519c:	ad05      	add	r5, sp, #20
 800519e:	f7fd fbc7 	bl	8002930 <parse_arguments>
 80051a2:	b150      	cbz	r0, 80051ba <shellThread+0xda>
      if (n >= SHELL_MAX_ARGUMENTS) {
 80051a4:	2c04      	cmp	r4, #4
 80051a6:	d01d      	beq.n	80051e4 <shellThread+0x104>
      args[n++] = lp;
 80051a8:	f845 0b04 	str.w	r0, [r5], #4
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 80051ac:	a904      	add	r1, sp, #16
 80051ae:	2000      	movs	r0, #0
      args[n++] = lp;
 80051b0:	3401      	adds	r4, #1
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 80051b2:	f7fd fbbd 	bl	8002930 <parse_arguments>
 80051b6:	2800      	cmp	r0, #0
 80051b8:	d1f4      	bne.n	80051a4 <shellThread+0xc4>
    args[n] = NULL;
 80051ba:	ab1a      	add	r3, sp, #104	; 0x68
 80051bc:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80051c0:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 80051c4:	f1b8 0f00 	cmp.w	r8, #0
 80051c8:	d09d      	beq.n	8005106 <shellThread+0x26>
      if (strcmp(cmd, "help") == 0) {
 80051ca:	493d      	ldr	r1, [pc, #244]	; (80052c0 <shellThread+0x1e0>)
 80051cc:	4640      	mov	r0, r8
 80051ce:	f7fb f91b 	bl	8000408 <strcmp>
 80051d2:	2800      	cmp	r0, #0
 80051d4:	d146      	bne.n	8005264 <shellThread+0x184>
        if (n > 0) {
 80051d6:	b324      	cbz	r4, 8005222 <shellThread+0x142>
          shellUsage(chp, "help");
 80051d8:	4a39      	ldr	r2, [pc, #228]	; (80052c0 <shellThread+0x1e0>)
 80051da:	493a      	ldr	r1, [pc, #232]	; (80052c4 <shellThread+0x1e4>)
 80051dc:	4638      	mov	r0, r7
 80051de:	f7fd fbd7 	bl	8002990 <chprintf>
 80051e2:	e790      	b.n	8005106 <shellThread+0x26>
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
 80051e4:	4938      	ldr	r1, [pc, #224]	; (80052c8 <shellThread+0x1e8>)
 80051e6:	4638      	mov	r0, r7
 80051e8:	f7fd fbd2 	bl	8002990 <chprintf>
    args[n] = NULL;
 80051ec:	2300      	movs	r3, #0
 80051ee:	9309      	str	r3, [sp, #36]	; 0x24
 80051f0:	e789      	b.n	8005106 <shellThread+0x26>
      chprintf(chp, "^D");
 80051f2:	4620      	mov	r0, r4
 80051f4:	4935      	ldr	r1, [pc, #212]	; (80052cc <shellThread+0x1ec>)
 80051f6:	f7fd fbcb 	bl	8002990 <chprintf>
      chprintf(chp, SHELL_NEWLINE_STR);
 80051fa:	492f      	ldr	r1, [pc, #188]	; (80052b8 <shellThread+0x1d8>)
 80051fc:	4638      	mov	r0, r7
 80051fe:	f7fd fbc7 	bl	8002990 <chprintf>
      chprintf(chp, "logout");
 8005202:	4638      	mov	r0, r7
 8005204:	4932      	ldr	r1, [pc, #200]	; (80052d0 <shellThread+0x1f0>)
 8005206:	f7fd fbc3 	bl	8002990 <chprintf>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800520a:	2320      	movs	r3, #32
 800520c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005210:	f7fe fad6 	bl	80037c0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8005214:	482f      	ldr	r0, [pc, #188]	; (80052d4 <shellThread+0x1f4>)
 8005216:	2100      	movs	r1, #0
 8005218:	f7fb fe62 	bl	8000ee0 <chEvtBroadcastFlagsI>
  chThdExitS(msg);
 800521c:	2000      	movs	r0, #0
 800521e:	f7fd ff27 	bl	8003070 <chThdExitS>
        chprintf(chp, "Commands: help ");
 8005222:	492d      	ldr	r1, [pc, #180]	; (80052d8 <shellThread+0x1f8>)
 8005224:	4c2d      	ldr	r4, [pc, #180]	; (80052dc <shellThread+0x1fc>)
    chprintf(chp, "%s ", scp->sc_name);
 8005226:	4d2e      	ldr	r5, [pc, #184]	; (80052e0 <shellThread+0x200>)
        chprintf(chp, "Commands: help ");
 8005228:	4638      	mov	r0, r7
 800522a:	f7fd fbb1 	bl	8002990 <chprintf>
  while (scp->sc_name != NULL) {
 800522e:	4a2d      	ldr	r2, [pc, #180]	; (80052e4 <shellThread+0x204>)
    chprintf(chp, "%s ", scp->sc_name);
 8005230:	4629      	mov	r1, r5
 8005232:	4638      	mov	r0, r7
 8005234:	f7fd fbac 	bl	8002990 <chprintf>
  while (scp->sc_name != NULL) {
 8005238:	f854 2f08 	ldr.w	r2, [r4, #8]!
 800523c:	2a00      	cmp	r2, #0
 800523e:	d1f7      	bne.n	8005230 <shellThread+0x150>
        if (scp != NULL)
 8005240:	9c01      	ldr	r4, [sp, #4]
 8005242:	b154      	cbz	r4, 800525a <shellThread+0x17a>
  while (scp->sc_name != NULL) {
 8005244:	6822      	ldr	r2, [r4, #0]
 8005246:	b142      	cbz	r2, 800525a <shellThread+0x17a>
    chprintf(chp, "%s ", scp->sc_name);
 8005248:	4d25      	ldr	r5, [pc, #148]	; (80052e0 <shellThread+0x200>)
 800524a:	4629      	mov	r1, r5
 800524c:	4638      	mov	r0, r7
 800524e:	f7fd fb9f 	bl	8002990 <chprintf>
  while (scp->sc_name != NULL) {
 8005252:	f854 2f08 	ldr.w	r2, [r4, #8]!
 8005256:	2a00      	cmp	r2, #0
 8005258:	d1f7      	bne.n	800524a <shellThread+0x16a>
        chprintf(chp, SHELL_NEWLINE_STR);
 800525a:	4659      	mov	r1, fp
 800525c:	4638      	mov	r0, r7
 800525e:	f7fd fb97 	bl	8002990 <chprintf>
 8005262:	e750      	b.n	8005106 <shellThread+0x26>
 8005264:	4d1d      	ldr	r5, [pc, #116]	; (80052dc <shellThread+0x1fc>)
  while (scp->sc_name != NULL) {
 8005266:	481f      	ldr	r0, [pc, #124]	; (80052e4 <shellThread+0x204>)
 8005268:	e002      	b.n	8005270 <shellThread+0x190>
 800526a:	f855 0f08 	ldr.w	r0, [r5, #8]!
 800526e:	b150      	cbz	r0, 8005286 <shellThread+0x1a6>
    if (strcmp(scp->sc_name, name) == 0) {
 8005270:	4641      	mov	r1, r8
 8005272:	f7fb f8c9 	bl	8000408 <strcmp>
 8005276:	2800      	cmp	r0, #0
 8005278:	d1f7      	bne.n	800526a <shellThread+0x18a>
      scp->sc_function(chp, argc, argv);
 800527a:	686b      	ldr	r3, [r5, #4]
 800527c:	aa05      	add	r2, sp, #20
 800527e:	4621      	mov	r1, r4
 8005280:	4638      	mov	r0, r7
 8005282:	4798      	blx	r3
 8005284:	e73f      	b.n	8005106 <shellThread+0x26>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8005286:	9d01      	ldr	r5, [sp, #4]
 8005288:	b15d      	cbz	r5, 80052a2 <shellThread+0x1c2>
  while (scp->sc_name != NULL) {
 800528a:	6828      	ldr	r0, [r5, #0]
 800528c:	b918      	cbnz	r0, 8005296 <shellThread+0x1b6>
 800528e:	e008      	b.n	80052a2 <shellThread+0x1c2>
 8005290:	f855 0f08 	ldr.w	r0, [r5, #8]!
 8005294:	b128      	cbz	r0, 80052a2 <shellThread+0x1c2>
    if (strcmp(scp->sc_name, name) == 0) {
 8005296:	4641      	mov	r1, r8
 8005298:	f7fb f8b6 	bl	8000408 <strcmp>
 800529c:	2800      	cmp	r0, #0
 800529e:	d1f7      	bne.n	8005290 <shellThread+0x1b0>
 80052a0:	e7eb      	b.n	800527a <shellThread+0x19a>
        chprintf(chp, "%s", cmd);
 80052a2:	4642      	mov	r2, r8
 80052a4:	4910      	ldr	r1, [pc, #64]	; (80052e8 <shellThread+0x208>)
 80052a6:	4638      	mov	r0, r7
 80052a8:	f7fd fb72 	bl	8002990 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
 80052ac:	490f      	ldr	r1, [pc, #60]	; (80052ec <shellThread+0x20c>)
 80052ae:	4638      	mov	r0, r7
 80052b0:	f7fd fb6e 	bl	8002990 <chprintf>
 80052b4:	e727      	b.n	8005106 <shellThread+0x26>
 80052b6:	bf00      	nop
 80052b8:	0800c488 	.word	0x0800c488
 80052bc:	0800dc88 	.word	0x0800dc88
 80052c0:	0800dcc8 	.word	0x0800dcc8
 80052c4:	0800c234 	.word	0x0800c234
 80052c8:	0800dcb0 	.word	0x0800dcb0
 80052cc:	0800dca4 	.word	0x0800dca4
 80052d0:	0800dca8 	.word	0x0800dca8
 80052d4:	20001420 	.word	0x20001420
 80052d8:	0800dcd0 	.word	0x0800dcd0
 80052dc:	0800dcf8 	.word	0x0800dcf8
 80052e0:	0800dce0 	.word	0x0800dce0
 80052e4:	0800dc80 	.word	0x0800dc80
 80052e8:	0800dce4 	.word	0x0800dce4
 80052ec:	0800dce8 	.word	0x0800dce8
 80052f0:	0800dc9c 	.word	0x0800dc9c
	...

08005300 <cmd_exit>:
  if (argc > 0) {
 8005300:	2900      	cmp	r1, #0
 8005302:	dd03      	ble.n	800530c <cmd_exit+0xc>
    shellUsage(chp, "exit");
 8005304:	4a08      	ldr	r2, [pc, #32]	; (8005328 <cmd_exit+0x28>)
 8005306:	4909      	ldr	r1, [pc, #36]	; (800532c <cmd_exit+0x2c>)
 8005308:	f7fd bb42 	b.w	8002990 <chprintf>
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
 800530c:	b508      	push	{r3, lr}
 800530e:	2320      	movs	r3, #32
 8005310:	f383 8811 	msr	BASEPRI, r3
 8005314:	f7fe fa54 	bl	80037c0 <_dbg_check_lock>
 8005318:	4805      	ldr	r0, [pc, #20]	; (8005330 <cmd_exit+0x30>)
 800531a:	2100      	movs	r1, #0
 800531c:	f7fb fde0 	bl	8000ee0 <chEvtBroadcastFlagsI>
  chThdExitS(msg);
 8005320:	2000      	movs	r0, #0
 8005322:	f7fd fea5 	bl	8003070 <chThdExitS>
 8005326:	bf00      	nop
 8005328:	0800dc80 	.word	0x0800dc80
 800532c:	0800c234 	.word	0x0800c234
 8005330:	20001420 	.word	0x20001420
	...

08005340 <chGuardedPoolLoadArray>:
  chDbgCheck((gmp != NULL) && (n != 0U));
 8005340:	b350      	cbz	r0, 8005398 <chGuardedPoolLoadArray+0x58>
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
 8005342:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005346:	4c19      	ldr	r4, [pc, #100]	; (80053ac <chGuardedPoolLoadArray+0x6c>)
 8005348:	460e      	mov	r6, r1
 800534a:	4617      	mov	r7, r2
 800534c:	4605      	mov	r5, r0
 800534e:	f100 0a0c 	add.w	sl, r0, #12
 8005352:	f04f 0920 	mov.w	r9, #32
 8005356:	f04f 0800 	mov.w	r8, #0
 800535a:	f389 8811 	msr	BASEPRI, r9
 800535e:	f7fe fa2f 	bl	80037c0 <_dbg_check_lock>
 *
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
 8005362:	4631      	mov	r1, r6
 8005364:	4650      	mov	r0, sl
 8005366:	f7fb fc4b 	bl	8000c00 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
 800536a:	4628      	mov	r0, r5
 800536c:	f7fb fe30 	bl	8000fd0 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8005370:	f7fe f9a6 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8005374:	f7fe f9bc 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005378:	6823      	ldr	r3, [r4, #0]
 800537a:	42a3      	cmp	r3, r4
 800537c:	d004      	beq.n	8005388 <chGuardedPoolLoadArray+0x48>
 800537e:	69a2      	ldr	r2, [r4, #24]
 8005380:	689b      	ldr	r3, [r3, #8]
 8005382:	6892      	ldr	r2, [r2, #8]
 8005384:	429a      	cmp	r2, r3
 8005386:	d30c      	bcc.n	80053a2 <chGuardedPoolLoadArray+0x62>
 8005388:	f388 8811 	msr	BASEPRI, r8
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 800538c:	692b      	ldr	r3, [r5, #16]
  while (n != 0U) {
 800538e:	3f01      	subs	r7, #1
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8005390:	441e      	add	r6, r3
  while (n != 0U) {
 8005392:	d1e2      	bne.n	800535a <chGuardedPoolLoadArray+0x1a>
}
 8005394:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8005398:	b672      	cpsid	i
 800539a:	4b04      	ldr	r3, [pc, #16]	; (80053ac <chGuardedPoolLoadArray+0x6c>)
 800539c:	4a04      	ldr	r2, [pc, #16]	; (80053b0 <chGuardedPoolLoadArray+0x70>)
 800539e:	62da      	str	r2, [r3, #44]	; 0x2c
 80053a0:	e7fe      	b.n	80053a0 <chGuardedPoolLoadArray+0x60>
 80053a2:	b672      	cpsid	i
 80053a4:	4b03      	ldr	r3, [pc, #12]	; (80053b4 <chGuardedPoolLoadArray+0x74>)
 80053a6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80053a8:	e7fe      	b.n	80053a8 <chGuardedPoolLoadArray+0x68>
 80053aa:	bf00      	nop
 80053ac:	200011a0 	.word	0x200011a0
 80053b0:	0800beec 	.word	0x0800beec
 80053b4:	0800bc50 	.word	0x0800bc50
	...

080053c0 <oslib_test_002_002_execute>:
static void oslib_test_002_002_execute(void) {
 80053c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(1);
 80053c4:	4c37      	ldr	r4, [pc, #220]	; (80054a4 <oslib_test_002_002_execute+0xe4>)
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 80053c6:	4938      	ldr	r1, [pc, #224]	; (80054a8 <oslib_test_002_002_execute+0xe8>)
 80053c8:	4838      	ldr	r0, [pc, #224]	; (80054ac <oslib_test_002_002_execute+0xec>)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 80053ca:	4e39      	ldr	r6, [pc, #228]	; (80054b0 <oslib_test_002_002_execute+0xf0>)
  test_set_step(1);
 80053cc:	2301      	movs	r3, #1
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 80053ce:	2204      	movs	r2, #4
  test_set_step(1);
 80053d0:	6023      	str	r3, [r4, #0]
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 80053d2:	f7ff ffb5 	bl	8005340 <chGuardedPoolLoadArray>
  test_set_step(2);
 80053d6:	2302      	movs	r3, #2
 80053d8:	6023      	str	r3, [r4, #0]
 80053da:	2504      	movs	r5, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 80053dc:	2000      	movs	r0, #0
 80053de:	f7fe fd2f 	bl	8003e40 <chGuardedPoolAllocTimeout.constprop.15>
 80053e2:	3000      	adds	r0, #0
 80053e4:	bf18      	it	ne
 80053e6:	2001      	movne	r0, #1
 80053e8:	4631      	mov	r1, r6
 80053ea:	f7fb fa99 	bl	8000920 <_test_assert>
 80053ee:	2800      	cmp	r0, #0
 80053f0:	d152      	bne.n	8005498 <oslib_test_002_002_execute+0xd8>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80053f2:	3d01      	subs	r5, #1
 80053f4:	d1f2      	bne.n	80053dc <oslib_test_002_002_execute+0x1c>
  test_set_step(3);
 80053f6:	2303      	movs	r3, #3
 80053f8:	6023      	str	r3, [r4, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80053fa:	f7fe fd21 	bl	8003e40 <chGuardedPoolAllocTimeout.constprop.15>
 80053fe:	fab0 f080 	clz	r0, r0
 8005402:	0940      	lsrs	r0, r0, #5
 8005404:	492b      	ldr	r1, [pc, #172]	; (80054b4 <oslib_test_002_002_execute+0xf4>)
 8005406:	f7fb fa8b 	bl	8000920 <_test_assert>
 800540a:	2800      	cmp	r0, #0
 800540c:	d144      	bne.n	8005498 <oslib_test_002_002_execute+0xd8>
 800540e:	4d26      	ldr	r5, [pc, #152]	; (80054a8 <oslib_test_002_002_execute+0xe8>)
  chPoolFreeI(&gmp->pool, objp);
 8005410:	4f29      	ldr	r7, [pc, #164]	; (80054b8 <oslib_test_002_002_execute+0xf8>)
 8005412:	4e2a      	ldr	r6, [pc, #168]	; (80054bc <oslib_test_002_002_execute+0xfc>)
  test_set_step(4);
 8005414:	2304      	movs	r3, #4
 8005416:	f105 0a10 	add.w	sl, r5, #16
  chSemSignalI(&gmp->sem);
 800541a:	f1a7 090c 	sub.w	r9, r7, #12
 800541e:	6023      	str	r3, [r4, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005420:	f04f 0820 	mov.w	r8, #32
 8005424:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock();
 8005428:	f7fe f9ca 	bl	80037c0 <_dbg_check_lock>
  chPoolFreeI(&gmp->pool, objp);
 800542c:	4629      	mov	r1, r5
 800542e:	4638      	mov	r0, r7
 8005430:	f7fb fbe6 	bl	8000c00 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
 8005434:	4648      	mov	r0, r9
 8005436:	f7fb fdcb 	bl	8000fd0 <chSemSignalI>
  chSchRescheduleS();
 800543a:	f7fe f941 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 800543e:	f7fe f957 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005442:	6833      	ldr	r3, [r6, #0]
 8005444:	42b3      	cmp	r3, r6
 8005446:	f04f 0100 	mov.w	r1, #0
 800544a:	d004      	beq.n	8005456 <oslib_test_002_002_execute+0x96>
 800544c:	69b2      	ldr	r2, [r6, #24]
 800544e:	689b      	ldr	r3, [r3, #8]
 8005450:	6892      	ldr	r2, [r2, #8]
 8005452:	429a      	cmp	r2, r3
 8005454:	d322      	bcc.n	800549c <oslib_test_002_002_execute+0xdc>
 8005456:	f381 8811 	msr	BASEPRI, r1
 800545a:	3504      	adds	r5, #4
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800545c:	45aa      	cmp	sl, r5
 800545e:	d1e1      	bne.n	8005424 <oslib_test_002_002_execute+0x64>
  test_set_step(5);
 8005460:	2305      	movs	r3, #5
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8005462:	4e13      	ldr	r6, [pc, #76]	; (80054b0 <oslib_test_002_002_execute+0xf0>)
  test_set_step(5);
 8005464:	6023      	str	r3, [r4, #0]
 8005466:	2504      	movs	r5, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8005468:	2000      	movs	r0, #0
 800546a:	f7fe fce9 	bl	8003e40 <chGuardedPoolAllocTimeout.constprop.15>
 800546e:	3000      	adds	r0, #0
 8005470:	bf18      	it	ne
 8005472:	2001      	movne	r0, #1
 8005474:	4631      	mov	r1, r6
 8005476:	f7fb fa53 	bl	8000920 <_test_assert>
 800547a:	b968      	cbnz	r0, 8005498 <oslib_test_002_002_execute+0xd8>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800547c:	3d01      	subs	r5, #1
 800547e:	d1f3      	bne.n	8005468 <oslib_test_002_002_execute+0xa8>
  test_set_step(6);
 8005480:	2306      	movs	r3, #6
 8005482:	6023      	str	r3, [r4, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8005484:	f7fe fcdc 	bl	8003e40 <chGuardedPoolAllocTimeout.constprop.15>
 8005488:	fab0 f080 	clz	r0, r0
 800548c:	0940      	lsrs	r0, r0, #5
 800548e:	4909      	ldr	r1, [pc, #36]	; (80054b4 <oslib_test_002_002_execute+0xf4>)
}
 8005490:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8005494:	f7fb ba44 	b.w	8000920 <_test_assert>
}
 8005498:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800549c:	b672      	cpsid	i
 800549e:	4b08      	ldr	r3, [pc, #32]	; (80054c0 <oslib_test_002_002_execute+0x100>)
 80054a0:	62f3      	str	r3, [r6, #44]	; 0x2c
 80054a2:	e7fe      	b.n	80054a2 <oslib_test_002_002_execute+0xe2>
 80054a4:	20001b3c 	.word	0x20001b3c
 80054a8:	200013f8 	.word	0x200013f8
 80054ac:	20000c14 	.word	0x20000c14
 80054b0:	0800c694 	.word	0x0800c694
 80054b4:	0800c6b0 	.word	0x0800c6b0
 80054b8:	20000c20 	.word	0x20000c20
 80054bc:	200011a0 	.word	0x200011a0
 80054c0:	0800bc50 	.word	0x0800bc50
	...

080054d0 <chPoolFree>:
void chPoolFree(memory_pool_t *mp, void *objp) {
 80054d0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80054d2:	2320      	movs	r3, #32
 80054d4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80054d8:	f7fe f972 	bl	80037c0 <_dbg_check_lock>
  chPoolFreeI(mp, objp);
 80054dc:	f7fb fb90 	bl	8000c00 <chPoolFreeI>
  _dbg_check_unlock();
 80054e0:	f7fe f906 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80054e4:	4b08      	ldr	r3, [pc, #32]	; (8005508 <chPoolFree+0x38>)
 80054e6:	681a      	ldr	r2, [r3, #0]
 80054e8:	429a      	cmp	r2, r3
 80054ea:	d004      	beq.n	80054f6 <chPoolFree+0x26>
 80054ec:	6999      	ldr	r1, [r3, #24]
 80054ee:	6892      	ldr	r2, [r2, #8]
 80054f0:	6889      	ldr	r1, [r1, #8]
 80054f2:	4291      	cmp	r1, r2
 80054f4:	d303      	bcc.n	80054fe <chPoolFree+0x2e>
 80054f6:	2300      	movs	r3, #0
 80054f8:	f383 8811 	msr	BASEPRI, r3
}
 80054fc:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80054fe:	b672      	cpsid	i
 8005500:	4a02      	ldr	r2, [pc, #8]	; (800550c <chPoolFree+0x3c>)
 8005502:	62da      	str	r2, [r3, #44]	; 0x2c
 8005504:	e7fe      	b.n	8005504 <chPoolFree+0x34>
 8005506:	bf00      	nop
 8005508:	200011a0 	.word	0x200011a0
 800550c:	0800bc50 	.word	0x0800bc50

08005510 <dyn_release_object_pool>:
  chDbgCheck(dep != NULL);
 8005510:	b1d8      	cbz	r0, 800554a <dyn_release_object_pool+0x3a>
  chDbgAssert(dep->refs > (ucnt_t)0, "invalid references number");
 8005512:	6843      	ldr	r3, [r0, #4]
 8005514:	b1a3      	cbz	r3, 8005540 <dyn_release_object_pool+0x30>
  dep->refs--;
 8005516:	3b01      	subs	r3, #1
 8005518:	6043      	str	r3, [r0, #4]
  if (dep->refs == (ucnt_t)0) {
 800551a:	b983      	cbnz	r3, 800553e <dyn_release_object_pool+0x2e>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 800551c:	460b      	mov	r3, r1
                                    memory_pool_t *mp) {
 800551e:	b410      	push	{r4}
  while (prev->next != (dyn_element_t *)dlp) {
 8005520:	681c      	ldr	r4, [r3, #0]
 8005522:	42a1      	cmp	r1, r4
 8005524:	d005      	beq.n	8005532 <dyn_release_object_pool+0x22>
    if (prev->next == element) {
 8005526:	42a0      	cmp	r0, r4
 8005528:	d014      	beq.n	8005554 <dyn_release_object_pool+0x44>
 800552a:	4623      	mov	r3, r4
  while (prev->next != (dyn_element_t *)dlp) {
 800552c:	681c      	ldr	r4, [r3, #0]
 800552e:	42a1      	cmp	r1, r4
 8005530:	d1f9      	bne.n	8005526 <dyn_release_object_pool+0x16>
  return NULL;
 8005532:	2000      	movs	r0, #0
    chPoolFree(mp, (void *)dep);
 8005534:	4601      	mov	r1, r0
}
 8005536:	bc10      	pop	{r4}
    chPoolFree(mp, (void *)dep);
 8005538:	4610      	mov	r0, r2
 800553a:	f7ff bfc9 	b.w	80054d0 <chPoolFree>
 800553e:	4770      	bx	lr
 8005540:	b672      	cpsid	i
 8005542:	4b08      	ldr	r3, [pc, #32]	; (8005564 <dyn_release_object_pool+0x54>)
 8005544:	4a08      	ldr	r2, [pc, #32]	; (8005568 <dyn_release_object_pool+0x58>)
 8005546:	62da      	str	r2, [r3, #44]	; 0x2c
 8005548:	e7fe      	b.n	8005548 <dyn_release_object_pool+0x38>
 800554a:	b672      	cpsid	i
 800554c:	4b05      	ldr	r3, [pc, #20]	; (8005564 <dyn_release_object_pool+0x54>)
 800554e:	4a06      	ldr	r2, [pc, #24]	; (8005568 <dyn_release_object_pool+0x58>)
 8005550:	62da      	str	r2, [r3, #44]	; 0x2c
 8005552:	e7fe      	b.n	8005552 <dyn_release_object_pool+0x42>
      prev->next = element->next;
 8005554:	6801      	ldr	r1, [r0, #0]
 8005556:	6019      	str	r1, [r3, #0]
}
 8005558:	bc10      	pop	{r4}
    chPoolFree(mp, (void *)dep);
 800555a:	4601      	mov	r1, r0
 800555c:	4610      	mov	r0, r2
 800555e:	f7ff bfb7 	b.w	80054d0 <chPoolFree>
 8005562:	bf00      	nop
 8005564:	200011a0 	.word	0x200011a0
 8005568:	0800bfc4 	.word	0x0800bfc4
 800556c:	00000000 	.word	0x00000000

08005570 <chPoolAlloc>:
void *chPoolAlloc(memory_pool_t *mp) {
 8005570:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005572:	2320      	movs	r3, #32
 8005574:	4604      	mov	r4, r0
 8005576:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800557a:	f7fe f921 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 800557e:	f7fb fb2f 	bl	8000be0 <chDbgCheckClassI>
  objp = mp->next;
 8005582:	6800      	ldr	r0, [r0, #0]
  if (objp != NULL) {
 8005584:	b180      	cbz	r0, 80055a8 <chPoolAlloc+0x38>
    mp->next = mp->next->next;
 8005586:	6803      	ldr	r3, [r0, #0]
 8005588:	6023      	str	r3, [r4, #0]
  _dbg_check_unlock();
 800558a:	f7fe f8b1 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800558e:	4b0c      	ldr	r3, [pc, #48]	; (80055c0 <chPoolAlloc+0x50>)
 8005590:	681a      	ldr	r2, [r3, #0]
 8005592:	429a      	cmp	r2, r3
 8005594:	d004      	beq.n	80055a0 <chPoolAlloc+0x30>
 8005596:	6999      	ldr	r1, [r3, #24]
 8005598:	6892      	ldr	r2, [r2, #8]
 800559a:	6889      	ldr	r1, [r1, #8]
 800559c:	4291      	cmp	r1, r2
 800559e:	d30a      	bcc.n	80055b6 <chPoolAlloc+0x46>
 80055a0:	2300      	movs	r3, #0
 80055a2:	f383 8811 	msr	BASEPRI, r3
}
 80055a6:	bd10      	pop	{r4, pc}
  else if (mp->provider != NULL) {
 80055a8:	68e3      	ldr	r3, [r4, #12]
 80055aa:	2b00      	cmp	r3, #0
 80055ac:	d0ed      	beq.n	800558a <chPoolAlloc+0x1a>
    objp = mp->provider(mp->object_size, mp->align);
 80055ae:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 80055b2:	4798      	blx	r3
 80055b4:	e7e9      	b.n	800558a <chPoolAlloc+0x1a>
  __ASM volatile ("cpsid i" : : : "memory");
 80055b6:	b672      	cpsid	i
 80055b8:	4a02      	ldr	r2, [pc, #8]	; (80055c4 <chPoolAlloc+0x54>)
 80055ba:	62da      	str	r2, [r3, #44]	; 0x2c
 80055bc:	e7fe      	b.n	80055bc <chPoolAlloc+0x4c>
 80055be:	bf00      	nop
 80055c0:	200011a0 	.word	0x200011a0
 80055c4:	0800bc50 	.word	0x0800bc50
	...

080055d0 <chThdCreateFromMemoryPool.constprop.30>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 80055d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80055d2:	4d1c      	ldr	r5, [pc, #112]	; (8005644 <chThdCreateFromMemoryPool.constprop.30+0x74>)
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 80055d4:	b087      	sub	sp, #28
 80055d6:	4604      	mov	r4, r0
  wsp = chPoolAlloc(mp);
 80055d8:	4628      	mov	r0, r5
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 80055da:	460f      	mov	r7, r1
 80055dc:	4616      	mov	r6, r2
  wsp = chPoolAlloc(mp);
 80055de:	f7ff ffc7 	bl	8005570 <chPoolAlloc>
  if (wsp == NULL) {
 80055e2:	b368      	cbz	r0, 8005640 <chThdCreateFromMemoryPool.constprop.30+0x70>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 80055e4:	686b      	ldr	r3, [r5, #4]
  thread_descriptor_t td = {
 80055e6:	9400      	str	r4, [sp, #0]
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 80055e8:	4403      	add	r3, r0
  thread_descriptor_t td = {
 80055ea:	4c17      	ldr	r4, [pc, #92]	; (8005648 <chThdCreateFromMemoryPool.constprop.30+0x78>)
 80055ec:	9302      	str	r3, [sp, #8]
 80055ee:	9001      	str	r0, [sp, #4]
 80055f0:	9703      	str	r7, [sp, #12]
 80055f2:	9605      	str	r6, [sp, #20]
 80055f4:	9404      	str	r4, [sp, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80055f6:	2320      	movs	r3, #32
 80055f8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80055fc:	f7fe f8e0 	bl	80037c0 <_dbg_check_lock>
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8005600:	4668      	mov	r0, sp
 8005602:	f7fb fb4d 	bl	8000ca0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 8005606:	2302      	movs	r3, #2
 8005608:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tp->mpool = mp;
 800560c:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 800560e:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(&td);
 8005610:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8005612:	f7fd fc65 	bl	8002ee0 <chSchWakeupS>
  _dbg_check_unlock();
 8005616:	f7fe f86b 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800561a:	4b0c      	ldr	r3, [pc, #48]	; (800564c <chThdCreateFromMemoryPool.constprop.30+0x7c>)
 800561c:	681a      	ldr	r2, [r3, #0]
 800561e:	429a      	cmp	r2, r3
 8005620:	d004      	beq.n	800562c <chThdCreateFromMemoryPool.constprop.30+0x5c>
 8005622:	6999      	ldr	r1, [r3, #24]
 8005624:	6892      	ldr	r2, [r2, #8]
 8005626:	6889      	ldr	r1, [r1, #8]
 8005628:	4291      	cmp	r1, r2
 800562a:	d305      	bcc.n	8005638 <chThdCreateFromMemoryPool.constprop.30+0x68>
 800562c:	2300      	movs	r3, #0
 800562e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8005632:	4620      	mov	r0, r4
 8005634:	b007      	add	sp, #28
 8005636:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8005638:	b672      	cpsid	i
 800563a:	4a05      	ldr	r2, [pc, #20]	; (8005650 <chThdCreateFromMemoryPool.constprop.30+0x80>)
 800563c:	62da      	str	r2, [r3, #44]	; 0x2c
 800563e:	e7fe      	b.n	800563e <chThdCreateFromMemoryPool.constprop.30+0x6e>
    return NULL;
 8005640:	4604      	mov	r4, r0
 8005642:	e7f6      	b.n	8005632 <chThdCreateFromMemoryPool.constprop.30+0x62>
 8005644:	200013d8 	.word	0x200013d8
 8005648:	08005061 	.word	0x08005061
 800564c:	200011a0 	.word	0x200011a0
 8005650:	0800bc2c 	.word	0x0800bc2c
	...

08005660 <oslib_test_002_001_execute>:
static void oslib_test_002_001_execute(void) {
 8005660:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_set_step(1);
 8005664:	4d44      	ldr	r5, [pc, #272]	; (8005778 <oslib_test_002_001_execute+0x118>)
 8005666:	4c45      	ldr	r4, [pc, #276]	; (800577c <oslib_test_002_001_execute+0x11c>)
 8005668:	f8df 8120 	ldr.w	r8, [pc, #288]	; 800578c <oslib_test_002_001_execute+0x12c>
 800566c:	4e44      	ldr	r6, [pc, #272]	; (8005780 <oslib_test_002_001_execute+0x120>)
 800566e:	2301      	movs	r3, #1
 8005670:	602b      	str	r3, [r5, #0]
  chPoolFreeI(mp, objp);
 8005672:	46a2      	mov	sl, r4
 8005674:	2704      	movs	r7, #4
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005676:	f04f 0b20 	mov.w	fp, #32
 800567a:	f04f 0900 	mov.w	r9, #0
 800567e:	f38b 8811 	msr	BASEPRI, fp
  _dbg_check_lock();
 8005682:	f7fe f89d 	bl	80037c0 <_dbg_check_lock>
 8005686:	4641      	mov	r1, r8
 8005688:	4650      	mov	r0, sl
 800568a:	f7fb fab9 	bl	8000c00 <chPoolFreeI>
  _dbg_check_unlock();
 800568e:	f7fe f82f 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005692:	6833      	ldr	r3, [r6, #0]
 8005694:	42b3      	cmp	r3, r6
 8005696:	d004      	beq.n	80056a2 <oslib_test_002_001_execute+0x42>
 8005698:	69b2      	ldr	r2, [r6, #24]
 800569a:	689b      	ldr	r3, [r3, #8]
 800569c:	6892      	ldr	r2, [r2, #8]
 800569e:	429a      	cmp	r2, r3
 80056a0:	d345      	bcc.n	800572e <oslib_test_002_001_execute+0xce>
 80056a2:	f389 8811 	msr	BASEPRI, r9
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80056a6:	6863      	ldr	r3, [r4, #4]
  while (n != 0U) {
 80056a8:	3f01      	subs	r7, #1
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80056aa:	4498      	add	r8, r3
  while (n != 0U) {
 80056ac:	d1e7      	bne.n	800567e <oslib_test_002_001_execute+0x1e>
  test_set_step(2);
 80056ae:	2302      	movs	r3, #2
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80056b0:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 800577c <oslib_test_002_001_execute+0x11c>
 80056b4:	4f33      	ldr	r7, [pc, #204]	; (8005784 <oslib_test_002_001_execute+0x124>)
  test_set_step(2);
 80056b6:	602b      	str	r3, [r5, #0]
 80056b8:	2604      	movs	r6, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80056ba:	4640      	mov	r0, r8
 80056bc:	f7ff ff58 	bl	8005570 <chPoolAlloc>
 80056c0:	3000      	adds	r0, #0
 80056c2:	bf18      	it	ne
 80056c4:	2001      	movne	r0, #1
 80056c6:	4639      	mov	r1, r7
 80056c8:	f7fb f92a 	bl	8000920 <_test_assert>
 80056cc:	bb68      	cbnz	r0, 800572a <oslib_test_002_001_execute+0xca>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80056ce:	3e01      	subs	r6, #1
 80056d0:	d1f3      	bne.n	80056ba <oslib_test_002_001_execute+0x5a>
  test_set_step(3);
 80056d2:	2303      	movs	r3, #3
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80056d4:	4829      	ldr	r0, [pc, #164]	; (800577c <oslib_test_002_001_execute+0x11c>)
  test_set_step(3);
 80056d6:	602b      	str	r3, [r5, #0]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80056d8:	f7ff ff4a 	bl	8005570 <chPoolAlloc>
 80056dc:	fab0 f080 	clz	r0, r0
 80056e0:	0940      	lsrs	r0, r0, #5
 80056e2:	4929      	ldr	r1, [pc, #164]	; (8005788 <oslib_test_002_001_execute+0x128>)
 80056e4:	f7fb f91c 	bl	8000920 <_test_assert>
 80056e8:	b9f8      	cbnz	r0, 800572a <oslib_test_002_001_execute+0xca>
      chPoolFree(&mp1, &objects[i]);
 80056ea:	4824      	ldr	r0, [pc, #144]	; (800577c <oslib_test_002_001_execute+0x11c>)
 80056ec:	4927      	ldr	r1, [pc, #156]	; (800578c <oslib_test_002_001_execute+0x12c>)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80056ee:	4f25      	ldr	r7, [pc, #148]	; (8005784 <oslib_test_002_001_execute+0x124>)
 80056f0:	4680      	mov	r8, r0
      chPoolFree(&mp1, &objects[i]);
 80056f2:	f7ff feed 	bl	80054d0 <chPoolFree>
 80056f6:	4926      	ldr	r1, [pc, #152]	; (8005790 <oslib_test_002_001_execute+0x130>)
 80056f8:	f7ff feea 	bl	80054d0 <chPoolFree>
 80056fc:	4925      	ldr	r1, [pc, #148]	; (8005794 <oslib_test_002_001_execute+0x134>)
 80056fe:	f7ff fee7 	bl	80054d0 <chPoolFree>
 8005702:	4925      	ldr	r1, [pc, #148]	; (8005798 <oslib_test_002_001_execute+0x138>)
 8005704:	f7ff fee4 	bl	80054d0 <chPoolFree>
  test_set_step(5);
 8005708:	2305      	movs	r3, #5
 800570a:	602b      	str	r3, [r5, #0]
 800570c:	2604      	movs	r6, #4
 800570e:	e001      	b.n	8005714 <oslib_test_002_001_execute+0xb4>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8005710:	3e01      	subs	r6, #1
 8005712:	d010      	beq.n	8005736 <oslib_test_002_001_execute+0xd6>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8005714:	4640      	mov	r0, r8
 8005716:	f7ff ff2b 	bl	8005570 <chPoolAlloc>
 800571a:	3000      	adds	r0, #0
 800571c:	bf18      	it	ne
 800571e:	2001      	movne	r0, #1
 8005720:	4639      	mov	r1, r7
 8005722:	f7fb f8fd 	bl	8000920 <_test_assert>
 8005726:	2800      	cmp	r0, #0
 8005728:	d0f2      	beq.n	8005710 <oslib_test_002_001_execute+0xb0>
}
 800572a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800572e:	b672      	cpsid	i
 8005730:	4b1a      	ldr	r3, [pc, #104]	; (800579c <oslib_test_002_001_execute+0x13c>)
 8005732:	62f3      	str	r3, [r6, #44]	; 0x2c
 8005734:	e7fe      	b.n	8005734 <oslib_test_002_001_execute+0xd4>
  test_set_step(6);
 8005736:	2306      	movs	r3, #6
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8005738:	4810      	ldr	r0, [pc, #64]	; (800577c <oslib_test_002_001_execute+0x11c>)
  test_set_step(6);
 800573a:	602b      	str	r3, [r5, #0]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800573c:	f7ff ff18 	bl	8005570 <chPoolAlloc>
 8005740:	fab0 f080 	clz	r0, r0
 8005744:	0940      	lsrs	r0, r0, #5
 8005746:	4910      	ldr	r1, [pc, #64]	; (8005788 <oslib_test_002_001_execute+0x128>)
 8005748:	f7fb f8ea 	bl	8000920 <_test_assert>
 800574c:	2800      	cmp	r0, #0
 800574e:	d1ec      	bne.n	800572a <oslib_test_002_001_execute+0xca>
  test_set_step(7);
 8005750:	2107      	movs	r1, #7
  mp->object_size = size;
 8005752:	2304      	movs	r3, #4
  mp->provider = provider;
 8005754:	4a12      	ldr	r2, [pc, #72]	; (80057a0 <oslib_test_002_001_execute+0x140>)
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8005756:	4809      	ldr	r0, [pc, #36]	; (800577c <oslib_test_002_001_execute+0x11c>)
  test_set_step(7);
 8005758:	6029      	str	r1, [r5, #0]
  mp->next = NULL;
 800575a:	6026      	str	r6, [r4, #0]
  mp->align = align;
 800575c:	e9c4 3301 	strd	r3, r3, [r4, #4]
  mp->provider = provider;
 8005760:	60e2      	str	r2, [r4, #12]
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8005762:	f7ff ff05 	bl	8005570 <chPoolAlloc>
 8005766:	fab0 f080 	clz	r0, r0
 800576a:	0940      	lsrs	r0, r0, #5
 800576c:	490d      	ldr	r1, [pc, #52]	; (80057a4 <oslib_test_002_001_execute+0x144>)
}
 800576e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8005772:	f7fb b8d5 	b.w	8000920 <_test_assert>
 8005776:	bf00      	nop
 8005778:	20001b3c 	.word	0x20001b3c
 800577c:	20000c80 	.word	0x20000c80
 8005780:	200011a0 	.word	0x200011a0
 8005784:	0800c694 	.word	0x0800c694
 8005788:	0800c6b0 	.word	0x0800c6b0
 800578c:	200013f8 	.word	0x200013f8
 8005790:	200013fc 	.word	0x200013fc
 8005794:	20001400 	.word	0x20001400
 8005798:	20001404 	.word	0x20001404
 800579c:	0800bc50 	.word	0x0800bc50
 80057a0:	08000851 	.word	0x08000851
 80057a4:	0800c668 	.word	0x0800c668
	...

080057b0 <dyn_create_object_pool>:
                                             memory_pool_t *mp) {
 80057b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_element_t *p = dlp->next;
 80057b2:	680c      	ldr	r4, [r1, #0]
  while (p != (dyn_element_t *)dlp) {
 80057b4:	42a1      	cmp	r1, r4
                                             memory_pool_t *mp) {
 80057b6:	460d      	mov	r5, r1
 80057b8:	4606      	mov	r6, r0
 80057ba:	4617      	mov	r7, r2
  while (p != (dyn_element_t *)dlp) {
 80057bc:	d103      	bne.n	80057c6 <dyn_create_object_pool+0x16>
 80057be:	e00d      	b.n	80057dc <dyn_create_object_pool+0x2c>
    p = p->next;
 80057c0:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 80057c2:	42a5      	cmp	r5, r4
 80057c4:	d00a      	beq.n	80057dc <dyn_create_object_pool+0x2c>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 80057c6:	2208      	movs	r2, #8
 80057c8:	4631      	mov	r1, r6
 80057ca:	18a0      	adds	r0, r4, r2
 80057cc:	f006 f940 	bl	800ba50 <strncmp>
 80057d0:	2800      	cmp	r0, #0
 80057d2:	d1f5      	bne.n	80057c0 <dyn_create_object_pool+0x10>
  if (dep != NULL) {
 80057d4:	b114      	cbz	r4, 80057dc <dyn_create_object_pool+0x2c>
    return NULL;
 80057d6:	4604      	mov	r4, r0
}
 80057d8:	4620      	mov	r0, r4
 80057da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  dep = (dyn_element_t *)chPoolAlloc(mp);
 80057dc:	4638      	mov	r0, r7
 80057de:	f7ff fec7 	bl	8005570 <chPoolAlloc>
  if (dep == NULL) {
 80057e2:	4604      	mov	r4, r0
 80057e4:	b148      	cbz	r0, 80057fa <dyn_create_object_pool+0x4a>
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 80057e6:	2208      	movs	r2, #8
 80057e8:	4410      	add	r0, r2
 80057ea:	4631      	mov	r1, r6
 80057ec:	f006 f97c 	bl	800bae8 <strncpy>
  dep->next = dlp->next;
 80057f0:	682b      	ldr	r3, [r5, #0]
  dep->refs = (ucnt_t)1;
 80057f2:	2201      	movs	r2, #1
  dep->next = dlp->next;
 80057f4:	e9c4 3200 	strd	r3, r2, [r4]
  dlp->next = (dyn_element_t *)dep;
 80057f8:	602c      	str	r4, [r5, #0]
}
 80057fa:	4620      	mov	r0, r4
 80057fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80057fe:	bf00      	nop

08005800 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8005800:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005802:	2320      	movs	r3, #32
 8005804:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005808:	f7fd ffda 	bl	80037c0 <_dbg_check_lock>

  chSysLock();
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 800580c:	f890 3020 	ldrb.w	r3, [r0, #32]
 8005810:	2b0d      	cmp	r3, #13
 8005812:	d004      	beq.n	800581e <chMsgRelease+0x1e>
  __ASM volatile ("cpsid i" : : : "memory");
 8005814:	b672      	cpsid	i
 8005816:	4b0d      	ldr	r3, [pc, #52]	; (800584c <chMsgRelease+0x4c>)
 8005818:	4a0d      	ldr	r2, [pc, #52]	; (8005850 <chMsgRelease+0x50>)
 800581a:	62da      	str	r2, [r3, #44]	; 0x2c
 800581c:	e7fe      	b.n	800581c <chMsgRelease+0x1c>
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();
 800581e:	f7fb f9cf 	bl	8000bc0 <chDbgCheckClassS>

  chSchWakeupS(tp, msg);
 8005822:	f7fd fb5d 	bl	8002ee0 <chSchWakeupS>
  _dbg_check_unlock();
 8005826:	f7fd ff63 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800582a:	4b08      	ldr	r3, [pc, #32]	; (800584c <chMsgRelease+0x4c>)
 800582c:	681a      	ldr	r2, [r3, #0]
 800582e:	429a      	cmp	r2, r3
 8005830:	d004      	beq.n	800583c <chMsgRelease+0x3c>
 8005832:	6999      	ldr	r1, [r3, #24]
 8005834:	6892      	ldr	r2, [r2, #8]
 8005836:	6889      	ldr	r1, [r1, #8]
 8005838:	4291      	cmp	r1, r2
 800583a:	d303      	bcc.n	8005844 <chMsgRelease+0x44>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800583c:	2300      	movs	r3, #0
 800583e:	f383 8811 	msr	BASEPRI, r3
  chMsgReleaseS(tp, msg);
  chSysUnlock();
}
 8005842:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8005844:	b672      	cpsid	i
 8005846:	4a03      	ldr	r2, [pc, #12]	; (8005854 <chMsgRelease+0x54>)
 8005848:	62da      	str	r2, [r3, #44]	; 0x2c
 800584a:	e7fe      	b.n	800584a <chMsgRelease+0x4a>
 800584c:	200011a0 	.word	0x200011a0
 8005850:	0800bd90 	.word	0x0800bd90
 8005854:	0800bc20 	.word	0x0800bc20
	...

08005860 <chMsgWait>:
thread_t *chMsgWait(void) {
 8005860:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005862:	2320      	movs	r3, #32
 8005864:	f383 8811 	msr	BASEPRI, r3
  if (!chMsgIsPendingI(currp)) {
 8005868:	4c15      	ldr	r4, [pc, #84]	; (80058c0 <chMsgWait+0x60>)
  _dbg_check_lock();
 800586a:	f7fd ffa9 	bl	80037c0 <_dbg_check_lock>
 800586e:	69a1      	ldr	r1, [r4, #24]
  chDbgCheckClassI();
 8005870:	f7fb f9b6 	bl	8000be0 <chDbgCheckClassI>
  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 8005874:	460b      	mov	r3, r1
 8005876:	f853 0f2c 	ldr.w	r0, [r3, #44]!
 800587a:	4298      	cmp	r0, r3
 800587c:	d013      	beq.n	80058a6 <chMsgWait+0x46>
  tqp->next             = tp->queue.next;
 800587e:	6802      	ldr	r2, [r0, #0]
 8005880:	62ca      	str	r2, [r1, #44]	; 0x2c
  tp->state = CH_STATE_SNDMSG;
 8005882:	210d      	movs	r1, #13
  tqp->next->queue.prev = (thread_t *)tqp;
 8005884:	6053      	str	r3, [r2, #4]
 8005886:	f880 1020 	strb.w	r1, [r0, #32]
  _dbg_check_unlock();
 800588a:	f7fd ff31 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800588e:	6823      	ldr	r3, [r4, #0]
 8005890:	42a3      	cmp	r3, r4
 8005892:	d004      	beq.n	800589e <chMsgWait+0x3e>
 8005894:	69a2      	ldr	r2, [r4, #24]
 8005896:	689b      	ldr	r3, [r3, #8]
 8005898:	6892      	ldr	r2, [r2, #8]
 800589a:	429a      	cmp	r2, r3
 800589c:	d30b      	bcc.n	80058b6 <chMsgWait+0x56>
 800589e:	2300      	movs	r3, #0
 80058a0:	f383 8811 	msr	BASEPRI, r3
}
 80058a4:	bd10      	pop	{r4, pc}
    chSchGoSleepS(CH_STATE_WTMSG);
 80058a6:	200e      	movs	r0, #14
 80058a8:	f7fd fb4a 	bl	8002f40 <chSchGoSleepS>
 80058ac:	69a1      	ldr	r1, [r4, #24]
 80058ae:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
 80058b0:	f101 032c 	add.w	r3, r1, #44	; 0x2c
 80058b4:	e7e3      	b.n	800587e <chMsgWait+0x1e>
  __ASM volatile ("cpsid i" : : : "memory");
 80058b6:	b672      	cpsid	i
 80058b8:	4b02      	ldr	r3, [pc, #8]	; (80058c4 <chMsgWait+0x64>)
 80058ba:	62e3      	str	r3, [r4, #44]	; 0x2c
 80058bc:	e7fe      	b.n	80058bc <chMsgWait+0x5c>
 80058be:	bf00      	nop
 80058c0:	200011a0 	.word	0x200011a0
 80058c4:	0800bc20 	.word	0x0800bc20
	...

080058d0 <bmk_thread1>:
static THD_FUNCTION(bmk_thread1, p) {
 80058d0:	b510      	push	{r4, lr}
    tp = chMsgWait();
 80058d2:	f7ff ffc5 	bl	8005860 <chMsgWait>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 80058d6:	f890 2020 	ldrb.w	r2, [r0, #32]
 80058da:	2a0d      	cmp	r2, #13
 80058dc:	d004      	beq.n	80058e8 <bmk_thread1+0x18>
 80058de:	b672      	cpsid	i
 80058e0:	4b05      	ldr	r3, [pc, #20]	; (80058f8 <bmk_thread1+0x28>)
 80058e2:	4a06      	ldr	r2, [pc, #24]	; (80058fc <bmk_thread1+0x2c>)
 80058e4:	62da      	str	r2, [r3, #44]	; 0x2c
 80058e6:	e7fe      	b.n	80058e6 <bmk_thread1+0x16>
  return tp->u.sentmsg;
 80058e8:	6a44      	ldr	r4, [r0, #36]	; 0x24
    chMsgRelease(tp, msg);
 80058ea:	4621      	mov	r1, r4
 80058ec:	f7ff ff88 	bl	8005800 <chMsgRelease>
  } while (msg);
 80058f0:	2c00      	cmp	r4, #0
 80058f2:	d1ee      	bne.n	80058d2 <bmk_thread1+0x2>
}
 80058f4:	bd10      	pop	{r4, pc}
 80058f6:	bf00      	nop
 80058f8:	200011a0 	.word	0x200011a0
 80058fc:	0800bd30 	.word	0x0800bd30

08005900 <chMsgSend>:
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8005900:	b538      	push	{r3, r4, r5, lr}
  chDbgCheck(tp != NULL);
 8005902:	b320      	cbz	r0, 800594e <chMsgSend+0x4e>
  thread_t *ctp = currp;
 8005904:	4d18      	ldr	r5, [pc, #96]	; (8005968 <chMsgSend+0x68>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005906:	2320      	movs	r3, #32
 8005908:	69ac      	ldr	r4, [r5, #24]
 800590a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800590e:	f7fd ff57 	bl	80037c0 <_dbg_check_lock>
  ctp->u.sentmsg = msg;
 8005912:	6261      	str	r1, [r4, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 8005914:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8005916:	6063      	str	r3, [r4, #4]
  msg_insert(ctp, &tp->msgqueue);
 8005918:	f100 022c 	add.w	r2, r0, #44	; 0x2c
  tp->queue.next             = (thread_t *)tqp;
 800591c:	6022      	str	r2, [r4, #0]
  tp->queue.prev->queue.next = tp;
 800591e:	601c      	str	r4, [r3, #0]
  if (tp->state == CH_STATE_WTMSG) {
 8005920:	f890 3020 	ldrb.w	r3, [r0, #32]
  tqp->prev                  = tp;
 8005924:	6304      	str	r4, [r0, #48]	; 0x30
 8005926:	2b0e      	cmp	r3, #14
 8005928:	d01a      	beq.n	8005960 <chMsgSend+0x60>
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 800592a:	200c      	movs	r0, #12
 800592c:	f7fd fb08 	bl	8002f40 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8005930:	6a60      	ldr	r0, [r4, #36]	; 0x24
  _dbg_check_unlock();
 8005932:	f7fd fedd 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005936:	682b      	ldr	r3, [r5, #0]
 8005938:	42ab      	cmp	r3, r5
 800593a:	d004      	beq.n	8005946 <chMsgSend+0x46>
 800593c:	69aa      	ldr	r2, [r5, #24]
 800593e:	689b      	ldr	r3, [r3, #8]
 8005940:	6892      	ldr	r2, [r2, #8]
 8005942:	429a      	cmp	r2, r3
 8005944:	d308      	bcc.n	8005958 <chMsgSend+0x58>
 8005946:	2300      	movs	r3, #0
 8005948:	f383 8811 	msr	BASEPRI, r3
}
 800594c:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800594e:	b672      	cpsid	i
 8005950:	4b05      	ldr	r3, [pc, #20]	; (8005968 <chMsgSend+0x68>)
 8005952:	4a06      	ldr	r2, [pc, #24]	; (800596c <chMsgSend+0x6c>)
 8005954:	62da      	str	r2, [r3, #44]	; 0x2c
 8005956:	e7fe      	b.n	8005956 <chMsgSend+0x56>
 8005958:	b672      	cpsid	i
 800595a:	4b05      	ldr	r3, [pc, #20]	; (8005970 <chMsgSend+0x70>)
 800595c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800595e:	e7fe      	b.n	800595e <chMsgSend+0x5e>
    (void) chSchReadyI(tp);
 8005960:	f7fb f9fe 	bl	8000d60 <chSchReadyI>
 8005964:	e7e1      	b.n	800592a <chMsgSend+0x2a>
 8005966:	bf00      	nop
 8005968:	200011a0 	.word	0x200011a0
 800596c:	0800bd3c 	.word	0x0800bd3c
 8005970:	0800bc20 	.word	0x0800bc20
	...

08005980 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8005980:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 8005982:	2141      	movs	r1, #65	; 0x41
static THD_FUNCTION(msg_thread1, p) {
 8005984:	4604      	mov	r4, r0
  chMsgSend(p, 'A');
 8005986:	f7ff ffbb 	bl	8005900 <chMsgSend>
  chMsgSend(p, 'B');
 800598a:	4620      	mov	r0, r4
 800598c:	2142      	movs	r1, #66	; 0x42
 800598e:	f7ff ffb7 	bl	8005900 <chMsgSend>
  chMsgSend(p, 'C');
 8005992:	4620      	mov	r0, r4
 8005994:	2143      	movs	r1, #67	; 0x43
 8005996:	f7ff ffb3 	bl	8005900 <chMsgSend>
  chMsgSend(p, 'D');
 800599a:	4620      	mov	r0, r4
 800599c:	2144      	movs	r1, #68	; 0x44
}
 800599e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMsgSend(p, 'D');
 80059a2:	f7ff bfad 	b.w	8005900 <chMsgSend>
 80059a6:	bf00      	nop
	...

080059b0 <chEvtAddEvents>:
eventmask_t chEvtAddEvents(eventmask_t events) {
 80059b0:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80059b2:	2320      	movs	r3, #32
 80059b4:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline eventmask_t chEvtAddEventsI(eventmask_t events) {

  return currp->epending |= events;
 80059b8:	4c0c      	ldr	r4, [pc, #48]	; (80059ec <chEvtAddEvents+0x3c>)
  _dbg_check_lock();
 80059ba:	f7fd ff01 	bl	80037c0 <_dbg_check_lock>
 80059be:	69a3      	ldr	r3, [r4, #24]
 80059c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80059c2:	4310      	orrs	r0, r2
 80059c4:	6358      	str	r0, [r3, #52]	; 0x34
  _dbg_check_unlock();
 80059c6:	f7fd fe93 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80059ca:	6823      	ldr	r3, [r4, #0]
 80059cc:	42a3      	cmp	r3, r4
 80059ce:	d004      	beq.n	80059da <chEvtAddEvents+0x2a>
 80059d0:	69a2      	ldr	r2, [r4, #24]
 80059d2:	689b      	ldr	r3, [r3, #8]
 80059d4:	6892      	ldr	r2, [r2, #8]
 80059d6:	429a      	cmp	r2, r3
 80059d8:	d303      	bcc.n	80059e2 <chEvtAddEvents+0x32>
 80059da:	2300      	movs	r3, #0
 80059dc:	f383 8811 	msr	BASEPRI, r3
}
 80059e0:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80059e2:	b672      	cpsid	i
 80059e4:	4b02      	ldr	r3, [pc, #8]	; (80059f0 <chEvtAddEvents+0x40>)
 80059e6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80059e8:	e7fe      	b.n	80059e8 <chEvtAddEvents+0x38>
 80059ea:	bf00      	nop
 80059ec:	200011a0 	.word	0x200011a0
 80059f0:	0800bc14 	.word	0x0800bc14
	...

08005a00 <chEvtUnregister>:
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 8005a00:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005a02:	2320      	movs	r3, #32
 8005a04:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005a08:	f7fd feda 	bl	80037c0 <_dbg_check_lock>
 8005a0c:	4603      	mov	r3, r0
 8005a0e:	e002      	b.n	8005a16 <chEvtUnregister+0x16>
    if (p->next == elp) {
 8005a10:	428a      	cmp	r2, r1
 8005a12:	d012      	beq.n	8005a3a <chEvtUnregister+0x3a>
 8005a14:	4613      	mov	r3, r2
  while (p->next != (event_listener_t *)esp) {
 8005a16:	681a      	ldr	r2, [r3, #0]
 8005a18:	4282      	cmp	r2, r0
 8005a1a:	d1f9      	bne.n	8005a10 <chEvtUnregister+0x10>
  _dbg_check_unlock();
 8005a1c:	f7fd fe68 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005a20:	4b09      	ldr	r3, [pc, #36]	; (8005a48 <chEvtUnregister+0x48>)
 8005a22:	681a      	ldr	r2, [r3, #0]
 8005a24:	429a      	cmp	r2, r3
 8005a26:	d004      	beq.n	8005a32 <chEvtUnregister+0x32>
 8005a28:	6999      	ldr	r1, [r3, #24]
 8005a2a:	6892      	ldr	r2, [r2, #8]
 8005a2c:	6889      	ldr	r1, [r1, #8]
 8005a2e:	4291      	cmp	r1, r2
 8005a30:	d306      	bcc.n	8005a40 <chEvtUnregister+0x40>
 8005a32:	2300      	movs	r3, #0
 8005a34:	f383 8811 	msr	BASEPRI, r3
}
 8005a38:	bd08      	pop	{r3, pc}
      p->next = elp->next;
 8005a3a:	680a      	ldr	r2, [r1, #0]
 8005a3c:	601a      	str	r2, [r3, #0]
 8005a3e:	e7ed      	b.n	8005a1c <chEvtUnregister+0x1c>
  __ASM volatile ("cpsid i" : : : "memory");
 8005a40:	b672      	cpsid	i
 8005a42:	4a02      	ldr	r2, [pc, #8]	; (8005a4c <chEvtUnregister+0x4c>)
 8005a44:	62da      	str	r2, [r3, #44]	; 0x2c
 8005a46:	e7fe      	b.n	8005a46 <chEvtUnregister+0x46>
 8005a48:	200011a0 	.word	0x200011a0
 8005a4c:	0800bc14 	.word	0x0800bc14

08005a50 <rt_test_008_001_execute>:
static void rt_test_008_001_execute(void) {
 8005a50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  esp->next = (event_listener_t *)esp;
 8005a54:	4d72      	ldr	r5, [pc, #456]	; (8005c20 <rt_test_008_001_execute+0x1d0>)
  test_set_step(2);
 8005a56:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 8005c38 <rt_test_008_001_execute+0x1e8>
 8005a5a:	602d      	str	r5, [r5, #0]
 8005a5c:	2302      	movs	r3, #2
 8005a5e:	f8c8 3000 	str.w	r3, [r8]
static void rt_test_008_001_execute(void) {
 8005a62:	b08a      	sub	sp, #40	; 0x28
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005a64:	2320      	movs	r3, #32
 8005a66:	f383 8811 	msr	BASEPRI, r3
  elp->listener = currp;
 8005a6a:	4c6e      	ldr	r4, [pc, #440]	; (8005c24 <rt_test_008_001_execute+0x1d4>)
  elp->next     = esp->next;
 8005a6c:	af0a      	add	r7, sp, #40	; 0x28
  _dbg_check_lock();
 8005a6e:	f7fd fea7 	bl	80037c0 <_dbg_check_lock>
 8005a72:	682b      	ldr	r3, [r5, #0]
 8005a74:	f847 3d14 	str.w	r3, [r7, #-20]!
  elp->listener = currp;
 8005a78:	69a3      	ldr	r3, [r4, #24]
 8005a7a:	9306      	str	r3, [sp, #24]
  elp->events   = events;
 8005a7c:	2301      	movs	r3, #1
  elp->flags    = (eventflags_t)0;
 8005a7e:	2200      	movs	r2, #0
  elp->events   = events;
 8005a80:	9307      	str	r3, [sp, #28]
  elp->wflags   = wflags;
 8005a82:	f04f 33ff 	mov.w	r3, #4294967295
 8005a86:	e9cd 2308 	strd	r2, r3, [sp, #32]
  esp->next     = elp;
 8005a8a:	602f      	str	r7, [r5, #0]
  _dbg_check_unlock();
 8005a8c:	f7fd fe30 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005a90:	6823      	ldr	r3, [r4, #0]
 8005a92:	42a3      	cmp	r3, r4
 8005a94:	d004      	beq.n	8005aa0 <rt_test_008_001_execute+0x50>
 8005a96:	69a2      	ldr	r2, [r4, #24]
 8005a98:	689b      	ldr	r3, [r3, #8]
 8005a9a:	6892      	ldr	r2, [r2, #8]
 8005a9c:	429a      	cmp	r2, r3
 8005a9e:	d372      	bcc.n	8005b86 <rt_test_008_001_execute+0x136>
 8005aa0:	2100      	movs	r1, #0
 8005aa2:	f381 8811 	msr	BASEPRI, r1
 8005aa6:	2320      	movs	r3, #32
 8005aa8:	f383 8811 	msr	BASEPRI, r3
  elp->next     = esp->next;
 8005aac:	ae0a      	add	r6, sp, #40	; 0x28
  _dbg_check_lock();
 8005aae:	f7fd fe87 	bl	80037c0 <_dbg_check_lock>
 8005ab2:	682b      	ldr	r3, [r5, #0]
 8005ab4:	f846 3d28 	str.w	r3, [r6, #-40]!
  elp->listener = currp;
 8005ab8:	69a3      	ldr	r3, [r4, #24]
 8005aba:	9301      	str	r3, [sp, #4]
  elp->events   = events;
 8005abc:	2202      	movs	r2, #2
  elp->wflags   = wflags;
 8005abe:	f04f 33ff 	mov.w	r3, #4294967295
 8005ac2:	9304      	str	r3, [sp, #16]
  elp->flags    = (eventflags_t)0;
 8005ac4:	9103      	str	r1, [sp, #12]
  elp->events   = events;
 8005ac6:	9202      	str	r2, [sp, #8]
  esp->next     = elp;
 8005ac8:	602e      	str	r6, [r5, #0]
  _dbg_check_unlock();
 8005aca:	f7fd fe11 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005ace:	6823      	ldr	r3, [r4, #0]
 8005ad0:	42a3      	cmp	r3, r4
 8005ad2:	d004      	beq.n	8005ade <rt_test_008_001_execute+0x8e>
 8005ad4:	69a2      	ldr	r2, [r4, #24]
 8005ad6:	689b      	ldr	r3, [r3, #8]
 8005ad8:	6892      	ldr	r2, [r2, #8]
 8005ada:	429a      	cmp	r2, r3
 8005adc:	d341      	bcc.n	8005b62 <rt_test_008_001_execute+0x112>
 8005ade:	2300      	movs	r3, #0
 8005ae0:	f383 8811 	msr	BASEPRI, r3
 8005ae4:	2320      	movs	r3, #32
 8005ae6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005aea:	f7fd fe69 	bl	80037c0 <_dbg_check_lock>
  return (bool)(esp != (event_source_t *)esp->next);
 8005aee:	6828      	ldr	r0, [r5, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8005af0:	494d      	ldr	r1, [pc, #308]	; (8005c28 <rt_test_008_001_execute+0x1d8>)
 8005af2:	1b40      	subs	r0, r0, r5
 8005af4:	bf18      	it	ne
 8005af6:	2001      	movne	r0, #1
 8005af8:	f7fa ff12 	bl	8000920 <_test_assert>
 8005afc:	2800      	cmp	r0, #0
 8005afe:	d134      	bne.n	8005b6a <rt_test_008_001_execute+0x11a>
  _dbg_check_unlock();
 8005b00:	f7fd fdf6 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005b04:	6823      	ldr	r3, [r4, #0]
 8005b06:	42a3      	cmp	r3, r4
 8005b08:	d004      	beq.n	8005b14 <rt_test_008_001_execute+0xc4>
 8005b0a:	69a2      	ldr	r2, [r4, #24]
 8005b0c:	689b      	ldr	r3, [r3, #8]
 8005b0e:	6892      	ldr	r2, [r2, #8]
 8005b10:	429a      	cmp	r2, r3
 8005b12:	d33c      	bcc.n	8005b8e <rt_test_008_001_execute+0x13e>
 8005b14:	2300      	movs	r3, #0
 8005b16:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 8005b1a:	2303      	movs	r3, #3
    chEvtUnregister(&es1, &el1);
 8005b1c:	4639      	mov	r1, r7
 8005b1e:	4840      	ldr	r0, [pc, #256]	; (8005c20 <rt_test_008_001_execute+0x1d0>)
  test_set_step(3);
 8005b20:	f8c8 3000 	str.w	r3, [r8]
    chEvtUnregister(&es1, &el1);
 8005b24:	f7ff ff6c 	bl	8005a00 <chEvtUnregister>
 8005b28:	2320      	movs	r3, #32
 8005b2a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005b2e:	f7fd fe47 	bl	80037c0 <_dbg_check_lock>
 8005b32:	6828      	ldr	r0, [r5, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8005b34:	493c      	ldr	r1, [pc, #240]	; (8005c28 <rt_test_008_001_execute+0x1d8>)
 8005b36:	1b40      	subs	r0, r0, r5
 8005b38:	bf18      	it	ne
 8005b3a:	2001      	movne	r0, #1
 8005b3c:	f7fa fef0 	bl	8000920 <_test_assert>
 8005b40:	b348      	cbz	r0, 8005b96 <rt_test_008_001_execute+0x146>
  _dbg_check_unlock();
 8005b42:	f7fd fdd5 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005b46:	6823      	ldr	r3, [r4, #0]
 8005b48:	42a3      	cmp	r3, r4
 8005b4a:	d004      	beq.n	8005b56 <rt_test_008_001_execute+0x106>
 8005b4c:	69a2      	ldr	r2, [r4, #24]
 8005b4e:	689b      	ldr	r3, [r3, #8]
 8005b50:	6892      	ldr	r2, [r2, #8]
 8005b52:	429a      	cmp	r2, r3
 8005b54:	d35c      	bcc.n	8005c10 <rt_test_008_001_execute+0x1c0>
 8005b56:	2300      	movs	r3, #0
 8005b58:	f383 8811 	msr	BASEPRI, r3
}
 8005b5c:	b00a      	add	sp, #40	; 0x28
 8005b5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8005b62:	b672      	cpsid	i
 8005b64:	4b31      	ldr	r3, [pc, #196]	; (8005c2c <rt_test_008_001_execute+0x1dc>)
 8005b66:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005b68:	e7fe      	b.n	8005b68 <rt_test_008_001_execute+0x118>
  _dbg_check_unlock();
 8005b6a:	f7fd fdc1 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005b6e:	6823      	ldr	r3, [r4, #0]
 8005b70:	42a3      	cmp	r3, r4
 8005b72:	d0f0      	beq.n	8005b56 <rt_test_008_001_execute+0x106>
 8005b74:	69a2      	ldr	r2, [r4, #24]
 8005b76:	689b      	ldr	r3, [r3, #8]
 8005b78:	6892      	ldr	r2, [r2, #8]
 8005b7a:	429a      	cmp	r2, r3
 8005b7c:	d2eb      	bcs.n	8005b56 <rt_test_008_001_execute+0x106>
 8005b7e:	b672      	cpsid	i
 8005b80:	4b2b      	ldr	r3, [pc, #172]	; (8005c30 <rt_test_008_001_execute+0x1e0>)
 8005b82:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005b84:	e7fe      	b.n	8005b84 <rt_test_008_001_execute+0x134>
 8005b86:	b672      	cpsid	i
 8005b88:	4b28      	ldr	r3, [pc, #160]	; (8005c2c <rt_test_008_001_execute+0x1dc>)
 8005b8a:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005b8c:	e7fe      	b.n	8005b8c <rt_test_008_001_execute+0x13c>
 8005b8e:	b672      	cpsid	i
 8005b90:	4b27      	ldr	r3, [pc, #156]	; (8005c30 <rt_test_008_001_execute+0x1e0>)
 8005b92:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005b94:	e7fe      	b.n	8005b94 <rt_test_008_001_execute+0x144>
  _dbg_check_unlock();
 8005b96:	f7fd fdab 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005b9a:	6823      	ldr	r3, [r4, #0]
 8005b9c:	42a3      	cmp	r3, r4
 8005b9e:	d004      	beq.n	8005baa <rt_test_008_001_execute+0x15a>
 8005ba0:	69a2      	ldr	r2, [r4, #24]
 8005ba2:	689b      	ldr	r3, [r3, #8]
 8005ba4:	6892      	ldr	r2, [r2, #8]
 8005ba6:	429a      	cmp	r2, r3
 8005ba8:	d336      	bcc.n	8005c18 <rt_test_008_001_execute+0x1c8>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005baa:	2300      	movs	r3, #0
 8005bac:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
 8005bb0:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el2);
 8005bb2:	4631      	mov	r1, r6
 8005bb4:	481a      	ldr	r0, [pc, #104]	; (8005c20 <rt_test_008_001_execute+0x1d0>)
  test_set_step(4);
 8005bb6:	f8c8 3000 	str.w	r3, [r8]
    chEvtUnregister(&es1, &el2);
 8005bba:	f7ff ff21 	bl	8005a00 <chEvtUnregister>
 8005bbe:	2320      	movs	r3, #32
 8005bc0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005bc4:	f7fd fdfc 	bl	80037c0 <_dbg_check_lock>
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 8005bc8:	6828      	ldr	r0, [r5, #0]
 8005bca:	491a      	ldr	r1, [pc, #104]	; (8005c34 <rt_test_008_001_execute+0x1e4>)
 8005bcc:	1b43      	subs	r3, r0, r5
 8005bce:	4258      	negs	r0, r3
 8005bd0:	4158      	adcs	r0, r3
 8005bd2:	f7fa fea5 	bl	8000920 <_test_assert>
 8005bd6:	b168      	cbz	r0, 8005bf4 <rt_test_008_001_execute+0x1a4>
  _dbg_check_unlock();
 8005bd8:	f7fd fd8a 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005bdc:	6823      	ldr	r3, [r4, #0]
 8005bde:	42a3      	cmp	r3, r4
 8005be0:	d0b9      	beq.n	8005b56 <rt_test_008_001_execute+0x106>
 8005be2:	69a2      	ldr	r2, [r4, #24]
 8005be4:	689b      	ldr	r3, [r3, #8]
 8005be6:	6892      	ldr	r2, [r2, #8]
 8005be8:	429a      	cmp	r2, r3
 8005bea:	d2b4      	bcs.n	8005b56 <rt_test_008_001_execute+0x106>
  __ASM volatile ("cpsid i" : : : "memory");
 8005bec:	b672      	cpsid	i
 8005bee:	4b10      	ldr	r3, [pc, #64]	; (8005c30 <rt_test_008_001_execute+0x1e0>)
 8005bf0:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005bf2:	e7fe      	b.n	8005bf2 <rt_test_008_001_execute+0x1a2>
  _dbg_check_unlock();
 8005bf4:	f7fd fd7c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005bf8:	6823      	ldr	r3, [r4, #0]
 8005bfa:	42a3      	cmp	r3, r4
 8005bfc:	d0ab      	beq.n	8005b56 <rt_test_008_001_execute+0x106>
 8005bfe:	69a2      	ldr	r2, [r4, #24]
 8005c00:	689b      	ldr	r3, [r3, #8]
 8005c02:	6892      	ldr	r2, [r2, #8]
 8005c04:	429a      	cmp	r2, r3
 8005c06:	d2a6      	bcs.n	8005b56 <rt_test_008_001_execute+0x106>
 8005c08:	b672      	cpsid	i
 8005c0a:	4b09      	ldr	r3, [pc, #36]	; (8005c30 <rt_test_008_001_execute+0x1e0>)
 8005c0c:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005c0e:	e7fe      	b.n	8005c0e <rt_test_008_001_execute+0x1be>
 8005c10:	b672      	cpsid	i
 8005c12:	4b07      	ldr	r3, [pc, #28]	; (8005c30 <rt_test_008_001_execute+0x1e0>)
 8005c14:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005c16:	e7fe      	b.n	8005c16 <rt_test_008_001_execute+0x1c6>
 8005c18:	b672      	cpsid	i
 8005c1a:	4b05      	ldr	r3, [pc, #20]	; (8005c30 <rt_test_008_001_execute+0x1e0>)
 8005c1c:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005c1e:	e7fe      	b.n	8005c1e <rt_test_008_001_execute+0x1ce>
 8005c20:	20000c0c 	.word	0x20000c0c
 8005c24:	200011a0 	.word	0x200011a0
 8005c28:	0800d748 	.word	0x0800d748
 8005c2c:	0800bc14 	.word	0x0800bc14
 8005c30:	0800bcb0 	.word	0x0800bcb0
 8005c34:	0800d754 	.word	0x0800d754
 8005c38:	20001b3c 	.word	0x20001b3c
 8005c3c:	00000000 	.word	0x00000000

08005c40 <chMtxUnlock>:
void chMtxUnlock(mutex_t *mp) {
 8005c40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck(mp != NULL);
 8005c42:	b1b8      	cbz	r0, 8005c74 <chMtxUnlock+0x34>
  thread_t *ctp = currp;
 8005c44:	4f2b      	ldr	r7, [pc, #172]	; (8005cf4 <chMtxUnlock+0xb4>)
 8005c46:	4601      	mov	r1, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005c48:	2320      	movs	r3, #32
 8005c4a:	69bd      	ldr	r5, [r7, #24]
 8005c4c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005c50:	f7fd fdb6 	bl	80037c0 <_dbg_check_lock>
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8005c54:	6bae      	ldr	r6, [r5, #56]	; 0x38
 8005c56:	2e00      	cmp	r6, #0
 8005c58:	d048      	beq.n	8005cec <chMtxUnlock+0xac>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8005c5a:	68b3      	ldr	r3, [r6, #8]
 8005c5c:	42ab      	cmp	r3, r5
 8005c5e:	d003      	beq.n	8005c68 <chMtxUnlock+0x28>
  __ASM volatile ("cpsid i" : : : "memory");
 8005c60:	b672      	cpsid	i
 8005c62:	4b25      	ldr	r3, [pc, #148]	; (8005cf8 <chMtxUnlock+0xb8>)
 8005c64:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005c66:	e7fe      	b.n	8005c66 <chMtxUnlock+0x26>
    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8005c68:	4286      	cmp	r6, r0
 8005c6a:	d008      	beq.n	8005c7e <chMtxUnlock+0x3e>
 8005c6c:	b672      	cpsid	i
 8005c6e:	4b22      	ldr	r3, [pc, #136]	; (8005cf8 <chMtxUnlock+0xb8>)
 8005c70:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005c72:	e7fe      	b.n	8005c72 <chMtxUnlock+0x32>
 8005c74:	b672      	cpsid	i
 8005c76:	4b1f      	ldr	r3, [pc, #124]	; (8005cf4 <chMtxUnlock+0xb4>)
 8005c78:	4a1f      	ldr	r2, [pc, #124]	; (8005cf8 <chMtxUnlock+0xb8>)
 8005c7a:	62da      	str	r2, [r3, #44]	; 0x2c
 8005c7c:	e7fe      	b.n	8005c7c <chMtxUnlock+0x3c>
    ctp->mtxlist = mp->next;
 8005c7e:	68c0      	ldr	r0, [r0, #12]
 8005c80:	63a8      	str	r0, [r5, #56]	; 0x38
 8005c82:	f7fa ff9d 	bl	8000bc0 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8005c86:	680c      	ldr	r4, [r1, #0]
    if (chMtxQueueNotEmptyS(mp)) {
 8005c88:	42a1      	cmp	r1, r4
 8005c8a:	d02c      	beq.n	8005ce6 <chMtxUnlock+0xa6>
      tprio_t newprio = ctp->realprio;
 8005c8c:	6bee      	ldr	r6, [r5, #60]	; 0x3c
      while (lmp != NULL) {
 8005c8e:	b158      	cbz	r0, 8005ca8 <chMtxUnlock+0x68>
 8005c90:	f7fa ff96 	bl	8000bc0 <chDbgCheckClassS>
 8005c94:	6803      	ldr	r3, [r0, #0]
        if (chMtxQueueNotEmptyS(lmp) &&
 8005c96:	4298      	cmp	r0, r3
 8005c98:	d003      	beq.n	8005ca2 <chMtxUnlock+0x62>
 8005c9a:	689b      	ldr	r3, [r3, #8]
 8005c9c:	429e      	cmp	r6, r3
 8005c9e:	bf38      	it	cc
 8005ca0:	461e      	movcc	r6, r3
        lmp = lmp->next;
 8005ca2:	68c0      	ldr	r0, [r0, #12]
      while (lmp != NULL) {
 8005ca4:	2800      	cmp	r0, #0
 8005ca6:	d1f3      	bne.n	8005c90 <chMtxUnlock+0x50>
  tqp->next             = tp->queue.next;
 8005ca8:	6823      	ldr	r3, [r4, #0]
      mp->next = tp->mtxlist;
 8005caa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      ctp->prio = newprio;
 8005cac:	60ae      	str	r6, [r5, #8]
      (void) chSchReadyI(tp);
 8005cae:	4620      	mov	r0, r4
 8005cb0:	600b      	str	r3, [r1, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005cb2:	6059      	str	r1, [r3, #4]
      mp->next = tp->mtxlist;
 8005cb4:	e9c1 4202 	strd	r4, r2, [r1, #8]
      tp->mtxlist = mp;
 8005cb8:	63a1      	str	r1, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 8005cba:	f7fb f851 	bl	8000d60 <chSchReadyI>
      chSchRescheduleS();
 8005cbe:	f7fd fcff 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8005cc2:	f7fd fd15 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005cc6:	683b      	ldr	r3, [r7, #0]
 8005cc8:	42bb      	cmp	r3, r7
 8005cca:	d004      	beq.n	8005cd6 <chMtxUnlock+0x96>
 8005ccc:	69ba      	ldr	r2, [r7, #24]
 8005cce:	689b      	ldr	r3, [r3, #8]
 8005cd0:	6892      	ldr	r2, [r2, #8]
 8005cd2:	429a      	cmp	r2, r3
 8005cd4:	d303      	bcc.n	8005cde <chMtxUnlock+0x9e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005cd6:	2300      	movs	r3, #0
 8005cd8:	f383 8811 	msr	BASEPRI, r3
}
 8005cdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8005cde:	b672      	cpsid	i
 8005ce0:	4b06      	ldr	r3, [pc, #24]	; (8005cfc <chMtxUnlock+0xbc>)
 8005ce2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005ce4:	e7fe      	b.n	8005ce4 <chMtxUnlock+0xa4>
      mp->owner = NULL;
 8005ce6:	2300      	movs	r3, #0
 8005ce8:	60b3      	str	r3, [r6, #8]
 8005cea:	e7ea      	b.n	8005cc2 <chMtxUnlock+0x82>
 8005cec:	b672      	cpsid	i
 8005cee:	4b02      	ldr	r3, [pc, #8]	; (8005cf8 <chMtxUnlock+0xb8>)
 8005cf0:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005cf2:	e7fe      	b.n	8005cf2 <chMtxUnlock+0xb2>
 8005cf4:	200011a0 	.word	0x200011a0
 8005cf8:	0800be60 	.word	0x0800be60
 8005cfc:	0800bbfc 	.word	0x0800bbfc

08005d00 <rt_test_006_005_execute>:
static void rt_test_006_005_execute(void) {
 8005d00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005d04:	4d58      	ldr	r5, [pc, #352]	; (8005e68 <rt_test_006_005_execute+0x168>)
  test_set_step(2);
 8005d06:	4c59      	ldr	r4, [pc, #356]	; (8005e6c <rt_test_006_005_execute+0x16c>)
  return chThdGetSelfX()->prio;
 8005d08:	69aa      	ldr	r2, [r5, #24]
 8005d0a:	2302      	movs	r3, #2
 8005d0c:	6896      	ldr	r6, [r2, #8]
 8005d0e:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
 8005d10:	f7fd fdb6 	bl	8003880 <chMtxTryLock.constprop.52>
    test_assert(b, "already locked");
 8005d14:	4956      	ldr	r1, [pc, #344]	; (8005e70 <rt_test_006_005_execute+0x170>)
 8005d16:	f7fa fe03 	bl	8000920 <_test_assert>
 8005d1a:	b108      	cbz	r0, 8005d20 <rt_test_006_005_execute+0x20>
}
 8005d1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  test_set_step(3);
 8005d20:	2303      	movs	r3, #3
 8005d22:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
 8005d24:	f7fd fdac 	bl	8003880 <chMtxTryLock.constprop.52>
    test_assert(!b, "not locked");
 8005d28:	f080 0001 	eor.w	r0, r0, #1
 8005d2c:	b2c0      	uxtb	r0, r0
 8005d2e:	4951      	ldr	r1, [pc, #324]	; (8005e74 <rt_test_006_005_execute+0x174>)
 8005d30:	f7fa fdf6 	bl	8000920 <_test_assert>
 8005d34:	2800      	cmp	r0, #0
 8005d36:	d1f1      	bne.n	8005d1c <rt_test_006_005_execute+0x1c>
    chMtxUnlock(&m1);
 8005d38:	4f4f      	ldr	r7, [pc, #316]	; (8005e78 <rt_test_006_005_execute+0x178>)
  test_set_step(4);
 8005d3a:	2304      	movs	r3, #4
    chMtxUnlock(&m1);
 8005d3c:	4638      	mov	r0, r7
  test_set_step(4);
 8005d3e:	6023      	str	r3, [r4, #0]
    chMtxUnlock(&m1);
 8005d40:	f7ff ff7e 	bl	8005c40 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8005d44:	68b8      	ldr	r0, [r7, #8]
 8005d46:	494d      	ldr	r1, [pc, #308]	; (8005e7c <rt_test_006_005_execute+0x17c>)
 8005d48:	fab0 f080 	clz	r0, r0
 8005d4c:	0940      	lsrs	r0, r0, #5
 8005d4e:	f7fa fde7 	bl	8000920 <_test_assert>
 8005d52:	2800      	cmp	r0, #0
 8005d54:	d1e2      	bne.n	8005d1c <rt_test_006_005_execute+0x1c>
  return (bool)(tqp->next == (const thread_t *)tqp);
 8005d56:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8005d58:	4949      	ldr	r1, [pc, #292]	; (8005e80 <rt_test_006_005_execute+0x180>)
 8005d5a:	1bc0      	subs	r0, r0, r7
 8005d5c:	fab0 f080 	clz	r0, r0
 8005d60:	0940      	lsrs	r0, r0, #5
 8005d62:	f7fa fddd 	bl	8000920 <_test_assert>
 8005d66:	2800      	cmp	r0, #0
 8005d68:	d1d8      	bne.n	8005d1c <rt_test_006_005_execute+0x1c>
 8005d6a:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8005d6c:	4945      	ldr	r1, [pc, #276]	; (8005e84 <rt_test_006_005_execute+0x184>)
 8005d6e:	6898      	ldr	r0, [r3, #8]
 8005d70:	1b80      	subs	r0, r0, r6
 8005d72:	fab0 f080 	clz	r0, r0
  test_set_step(5);
 8005d76:	2305      	movs	r3, #5
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8005d78:	0940      	lsrs	r0, r0, #5
  test_set_step(5);
 8005d7a:	6023      	str	r3, [r4, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8005d7c:	f7fa fdd0 	bl	8000920 <_test_assert>
 8005d80:	2800      	cmp	r0, #0
 8005d82:	d1cb      	bne.n	8005d1c <rt_test_006_005_execute+0x1c>
  test_set_step(6);
 8005d84:	2306      	movs	r3, #6
 8005d86:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
 8005d88:	f7fd fd7a 	bl	8003880 <chMtxTryLock.constprop.52>
    test_assert(b, "already locked");
 8005d8c:	4938      	ldr	r1, [pc, #224]	; (8005e70 <rt_test_006_005_execute+0x170>)
 8005d8e:	f7fa fdc7 	bl	8000920 <_test_assert>
 8005d92:	2800      	cmp	r0, #0
 8005d94:	d1c2      	bne.n	8005d1c <rt_test_006_005_execute+0x1c>
    b = chMtxTryLock(&m1);
 8005d96:	f7fd fd73 	bl	8003880 <chMtxTryLock.constprop.52>
    test_assert(!b, "not locked");
 8005d9a:	f080 0001 	eor.w	r0, r0, #1
 8005d9e:	b2c0      	uxtb	r0, r0
 8005da0:	4934      	ldr	r1, [pc, #208]	; (8005e74 <rt_test_006_005_execute+0x174>)
 8005da2:	f7fa fdbd 	bl	8000920 <_test_assert>
 8005da6:	2800      	cmp	r0, #0
 8005da8:	d1b8      	bne.n	8005d1c <rt_test_006_005_execute+0x1c>
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 8005daa:	f8d5 8018 	ldr.w	r8, [r5, #24]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005dae:	2320      	movs	r3, #32
 8005db0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005db4:	f7fd fd04 	bl	80037c0 <_dbg_check_lock>

  chSysLock();
  if (ctp->mtxlist != NULL) {
 8005db8:	f8d8 1038 	ldr.w	r1, [r8, #56]	; 0x38
 8005dbc:	b1f1      	cbz	r1, 8005dfc <rt_test_006_005_execute+0xfc>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8005dbe:	4681      	mov	r9, r0
      ctp->mtxlist = mp->next;
 8005dc0:	f8d1 a00c 	ldr.w	sl, [r1, #12]
 8005dc4:	f8c8 a038 	str.w	sl, [r8, #56]	; 0x38
 8005dc8:	f7fa fefa 	bl	8000bc0 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8005dcc:	680b      	ldr	r3, [r1, #0]
      if (chMtxQueueNotEmptyS(mp)) {
 8005dce:	4299      	cmp	r1, r3
        (void) chSchReadyI(tp);
 8005dd0:	4618      	mov	r0, r3
      if (chMtxQueueNotEmptyS(mp)) {
 8005dd2:	d040      	beq.n	8005e56 <rt_test_006_005_execute+0x156>
        mp->next = tp->mtxlist;
 8005dd4:	f8d3 c038 	ldr.w	ip, [r3, #56]	; 0x38
  tqp->next             = tp->queue.next;
 8005dd8:	681a      	ldr	r2, [r3, #0]
 8005dda:	600a      	str	r2, [r1, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005ddc:	6051      	str	r1, [r2, #4]
 8005dde:	e9c1 3c02 	strd	r3, ip, [r1, #8]
        tp->mtxlist = mp;
 8005de2:	6399      	str	r1, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
 8005de4:	f7fa ffbc 	bl	8000d60 <chSchReadyI>
 8005de8:	f8d8 1038 	ldr.w	r1, [r8, #56]	; 0x38
      }
    } while (ctp->mtxlist != NULL);
 8005dec:	2900      	cmp	r1, #0
 8005dee:	d1e7      	bne.n	8005dc0 <rt_test_006_005_execute+0xc0>
    ctp->prio = ctp->realprio;
 8005df0:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
 8005df4:	f8c8 3008 	str.w	r3, [r8, #8]
    chSchRescheduleS();
 8005df8:	f7fd fc62 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8005dfc:	f7fd fc78 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005e00:	682b      	ldr	r3, [r5, #0]
 8005e02:	42ab      	cmp	r3, r5
 8005e04:	d004      	beq.n	8005e10 <rt_test_006_005_execute+0x110>
 8005e06:	69aa      	ldr	r2, [r5, #24]
 8005e08:	689b      	ldr	r3, [r3, #8]
 8005e0a:	6892      	ldr	r2, [r2, #8]
 8005e0c:	429a      	cmp	r2, r3
 8005e0e:	d326      	bcc.n	8005e5e <rt_test_006_005_execute+0x15e>
 8005e10:	2300      	movs	r3, #0
 8005e12:	f383 8811 	msr	BASEPRI, r3
    test_assert(m1.owner == NULL, "still owned");
 8005e16:	68b8      	ldr	r0, [r7, #8]
 8005e18:	4918      	ldr	r1, [pc, #96]	; (8005e7c <rt_test_006_005_execute+0x17c>)
 8005e1a:	fab0 f080 	clz	r0, r0
 8005e1e:	0940      	lsrs	r0, r0, #5
 8005e20:	f7fa fd7e 	bl	8000920 <_test_assert>
 8005e24:	2800      	cmp	r0, #0
 8005e26:	f47f af79 	bne.w	8005d1c <rt_test_006_005_execute+0x1c>
  return (bool)(tqp->next == (const thread_t *)tqp);
 8005e2a:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8005e2c:	4914      	ldr	r1, [pc, #80]	; (8005e80 <rt_test_006_005_execute+0x180>)
 8005e2e:	1bc7      	subs	r7, r0, r7
 8005e30:	4278      	negs	r0, r7
 8005e32:	4178      	adcs	r0, r7
 8005e34:	f7fa fd74 	bl	8000920 <_test_assert>
 8005e38:	2800      	cmp	r0, #0
 8005e3a:	f47f af6f 	bne.w	8005d1c <rt_test_006_005_execute+0x1c>
 8005e3e:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8005e40:	4910      	ldr	r1, [pc, #64]	; (8005e84 <rt_test_006_005_execute+0x184>)
 8005e42:	6898      	ldr	r0, [r3, #8]
 8005e44:	1b82      	subs	r2, r0, r6
  test_set_step(7);
 8005e46:	2307      	movs	r3, #7
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8005e48:	4250      	negs	r0, r2
  test_set_step(7);
 8005e4a:	6023      	str	r3, [r4, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8005e4c:	4150      	adcs	r0, r2
}
 8005e4e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8005e52:	f7fa bd65 	b.w	8000920 <_test_assert>
        mp->owner = NULL;
 8005e56:	f8c1 9008 	str.w	r9, [r1, #8]
 8005e5a:	4651      	mov	r1, sl
 8005e5c:	e7c6      	b.n	8005dec <rt_test_006_005_execute+0xec>
  __ASM volatile ("cpsid i" : : : "memory");
 8005e5e:	b672      	cpsid	i
 8005e60:	4b09      	ldr	r3, [pc, #36]	; (8005e88 <rt_test_006_005_execute+0x188>)
 8005e62:	62eb      	str	r3, [r5, #44]	; 0x2c
 8005e64:	e7fe      	b.n	8005e64 <rt_test_006_005_execute+0x164>
 8005e66:	bf00      	nop
 8005e68:	200011a0 	.word	0x200011a0
 8005e6c:	20001b3c 	.word	0x20001b3c
 8005e70:	0800d6a0 	.word	0x0800d6a0
 8005e74:	0800d6b0 	.word	0x0800d6b0
 8005e78:	20000c38 	.word	0x20000c38
 8005e7c:	0800d6bc 	.word	0x0800d6bc
 8005e80:	0800d6c8 	.word	0x0800d6c8
 8005e84:	0800d6d8 	.word	0x0800d6d8
 8005e88:	0800bbfc 	.word	0x0800bbfc
 8005e8c:	00000000 	.word	0x00000000

08005e90 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 8005e90:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005e92:	2320      	movs	r3, #32
 8005e94:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005e98:	f7fd fc92 	bl	80037c0 <_dbg_check_lock>
  chMtxLockS(mp);
 8005e9c:	f7fd f868 	bl	8002f70 <chMtxLockS>
  _dbg_check_unlock();
 8005ea0:	f7fd fc26 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005ea4:	4b08      	ldr	r3, [pc, #32]	; (8005ec8 <chMtxLock+0x38>)
 8005ea6:	681a      	ldr	r2, [r3, #0]
 8005ea8:	429a      	cmp	r2, r3
 8005eaa:	d004      	beq.n	8005eb6 <chMtxLock+0x26>
 8005eac:	6999      	ldr	r1, [r3, #24]
 8005eae:	6892      	ldr	r2, [r2, #8]
 8005eb0:	6889      	ldr	r1, [r1, #8]
 8005eb2:	4291      	cmp	r1, r2
 8005eb4:	d303      	bcc.n	8005ebe <chMtxLock+0x2e>
 8005eb6:	2300      	movs	r3, #0
 8005eb8:	f383 8811 	msr	BASEPRI, r3
}
 8005ebc:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8005ebe:	b672      	cpsid	i
 8005ec0:	4a02      	ldr	r2, [pc, #8]	; (8005ecc <chMtxLock+0x3c>)
 8005ec2:	62da      	str	r2, [r3, #44]	; 0x2c
 8005ec4:	e7fe      	b.n	8005ec4 <chMtxLock+0x34>
 8005ec6:	bf00      	nop
 8005ec8:	200011a0 	.word	0x200011a0
 8005ecc:	0800bbfc 	.word	0x0800bbfc

08005ed0 <chHeapAllocAligned.constprop.31>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8005ed0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  heap_header_t *qp, *hp, *ahp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
 8005ed4:	b349      	cbz	r1, 8005f2a <chHeapAllocAligned.constprop.31+0x5a>

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
 8005ed6:	4b39      	ldr	r3, [pc, #228]	; (8005fbc <chHeapAllocAligned.constprop.31+0xec>)
 8005ed8:	4606      	mov	r6, r0
 8005eda:	2800      	cmp	r0, #0
 8005edc:	bf08      	it	eq
 8005ede:	461e      	moveq	r6, r3

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8005ee0:	f106 070c 	add.w	r7, r6, #12
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8005ee4:	1dcc      	adds	r4, r1, #7
  H_LOCK(heapp);
 8005ee6:	4638      	mov	r0, r7
 8005ee8:	460d      	mov	r5, r1
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8005eea:	08e4      	lsrs	r4, r4, #3
  H_LOCK(heapp);
 8005eec:	f7ff ffd0 	bl	8005e90 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 8005ef0:	f106 0e04 	add.w	lr, r6, #4
  while (H_NEXT(qp) != NULL) {
 8005ef4:	f8de 3000 	ldr.w	r3, [lr]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005ef8:	f103 010f 	add.w	r1, r3, #15
 8005efc:	f021 0107 	bic.w	r1, r1, #7
 8005f00:	f1a1 0008 	sub.w	r0, r1, #8
 8005f04:	f103 0808 	add.w	r8, r3, #8
  while (H_NEXT(qp) != NULL) {
 8005f08:	b1a3      	cbz	r3, 8005f34 <chHeapAllocAligned.constprop.31+0x64>

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005f0a:	f8d3 9004 	ldr.w	r9, [r3, #4]
 8005f0e:	f109 0201 	add.w	r2, r9, #1
 8005f12:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
 8005f16:	ebac 0101 	sub.w	r1, ip, r1
 8005f1a:	4560      	cmp	r0, ip
 8005f1c:	ea4f 02e1 	mov.w	r2, r1, asr #3
 8005f20:	d201      	bcs.n	8005f26 <chHeapAllocAligned.constprop.31+0x56>
 8005f22:	4294      	cmp	r4, r2
 8005f24:	d919      	bls.n	8005f5a <chHeapAllocAligned.constprop.31+0x8a>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 8005f26:	469e      	mov	lr, r3
 8005f28:	e7e4      	b.n	8005ef4 <chHeapAllocAligned.constprop.31+0x24>
 8005f2a:	b672      	cpsid	i
 8005f2c:	4b24      	ldr	r3, [pc, #144]	; (8005fc0 <chHeapAllocAligned.constprop.31+0xf0>)
 8005f2e:	4a25      	ldr	r2, [pc, #148]	; (8005fc4 <chHeapAllocAligned.constprop.31+0xf4>)
 8005f30:	62da      	str	r2, [r3, #44]	; 0x2c
 8005f32:	e7fe      	b.n	8005f32 <chHeapAllocAligned.constprop.31+0x62>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8005f34:	4638      	mov	r0, r7
 8005f36:	f7ff fe83 	bl	8005c40 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 8005f3a:	6833      	ldr	r3, [r6, #0]
 8005f3c:	b15b      	cbz	r3, 8005f56 <chHeapAllocAligned.constprop.31+0x86>
    ahp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT,
 8005f3e:	1c60      	adds	r0, r4, #1
 8005f40:	2208      	movs	r2, #8
 8005f42:	00c0      	lsls	r0, r0, #3
 8005f44:	4611      	mov	r1, r2
 8005f46:	4798      	blx	r3
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 8005f48:	4604      	mov	r4, r0
 8005f4a:	b108      	cbz	r0, 8005f50 <chHeapAllocAligned.constprop.31+0x80>
      hp = ahp - 1U;
      H_HEAP(hp) = heapp;
      H_SIZE(hp) = size;
 8005f4c:	e940 6502 	strd	r6, r5, [r0, #-8]
      /*lint -restore*/
    }
  }

  return NULL;
}
 8005f50:	4620      	mov	r0, r4
 8005f52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return NULL;
 8005f56:	461c      	mov	r4, r3
 8005f58:	e7fa      	b.n	8005f50 <chHeapAllocAligned.constprop.31+0x80>
      if (ahp > hp) {
 8005f5a:	4283      	cmp	r3, r0
 8005f5c:	d218      	bcs.n	8005f90 <chHeapAllocAligned.constprop.31+0xc0>
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8005f5e:	eba0 0108 	sub.w	r1, r0, r8
 8005f62:	10c9      	asrs	r1, r1, #3
        if (bpages > pages) {
 8005f64:	4294      	cmp	r4, r2
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8005f66:	6059      	str	r1, [r3, #4]
        if (bpages > pages) {
 8005f68:	d20a      	bcs.n	8005f80 <chHeapAllocAligned.constprop.31+0xb0>
          fp = H_BLOCK(ahp) + pages;
 8005f6a:	f104 0c01 	add.w	ip, r4, #1
 8005f6e:	eb00 01cc 	add.w	r1, r0, ip, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 8005f72:	43e4      	mvns	r4, r4
 8005f74:	4422      	add	r2, r4
          H_NEXT(fp) = H_NEXT(hp);
 8005f76:	681c      	ldr	r4, [r3, #0]
          H_PAGES(fp) = (bpages - pages) - 1U;
 8005f78:	604a      	str	r2, [r1, #4]
          H_NEXT(fp) = H_NEXT(hp);
 8005f7a:	f840 403c 	str.w	r4, [r0, ip, lsl #3]
          H_NEXT(hp) = fp;
 8005f7e:	6019      	str	r1, [r3, #0]
      H_HEAP(hp) = heapp;
 8005f80:	4604      	mov	r4, r0
      H_SIZE(hp) = size;
 8005f82:	6045      	str	r5, [r0, #4]
      H_UNLOCK(heapp);
 8005f84:	4638      	mov	r0, r7
      H_HEAP(hp) = heapp;
 8005f86:	f844 6b08 	str.w	r6, [r4], #8
      H_UNLOCK(heapp);
 8005f8a:	f7ff fe59 	bl	8005c40 <chMtxUnlock>
 8005f8e:	e7df      	b.n	8005f50 <chHeapAllocAligned.constprop.31+0x80>
        if (H_PAGES(hp) == pages) {
 8005f90:	454c      	cmp	r4, r9
 8005f92:	6818      	ldr	r0, [r3, #0]
 8005f94:	d00e      	beq.n	8005fb4 <chHeapAllocAligned.constprop.31+0xe4>
          fp = H_BLOCK(hp) + pages;
 8005f96:	3401      	adds	r4, #1
 8005f98:	eb03 01c4 	add.w	r1, r3, r4, lsl #3
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8005f9c:	f101 0208 	add.w	r2, r1, #8
 8005fa0:	ebac 0202 	sub.w	r2, ip, r2
 8005fa4:	10d2      	asrs	r2, r2, #3
          H_NEXT(fp) = H_NEXT(hp);
 8005fa6:	f843 0034 	str.w	r0, [r3, r4, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8005faa:	604a      	str	r2, [r1, #4]
          H_NEXT(qp) = fp;
 8005fac:	4618      	mov	r0, r3
 8005fae:	f8ce 1000 	str.w	r1, [lr]
 8005fb2:	e7e5      	b.n	8005f80 <chHeapAllocAligned.constprop.31+0xb0>
          H_NEXT(qp) = H_NEXT(hp);
 8005fb4:	f8ce 0000 	str.w	r0, [lr]
 8005fb8:	4618      	mov	r0, r3
 8005fba:	e7e1      	b.n	8005f80 <chHeapAllocAligned.constprop.31+0xb0>
 8005fbc:	20001348 	.word	0x20001348
 8005fc0:	200011a0 	.word	0x200011a0
 8005fc4:	0800bde4 	.word	0x0800bde4
	...

08005fd0 <dyn_create_object_heap>:
                                             size_t size) {
 8005fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_element_t *p = dlp->next;
 8005fd2:	680c      	ldr	r4, [r1, #0]
  while (p != (dyn_element_t *)dlp) {
 8005fd4:	42a1      	cmp	r1, r4
                                             size_t size) {
 8005fd6:	460d      	mov	r5, r1
 8005fd8:	4606      	mov	r6, r0
 8005fda:	4617      	mov	r7, r2
  while (p != (dyn_element_t *)dlp) {
 8005fdc:	d103      	bne.n	8005fe6 <dyn_create_object_heap+0x16>
 8005fde:	e00d      	b.n	8005ffc <dyn_create_object_heap+0x2c>
    p = p->next;
 8005fe0:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8005fe2:	42a5      	cmp	r5, r4
 8005fe4:	d00a      	beq.n	8005ffc <dyn_create_object_heap+0x2c>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8005fe6:	2208      	movs	r2, #8
 8005fe8:	4631      	mov	r1, r6
 8005fea:	18a0      	adds	r0, r4, r2
 8005fec:	f005 fd30 	bl	800ba50 <strncmp>
 8005ff0:	2800      	cmp	r0, #0
 8005ff2:	d1f5      	bne.n	8005fe0 <dyn_create_object_heap+0x10>
  if (dep != NULL) {
 8005ff4:	b114      	cbz	r4, 8005ffc <dyn_create_object_heap+0x2c>
    return NULL;
 8005ff6:	4604      	mov	r4, r0
}
 8005ff8:	4620      	mov	r0, r4
 8005ffa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 8005ffc:	4639      	mov	r1, r7
 8005ffe:	2000      	movs	r0, #0
 8006000:	f7ff ff66 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
  if (dep == NULL) {
 8006004:	4604      	mov	r4, r0
 8006006:	b148      	cbz	r0, 800601c <dyn_create_object_heap+0x4c>
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 8006008:	2208      	movs	r2, #8
 800600a:	4410      	add	r0, r2
 800600c:	4631      	mov	r1, r6
 800600e:	f005 fd6b 	bl	800bae8 <strncpy>
  dep->next = dlp->next;
 8006012:	682b      	ldr	r3, [r5, #0]
  dep->refs = (ucnt_t)1;
 8006014:	2201      	movs	r2, #1
  dep->next = dlp->next;
 8006016:	e9c4 3200 	strd	r3, r2, [r4]
  dlp->next = dep;
 800601a:	602c      	str	r4, [r5, #0]
}
 800601c:	4620      	mov	r0, r4
 800601e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006020 <chThdCreateFromHeap>:
                              tfunc_t pf, void *arg) {
 8006020:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006022:	b087      	sub	sp, #28
 8006024:	4615      	mov	r5, r2
 8006026:	461f      	mov	r7, r3
 8006028:	460c      	mov	r4, r1
 800602a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 800602c:	f7ff ff50 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
  if (wsp == NULL) {
 8006030:	b358      	cbz	r0, 800608a <chThdCreateFromHeap+0x6a>
  thread_descriptor_t td = {
 8006032:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006034:	9305      	str	r3, [sp, #20]
    (stkalign_t *)((uint8_t *)wsp + size),
 8006036:	4404      	add	r4, r0
  thread_descriptor_t td = {
 8006038:	9402      	str	r4, [sp, #8]
 800603a:	e9cd 5000 	strd	r5, r0, [sp]
 800603e:	e9cd 7603 	strd	r7, r6, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006042:	2320      	movs	r3, #32
 8006044:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8006048:	f7fd fbba 	bl	80037c0 <_dbg_check_lock>
  tp = chThdCreateSuspendedI(&td);
 800604c:	4668      	mov	r0, sp
 800604e:	f7fa fe27 	bl	8000ca0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 8006052:	2301      	movs	r3, #1
 8006054:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 8006058:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(&td);
 800605a:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 800605c:	f7fc ff40 	bl	8002ee0 <chSchWakeupS>
  _dbg_check_unlock();
 8006060:	f7fd fb46 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006064:	4b0a      	ldr	r3, [pc, #40]	; (8006090 <chThdCreateFromHeap+0x70>)
 8006066:	681a      	ldr	r2, [r3, #0]
 8006068:	429a      	cmp	r2, r3
 800606a:	d004      	beq.n	8006076 <chThdCreateFromHeap+0x56>
 800606c:	6999      	ldr	r1, [r3, #24]
 800606e:	6892      	ldr	r2, [r2, #8]
 8006070:	6889      	ldr	r1, [r1, #8]
 8006072:	4291      	cmp	r1, r2
 8006074:	d305      	bcc.n	8006082 <chThdCreateFromHeap+0x62>
 8006076:	2300      	movs	r3, #0
 8006078:	f383 8811 	msr	BASEPRI, r3
}
 800607c:	4620      	mov	r0, r4
 800607e:	b007      	add	sp, #28
 8006080:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8006082:	b672      	cpsid	i
 8006084:	4a03      	ldr	r2, [pc, #12]	; (8006094 <chThdCreateFromHeap+0x74>)
 8006086:	62da      	str	r2, [r3, #44]	; 0x2c
 8006088:	e7fe      	b.n	8006088 <chThdCreateFromHeap+0x68>
    return NULL;
 800608a:	4604      	mov	r4, r0
 800608c:	e7f6      	b.n	800607c <chThdCreateFromHeap+0x5c>
 800608e:	bf00      	nop
 8006090:	200011a0 	.word	0x200011a0
 8006094:	0800bc2c 	.word	0x0800bc2c
	...

080060a0 <chFactoryRegisterObject.constprop.13>:
 * @retval NULL         if the object to be registered cannot be allocated or
 *                      a registered object with the same name exists.
 *
 * @api
 */
registered_object_t *chFactoryRegisterObject(const char *name,
 80060a0:	b538      	push	{r3, r4, r5, lr}
 80060a2:	4605      	mov	r5, r0
                                             void *objp) {
  registered_object_t *rop;

  F_LOCK();
 80060a4:	4807      	ldr	r0, [pc, #28]	; (80060c4 <chFactoryRegisterObject.constprop.13+0x24>)
 80060a6:	f7ff fef3 	bl	8005e90 <chMtxLock>

  rop = (registered_object_t *)dyn_create_object_pool(name,
 80060aa:	4a07      	ldr	r2, [pc, #28]	; (80060c8 <chFactoryRegisterObject.constprop.13+0x28>)
 80060ac:	4807      	ldr	r0, [pc, #28]	; (80060cc <chFactoryRegisterObject.constprop.13+0x2c>)
 80060ae:	1f11      	subs	r1, r2, #4
 80060b0:	f7ff fb7e 	bl	80057b0 <dyn_create_object_pool>
                                                      &ch_factory.obj_list,
                                                      &ch_factory.obj_pool);
  if (rop != NULL) {
 80060b4:	4604      	mov	r4, r0
 80060b6:	b100      	cbz	r0, 80060ba <chFactoryRegisterObject.constprop.13+0x1a>
    /* Initializing registered object data.*/
    rop->objp = objp;
 80060b8:	6105      	str	r5, [r0, #16]
  }

  F_UNLOCK();
 80060ba:	4802      	ldr	r0, [pc, #8]	; (80060c4 <chFactoryRegisterObject.constprop.13+0x24>)
 80060bc:	f7ff fdc0 	bl	8005c40 <chMtxUnlock>

  return rop;
}
 80060c0:	4620      	mov	r0, r4
 80060c2:	bd38      	pop	{r3, r4, r5, pc}
 80060c4:	20001220 	.word	0x20001220
 80060c8:	20001234 	.word	0x20001234
 80060cc:	0800c1f4 	.word	0x0800c1f4

080060d0 <chFactoryFindObject.constprop.12>:
 * @retval NULL         if a registered object with the specified name
 *                      does not exist.
 *
 * @api
 */
registered_object_t *chFactoryFindObject(const char *name) {
 80060d0:	b538      	push	{r3, r4, r5, lr}
  registered_object_t *rop;

  F_LOCK();
 80060d2:	4c07      	ldr	r4, [pc, #28]	; (80060f0 <chFactoryFindObject.constprop.12+0x20>)
 80060d4:	4620      	mov	r0, r4
 80060d6:	f7ff fedb 	bl	8005e90 <chMtxLock>

  rop = (registered_object_t *)dyn_find_object(name, &ch_factory.obj_list);
 80060da:	f104 0110 	add.w	r1, r4, #16
 80060de:	4805      	ldr	r0, [pc, #20]	; (80060f4 <chFactoryFindObject.constprop.12+0x24>)
 80060e0:	f7fc fede 	bl	8002ea0 <dyn_find_object>
 80060e4:	4605      	mov	r5, r0

  F_UNLOCK();
 80060e6:	4620      	mov	r0, r4
 80060e8:	f7ff fdaa 	bl	8005c40 <chMtxUnlock>

  return rop;
}
 80060ec:	4628      	mov	r0, r5
 80060ee:	bd38      	pop	{r3, r4, r5, pc}
 80060f0:	20001220 	.word	0x20001220
 80060f4:	0800c1f4 	.word	0x0800c1f4
	...

08006100 <chFactoryCreateBuffer.constprop.11>:
 * @retval NULL         if the dynamic buffer object cannot be allocated or
 *                      a dynamic buffer object with the same name exists.
 *
 * @api
 */
dyn_buffer_t *chFactoryCreateBuffer(const char *name, size_t size) {
 8006100:	b510      	push	{r4, lr}
  dyn_buffer_t *dbp;

  F_LOCK();
 8006102:	480a      	ldr	r0, [pc, #40]	; (800612c <chFactoryCreateBuffer.constprop.11+0x2c>)
 8006104:	f7ff fec4 	bl	8005e90 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_create_object_heap(name,
 8006108:	2280      	movs	r2, #128	; 0x80
 800610a:	4909      	ldr	r1, [pc, #36]	; (8006130 <chFactoryCreateBuffer.constprop.11+0x30>)
 800610c:	4809      	ldr	r0, [pc, #36]	; (8006134 <chFactoryCreateBuffer.constprop.11+0x34>)
 800610e:	f7ff ff5f 	bl	8005fd0 <dyn_create_object_heap>
                                               &ch_factory.buf_list,
                                               size);
  if (dbp != NULL) {
 8006112:	4604      	mov	r4, r0
 8006114:	b120      	cbz	r0, 8006120 <chFactoryCreateBuffer.constprop.11+0x20>
    /* Initializing buffer object data.*/
    memset((void *)dbp->buffer, 0, size);
 8006116:	2280      	movs	r2, #128	; 0x80
 8006118:	2100      	movs	r1, #0
 800611a:	3010      	adds	r0, #16
 800611c:	f005 fbda 	bl	800b8d4 <memset>
  }

  F_UNLOCK();
 8006120:	4802      	ldr	r0, [pc, #8]	; (800612c <chFactoryCreateBuffer.constprop.11+0x2c>)
 8006122:	f7ff fd8d 	bl	8005c40 <chMtxUnlock>

  return dbp;
}
 8006126:	4620      	mov	r0, r4
 8006128:	bd10      	pop	{r4, pc}
 800612a:	bf00      	nop
 800612c:	20001220 	.word	0x20001220
 8006130:	20001244 	.word	0x20001244
 8006134:	0800c1d4 	.word	0x0800c1d4
	...

08006140 <chFactoryFindBuffer.constprop.10>:
 * @retval NULL         if a dynamic buffer object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
 8006140:	b538      	push	{r3, r4, r5, lr}
  dyn_buffer_t *dbp;

  F_LOCK();
 8006142:	4c07      	ldr	r4, [pc, #28]	; (8006160 <chFactoryFindBuffer.constprop.10+0x20>)
 8006144:	4620      	mov	r0, r4
 8006146:	f7ff fea3 	bl	8005e90 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_find_object(name, &ch_factory.buf_list);
 800614a:	f104 0124 	add.w	r1, r4, #36	; 0x24
 800614e:	4805      	ldr	r0, [pc, #20]	; (8006164 <chFactoryFindBuffer.constprop.10+0x24>)
 8006150:	f7fc fea6 	bl	8002ea0 <dyn_find_object>
 8006154:	4605      	mov	r5, r0

  F_UNLOCK();
 8006156:	4620      	mov	r0, r4
 8006158:	f7ff fd72 	bl	8005c40 <chMtxUnlock>

  return dbp;
}
 800615c:	4628      	mov	r0, r5
 800615e:	bd38      	pop	{r3, r4, r5, pc}
 8006160:	20001220 	.word	0x20001220
 8006164:	0800c1d4 	.word	0x0800c1d4
	...

08006170 <chFactoryCreateSemaphore.constprop.9>:
 * @retval NULL         if the dynamic semaphore object cannot be allocated or
 *                      a dynamic semaphore with the same name exists.
 *
 * @api
 */
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
 8006170:	b510      	push	{r4, lr}
  dyn_semaphore_t *dsp;

  F_LOCK();
 8006172:	480a      	ldr	r0, [pc, #40]	; (800619c <chFactoryCreateSemaphore.constprop.9+0x2c>)
 8006174:	f7ff fe8c 	bl	8005e90 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_create_object_pool(name,
 8006178:	4a09      	ldr	r2, [pc, #36]	; (80061a0 <chFactoryCreateSemaphore.constprop.9+0x30>)
 800617a:	480a      	ldr	r0, [pc, #40]	; (80061a4 <chFactoryCreateSemaphore.constprop.9+0x34>)
 800617c:	1f11      	subs	r1, r2, #4
 800617e:	f7ff fb17 	bl	80057b0 <dyn_create_object_pool>
                                                  &ch_factory.sem_list,
                                                  &ch_factory.sem_pool);
  if (dsp != NULL) {
 8006182:	4604      	mov	r4, r0
 8006184:	b128      	cbz	r0, 8006192 <chFactoryCreateSemaphore.constprop.9+0x22>
    /* Initializing semaphore object dataa.*/
    chSemObjectInit(&dsp->sem, n);
 8006186:	f100 0310 	add.w	r3, r0, #16
  tqp->prev = (thread_t *)tqp;
 800618a:	e9c0 3304 	strd	r3, r3, [r0, #16]
  sp->cnt = n;
 800618e:	2200      	movs	r2, #0
 8006190:	6182      	str	r2, [r0, #24]
  }

  F_UNLOCK();
 8006192:	4802      	ldr	r0, [pc, #8]	; (800619c <chFactoryCreateSemaphore.constprop.9+0x2c>)
 8006194:	f7ff fd54 	bl	8005c40 <chMtxUnlock>

  return dsp;
}
 8006198:	4620      	mov	r0, r4
 800619a:	bd10      	pop	{r4, pc}
 800619c:	20001220 	.word	0x20001220
 80061a0:	2000124c 	.word	0x2000124c
 80061a4:	0800c1ec 	.word	0x0800c1ec
	...

080061b0 <chFactoryFindSemaphore.constprop.8>:
 * @retval NULL         if a dynamic semaphore object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
 80061b0:	b538      	push	{r3, r4, r5, lr}
  dyn_semaphore_t *dsp;

  F_LOCK();
 80061b2:	4c07      	ldr	r4, [pc, #28]	; (80061d0 <chFactoryFindSemaphore.constprop.8+0x20>)
 80061b4:	4620      	mov	r0, r4
 80061b6:	f7ff fe6b 	bl	8005e90 <chMtxLock>

  dsp = (dyn_semaphore_t *)dyn_find_object(name, &ch_factory.sem_list);
 80061ba:	f104 0128 	add.w	r1, r4, #40	; 0x28
 80061be:	4805      	ldr	r0, [pc, #20]	; (80061d4 <chFactoryFindSemaphore.constprop.8+0x24>)
 80061c0:	f7fc fe6e 	bl	8002ea0 <dyn_find_object>
 80061c4:	4605      	mov	r5, r0

  F_UNLOCK();
 80061c6:	4620      	mov	r0, r4
 80061c8:	f7ff fd3a 	bl	8005c40 <chMtxUnlock>

  return dsp;
}
 80061cc:	4628      	mov	r0, r5
 80061ce:	bd38      	pop	{r3, r4, r5, pc}
 80061d0:	20001220 	.word	0x20001220
 80061d4:	0800c1ec 	.word	0x0800c1ec
	...

080061e0 <chFactoryCreateMailbox.constprop.7>:
 * @retval NULL         if the dynamic mailbox object cannot be allocated or
 *                      a dynamic mailbox object with the same name exists.
 *
 * @api
 */
dyn_mailbox_t *chFactoryCreateMailbox(const char *name, size_t n) {
 80061e0:	b538      	push	{r3, r4, r5, lr}
  dyn_mailbox_t *dmp;

  F_LOCK();
 80061e2:	4811      	ldr	r0, [pc, #68]	; (8006228 <chFactoryCreateMailbox.constprop.7+0x48>)
 80061e4:	f7ff fe54 	bl	8005e90 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
 80061e8:	2278      	movs	r2, #120	; 0x78
 80061ea:	4910      	ldr	r1, [pc, #64]	; (800622c <chFactoryCreateMailbox.constprop.7+0x4c>)
 80061ec:	4810      	ldr	r0, [pc, #64]	; (8006230 <chFactoryCreateMailbox.constprop.7+0x50>)
 80061ee:	f7ff feef 	bl	8005fd0 <dyn_create_object_heap>
                                                &ch_factory.mbx_list,
                                                sizeof (dyn_mailbox_t) +
                                                (n * sizeof (msg_t)));
  if (dmp != NULL) {
 80061f2:	4604      	mov	r4, r0
 80061f4:	b198      	cbz	r0, 800621e <chFactoryCreateMailbox.constprop.7+0x3e>
    /* Initializing mailbox object data.*/
    chMBObjectInit(&dmp->mbx, dmp->msgbuf, n);
 80061f6:	f100 0338 	add.w	r3, r0, #56	; 0x38
  chThdQueueObjectInit(&mbp->qw);
 80061fa:	f104 0128 	add.w	r1, r4, #40	; 0x28
  chThdQueueObjectInit(&mbp->qr);
 80061fe:	f104 0230 	add.w	r2, r4, #48	; 0x30
  mbp->wrptr  = buf;
 8006202:	e9c4 3306 	strd	r3, r3, [r4, #24]
 8006206:	e9c4 110a 	strd	r1, r1, [r4, #40]	; 0x28
 800620a:	e9c4 220c 	strd	r2, r2, [r4, #48]	; 0x30
  mbp->top    = &buf[n];
 800620e:	f100 0578 	add.w	r5, r0, #120	; 0x78
  mbp->cnt    = (size_t)0;
 8006212:	2000      	movs	r0, #0
  mbp->buffer = buf;
 8006214:	6123      	str	r3, [r4, #16]
  mbp->top    = &buf[n];
 8006216:	6165      	str	r5, [r4, #20]
  mbp->cnt    = (size_t)0;
 8006218:	6220      	str	r0, [r4, #32]
  mbp->reset  = false;
 800621a:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
  }

  F_UNLOCK();
 800621e:	4802      	ldr	r0, [pc, #8]	; (8006228 <chFactoryCreateMailbox.constprop.7+0x48>)
 8006220:	f7ff fd0e 	bl	8005c40 <chMtxUnlock>

  return dmp;
}
 8006224:	4620      	mov	r0, r4
 8006226:	bd38      	pop	{r3, r4, r5, pc}
 8006228:	20001220 	.word	0x20001220
 800622c:	2000125c 	.word	0x2000125c
 8006230:	0800c1dc 	.word	0x0800c1dc
	...

08006240 <chFactoryFindMailbox.constprop.6>:
 * @retval NULL         if a dynamic mailbox object with the specified name
 *                      does not exist.
 *
 * @api
 */
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
 8006240:	b538      	push	{r3, r4, r5, lr}
  dyn_mailbox_t *dmp;

  F_LOCK();
 8006242:	4c07      	ldr	r4, [pc, #28]	; (8006260 <chFactoryFindMailbox.constprop.6+0x20>)
 8006244:	4620      	mov	r0, r4
 8006246:	f7ff fe23 	bl	8005e90 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_find_object(name, &ch_factory.mbx_list);
 800624a:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 800624e:	4805      	ldr	r0, [pc, #20]	; (8006264 <chFactoryFindMailbox.constprop.6+0x24>)
 8006250:	f7fc fe26 	bl	8002ea0 <dyn_find_object>
 8006254:	4605      	mov	r5, r0

  F_UNLOCK();
 8006256:	4620      	mov	r0, r4
 8006258:	f7ff fcf2 	bl	8005c40 <chMtxUnlock>

  return dmp;
}
 800625c:	4628      	mov	r0, r5
 800625e:	bd38      	pop	{r3, r4, r5, pc}
 8006260:	20001220 	.word	0x20001220
 8006264:	0800c1dc 	.word	0x0800c1dc
	...

08006270 <chFactoryCreateObjectsFIFO.constprop.5>:
 *                      allocated or a dynamic "objects FIFO" object with
 *                      the same name exists.
 *
 * @api
 */
dyn_objects_fifo_t *chFactoryCreateObjectsFIFO(const char *name,
 8006270:	b570      	push	{r4, r5, r6, lr}
                                               size_t objsize,
                                               size_t objn,
                                               unsigned objalign) {
  dyn_objects_fifo_t *dofp;

  F_LOCK();
 8006272:	4818      	ldr	r0, [pc, #96]	; (80062d4 <chFactoryCreateObjectsFIFO.constprop.5+0x64>)
 8006274:	f7ff fe0c 	bl	8005e90 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_create_object_heap(name,
 8006278:	f44f 72ca 	mov.w	r2, #404	; 0x194
 800627c:	4916      	ldr	r1, [pc, #88]	; (80062d8 <chFactoryCreateObjectsFIFO.constprop.5+0x68>)
 800627e:	4817      	ldr	r0, [pc, #92]	; (80062dc <chFactoryCreateObjectsFIFO.constprop.5+0x6c>)
 8006280:	f7ff fea6 	bl	8005fd0 <dyn_create_object_heap>
                                                      &ch_factory.fifo_list,
                                                      sizeof (dyn_objects_fifo_t) +
                                                      (objn * sizeof (msg_t)) +
                                                      (objn * objsize));
  if (dofp != NULL) {
 8006284:	4604      	mov	r4, r0
 8006286:	b300      	cbz	r0, 80062ca <chFactoryCreateObjectsFIFO.constprop.5+0x5a>
  mp->next = NULL;
 8006288:	2500      	movs	r5, #0
    /* Initializing mailbox object data.*/
    chFifoObjectInit(&dofp->fifo, objsize, objn, objalign,
                     (void *)&dofp->msgbuf[objn], dofp->msgbuf);
 800628a:	f100 0694 	add.w	r6, r0, #148	; 0x94
  mp->object_size = size;
 800628e:	2210      	movs	r2, #16
  mp->align = align;
 8006290:	2304      	movs	r3, #4
 */
static inline void chFifoObjectInit(objects_fifo_t *ofp, size_t objsize,
                                    size_t objn, unsigned objalign,
                                    void *objbuf, msg_t *msgbuf) {

  chGuardedPoolObjectInitAligned(&ofp->free, objsize, objalign);
 8006292:	3010      	adds	r0, #16
 8006294:	e9c4 2308 	strd	r2, r3, [r4, #32]
  chGuardedPoolLoadArray(&ofp->free, objbuf, objn);
 8006298:	4631      	mov	r1, r6
 800629a:	e9c4 0004 	strd	r0, r0, [r4, #16]
  mp->next = NULL;
 800629e:	61e5      	str	r5, [r4, #28]
  mp->provider = provider;
 80062a0:	62a5      	str	r5, [r4, #40]	; 0x28
 80062a2:	61a5      	str	r5, [r4, #24]
 80062a4:	f7ff f84c 	bl	8005340 <chGuardedPoolLoadArray>
 80062a8:	f104 0354 	add.w	r3, r4, #84	; 0x54
  chThdQueueObjectInit(&mbp->qw);
 80062ac:	f104 0144 	add.w	r1, r4, #68	; 0x44
  chThdQueueObjectInit(&mbp->qr);
 80062b0:	f104 024c 	add.w	r2, r4, #76	; 0x4c
  mbp->wrptr  = buf;
 80062b4:	e9c4 330d 	strd	r3, r3, [r4, #52]	; 0x34
 80062b8:	e9c4 1111 	strd	r1, r1, [r4, #68]	; 0x44
 80062bc:	e9c4 2213 	strd	r2, r2, [r4, #76]	; 0x4c
  mbp->top    = &buf[n];
 80062c0:	6326      	str	r6, [r4, #48]	; 0x30
  mbp->cnt    = (size_t)0;
 80062c2:	63e5      	str	r5, [r4, #60]	; 0x3c
  mbp->reset  = false;
 80062c4:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
  mbp->buffer = buf;
 80062c8:	62e3      	str	r3, [r4, #44]	; 0x2c
  }

  F_UNLOCK();
 80062ca:	4802      	ldr	r0, [pc, #8]	; (80062d4 <chFactoryCreateObjectsFIFO.constprop.5+0x64>)
 80062cc:	f7ff fcb8 	bl	8005c40 <chMtxUnlock>

  return dofp;
}
 80062d0:	4620      	mov	r0, r4
 80062d2:	bd70      	pop	{r4, r5, r6, pc}
 80062d4:	20001220 	.word	0x20001220
 80062d8:	20001260 	.word	0x20001260
 80062dc:	0800c1e4 	.word	0x0800c1e4

080062e0 <chFactoryFindObjectsFIFO.constprop.4>:
 * @retval NULL         if a dynamic "objects FIFO" object with the specified
 *                      name does not exist.
 *
 * @api
 */
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
 80062e0:	b538      	push	{r3, r4, r5, lr}
  dyn_objects_fifo_t *dofp;

  F_LOCK();
 80062e2:	4c07      	ldr	r4, [pc, #28]	; (8006300 <chFactoryFindObjectsFIFO.constprop.4+0x20>)
 80062e4:	4620      	mov	r0, r4
 80062e6:	f7ff fdd3 	bl	8005e90 <chMtxLock>

  dofp = (dyn_objects_fifo_t *)dyn_find_object(name, &ch_factory.fifo_list);
 80062ea:	f104 0140 	add.w	r1, r4, #64	; 0x40
 80062ee:	4805      	ldr	r0, [pc, #20]	; (8006304 <chFactoryFindObjectsFIFO.constprop.4+0x24>)
 80062f0:	f7fc fdd6 	bl	8002ea0 <dyn_find_object>
 80062f4:	4605      	mov	r5, r0

  F_UNLOCK();
 80062f6:	4620      	mov	r0, r4
 80062f8:	f7ff fca2 	bl	8005c40 <chMtxUnlock>

  return dofp;
}
 80062fc:	4628      	mov	r0, r5
 80062fe:	bd38      	pop	{r3, r4, r5, pc}
 8006300:	20001220 	.word	0x20001220
 8006304:	0800c1e4 	.word	0x0800c1e4
	...

08006310 <thread8>:
static THD_FUNCTION(thread8, p) {
 8006310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006312:	4607      	mov	r7, r0
  chMtxLock(&m2);
 8006314:	4827      	ldr	r0, [pc, #156]	; (80063b4 <thread8+0xa4>)
 8006316:	f7ff fdbb 	bl	8005e90 <chMtxLock>
  chMtxLock(&m1);
 800631a:	4827      	ldr	r0, [pc, #156]	; (80063b8 <thread8+0xa8>)
 800631c:	f7ff fdb8 	bl	8005e90 <chMtxLock>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006320:	2320      	movs	r3, #32
 8006322:	f383 8811 	msr	BASEPRI, r3
  return ch.rlist.current;
 8006326:	4c25      	ldr	r4, [pc, #148]	; (80063bc <thread8+0xac>)
  _dbg_check_lock();
 8006328:	f7fd fa4a 	bl	80037c0 <_dbg_check_lock>
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
 800632c:	69a3      	ldr	r3, [r4, #24]
 800632e:	6b9d      	ldr	r5, [r3, #56]	; 0x38
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, sysinterval_t timeout) {
  mutex_t *mp = chMtxGetNextMutexX();
  msg_t msg;

  chDbgCheckClassS();
 8006330:	f7fa fc46 	bl	8000bc0 <chDbgCheckClassS>
  chDbgCheck((cp != NULL) && (timeout != TIME_IMMEDIATE));
  chDbgAssert(mp != NULL, "not owning a mutex");
 8006334:	2d00      	cmp	r5, #0
 8006336:	d035      	beq.n	80063a4 <thread8+0x94>

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 8006338:	4628      	mov	r0, r5
 800633a:	f7fa fdf9 	bl	8000f30 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 800633e:	4b20      	ldr	r3, [pc, #128]	; (80063c0 <thread8+0xb0>)
 8006340:	69a2      	ldr	r2, [r4, #24]
  thread_t *cp = (thread_t *)tqp;
 8006342:	4619      	mov	r1, r3
 8006344:	6253      	str	r3, [r2, #36]	; 0x24
 8006346:	e003      	b.n	8006350 <thread8+0x40>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006348:	689e      	ldr	r6, [r3, #8]
 800634a:	6890      	ldr	r0, [r2, #8]
 800634c:	4286      	cmp	r6, r0
 800634e:	d302      	bcc.n	8006356 <thread8+0x46>
    cp = cp->queue.next;
 8006350:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006352:	428b      	cmp	r3, r1
 8006354:	d1f8      	bne.n	8006348 <thread8+0x38>
  tp->queue.prev             = cp->queue.prev;
 8006356:	6859      	ldr	r1, [r3, #4]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
 8006358:	2007      	movs	r0, #7
 800635a:	e9c2 3100 	strd	r3, r1, [r2]
  tp->queue.prev->queue.next = tp;
 800635e:	600a      	str	r2, [r1, #0]
 8006360:	f04f 31ff 	mov.w	r1, #4294967295
  cp->queue.prev             = tp;
 8006364:	605a      	str	r2, [r3, #4]
 8006366:	f7fc feab 	bl	80030c0 <chSchGoSleepTimeoutS>
  if (msg != MSG_TIMEOUT) {
 800636a:	3001      	adds	r0, #1
 800636c:	d002      	beq.n	8006374 <thread8+0x64>
    chMtxLockS(mp);
 800636e:	4628      	mov	r0, r5
 8006370:	f7fc fdfe 	bl	8002f70 <chMtxLockS>
  _dbg_check_unlock();
 8006374:	f7fd f9bc 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006378:	6823      	ldr	r3, [r4, #0]
 800637a:	42a3      	cmp	r3, r4
 800637c:	d004      	beq.n	8006388 <thread8+0x78>
 800637e:	69a2      	ldr	r2, [r4, #24]
 8006380:	689b      	ldr	r3, [r3, #8]
 8006382:	6892      	ldr	r2, [r2, #8]
 8006384:	429a      	cmp	r2, r3
 8006386:	d311      	bcc.n	80063ac <thread8+0x9c>
 8006388:	2300      	movs	r3, #0
 800638a:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 800638e:	7838      	ldrb	r0, [r7, #0]
 8006390:	f7fe f8a6 	bl	80044e0 <test_emit_token>
  chMtxUnlock(&m1);
 8006394:	4808      	ldr	r0, [pc, #32]	; (80063b8 <thread8+0xa8>)
 8006396:	f7ff fc53 	bl	8005c40 <chMtxUnlock>
  chMtxUnlock(&m2);
 800639a:	4806      	ldr	r0, [pc, #24]	; (80063b4 <thread8+0xa4>)
}
 800639c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chMtxUnlock(&m2);
 80063a0:	f7ff bc4e 	b.w	8005c40 <chMtxUnlock>
  __ASM volatile ("cpsid i" : : : "memory");
 80063a4:	b672      	cpsid	i
 80063a6:	4b07      	ldr	r3, [pc, #28]	; (80063c4 <thread8+0xb4>)
 80063a8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80063aa:	e7fe      	b.n	80063aa <thread8+0x9a>
 80063ac:	b672      	cpsid	i
 80063ae:	4b06      	ldr	r3, [pc, #24]	; (80063c8 <thread8+0xb8>)
 80063b0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80063b2:	e7fe      	b.n	80063b2 <thread8+0xa2>
 80063b4:	20000c48 	.word	0x20000c48
 80063b8:	20000c38 	.word	0x20000c38
 80063bc:	200011a0 	.word	0x200011a0
 80063c0:	20000c04 	.word	0x20000c04
 80063c4:	0800becc 	.word	0x0800becc
 80063c8:	0800bc08 	.word	0x0800bc08
 80063cc:	00000000 	.word	0x00000000

080063d0 <thread6>:
static THD_FUNCTION(thread6, p) {
 80063d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80063d2:	4607      	mov	r7, r0
  chMtxLock(&m1);
 80063d4:	4821      	ldr	r0, [pc, #132]	; (800645c <thread6+0x8c>)
 80063d6:	f7ff fd5b 	bl	8005e90 <chMtxLock>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80063da:	2320      	movs	r3, #32
 80063dc:	f383 8811 	msr	BASEPRI, r3
  thread_t *ctp = currp;
 80063e0:	4d1f      	ldr	r5, [pc, #124]	; (8006460 <thread6+0x90>)
  _dbg_check_lock();
 80063e2:	f7fd f9ed 	bl	80037c0 <_dbg_check_lock>
 80063e6:	69ac      	ldr	r4, [r5, #24]
 80063e8:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  chDbgCheckClassS();
 80063ea:	f7fa fbe9 	bl	8000bc0 <chDbgCheckClassS>
  chDbgAssert(mp != NULL, "not owning a mutex");
 80063ee:	b36e      	cbz	r6, 800644c <thread6+0x7c>
  chMtxUnlockS(mp);
 80063f0:	4630      	mov	r0, r6
 80063f2:	f7fa fd9d 	bl	8000f30 <chMtxUnlockS>
  ctp->u.wtobjp = cp;
 80063f6:	4a1b      	ldr	r2, [pc, #108]	; (8006464 <thread6+0x94>)
 80063f8:	6262      	str	r2, [r4, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 80063fa:	4613      	mov	r3, r2
 80063fc:	e003      	b.n	8006406 <thread6+0x36>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80063fe:	6898      	ldr	r0, [r3, #8]
 8006400:	68a1      	ldr	r1, [r4, #8]
 8006402:	4288      	cmp	r0, r1
 8006404:	d302      	bcc.n	800640c <thread6+0x3c>
    cp = cp->queue.next;
 8006406:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006408:	4293      	cmp	r3, r2
 800640a:	d1f8      	bne.n	80063fe <thread6+0x2e>
  tp->queue.prev             = cp->queue.prev;
 800640c:	685a      	ldr	r2, [r3, #4]
  chSchGoSleepS(CH_STATE_WTCOND);
 800640e:	2007      	movs	r0, #7
 8006410:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8006414:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8006416:	605c      	str	r4, [r3, #4]
 8006418:	f7fc fd92 	bl	8002f40 <chSchGoSleepS>
  chMtxLockS(mp);
 800641c:	4630      	mov	r0, r6
 800641e:	f7fc fda7 	bl	8002f70 <chMtxLockS>
  _dbg_check_unlock();
 8006422:	f7fd f965 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006426:	682b      	ldr	r3, [r5, #0]
 8006428:	42ab      	cmp	r3, r5
 800642a:	d004      	beq.n	8006436 <thread6+0x66>
 800642c:	69aa      	ldr	r2, [r5, #24]
 800642e:	689b      	ldr	r3, [r3, #8]
 8006430:	6892      	ldr	r2, [r2, #8]
 8006432:	429a      	cmp	r2, r3
 8006434:	d30e      	bcc.n	8006454 <thread6+0x84>
 8006436:	2300      	movs	r3, #0
 8006438:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 800643c:	7838      	ldrb	r0, [r7, #0]
 800643e:	f7fe f84f 	bl	80044e0 <test_emit_token>
  chMtxUnlock(&m1);
 8006442:	4806      	ldr	r0, [pc, #24]	; (800645c <thread6+0x8c>)
}
 8006444:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chMtxUnlock(&m1);
 8006448:	f7ff bbfa 	b.w	8005c40 <chMtxUnlock>
  __ASM volatile ("cpsid i" : : : "memory");
 800644c:	b672      	cpsid	i
 800644e:	4b06      	ldr	r3, [pc, #24]	; (8006468 <thread6+0x98>)
 8006450:	62eb      	str	r3, [r5, #44]	; 0x2c
 8006452:	e7fe      	b.n	8006452 <thread6+0x82>
 8006454:	b672      	cpsid	i
 8006456:	4b05      	ldr	r3, [pc, #20]	; (800646c <thread6+0x9c>)
 8006458:	62eb      	str	r3, [r5, #44]	; 0x2c
 800645a:	e7fe      	b.n	800645a <thread6+0x8a>
 800645c:	20000c38 	.word	0x20000c38
 8006460:	200011a0 	.word	0x200011a0
 8006464:	20000c04 	.word	0x20000c04
 8006468:	0800be30 	.word	0x0800be30
 800646c:	0800bc08 	.word	0x0800bc08

08006470 <thread9>:
static THD_FUNCTION(thread9, p) {
 8006470:	b538      	push	{r3, r4, r5, lr}
  chMtxLock(&m2);
 8006472:	4c06      	ldr	r4, [pc, #24]	; (800648c <thread9+0x1c>)
static THD_FUNCTION(thread9, p) {
 8006474:	4605      	mov	r5, r0
  chMtxLock(&m2);
 8006476:	4620      	mov	r0, r4
 8006478:	f7ff fd0a 	bl	8005e90 <chMtxLock>
  test_emit_token(*(char *)p);
 800647c:	7828      	ldrb	r0, [r5, #0]
 800647e:	f7fe f82f 	bl	80044e0 <test_emit_token>
  chMtxUnlock(&m2);
 8006482:	4620      	mov	r0, r4
}
 8006484:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m2);
 8006488:	f7ff bbda 	b.w	8005c40 <chMtxUnlock>
 800648c:	20000c48 	.word	0x20000c48

08006490 <thread1.lto_priv.179>:
static THD_FUNCTION(thread1, p) {
 8006490:	b538      	push	{r3, r4, r5, lr}
  chMtxLock(&m1);
 8006492:	4c06      	ldr	r4, [pc, #24]	; (80064ac <thread1.lto_priv.179+0x1c>)
static THD_FUNCTION(thread1, p) {
 8006494:	4605      	mov	r5, r0
  chMtxLock(&m1);
 8006496:	4620      	mov	r0, r4
 8006498:	f7ff fcfa 	bl	8005e90 <chMtxLock>
  test_emit_token(*(char *)p);
 800649c:	7828      	ldrb	r0, [r5, #0]
 800649e:	f7fe f81f 	bl	80044e0 <test_emit_token>
  chMtxUnlock(&m1);
 80064a2:	4620      	mov	r0, r4
}
 80064a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m1);
 80064a8:	f7ff bbca 	b.w	8005c40 <chMtxUnlock>
 80064ac:	20000c38 	.word	0x20000c38

080064b0 <chFactoryReleaseSemaphore>:
void chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
 80064b0:	b538      	push	{r3, r4, r5, lr}
  F_LOCK();
 80064b2:	4c08      	ldr	r4, [pc, #32]	; (80064d4 <chFactoryReleaseSemaphore+0x24>)
void chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
 80064b4:	4605      	mov	r5, r0
  F_LOCK();
 80064b6:	4620      	mov	r0, r4
 80064b8:	f7ff fcea 	bl	8005e90 <chMtxLock>
  dyn_release_object_pool(&dsp->element,
 80064bc:	4628      	mov	r0, r5
 80064be:	f104 022c 	add.w	r2, r4, #44	; 0x2c
 80064c2:	f104 0128 	add.w	r1, r4, #40	; 0x28
 80064c6:	f7ff f823 	bl	8005510 <dyn_release_object_pool>
  F_UNLOCK();
 80064ca:	4620      	mov	r0, r4
}
 80064cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 80064d0:	f7ff bbb6 	b.w	8005c40 <chMtxUnlock>
 80064d4:	20001220 	.word	0x20001220
	...

080064e0 <oslib_test_004_003_execute>:
      chFactoryReleaseSemaphore(dsp);
    }
  }
}

static void oslib_test_004_003_execute(void) {
 80064e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_semaphore_t *dsp;

  /* [4.3.1] Retrieving a dynamic semaphore by name, must not exist.*/
  test_set_step(1);
 80064e2:	4c42      	ldr	r4, [pc, #264]	; (80065ec <oslib_test_004_003_execute+0x10c>)
 80064e4:	2501      	movs	r5, #1
 80064e6:	6025      	str	r5, [r4, #0]
  {
    dsp = chFactoryFindSemaphore("mysem");
 80064e8:	f7ff fe62 	bl	80061b0 <chFactoryFindSemaphore.constprop.8>
    test_assert(dsp == NULL, "found");
 80064ec:	fab0 f080 	clz	r0, r0
 80064f0:	0940      	lsrs	r0, r0, #5
 80064f2:	493f      	ldr	r1, [pc, #252]	; (80065f0 <oslib_test_004_003_execute+0x110>)
 80064f4:	f7fa fa14 	bl	8000920 <_test_assert>
 80064f8:	b100      	cbz	r0, 80064fc <oslib_test_004_003_execute+0x1c>
  test_set_step(6);
  {
    dsp = chFactoryFindSemaphore("mysem");
    test_assert(dsp == NULL, "found");
  }
}
 80064fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 80064fc:	2302      	movs	r3, #2
 80064fe:	6023      	str	r3, [r4, #0]
    dsp = chFactoryCreateSemaphore("mysem", 0);
 8006500:	f7ff fe36 	bl	8006170 <chFactoryCreateSemaphore.constprop.9>
    test_assert(dsp != NULL, "cannot create");
 8006504:	4606      	mov	r6, r0
 8006506:	3000      	adds	r0, #0
 8006508:	bf18      	it	ne
 800650a:	2001      	movne	r0, #1
 800650c:	4939      	ldr	r1, [pc, #228]	; (80065f4 <oslib_test_004_003_execute+0x114>)
 800650e:	f7fa fa07 	bl	8000920 <_test_assert>
 8006512:	2800      	cmp	r0, #0
 8006514:	d1f1      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
  test_set_step(3);
 8006516:	2303      	movs	r3, #3
 8006518:	6023      	str	r3, [r4, #0]
    dsp1 = chFactoryCreateSemaphore("mysem", 0);
 800651a:	f7ff fe29 	bl	8006170 <chFactoryCreateSemaphore.constprop.9>
    test_assert(dsp1 == NULL, "can create");
 800651e:	fab0 f080 	clz	r0, r0
 8006522:	0940      	lsrs	r0, r0, #5
 8006524:	4934      	ldr	r1, [pc, #208]	; (80065f8 <oslib_test_004_003_execute+0x118>)
 8006526:	f7fa f9fb 	bl	8000920 <_test_assert>
 800652a:	2800      	cmp	r0, #0
 800652c:	d1e5      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
  test_set_step(4);
 800652e:	2304      	movs	r3, #4
 8006530:	6023      	str	r3, [r4, #0]
    dsp1 = chFactoryFindSemaphore("mysem");
 8006532:	f7ff fe3d 	bl	80061b0 <chFactoryFindSemaphore.constprop.8>
    test_assert(dsp1 != NULL, "not found");
 8006536:	4607      	mov	r7, r0
 8006538:	3000      	adds	r0, #0
 800653a:	bf18      	it	ne
 800653c:	2001      	movne	r0, #1
 800653e:	492f      	ldr	r1, [pc, #188]	; (80065fc <oslib_test_004_003_execute+0x11c>)
 8006540:	f7fa f9ee 	bl	8000920 <_test_assert>
 8006544:	2800      	cmp	r0, #0
 8006546:	d1d8      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
    test_assert(dsp == dsp1, "object reference mismatch");
 8006548:	1bf0      	subs	r0, r6, r7
 800654a:	fab0 f080 	clz	r0, r0
 800654e:	492c      	ldr	r1, [pc, #176]	; (8006600 <oslib_test_004_003_execute+0x120>)
 8006550:	0940      	lsrs	r0, r0, #5
 8006552:	f7fa f9e5 	bl	8000920 <_test_assert>
 8006556:	2800      	cmp	r0, #0
 8006558:	d1cf      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
    test_assert(dsp1->element.refs == 2, "object reference mismatch");
 800655a:	6878      	ldr	r0, [r7, #4]
 800655c:	4928      	ldr	r1, [pc, #160]	; (8006600 <oslib_test_004_003_execute+0x120>)
 800655e:	f1a0 0002 	sub.w	r0, r0, #2
 8006562:	fab0 f080 	clz	r0, r0
 8006566:	0940      	lsrs	r0, r0, #5
 8006568:	f7fa f9da 	bl	8000920 <_test_assert>
 800656c:	2800      	cmp	r0, #0
 800656e:	d1c4      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
 *
 * @api
 */
static inline dyn_element_t *chFactoryDuplicateReference(dyn_element_t *dep) {

  dep->refs++;
 8006570:	687b      	ldr	r3, [r7, #4]
    test_assert(dsp1 == dsp2, "object reference mismatch");
 8006572:	4923      	ldr	r1, [pc, #140]	; (8006600 <oslib_test_004_003_execute+0x120>)
 8006574:	442b      	add	r3, r5
 8006576:	4628      	mov	r0, r5
 8006578:	607b      	str	r3, [r7, #4]
 800657a:	f7fa f9d1 	bl	8000920 <_test_assert>
 800657e:	2800      	cmp	r0, #0
 8006580:	d1bb      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
    test_assert(dsp2->element.refs == 3, "object reference mismatch");
 8006582:	6878      	ldr	r0, [r7, #4]
 8006584:	491e      	ldr	r1, [pc, #120]	; (8006600 <oslib_test_004_003_execute+0x120>)
 8006586:	f1a0 0c03 	sub.w	ip, r0, #3
 800658a:	f1dc 0000 	rsbs	r0, ip, #0
 800658e:	eb40 000c 	adc.w	r0, r0, ip
 8006592:	f7fa f9c5 	bl	8000920 <_test_assert>
 8006596:	2800      	cmp	r0, #0
 8006598:	d1af      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
    chFactoryReleaseSemaphore(dsp2);
 800659a:	4638      	mov	r0, r7
 800659c:	f7ff ff88 	bl	80064b0 <chFactoryReleaseSemaphore>
    test_assert(dsp1->element.refs == 2, "references mismatch");
 80065a0:	6878      	ldr	r0, [r7, #4]
 80065a2:	4918      	ldr	r1, [pc, #96]	; (8006604 <oslib_test_004_003_execute+0x124>)
 80065a4:	1e82      	subs	r2, r0, #2
 80065a6:	4250      	negs	r0, r2
 80065a8:	4150      	adcs	r0, r2
 80065aa:	f7fa f9b9 	bl	8000920 <_test_assert>
 80065ae:	2800      	cmp	r0, #0
 80065b0:	d1a3      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
    chFactoryReleaseSemaphore(dsp1);
 80065b2:	4638      	mov	r0, r7
 80065b4:	f7ff ff7c 	bl	80064b0 <chFactoryReleaseSemaphore>
    test_assert(dsp->element.refs == 1, "references mismatch");
 80065b8:	6870      	ldr	r0, [r6, #4]
 80065ba:	4912      	ldr	r1, [pc, #72]	; (8006604 <oslib_test_004_003_execute+0x124>)
 80065bc:	1b43      	subs	r3, r0, r5
 80065be:	4258      	negs	r0, r3
 80065c0:	4158      	adcs	r0, r3
 80065c2:	f7fa f9ad 	bl	8000920 <_test_assert>
 80065c6:	2800      	cmp	r0, #0
 80065c8:	d197      	bne.n	80064fa <oslib_test_004_003_execute+0x1a>
    chFactoryReleaseSemaphore(dsp);
 80065ca:	4630      	mov	r0, r6
  test_set_step(5);
 80065cc:	2305      	movs	r3, #5
 80065ce:	6023      	str	r3, [r4, #0]
    chFactoryReleaseSemaphore(dsp);
 80065d0:	f7ff ff6e 	bl	80064b0 <chFactoryReleaseSemaphore>
  test_set_step(6);
 80065d4:	2306      	movs	r3, #6
 80065d6:	6023      	str	r3, [r4, #0]
    dsp = chFactoryFindSemaphore("mysem");
 80065d8:	f7ff fdea 	bl	80061b0 <chFactoryFindSemaphore.constprop.8>
    test_assert(dsp == NULL, "found");
 80065dc:	fab0 f080 	clz	r0, r0
 80065e0:	0940      	lsrs	r0, r0, #5
 80065e2:	4903      	ldr	r1, [pc, #12]	; (80065f0 <oslib_test_004_003_execute+0x110>)
}
 80065e4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dsp == NULL, "found");
 80065e8:	f7fa b99a 	b.w	8000920 <_test_assert>
 80065ec:	20001b3c 	.word	0x20001b3c
 80065f0:	0800c7e8 	.word	0x0800c7e8
 80065f4:	0800c7c8 	.word	0x0800c7c8
 80065f8:	0800c7d8 	.word	0x0800c7d8
 80065fc:	0800c7e4 	.word	0x0800c7e4
 8006600:	0800c7f0 	.word	0x0800c7f0
 8006604:	0800c80c 	.word	0x0800c80c
	...

08006610 <oslib_test_004_003_teardown>:
static void oslib_test_004_003_teardown(void) {
 8006610:	b510      	push	{r4, lr}
  dsp = chFactoryFindSemaphore("mysem");
 8006612:	f7ff fdcd 	bl	80061b0 <chFactoryFindSemaphore.constprop.8>
  if (dsp != NULL) {
 8006616:	b140      	cbz	r0, 800662a <oslib_test_004_003_teardown+0x1a>
    while (dsp->element.refs > 0U) {
 8006618:	6843      	ldr	r3, [r0, #4]
 800661a:	4604      	mov	r4, r0
 800661c:	b12b      	cbz	r3, 800662a <oslib_test_004_003_teardown+0x1a>
      chFactoryReleaseSemaphore(dsp);
 800661e:	4620      	mov	r0, r4
 8006620:	f7ff ff46 	bl	80064b0 <chFactoryReleaseSemaphore>
    while (dsp->element.refs > 0U) {
 8006624:	6863      	ldr	r3, [r4, #4]
 8006626:	2b00      	cmp	r3, #0
 8006628:	d1f9      	bne.n	800661e <oslib_test_004_003_teardown+0xe>
}
 800662a:	bd10      	pop	{r4, pc}
 800662c:	0000      	movs	r0, r0
	...

08006630 <chFactoryReleaseObject>:
void chFactoryReleaseObject(registered_object_t *rop){
 8006630:	b538      	push	{r3, r4, r5, lr}
  F_LOCK();
 8006632:	4c08      	ldr	r4, [pc, #32]	; (8006654 <chFactoryReleaseObject+0x24>)
void chFactoryReleaseObject(registered_object_t *rop){
 8006634:	4605      	mov	r5, r0
  F_LOCK();
 8006636:	4620      	mov	r0, r4
 8006638:	f7ff fc2a 	bl	8005e90 <chMtxLock>
  dyn_release_object_pool(&rop->element,
 800663c:	4628      	mov	r0, r5
 800663e:	f104 0214 	add.w	r2, r4, #20
 8006642:	f104 0110 	add.w	r1, r4, #16
 8006646:	f7fe ff63 	bl	8005510 <dyn_release_object_pool>
  F_UNLOCK();
 800664a:	4620      	mov	r0, r4
}
 800664c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 8006650:	f7ff baf6 	b.w	8005c40 <chMtxUnlock>
 8006654:	20001220 	.word	0x20001220
	...

08006660 <oslib_test_004_001_execute>:
static void oslib_test_004_001_execute(void) {
 8006660:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8006664:	4c51      	ldr	r4, [pc, #324]	; (80067ac <oslib_test_004_001_execute+0x14c>)
 8006666:	2501      	movs	r5, #1
 8006668:	6025      	str	r5, [r4, #0]
    rop = chFactoryFindObject("myobj");
 800666a:	f7ff fd31 	bl	80060d0 <chFactoryFindObject.constprop.12>
    test_assert(rop == NULL, "found");
 800666e:	fab0 f080 	clz	r0, r0
 8006672:	0940      	lsrs	r0, r0, #5
 8006674:	494e      	ldr	r1, [pc, #312]	; (80067b0 <oslib_test_004_001_execute+0x150>)
 8006676:	f7fa f953 	bl	8000920 <_test_assert>
 800667a:	b108      	cbz	r0, 8006680 <oslib_test_004_001_execute+0x20>
}
 800667c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(2);
 8006680:	2302      	movs	r3, #2
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
 8006682:	484c      	ldr	r0, [pc, #304]	; (80067b4 <oslib_test_004_001_execute+0x154>)
  test_set_step(2);
 8006684:	6023      	str	r3, [r4, #0]
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
 8006686:	f7ff fd0b 	bl	80060a0 <chFactoryRegisterObject.constprop.13>
    test_assert(rop != NULL, "cannot register");
 800668a:	4606      	mov	r6, r0
 800668c:	3000      	adds	r0, #0
 800668e:	bf18      	it	ne
 8006690:	2001      	movne	r0, #1
 8006692:	4949      	ldr	r1, [pc, #292]	; (80067b8 <oslib_test_004_001_execute+0x158>)
 8006694:	f7fa f944 	bl	8000920 <_test_assert>
 8006698:	2800      	cmp	r0, #0
 800669a:	d1ef      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
  test_set_step(3);
 800669c:	2303      	movs	r3, #3
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
 800669e:	4847      	ldr	r0, [pc, #284]	; (80067bc <oslib_test_004_001_execute+0x15c>)
  test_set_step(3);
 80066a0:	6023      	str	r3, [r4, #0]
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
 80066a2:	f7ff fcfd 	bl	80060a0 <chFactoryRegisterObject.constprop.13>
    test_assert(rop1 == NULL, "can register");
 80066a6:	fab0 f080 	clz	r0, r0
 80066aa:	0940      	lsrs	r0, r0, #5
 80066ac:	4944      	ldr	r1, [pc, #272]	; (80067c0 <oslib_test_004_001_execute+0x160>)
 80066ae:	f7fa f937 	bl	8000920 <_test_assert>
 80066b2:	2800      	cmp	r0, #0
 80066b4:	d1e2      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
  test_set_step(4);
 80066b6:	2304      	movs	r3, #4
 80066b8:	6023      	str	r3, [r4, #0]
    rop1 = chFactoryFindObject("myobj");
 80066ba:	f7ff fd09 	bl	80060d0 <chFactoryFindObject.constprop.12>
    test_assert(rop1 != NULL, "not found");
 80066be:	4607      	mov	r7, r0
 80066c0:	3000      	adds	r0, #0
 80066c2:	bf18      	it	ne
 80066c4:	2001      	movne	r0, #1
 80066c6:	493f      	ldr	r1, [pc, #252]	; (80067c4 <oslib_test_004_001_execute+0x164>)
 80066c8:	f7fa f92a 	bl	8000920 <_test_assert>
 80066cc:	2800      	cmp	r0, #0
 80066ce:	d1d5      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
    test_assert(*(uint32_t *)(rop1->objp) == 0x55aa, "object mismatch");
 80066d0:	693b      	ldr	r3, [r7, #16]
 80066d2:	493d      	ldr	r1, [pc, #244]	; (80067c8 <oslib_test_004_001_execute+0x168>)
 80066d4:	6818      	ldr	r0, [r3, #0]
 80066d6:	f245 58aa 	movw	r8, #21930	; 0x55aa
 80066da:	eba0 0008 	sub.w	r0, r0, r8
 80066de:	fab0 f080 	clz	r0, r0
 80066e2:	0940      	lsrs	r0, r0, #5
 80066e4:	f7fa f91c 	bl	8000920 <_test_assert>
 80066e8:	2800      	cmp	r0, #0
 80066ea:	d1c7      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
    test_assert(rop == rop1, "object reference mismatch");
 80066ec:	1bf0      	subs	r0, r6, r7
 80066ee:	fab0 f080 	clz	r0, r0
 80066f2:	4936      	ldr	r1, [pc, #216]	; (80067cc <oslib_test_004_001_execute+0x16c>)
 80066f4:	0940      	lsrs	r0, r0, #5
 80066f6:	f7fa f913 	bl	8000920 <_test_assert>
 80066fa:	2800      	cmp	r0, #0
 80066fc:	d1be      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
    test_assert(rop1->element.refs == 2, "object reference mismatch");
 80066fe:	6878      	ldr	r0, [r7, #4]
 8006700:	4932      	ldr	r1, [pc, #200]	; (80067cc <oslib_test_004_001_execute+0x16c>)
 8006702:	f1a0 0002 	sub.w	r0, r0, #2
 8006706:	fab0 f080 	clz	r0, r0
 800670a:	0940      	lsrs	r0, r0, #5
 800670c:	f7fa f908 	bl	8000920 <_test_assert>
 8006710:	2800      	cmp	r0, #0
 8006712:	d1b3      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
 8006714:	687b      	ldr	r3, [r7, #4]
    test_assert(rop1 == rop2, "object reference mismatch");
 8006716:	492d      	ldr	r1, [pc, #180]	; (80067cc <oslib_test_004_001_execute+0x16c>)
 8006718:	442b      	add	r3, r5
 800671a:	4628      	mov	r0, r5
 800671c:	607b      	str	r3, [r7, #4]
 800671e:	f7fa f8ff 	bl	8000920 <_test_assert>
 8006722:	2800      	cmp	r0, #0
 8006724:	d1aa      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
    test_assert(*(uint32_t *)(rop2->objp) == 0x55aa, "object mismatch");
 8006726:	693b      	ldr	r3, [r7, #16]
 8006728:	4927      	ldr	r1, [pc, #156]	; (80067c8 <oslib_test_004_001_execute+0x168>)
 800672a:	6818      	ldr	r0, [r3, #0]
 800672c:	eba0 0e08 	sub.w	lr, r0, r8
 8006730:	f1de 0000 	rsbs	r0, lr, #0
 8006734:	eb40 000e 	adc.w	r0, r0, lr
 8006738:	f7fa f8f2 	bl	8000920 <_test_assert>
 800673c:	2800      	cmp	r0, #0
 800673e:	d19d      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
    test_assert(rop2->element.refs == 3, "object reference mismatch");
 8006740:	6878      	ldr	r0, [r7, #4]
 8006742:	4922      	ldr	r1, [pc, #136]	; (80067cc <oslib_test_004_001_execute+0x16c>)
 8006744:	f1a0 0c03 	sub.w	ip, r0, #3
 8006748:	f1dc 0000 	rsbs	r0, ip, #0
 800674c:	eb40 000c 	adc.w	r0, r0, ip
 8006750:	f7fa f8e6 	bl	8000920 <_test_assert>
 8006754:	2800      	cmp	r0, #0
 8006756:	d191      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
    chFactoryReleaseObject(rop2);
 8006758:	4638      	mov	r0, r7
 800675a:	f7ff ff69 	bl	8006630 <chFactoryReleaseObject>
    test_assert(rop1->element.refs == 2, "references mismatch");
 800675e:	6878      	ldr	r0, [r7, #4]
 8006760:	491b      	ldr	r1, [pc, #108]	; (80067d0 <oslib_test_004_001_execute+0x170>)
 8006762:	1e82      	subs	r2, r0, #2
 8006764:	4250      	negs	r0, r2
 8006766:	4150      	adcs	r0, r2
 8006768:	f7fa f8da 	bl	8000920 <_test_assert>
 800676c:	2800      	cmp	r0, #0
 800676e:	d185      	bne.n	800667c <oslib_test_004_001_execute+0x1c>
    chFactoryReleaseObject(rop1);
 8006770:	4638      	mov	r0, r7
 8006772:	f7ff ff5d 	bl	8006630 <chFactoryReleaseObject>
    test_assert(rop->element.refs == 1, "references mismatch");
 8006776:	6870      	ldr	r0, [r6, #4]
 8006778:	4915      	ldr	r1, [pc, #84]	; (80067d0 <oslib_test_004_001_execute+0x170>)
 800677a:	1b43      	subs	r3, r0, r5
 800677c:	4258      	negs	r0, r3
 800677e:	4158      	adcs	r0, r3
 8006780:	f7fa f8ce 	bl	8000920 <_test_assert>
 8006784:	2800      	cmp	r0, #0
 8006786:	f47f af79 	bne.w	800667c <oslib_test_004_001_execute+0x1c>
    chFactoryReleaseObject(rop);
 800678a:	4630      	mov	r0, r6
  test_set_step(5);
 800678c:	2305      	movs	r3, #5
 800678e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseObject(rop);
 8006790:	f7ff ff4e 	bl	8006630 <chFactoryReleaseObject>
  test_set_step(6);
 8006794:	2306      	movs	r3, #6
 8006796:	6023      	str	r3, [r4, #0]
    rop = chFactoryFindObject("myobj");
 8006798:	f7ff fc9a 	bl	80060d0 <chFactoryFindObject.constprop.12>
    test_assert(rop == NULL, "found");
 800679c:	fab0 f080 	clz	r0, r0
 80067a0:	0940      	lsrs	r0, r0, #5
 80067a2:	4903      	ldr	r1, [pc, #12]	; (80067b0 <oslib_test_004_001_execute+0x150>)
}
 80067a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(rop == NULL, "found");
 80067a8:	f7fa b8ba 	b.w	8000920 <_test_assert>
 80067ac:	20001b3c 	.word	0x20001b3c
 80067b0:	0800c7e8 	.word	0x0800c7e8
 80067b4:	20000c90 	.word	0x20000c90
 80067b8:	0800c778 	.word	0x0800c778
 80067bc:	20000c94 	.word	0x20000c94
 80067c0:	0800c788 	.word	0x0800c788
 80067c4:	0800c7e4 	.word	0x0800c7e4
 80067c8:	0800c798 	.word	0x0800c798
 80067cc:	0800c7f0 	.word	0x0800c7f0
 80067d0:	0800c80c 	.word	0x0800c80c
	...

080067e0 <oslib_test_004_001_teardown>:
static void oslib_test_004_001_teardown(void) {
 80067e0:	b510      	push	{r4, lr}
  rop = chFactoryFindObject("myobj");
 80067e2:	f7ff fc75 	bl	80060d0 <chFactoryFindObject.constprop.12>
  if (rop != NULL) {
 80067e6:	b140      	cbz	r0, 80067fa <oslib_test_004_001_teardown+0x1a>
    while (rop->element.refs > 0U) {
 80067e8:	6843      	ldr	r3, [r0, #4]
 80067ea:	4604      	mov	r4, r0
 80067ec:	b12b      	cbz	r3, 80067fa <oslib_test_004_001_teardown+0x1a>
      chFactoryReleaseObject(rop);
 80067ee:	4620      	mov	r0, r4
 80067f0:	f7ff ff1e 	bl	8006630 <chFactoryReleaseObject>
    while (rop->element.refs > 0U) {
 80067f4:	6863      	ldr	r3, [r4, #4]
 80067f6:	2b00      	cmp	r3, #0
 80067f8:	d1f9      	bne.n	80067ee <oslib_test_004_001_teardown+0xe>
}
 80067fa:	bd10      	pop	{r4, pc}
 80067fc:	0000      	movs	r0, r0
	...

08006800 <chHeapStatus>:
 *                      free free block found space or @p NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8006800:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 8006804:	4c17      	ldr	r4, [pc, #92]	; (8006864 <chHeapStatus+0x64>)
 8006806:	2800      	cmp	r0, #0
 8006808:	bf18      	it	ne
 800680a:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 800680c:	f104 070c 	add.w	r7, r4, #12
 8006810:	4638      	mov	r0, r7
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8006812:	4689      	mov	r9, r1
 8006814:	4690      	mov	r8, r2
  H_LOCK(heapp);
 8006816:	f7ff fb3b 	bl	8005e90 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800681a:	6863      	ldr	r3, [r4, #4]
 800681c:	b1f3      	cbz	r3, 800685c <chHeapStatus+0x5c>
  lpages = 0U;
 800681e:	2400      	movs	r4, #0
  tpages = 0U;
 8006820:	4625      	mov	r5, r4
  n = 0U;
 8006822:	4626      	mov	r6, r4
  while (H_NEXT(qp) != NULL) {
 8006824:	e9d3 3000 	ldrd	r3, r0, [r3]
 8006828:	4284      	cmp	r4, r0
    size_t pages = H_PAGES(H_NEXT(qp));

    /* Updating counters.*/
    n++;
 800682a:	f106 0601 	add.w	r6, r6, #1
    tpages += pages;
 800682e:	4405      	add	r5, r0
 8006830:	bf38      	it	cc
 8006832:	4604      	movcc	r4, r0
  while (H_NEXT(qp) != NULL) {
 8006834:	2b00      	cmp	r3, #0
 8006836:	d1f5      	bne.n	8006824 <chHeapStatus+0x24>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 8006838:	f1b9 0f00 	cmp.w	r9, #0
 800683c:	d002      	beq.n	8006844 <chHeapStatus+0x44>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 800683e:	00ed      	lsls	r5, r5, #3
 8006840:	f8c9 5000 	str.w	r5, [r9]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 8006844:	f1b8 0f00 	cmp.w	r8, #0
 8006848:	d002      	beq.n	8006850 <chHeapStatus+0x50>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 800684a:	00e4      	lsls	r4, r4, #3
 800684c:	f8c8 4000 	str.w	r4, [r8]
  }
  H_UNLOCK(heapp);
 8006850:	4638      	mov	r0, r7
 8006852:	f7ff f9f5 	bl	8005c40 <chMtxUnlock>

  return n;
}
 8006856:	4630      	mov	r0, r6
 8006858:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  lpages = 0U;
 800685c:	461c      	mov	r4, r3
  tpages = 0U;
 800685e:	461d      	mov	r5, r3
  n = 0U;
 8006860:	461e      	mov	r6, r3
 8006862:	e7e9      	b.n	8006838 <chHeapStatus+0x38>
 8006864:	20001348 	.word	0x20001348
	...

08006870 <cmd_mem>:
#endif

#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8006870:	b530      	push	{r4, r5, lr}
  size_t n, total, largest;

  (void)argv;
  if (argc > 0) {
 8006872:	2900      	cmp	r1, #0
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8006874:	b083      	sub	sp, #12
  if (argc > 0) {
 8006876:	dd05      	ble.n	8006884 <cmd_mem+0x14>
    shellUsage(chp, "mem");
 8006878:	4a12      	ldr	r2, [pc, #72]	; (80068c4 <cmd_mem+0x54>)
 800687a:	4913      	ldr	r1, [pc, #76]	; (80068c8 <cmd_mem+0x58>)
 800687c:	f7fc f888 	bl	8002990 <chprintf>
  n = chHeapStatus(NULL, &total, &largest);
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
}
 8006880:	b003      	add	sp, #12
 8006882:	bd30      	pop	{r4, r5, pc}
 8006884:	4604      	mov	r4, r0
  n = chHeapStatus(NULL, &total, &largest);
 8006886:	aa01      	add	r2, sp, #4
 8006888:	4669      	mov	r1, sp
 800688a:	2000      	movs	r0, #0
 800688c:	f7ff ffb8 	bl	8006800 <chHeapStatus>
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 8006890:	4b0e      	ldr	r3, [pc, #56]	; (80068cc <cmd_mem+0x5c>)
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
 8006892:	490f      	ldr	r1, [pc, #60]	; (80068d0 <cmd_mem+0x60>)
 8006894:	e9d3 3200 	ldrd	r3, r2, [r3]
  n = chHeapStatus(NULL, &total, &largest);
 8006898:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
 800689a:	1ad2      	subs	r2, r2, r3
 800689c:	4620      	mov	r0, r4
 800689e:	f7fc f877 	bl	8002990 <chprintf>
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
 80068a2:	462a      	mov	r2, r5
 80068a4:	490b      	ldr	r1, [pc, #44]	; (80068d4 <cmd_mem+0x64>)
 80068a6:	4620      	mov	r0, r4
 80068a8:	f7fc f872 	bl	8002990 <chprintf>
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
 80068ac:	9a00      	ldr	r2, [sp, #0]
 80068ae:	490a      	ldr	r1, [pc, #40]	; (80068d8 <cmd_mem+0x68>)
 80068b0:	4620      	mov	r0, r4
 80068b2:	f7fc f86d 	bl	8002990 <chprintf>
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
 80068b6:	4620      	mov	r0, r4
 80068b8:	9a01      	ldr	r2, [sp, #4]
 80068ba:	4908      	ldr	r1, [pc, #32]	; (80068dc <cmd_mem+0x6c>)
 80068bc:	f7fc f868 	bl	8002990 <chprintf>
}
 80068c0:	b003      	add	sp, #12
 80068c2:	bd30      	pop	{r4, r5, pc}
 80068c4:	0800c354 	.word	0x0800c354
 80068c8:	0800c234 	.word	0x0800c234
 80068cc:	20001340 	.word	0x20001340
 80068d0:	0800c358 	.word	0x0800c358
 80068d4:	0800c378 	.word	0x0800c378
 80068d8:	0800c390 	.word	0x0800c390
 80068dc:	0800c3b0 	.word	0x0800c3b0

080068e0 <chHeapFree>:
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80068e0:	b108      	cbz	r0, 80068e6 <chHeapFree+0x6>
 80068e2:	0743      	lsls	r3, r0, #29
 80068e4:	d004      	beq.n	80068f0 <chHeapFree+0x10>
 80068e6:	b672      	cpsid	i
 80068e8:	4b28      	ldr	r3, [pc, #160]	; (800698c <chHeapFree+0xac>)
 80068ea:	4a29      	ldr	r2, [pc, #164]	; (8006990 <chHeapFree+0xb0>)
 80068ec:	62da      	str	r2, [r3, #44]	; 0x2c
 80068ee:	e7fe      	b.n	80068ee <chHeapFree+0xe>
void chHeapFree(void *p) {
 80068f0:	b570      	push	{r4, r5, r6, lr}
  heapp = H_HEAP(hp);
 80068f2:	e950 5302 	ldrd	r5, r3, [r0, #-8]
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80068f6:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80068f8:	08db      	lsrs	r3, r3, #3
  H_LOCK(heapp);
 80068fa:	f105 060c 	add.w	r6, r5, #12
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80068fe:	f840 3c04 	str.w	r3, [r0, #-4]
 8006902:	4604      	mov	r4, r0
  qp = &heapp->header;
 8006904:	3504      	adds	r5, #4
  H_LOCK(heapp);
 8006906:	4630      	mov	r0, r6
 8006908:	f7ff fac2 	bl	8005e90 <chMtxLock>
  hp = (heap_header_t *)p - 1U;
 800690c:	f1a4 0208 	sub.w	r2, r4, #8
  qp = &heapp->header;
 8006910:	462b      	mov	r3, r5
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8006912:	4293      	cmp	r3, r2
 8006914:	d805      	bhi.n	8006922 <chHeapFree+0x42>
 8006916:	6859      	ldr	r1, [r3, #4]
 8006918:	3101      	adds	r1, #1
 800691a:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 800691e:	428a      	cmp	r2, r1
 8006920:	d309      	bcc.n	8006936 <chHeapFree+0x56>
    if (((qp == &heapp->header) || (hp > qp)) &&
 8006922:	42ab      	cmp	r3, r5
 8006924:	6818      	ldr	r0, [r3, #0]
 8006926:	d001      	beq.n	800692c <chHeapFree+0x4c>
 8006928:	4293      	cmp	r3, r2
 800692a:	d202      	bcs.n	8006932 <chHeapFree+0x52>
 800692c:	b140      	cbz	r0, 8006940 <chHeapFree+0x60>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800692e:	4282      	cmp	r2, r0
 8006930:	d306      	bcc.n	8006940 <chHeapFree+0x60>
void chHeapFree(void *p) {
 8006932:	4603      	mov	r3, r0
 8006934:	e7ed      	b.n	8006912 <chHeapFree+0x32>
 8006936:	b672      	cpsid	i
 8006938:	4b14      	ldr	r3, [pc, #80]	; (800698c <chHeapFree+0xac>)
 800693a:	4a15      	ldr	r2, [pc, #84]	; (8006990 <chHeapFree+0xb0>)
 800693c:	62da      	str	r2, [r3, #44]	; 0x2c
 800693e:	e7fe      	b.n	800693e <chHeapFree+0x5e>
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8006940:	f854 1c04 	ldr.w	r1, [r4, #-4]
      H_NEXT(hp) = H_NEXT(qp);
 8006944:	f844 0c08 	str.w	r0, [r4, #-8]
      H_NEXT(qp) = hp;
 8006948:	601a      	str	r2, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800694a:	3101      	adds	r1, #1
 800694c:	f854 5c08 	ldr.w	r5, [r4, #-8]
 8006950:	eb02 00c1 	add.w	r0, r2, r1, lsl #3
 8006954:	42a8      	cmp	r0, r5
 8006956:	d107      	bne.n	8006968 <chHeapFree+0x88>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8006958:	6840      	ldr	r0, [r0, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800695a:	f852 5031 	ldr.w	r5, [r2, r1, lsl #3]
 800695e:	f844 5c08 	str.w	r5, [r4, #-8]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8006962:	4401      	add	r1, r0
 8006964:	f844 1c04 	str.w	r1, [r4, #-4]
      if ((H_LIMIT(qp) == hp)) {
 8006968:	6858      	ldr	r0, [r3, #4]
 800696a:	1c41      	adds	r1, r0, #1
 800696c:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8006970:	428a      	cmp	r2, r1
 8006972:	d105      	bne.n	8006980 <chHeapFree+0xa0>
        H_NEXT(qp) = H_NEXT(hp);
 8006974:	e954 1202 	ldrd	r1, r2, [r4, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8006978:	3201      	adds	r2, #1
 800697a:	4402      	add	r2, r0
        H_NEXT(qp) = H_NEXT(hp);
 800697c:	6019      	str	r1, [r3, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800697e:	605a      	str	r2, [r3, #4]
  H_UNLOCK(heapp);
 8006980:	4630      	mov	r0, r6
}
 8006982:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  H_UNLOCK(heapp);
 8006986:	f7ff b95b 	b.w	8005c40 <chMtxUnlock>
 800698a:	bf00      	nop
 800698c:	200011a0 	.word	0x200011a0
 8006990:	0800be54 	.word	0x0800be54
	...

080069a0 <oslib_test_003_002_execute>:
 *   is freed using chHeapFree(), must not fail.
 * - [3.2.2] Testing allocation failure.
 * .
 */

static void oslib_test_003_002_execute(void) {
 80069a0:	b570      	push	{r4, r5, r6, lr}
  void *p1;
  size_t total_size, largest_size;

  /* [3.2.1] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 80069a2:	4c14      	ldr	r4, [pc, #80]	; (80069f4 <oslib_test_003_002_execute+0x54>)
static void oslib_test_003_002_execute(void) {
 80069a4:	b082      	sub	sp, #8
  test_set_step(1);
 80069a6:	2301      	movs	r3, #1
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 80069a8:	466a      	mov	r2, sp
 80069aa:	a901      	add	r1, sp, #4
 80069ac:	2000      	movs	r0, #0
  test_set_step(1);
 80069ae:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 80069b0:	f7ff ff26 	bl	8006800 <chHeapStatus>
 80069b4:	2110      	movs	r1, #16
 80069b6:	4810      	ldr	r0, [pc, #64]	; (80069f8 <oslib_test_003_002_execute+0x58>)
 80069b8:	f7ff fa8a 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 80069bc:	4606      	mov	r6, r0
 80069be:	3000      	adds	r0, #0
 80069c0:	bf18      	it	ne
 80069c2:	2001      	movne	r0, #1
 80069c4:	490d      	ldr	r1, [pc, #52]	; (80069fc <oslib_test_003_002_execute+0x5c>)
 80069c6:	f7f9 ffab 	bl	8000920 <_test_assert>
 80069ca:	b980      	cbnz	r0, 80069ee <oslib_test_003_002_execute+0x4e>
 80069cc:	4605      	mov	r5, r0
    chHeapFree(p1);
 80069ce:	4630      	mov	r0, r6
 80069d0:	f7ff ff86 	bl	80068e0 <chHeapFree>
  }

  /* [3.2.2] Testing allocation failure.*/
  test_set_step(2);
 80069d4:	2302      	movs	r3, #2
 80069d6:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 80069da:	4628      	mov	r0, r5
 80069dc:	6023      	str	r3, [r4, #0]
 80069de:	f7ff fa77 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
 80069e2:	fab0 f080 	clz	r0, r0
 80069e6:	0940      	lsrs	r0, r0, #5
 80069e8:	4905      	ldr	r1, [pc, #20]	; (8006a00 <oslib_test_003_002_execute+0x60>)
 80069ea:	f7f9 ff99 	bl	8000920 <_test_assert>
  }
}
 80069ee:	b002      	add	sp, #8
 80069f0:	bd70      	pop	{r4, r5, r6, pc}
 80069f2:	bf00      	nop
 80069f4:	20001b3c 	.word	0x20001b3c
 80069f8:	20001a9c 	.word	0x20001a9c
 80069fc:	0800c73c 	.word	0x0800c73c
 8006a00:	0800c750 	.word	0x0800c750
	...

08006a10 <oslib_test_003_001_execute>:
static void oslib_test_003_001_execute(void) {
 8006a10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8006a14:	4cbf      	ldr	r4, [pc, #764]	; (8006d14 <oslib_test_003_001_execute+0x304>)
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8006a16:	48c0      	ldr	r0, [pc, #768]	; (8006d18 <oslib_test_003_001_execute+0x308>)
static void oslib_test_003_001_execute(void) {
 8006a18:	b084      	sub	sp, #16
  test_set_step(1);
 8006a1a:	2301      	movs	r3, #1
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8006a1c:	4669      	mov	r1, sp
 8006a1e:	2200      	movs	r2, #0
  test_set_step(1);
 8006a20:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8006a22:	f7ff feed 	bl	8006800 <chHeapStatus>
 8006a26:	f1a0 0001 	sub.w	r0, r0, #1
 8006a2a:	fab0 f080 	clz	r0, r0
 8006a2e:	49bb      	ldr	r1, [pc, #748]	; (8006d1c <oslib_test_003_001_execute+0x30c>)
 8006a30:	0940      	lsrs	r0, r0, #5
 8006a32:	f7f9 ff75 	bl	8000920 <_test_assert>
 8006a36:	b110      	cbz	r0, 8006a3e <oslib_test_003_001_execute+0x2e>
}
 8006a38:	b004      	add	sp, #16
 8006a3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(2);
 8006a3e:	2302      	movs	r3, #2
 8006a40:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006a44:	48b4      	ldr	r0, [pc, #720]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006a46:	6023      	str	r3, [r4, #0]
 8006a48:	f7ff fa42 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
    test_assert(p1 == NULL, "allocation not failed");
 8006a4c:	fab0 f080 	clz	r0, r0
 8006a50:	0940      	lsrs	r0, r0, #5
 8006a52:	49b3      	ldr	r1, [pc, #716]	; (8006d20 <oslib_test_003_001_execute+0x310>)
 8006a54:	f7f9 ff64 	bl	8000920 <_test_assert>
 8006a58:	2800      	cmp	r0, #0
 8006a5a:	d1ed      	bne.n	8006a38 <oslib_test_003_001_execute+0x28>
  test_set_step(3);
 8006a5c:	2303      	movs	r3, #3
 8006a5e:	2110      	movs	r1, #16
 8006a60:	48ad      	ldr	r0, [pc, #692]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006a62:	6023      	str	r3, [r4, #0]
 8006a64:	f7ff fa34 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
    test_assert(p1 != NULL, "allocation failed");
 8006a68:	4605      	mov	r5, r0
 8006a6a:	3000      	adds	r0, #0
 8006a6c:	bf18      	it	ne
 8006a6e:	2001      	movne	r0, #1
 8006a70:	49ac      	ldr	r1, [pc, #688]	; (8006d24 <oslib_test_003_001_execute+0x314>)
 8006a72:	f7f9 ff55 	bl	8000920 <_test_assert>
 8006a76:	2800      	cmp	r0, #0
 8006a78:	d1de      	bne.n	8006a38 <oslib_test_003_001_execute+0x28>
    chHeapFree(p1);
 8006a7a:	4628      	mov	r0, r5
 8006a7c:	f7ff ff30 	bl	80068e0 <chHeapFree>
  test_set_step(4);
 8006a80:	2304      	movs	r3, #4
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8006a82:	a903      	add	r1, sp, #12
 8006a84:	aa02      	add	r2, sp, #8
 8006a86:	48a4      	ldr	r0, [pc, #656]	; (8006d18 <oslib_test_003_001_execute+0x308>)
  test_set_step(4);
 8006a88:	6023      	str	r3, [r4, #0]
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8006a8a:	f7ff feb9 	bl	8006800 <chHeapStatus>
 8006a8e:	4603      	mov	r3, r0
    test_assert(n == 1, "missing free block");
 8006a90:	f1a0 0001 	sub.w	r0, r0, #1
 8006a94:	fab0 f080 	clz	r0, r0
 8006a98:	0940      	lsrs	r0, r0, #5
 8006a9a:	49a3      	ldr	r1, [pc, #652]	; (8006d28 <oslib_test_003_001_execute+0x318>)
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8006a9c:	9301      	str	r3, [sp, #4]
    test_assert(n == 1, "missing free block");
 8006a9e:	f7f9 ff3f 	bl	8000920 <_test_assert>
 8006aa2:	2800      	cmp	r0, #0
 8006aa4:	d1c8      	bne.n	8006a38 <oslib_test_003_001_execute+0x28>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 8006aa6:	9803      	ldr	r0, [sp, #12]
 8006aa8:	49a0      	ldr	r1, [pc, #640]	; (8006d2c <oslib_test_003_001_execute+0x31c>)
 8006aaa:	280f      	cmp	r0, #15
 8006aac:	bf94      	ite	ls
 8006aae:	2000      	movls	r0, #0
 8006ab0:	2001      	movhi	r0, #1
 8006ab2:	f7f9 ff35 	bl	8000920 <_test_assert>
 8006ab6:	2800      	cmp	r0, #0
 8006ab8:	d1be      	bne.n	8006a38 <oslib_test_003_001_execute+0x28>
    test_assert(total_size == largest_size, "unexpected heap state");
 8006aba:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
 8006abe:	1ac0      	subs	r0, r0, r3
 8006ac0:	fab0 f080 	clz	r0, r0
 8006ac4:	4999      	ldr	r1, [pc, #612]	; (8006d2c <oslib_test_003_001_execute+0x31c>)
 8006ac6:	0940      	lsrs	r0, r0, #5
 8006ac8:	f7f9 ff2a 	bl	8000920 <_test_assert>
 8006acc:	4605      	mov	r5, r0
 8006ace:	2800      	cmp	r0, #0
 8006ad0:	d1b2      	bne.n	8006a38 <oslib_test_003_001_execute+0x28>
  test_set_step(5);
 8006ad2:	2305      	movs	r3, #5
 8006ad4:	2110      	movs	r1, #16
 8006ad6:	4890      	ldr	r0, [pc, #576]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006ad8:	6023      	str	r3, [r4, #0]
 8006ada:	f7ff f9f9 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006ade:	2110      	movs	r1, #16
 8006ae0:	4680      	mov	r8, r0
 8006ae2:	488d      	ldr	r0, [pc, #564]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006ae4:	f7ff f9f4 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006ae8:	2110      	movs	r1, #16
 8006aea:	4607      	mov	r7, r0
 8006aec:	488a      	ldr	r0, [pc, #552]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006aee:	f7ff f9ef 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006af2:	4606      	mov	r6, r0
    chHeapFree(p1);                                 /* Does not merge.*/
 8006af4:	4640      	mov	r0, r8
 8006af6:	f7ff fef3 	bl	80068e0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 8006afa:	4638      	mov	r0, r7
 8006afc:	f7ff fef0 	bl	80068e0 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 8006b00:	4630      	mov	r0, r6
 8006b02:	f7ff feed 	bl	80068e0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006b06:	462a      	mov	r2, r5
 8006b08:	a901      	add	r1, sp, #4
 8006b0a:	4883      	ldr	r0, [pc, #524]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006b0c:	f7ff fe78 	bl	8006800 <chHeapStatus>
 8006b10:	f1a0 0001 	sub.w	r0, r0, #1
 8006b14:	fab0 f080 	clz	r0, r0
 8006b18:	4980      	ldr	r1, [pc, #512]	; (8006d1c <oslib_test_003_001_execute+0x30c>)
 8006b1a:	0940      	lsrs	r0, r0, #5
 8006b1c:	f7f9 ff00 	bl	8000920 <_test_assert>
 8006b20:	4605      	mov	r5, r0
 8006b22:	2800      	cmp	r0, #0
 8006b24:	d188      	bne.n	8006a38 <oslib_test_003_001_execute+0x28>
  test_set_step(6);
 8006b26:	2306      	movs	r3, #6
 8006b28:	2110      	movs	r1, #16
 8006b2a:	487b      	ldr	r0, [pc, #492]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006b2c:	6023      	str	r3, [r4, #0]
 8006b2e:	f7ff f9cf 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006b32:	2110      	movs	r1, #16
 8006b34:	4606      	mov	r6, r0
 8006b36:	4878      	ldr	r0, [pc, #480]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006b38:	f7ff f9ca 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006b3c:	2110      	movs	r1, #16
 8006b3e:	4607      	mov	r7, r0
 8006b40:	4875      	ldr	r0, [pc, #468]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006b42:	f7ff f9c5 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
    chHeapFree(p3);                                 /* Merges forward.*/
 8006b46:	f7ff fecb 	bl	80068e0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 8006b4a:	4638      	mov	r0, r7
 8006b4c:	f7ff fec8 	bl	80068e0 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 8006b50:	4630      	mov	r0, r6
 8006b52:	f7ff fec5 	bl	80068e0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006b56:	462a      	mov	r2, r5
 8006b58:	a901      	add	r1, sp, #4
 8006b5a:	486f      	ldr	r0, [pc, #444]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006b5c:	f7ff fe50 	bl	8006800 <chHeapStatus>
 8006b60:	1e43      	subs	r3, r0, #1
 8006b62:	4258      	negs	r0, r3
 8006b64:	496d      	ldr	r1, [pc, #436]	; (8006d1c <oslib_test_003_001_execute+0x30c>)
 8006b66:	4158      	adcs	r0, r3
 8006b68:	f7f9 feda 	bl	8000920 <_test_assert>
 8006b6c:	4605      	mov	r5, r0
 8006b6e:	2800      	cmp	r0, #0
 8006b70:	f47f af62 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
  test_set_step(7);
 8006b74:	2307      	movs	r3, #7
 8006b76:	2111      	movs	r1, #17
 8006b78:	4867      	ldr	r0, [pc, #412]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006b7a:	6023      	str	r3, [r4, #0]
 8006b7c:	f7ff f9a8 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006b80:	2110      	movs	r1, #16
 8006b82:	4606      	mov	r6, r0
 8006b84:	4864      	ldr	r0, [pc, #400]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006b86:	f7ff f9a3 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006b8a:	4607      	mov	r7, r0
    chHeapFree(p1);
 8006b8c:	4630      	mov	r0, r6
 8006b8e:	f7ff fea7 	bl	80068e0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8006b92:	462a      	mov	r2, r5
 8006b94:	a901      	add	r1, sp, #4
 8006b96:	4860      	ldr	r0, [pc, #384]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006b98:	f7ff fe32 	bl	8006800 <chHeapStatus>
 8006b9c:	f1a0 0802 	sub.w	r8, r0, #2
 8006ba0:	f1d8 0000 	rsbs	r0, r8, #0
 8006ba4:	4962      	ldr	r1, [pc, #392]	; (8006d30 <oslib_test_003_001_execute+0x320>)
 8006ba6:	eb40 0008 	adc.w	r0, r0, r8
 8006baa:	f7f9 feb9 	bl	8000920 <_test_assert>
 8006bae:	4605      	mov	r5, r0
 8006bb0:	2800      	cmp	r0, #0
 8006bb2:	f47f af41 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
 8006bb6:	2110      	movs	r1, #16
 8006bb8:	4857      	ldr	r0, [pc, #348]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006bba:	f7ff f989 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8006bbe:	462a      	mov	r2, r5
 8006bc0:	4606      	mov	r6, r0
 8006bc2:	a901      	add	r1, sp, #4
 8006bc4:	4854      	ldr	r0, [pc, #336]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006bc6:	f7ff fe1b 	bl	8006800 <chHeapStatus>
 8006bca:	2801      	cmp	r0, #1
 8006bcc:	f000 809f 	beq.w	8006d0e <oslib_test_003_001_execute+0x2fe>
 8006bd0:	2200      	movs	r2, #0
 8006bd2:	a901      	add	r1, sp, #4
 8006bd4:	4850      	ldr	r0, [pc, #320]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006bd6:	f7ff fe13 	bl	8006800 <chHeapStatus>
 8006bda:	f1a0 0e02 	sub.w	lr, r0, #2
 8006bde:	f1de 0000 	rsbs	r0, lr, #0
 8006be2:	eb40 000e 	adc.w	r0, r0, lr
 8006be6:	494d      	ldr	r1, [pc, #308]	; (8006d1c <oslib_test_003_001_execute+0x30c>)
 8006be8:	f7f9 fe9a 	bl	8000920 <_test_assert>
 8006bec:	4605      	mov	r5, r0
 8006bee:	2800      	cmp	r0, #0
 8006bf0:	f47f af22 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
    chHeapFree(p2);
 8006bf4:	4638      	mov	r0, r7
 8006bf6:	f7ff fe73 	bl	80068e0 <chHeapFree>
    chHeapFree(p1);
 8006bfa:	4630      	mov	r0, r6
 8006bfc:	f7ff fe70 	bl	80068e0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006c00:	462a      	mov	r2, r5
 8006c02:	a901      	add	r1, sp, #4
 8006c04:	4844      	ldr	r0, [pc, #272]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006c06:	f7ff fdfb 	bl	8006800 <chHeapStatus>
 8006c0a:	f100 3cff 	add.w	ip, r0, #4294967295
 8006c0e:	f1dc 0000 	rsbs	r0, ip, #0
 8006c12:	4942      	ldr	r1, [pc, #264]	; (8006d1c <oslib_test_003_001_execute+0x30c>)
 8006c14:	eb40 000c 	adc.w	r0, r0, ip
 8006c18:	f7f9 fe82 	bl	8000920 <_test_assert>
 8006c1c:	4605      	mov	r5, r0
 8006c1e:	2800      	cmp	r0, #0
 8006c20:	f47f af0a 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
  test_set_step(8);
 8006c24:	2308      	movs	r3, #8
 8006c26:	2110      	movs	r1, #16
 8006c28:	483b      	ldr	r0, [pc, #236]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006c2a:	6023      	str	r3, [r4, #0]
 8006c2c:	f7ff f950 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006c30:	2110      	movs	r1, #16
 8006c32:	4607      	mov	r7, r0
 8006c34:	4838      	ldr	r0, [pc, #224]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006c36:	f7ff f94b 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
 8006c3a:	4606      	mov	r6, r0
    chHeapFree(p1);
 8006c3c:	4638      	mov	r0, r7
 8006c3e:	f7ff fe4f 	bl	80068e0 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8006c42:	462a      	mov	r2, r5
 8006c44:	a901      	add	r1, sp, #4
 8006c46:	4834      	ldr	r0, [pc, #208]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006c48:	f7ff fdda 	bl	8006800 <chHeapStatus>
 8006c4c:	1e87      	subs	r7, r0, #2
 8006c4e:	4278      	negs	r0, r7
 8006c50:	4937      	ldr	r1, [pc, #220]	; (8006d30 <oslib_test_003_001_execute+0x320>)
 8006c52:	4178      	adcs	r0, r7
 8006c54:	f7f9 fe64 	bl	8000920 <_test_assert>
 8006c58:	4605      	mov	r5, r0
 8006c5a:	2800      	cmp	r0, #0
 8006c5c:	f47f aeec 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
 8006c60:	2120      	movs	r1, #32
 8006c62:	482d      	ldr	r0, [pc, #180]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006c64:	f7ff f934 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
    chHeapFree(p1);
 8006c68:	f7ff fe3a 	bl	80068e0 <chHeapFree>
    chHeapFree(p2);
 8006c6c:	4630      	mov	r0, r6
 8006c6e:	f7ff fe37 	bl	80068e0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006c72:	462a      	mov	r2, r5
 8006c74:	a901      	add	r1, sp, #4
 8006c76:	4828      	ldr	r0, [pc, #160]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006c78:	f7ff fdc2 	bl	8006800 <chHeapStatus>
 8006c7c:	1e45      	subs	r5, r0, #1
 8006c7e:	4268      	negs	r0, r5
 8006c80:	4926      	ldr	r1, [pc, #152]	; (8006d1c <oslib_test_003_001_execute+0x30c>)
 8006c82:	4168      	adcs	r0, r5
 8006c84:	f7f9 fe4c 	bl	8000920 <_test_assert>
 8006c88:	4602      	mov	r2, r0
 8006c8a:	2800      	cmp	r0, #0
 8006c8c:	f47f aed4 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
  test_set_step(9);
 8006c90:	2309      	movs	r3, #9
    (void)chHeapStatus(&test_heap, &n, NULL);
 8006c92:	a901      	add	r1, sp, #4
 8006c94:	4820      	ldr	r0, [pc, #128]	; (8006d18 <oslib_test_003_001_execute+0x308>)
  test_set_step(9);
 8006c96:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(&test_heap, &n, NULL);
 8006c98:	f7ff fdb2 	bl	8006800 <chHeapStatus>
 8006c9c:	9901      	ldr	r1, [sp, #4]
 8006c9e:	481e      	ldr	r0, [pc, #120]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006ca0:	f7ff f916 	bl	8005ed0 <chHeapAllocAligned.constprop.31>
    test_assert(p1 != NULL, "allocation failed");
 8006ca4:	4606      	mov	r6, r0
 8006ca6:	3000      	adds	r0, #0
 8006ca8:	491e      	ldr	r1, [pc, #120]	; (8006d24 <oslib_test_003_001_execute+0x314>)
 8006caa:	bf18      	it	ne
 8006cac:	2001      	movne	r0, #1
 8006cae:	f7f9 fe37 	bl	8000920 <_test_assert>
 8006cb2:	4602      	mov	r2, r0
 8006cb4:	2800      	cmp	r0, #0
 8006cb6:	f47f aebf 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 8006cba:	4601      	mov	r1, r0
 8006cbc:	4816      	ldr	r0, [pc, #88]	; (8006d18 <oslib_test_003_001_execute+0x308>)
 8006cbe:	f7ff fd9f 	bl	8006800 <chHeapStatus>
 8006cc2:	fab0 f080 	clz	r0, r0
 8006cc6:	0940      	lsrs	r0, r0, #5
 8006cc8:	491a      	ldr	r1, [pc, #104]	; (8006d34 <oslib_test_003_001_execute+0x324>)
 8006cca:	f7f9 fe29 	bl	8000920 <_test_assert>
 8006cce:	4605      	mov	r5, r0
 8006cd0:	2800      	cmp	r0, #0
 8006cd2:	f47f aeb1 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
    chHeapFree(p1);
 8006cd6:	4630      	mov	r0, r6
 8006cd8:	f7ff fe02 	bl	80068e0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006cdc:	462a      	mov	r2, r5
 8006cde:	a901      	add	r1, sp, #4
  test_set_step(10);
 8006ce0:	230a      	movs	r3, #10
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006ce2:	480d      	ldr	r0, [pc, #52]	; (8006d18 <oslib_test_003_001_execute+0x308>)
  test_set_step(10);
 8006ce4:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8006ce6:	f7ff fd8b 	bl	8006800 <chHeapStatus>
 8006cea:	1e42      	subs	r2, r0, #1
 8006cec:	4250      	negs	r0, r2
 8006cee:	4150      	adcs	r0, r2
 8006cf0:	490a      	ldr	r1, [pc, #40]	; (8006d1c <oslib_test_003_001_execute+0x30c>)
 8006cf2:	f7f9 fe15 	bl	8000920 <_test_assert>
 8006cf6:	2800      	cmp	r0, #0
 8006cf8:	f47f ae9e 	bne.w	8006a38 <oslib_test_003_001_execute+0x28>
    test_assert(n == sz, "size changed");
 8006cfc:	e9dd 3000 	ldrd	r3, r0, [sp]
 8006d00:	1ac3      	subs	r3, r0, r3
 8006d02:	4258      	negs	r0, r3
 8006d04:	490c      	ldr	r1, [pc, #48]	; (8006d38 <oslib_test_003_001_execute+0x328>)
 8006d06:	4158      	adcs	r0, r3
 8006d08:	f7f9 fe0a 	bl	8000920 <_test_assert>
 8006d0c:	e694      	b.n	8006a38 <oslib_test_003_001_execute+0x28>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8006d0e:	2001      	movs	r0, #1
 8006d10:	e769      	b.n	8006be6 <oslib_test_003_001_execute+0x1d6>
 8006d12:	bf00      	nop
 8006d14:	20001b3c 	.word	0x20001b3c
 8006d18:	20001a9c 	.word	0x20001a9c
 8006d1c:	0800c6d0 	.word	0x0800c6d0
 8006d20:	0800c750 	.word	0x0800c750
 8006d24:	0800c73c 	.word	0x0800c73c
 8006d28:	0800c6e0 	.word	0x0800c6e0
 8006d2c:	0800c6f4 	.word	0x0800c6f4
 8006d30:	0800c70c 	.word	0x0800c70c
 8006d34:	0800c584 	.word	0x0800c584
 8006d38:	0800c71c 	.word	0x0800c71c
 8006d3c:	00000000 	.word	0x00000000

08006d40 <dyn_release_object_heap>:
  chDbgCheck(dep != NULL);
 8006d40:	b1b8      	cbz	r0, 8006d72 <dyn_release_object_heap+0x32>
  chDbgAssert(dep->refs > (ucnt_t)0, "invalid references number");
 8006d42:	6843      	ldr	r3, [r0, #4]
 8006d44:	b183      	cbz	r3, 8006d68 <dyn_release_object_heap+0x28>
  dep->refs--;
 8006d46:	3b01      	subs	r3, #1
 8006d48:	6043      	str	r3, [r0, #4]
  if (dep->refs == (ucnt_t)0) {
 8006d4a:	b963      	cbnz	r3, 8006d66 <dyn_release_object_heap+0x26>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8006d4c:	460b      	mov	r3, r1
  while (prev->next != (dyn_element_t *)dlp) {
 8006d4e:	681a      	ldr	r2, [r3, #0]
 8006d50:	4291      	cmp	r1, r2
 8006d52:	d005      	beq.n	8006d60 <dyn_release_object_heap+0x20>
    if (prev->next == element) {
 8006d54:	4290      	cmp	r0, r2
 8006d56:	d011      	beq.n	8006d7c <dyn_release_object_heap+0x3c>
 8006d58:	4613      	mov	r3, r2
  while (prev->next != (dyn_element_t *)dlp) {
 8006d5a:	681a      	ldr	r2, [r3, #0]
 8006d5c:	4291      	cmp	r1, r2
 8006d5e:	d1f9      	bne.n	8006d54 <dyn_release_object_heap+0x14>
  return NULL;
 8006d60:	2000      	movs	r0, #0
    chHeapFree((void *)dep);
 8006d62:	f7ff bdbd 	b.w	80068e0 <chHeapFree>
 8006d66:	4770      	bx	lr
 8006d68:	b672      	cpsid	i
 8006d6a:	4b06      	ldr	r3, [pc, #24]	; (8006d84 <dyn_release_object_heap+0x44>)
 8006d6c:	4a06      	ldr	r2, [pc, #24]	; (8006d88 <dyn_release_object_heap+0x48>)
 8006d6e:	62da      	str	r2, [r3, #44]	; 0x2c
 8006d70:	e7fe      	b.n	8006d70 <dyn_release_object_heap+0x30>
 8006d72:	b672      	cpsid	i
 8006d74:	4b03      	ldr	r3, [pc, #12]	; (8006d84 <dyn_release_object_heap+0x44>)
 8006d76:	4a04      	ldr	r2, [pc, #16]	; (8006d88 <dyn_release_object_heap+0x48>)
 8006d78:	62da      	str	r2, [r3, #44]	; 0x2c
 8006d7a:	e7fe      	b.n	8006d7a <dyn_release_object_heap+0x3a>
      prev->next = element->next;
 8006d7c:	6802      	ldr	r2, [r0, #0]
 8006d7e:	601a      	str	r2, [r3, #0]
    chHeapFree((void *)dep);
 8006d80:	f7ff bdae 	b.w	80068e0 <chHeapFree>
 8006d84:	200011a0 	.word	0x200011a0
 8006d88:	0800bfac 	.word	0x0800bfac
 8006d8c:	00000000 	.word	0x00000000

08006d90 <chFactoryReleaseObjectsFIFO>:
 *
 * @param[in] dofp      dynamic "objects FIFO" object reference
 *
 * @api
 */
void chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
 8006d90:	b538      	push	{r3, r4, r5, lr}

  F_LOCK();
 8006d92:	4c07      	ldr	r4, [pc, #28]	; (8006db0 <chFactoryReleaseObjectsFIFO+0x20>)
void chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
 8006d94:	4605      	mov	r5, r0
  F_LOCK();
 8006d96:	4620      	mov	r0, r4
 8006d98:	f7ff f87a 	bl	8005e90 <chMtxLock>

  dyn_release_object_heap(&dofp->element, &ch_factory.fifo_list);
 8006d9c:	4628      	mov	r0, r5
 8006d9e:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8006da2:	f7ff ffcd 	bl	8006d40 <dyn_release_object_heap>

  F_UNLOCK();
 8006da6:	4620      	mov	r0, r4
}
 8006da8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 8006dac:	f7fe bf48 	b.w	8005c40 <chMtxUnlock>
 8006db0:	20001220 	.word	0x20001220
	...

08006dc0 <oslib_test_004_005_execute>:
      chFactoryReleaseObjectsFIFO(dofp);
    }
  }
}

static void oslib_test_004_005_execute(void) {
 8006dc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_objects_fifo_t *dofp;

  /* [4.5.1] Retrieving a dynamic objects FIFO by name, must not
     exist.*/
  test_set_step(1);
 8006dc2:	4c42      	ldr	r4, [pc, #264]	; (8006ecc <oslib_test_004_005_execute+0x10c>)
 8006dc4:	2501      	movs	r5, #1
 8006dc6:	6025      	str	r5, [r4, #0]
  {
    dofp = chFactoryFindObjectsFIFO("myfifo");
 8006dc8:	f7ff fa8a 	bl	80062e0 <chFactoryFindObjectsFIFO.constprop.4>
    test_assert(dofp == NULL, "found");
 8006dcc:	fab0 f080 	clz	r0, r0
 8006dd0:	0940      	lsrs	r0, r0, #5
 8006dd2:	493f      	ldr	r1, [pc, #252]	; (8006ed0 <oslib_test_004_005_execute+0x110>)
 8006dd4:	f7f9 fda4 	bl	8000920 <_test_assert>
 8006dd8:	b100      	cbz	r0, 8006ddc <oslib_test_004_005_execute+0x1c>
  test_set_step(6);
  {
    dofp = chFactoryFindObjectsFIFO("myfifo");
    test_assert(dofp == NULL, "found");
  }
}
 8006dda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 8006ddc:	2302      	movs	r3, #2
 8006dde:	6023      	str	r3, [r4, #0]
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8006de0:	f7ff fa46 	bl	8006270 <chFactoryCreateObjectsFIFO.constprop.5>
    test_assert(dofp != NULL, "cannot create");
 8006de4:	4606      	mov	r6, r0
 8006de6:	3000      	adds	r0, #0
 8006de8:	bf18      	it	ne
 8006dea:	2001      	movne	r0, #1
 8006dec:	4939      	ldr	r1, [pc, #228]	; (8006ed4 <oslib_test_004_005_execute+0x114>)
 8006dee:	f7f9 fd97 	bl	8000920 <_test_assert>
 8006df2:	2800      	cmp	r0, #0
 8006df4:	d1f1      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
  test_set_step(3);
 8006df6:	2303      	movs	r3, #3
 8006df8:	6023      	str	r3, [r4, #0]
    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8006dfa:	f7ff fa39 	bl	8006270 <chFactoryCreateObjectsFIFO.constprop.5>
    test_assert(dofp1 == NULL, "can create");
 8006dfe:	fab0 f080 	clz	r0, r0
 8006e02:	0940      	lsrs	r0, r0, #5
 8006e04:	4934      	ldr	r1, [pc, #208]	; (8006ed8 <oslib_test_004_005_execute+0x118>)
 8006e06:	f7f9 fd8b 	bl	8000920 <_test_assert>
 8006e0a:	2800      	cmp	r0, #0
 8006e0c:	d1e5      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
  test_set_step(4);
 8006e0e:	2304      	movs	r3, #4
 8006e10:	6023      	str	r3, [r4, #0]
    dofp1 = chFactoryFindObjectsFIFO("myfifo");
 8006e12:	f7ff fa65 	bl	80062e0 <chFactoryFindObjectsFIFO.constprop.4>
    test_assert(dofp1 != NULL, "not found");
 8006e16:	4607      	mov	r7, r0
 8006e18:	3000      	adds	r0, #0
 8006e1a:	bf18      	it	ne
 8006e1c:	2001      	movne	r0, #1
 8006e1e:	492f      	ldr	r1, [pc, #188]	; (8006edc <oslib_test_004_005_execute+0x11c>)
 8006e20:	f7f9 fd7e 	bl	8000920 <_test_assert>
 8006e24:	2800      	cmp	r0, #0
 8006e26:	d1d8      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
    test_assert(dofp == dofp1, "object reference mismatch");
 8006e28:	1bf0      	subs	r0, r6, r7
 8006e2a:	fab0 f080 	clz	r0, r0
 8006e2e:	492c      	ldr	r1, [pc, #176]	; (8006ee0 <oslib_test_004_005_execute+0x120>)
 8006e30:	0940      	lsrs	r0, r0, #5
 8006e32:	f7f9 fd75 	bl	8000920 <_test_assert>
 8006e36:	2800      	cmp	r0, #0
 8006e38:	d1cf      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
    test_assert(dofp1->element.refs == 2, "object reference mismatch");
 8006e3a:	6878      	ldr	r0, [r7, #4]
 8006e3c:	4928      	ldr	r1, [pc, #160]	; (8006ee0 <oslib_test_004_005_execute+0x120>)
 8006e3e:	f1a0 0002 	sub.w	r0, r0, #2
 8006e42:	fab0 f080 	clz	r0, r0
 8006e46:	0940      	lsrs	r0, r0, #5
 8006e48:	f7f9 fd6a 	bl	8000920 <_test_assert>
 8006e4c:	2800      	cmp	r0, #0
 8006e4e:	d1c4      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
 8006e50:	687b      	ldr	r3, [r7, #4]
    test_assert(dofp1 == dofp2, "object reference mismatch");
 8006e52:	4923      	ldr	r1, [pc, #140]	; (8006ee0 <oslib_test_004_005_execute+0x120>)
 8006e54:	442b      	add	r3, r5
 8006e56:	4628      	mov	r0, r5
 8006e58:	607b      	str	r3, [r7, #4]
 8006e5a:	f7f9 fd61 	bl	8000920 <_test_assert>
 8006e5e:	2800      	cmp	r0, #0
 8006e60:	d1bb      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
    test_assert(dofp2->element.refs == 3, "object reference mismatch");
 8006e62:	6878      	ldr	r0, [r7, #4]
 8006e64:	491e      	ldr	r1, [pc, #120]	; (8006ee0 <oslib_test_004_005_execute+0x120>)
 8006e66:	f1a0 0c03 	sub.w	ip, r0, #3
 8006e6a:	f1dc 0000 	rsbs	r0, ip, #0
 8006e6e:	eb40 000c 	adc.w	r0, r0, ip
 8006e72:	f7f9 fd55 	bl	8000920 <_test_assert>
 8006e76:	2800      	cmp	r0, #0
 8006e78:	d1af      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
    chFactoryReleaseObjectsFIFO(dofp2);
 8006e7a:	4638      	mov	r0, r7
 8006e7c:	f7ff ff88 	bl	8006d90 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp1->element.refs == 2, "references mismatch");
 8006e80:	6878      	ldr	r0, [r7, #4]
 8006e82:	4918      	ldr	r1, [pc, #96]	; (8006ee4 <oslib_test_004_005_execute+0x124>)
 8006e84:	1e82      	subs	r2, r0, #2
 8006e86:	4250      	negs	r0, r2
 8006e88:	4150      	adcs	r0, r2
 8006e8a:	f7f9 fd49 	bl	8000920 <_test_assert>
 8006e8e:	2800      	cmp	r0, #0
 8006e90:	d1a3      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
    chFactoryReleaseObjectsFIFO(dofp1);
 8006e92:	4638      	mov	r0, r7
 8006e94:	f7ff ff7c 	bl	8006d90 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp->element.refs == 1, "references mismatch");
 8006e98:	6870      	ldr	r0, [r6, #4]
 8006e9a:	4912      	ldr	r1, [pc, #72]	; (8006ee4 <oslib_test_004_005_execute+0x124>)
 8006e9c:	1b43      	subs	r3, r0, r5
 8006e9e:	4258      	negs	r0, r3
 8006ea0:	4158      	adcs	r0, r3
 8006ea2:	f7f9 fd3d 	bl	8000920 <_test_assert>
 8006ea6:	2800      	cmp	r0, #0
 8006ea8:	d197      	bne.n	8006dda <oslib_test_004_005_execute+0x1a>
    chFactoryReleaseObjectsFIFO(dofp);
 8006eaa:	4630      	mov	r0, r6
  test_set_step(5);
 8006eac:	2305      	movs	r3, #5
 8006eae:	6023      	str	r3, [r4, #0]
    chFactoryReleaseObjectsFIFO(dofp);
 8006eb0:	f7ff ff6e 	bl	8006d90 <chFactoryReleaseObjectsFIFO>
  test_set_step(6);
 8006eb4:	2306      	movs	r3, #6
 8006eb6:	6023      	str	r3, [r4, #0]
    dofp = chFactoryFindObjectsFIFO("myfifo");
 8006eb8:	f7ff fa12 	bl	80062e0 <chFactoryFindObjectsFIFO.constprop.4>
    test_assert(dofp == NULL, "found");
 8006ebc:	fab0 f080 	clz	r0, r0
 8006ec0:	0940      	lsrs	r0, r0, #5
 8006ec2:	4903      	ldr	r1, [pc, #12]	; (8006ed0 <oslib_test_004_005_execute+0x110>)
}
 8006ec4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dofp == NULL, "found");
 8006ec8:	f7f9 bd2a 	b.w	8000920 <_test_assert>
 8006ecc:	20001b3c 	.word	0x20001b3c
 8006ed0:	0800c7e8 	.word	0x0800c7e8
 8006ed4:	0800c7c8 	.word	0x0800c7c8
 8006ed8:	0800c7d8 	.word	0x0800c7d8
 8006edc:	0800c7e4 	.word	0x0800c7e4
 8006ee0:	0800c7f0 	.word	0x0800c7f0
 8006ee4:	0800c80c 	.word	0x0800c80c
	...

08006ef0 <oslib_test_004_005_teardown>:
static void oslib_test_004_005_teardown(void) {
 8006ef0:	b510      	push	{r4, lr}
  dofp = chFactoryFindObjectsFIFO("myfifo");
 8006ef2:	f7ff f9f5 	bl	80062e0 <chFactoryFindObjectsFIFO.constprop.4>
  if (dofp != NULL) {
 8006ef6:	b140      	cbz	r0, 8006f0a <oslib_test_004_005_teardown+0x1a>
    while (dofp->element.refs > 0U) {
 8006ef8:	6843      	ldr	r3, [r0, #4]
 8006efa:	4604      	mov	r4, r0
 8006efc:	b12b      	cbz	r3, 8006f0a <oslib_test_004_005_teardown+0x1a>
      chFactoryReleaseObjectsFIFO(dofp);
 8006efe:	4620      	mov	r0, r4
 8006f00:	f7ff ff46 	bl	8006d90 <chFactoryReleaseObjectsFIFO>
    while (dofp->element.refs > 0U) {
 8006f04:	6863      	ldr	r3, [r4, #4]
 8006f06:	2b00      	cmp	r3, #0
 8006f08:	d1f9      	bne.n	8006efe <oslib_test_004_005_teardown+0xe>
}
 8006f0a:	bd10      	pop	{r4, pc}
 8006f0c:	0000      	movs	r0, r0
	...

08006f10 <chFactoryReleaseMailbox>:
void chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
 8006f10:	b538      	push	{r3, r4, r5, lr}
  F_LOCK();
 8006f12:	4c07      	ldr	r4, [pc, #28]	; (8006f30 <chFactoryReleaseMailbox+0x20>)
void chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
 8006f14:	4605      	mov	r5, r0
  F_LOCK();
 8006f16:	4620      	mov	r0, r4
 8006f18:	f7fe ffba 	bl	8005e90 <chMtxLock>
  dyn_release_object_heap(&dmp->element, &ch_factory.mbx_list);
 8006f1c:	4628      	mov	r0, r5
 8006f1e:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 8006f22:	f7ff ff0d 	bl	8006d40 <dyn_release_object_heap>
  F_UNLOCK();
 8006f26:	4620      	mov	r0, r4
}
 8006f28:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 8006f2c:	f7fe be88 	b.w	8005c40 <chMtxUnlock>
 8006f30:	20001220 	.word	0x20001220
	...

08006f40 <oslib_test_004_004_execute>:
static void oslib_test_004_004_execute(void) {
 8006f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8006f42:	4c42      	ldr	r4, [pc, #264]	; (800704c <oslib_test_004_004_execute+0x10c>)
 8006f44:	2501      	movs	r5, #1
 8006f46:	6025      	str	r5, [r4, #0]
    dmp = chFactoryFindMailbox("mymbx");
 8006f48:	f7ff f97a 	bl	8006240 <chFactoryFindMailbox.constprop.6>
    test_assert(dmp == NULL, "found");
 8006f4c:	fab0 f080 	clz	r0, r0
 8006f50:	0940      	lsrs	r0, r0, #5
 8006f52:	493f      	ldr	r1, [pc, #252]	; (8007050 <oslib_test_004_004_execute+0x110>)
 8006f54:	f7f9 fce4 	bl	8000920 <_test_assert>
 8006f58:	b100      	cbz	r0, 8006f5c <oslib_test_004_004_execute+0x1c>
}
 8006f5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 8006f5c:	2302      	movs	r3, #2
 8006f5e:	6023      	str	r3, [r4, #0]
    dmp = chFactoryCreateMailbox("mymbx", 16U);
 8006f60:	f7ff f93e 	bl	80061e0 <chFactoryCreateMailbox.constprop.7>
    test_assert(dmp != NULL, "cannot create");
 8006f64:	4606      	mov	r6, r0
 8006f66:	3000      	adds	r0, #0
 8006f68:	bf18      	it	ne
 8006f6a:	2001      	movne	r0, #1
 8006f6c:	4939      	ldr	r1, [pc, #228]	; (8007054 <oslib_test_004_004_execute+0x114>)
 8006f6e:	f7f9 fcd7 	bl	8000920 <_test_assert>
 8006f72:	2800      	cmp	r0, #0
 8006f74:	d1f1      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
  test_set_step(3);
 8006f76:	2303      	movs	r3, #3
 8006f78:	6023      	str	r3, [r4, #0]
    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
 8006f7a:	f7ff f931 	bl	80061e0 <chFactoryCreateMailbox.constprop.7>
    test_assert(dmp1 == NULL, "can create");
 8006f7e:	fab0 f080 	clz	r0, r0
 8006f82:	0940      	lsrs	r0, r0, #5
 8006f84:	4934      	ldr	r1, [pc, #208]	; (8007058 <oslib_test_004_004_execute+0x118>)
 8006f86:	f7f9 fccb 	bl	8000920 <_test_assert>
 8006f8a:	2800      	cmp	r0, #0
 8006f8c:	d1e5      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
  test_set_step(4);
 8006f8e:	2304      	movs	r3, #4
 8006f90:	6023      	str	r3, [r4, #0]
    dmp1 = chFactoryFindMailbox("mymbx");
 8006f92:	f7ff f955 	bl	8006240 <chFactoryFindMailbox.constprop.6>
    test_assert(dmp1 != NULL, "not found");
 8006f96:	4607      	mov	r7, r0
 8006f98:	3000      	adds	r0, #0
 8006f9a:	bf18      	it	ne
 8006f9c:	2001      	movne	r0, #1
 8006f9e:	492f      	ldr	r1, [pc, #188]	; (800705c <oslib_test_004_004_execute+0x11c>)
 8006fa0:	f7f9 fcbe 	bl	8000920 <_test_assert>
 8006fa4:	2800      	cmp	r0, #0
 8006fa6:	d1d8      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
    test_assert(dmp == dmp1, "object reference mismatch");
 8006fa8:	1bf0      	subs	r0, r6, r7
 8006faa:	fab0 f080 	clz	r0, r0
 8006fae:	492c      	ldr	r1, [pc, #176]	; (8007060 <oslib_test_004_004_execute+0x120>)
 8006fb0:	0940      	lsrs	r0, r0, #5
 8006fb2:	f7f9 fcb5 	bl	8000920 <_test_assert>
 8006fb6:	2800      	cmp	r0, #0
 8006fb8:	d1cf      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
    test_assert(dmp1->element.refs == 2, "object reference mismatch");
 8006fba:	6878      	ldr	r0, [r7, #4]
 8006fbc:	4928      	ldr	r1, [pc, #160]	; (8007060 <oslib_test_004_004_execute+0x120>)
 8006fbe:	f1a0 0002 	sub.w	r0, r0, #2
 8006fc2:	fab0 f080 	clz	r0, r0
 8006fc6:	0940      	lsrs	r0, r0, #5
 8006fc8:	f7f9 fcaa 	bl	8000920 <_test_assert>
 8006fcc:	2800      	cmp	r0, #0
 8006fce:	d1c4      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
 8006fd0:	687b      	ldr	r3, [r7, #4]
    test_assert(dmp1 == dmp2, "object reference mismatch");
 8006fd2:	4923      	ldr	r1, [pc, #140]	; (8007060 <oslib_test_004_004_execute+0x120>)
 8006fd4:	442b      	add	r3, r5
 8006fd6:	4628      	mov	r0, r5
 8006fd8:	607b      	str	r3, [r7, #4]
 8006fda:	f7f9 fca1 	bl	8000920 <_test_assert>
 8006fde:	2800      	cmp	r0, #0
 8006fe0:	d1bb      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
    test_assert(dmp2->element.refs == 3, "object reference mismatch");
 8006fe2:	6878      	ldr	r0, [r7, #4]
 8006fe4:	491e      	ldr	r1, [pc, #120]	; (8007060 <oslib_test_004_004_execute+0x120>)
 8006fe6:	f1a0 0c03 	sub.w	ip, r0, #3
 8006fea:	f1dc 0000 	rsbs	r0, ip, #0
 8006fee:	eb40 000c 	adc.w	r0, r0, ip
 8006ff2:	f7f9 fc95 	bl	8000920 <_test_assert>
 8006ff6:	2800      	cmp	r0, #0
 8006ff8:	d1af      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
    chFactoryReleaseMailbox(dmp2);
 8006ffa:	4638      	mov	r0, r7
 8006ffc:	f7ff ff88 	bl	8006f10 <chFactoryReleaseMailbox>
    test_assert(dmp1->element.refs == 2, "references mismatch");
 8007000:	6878      	ldr	r0, [r7, #4]
 8007002:	4918      	ldr	r1, [pc, #96]	; (8007064 <oslib_test_004_004_execute+0x124>)
 8007004:	1e82      	subs	r2, r0, #2
 8007006:	4250      	negs	r0, r2
 8007008:	4150      	adcs	r0, r2
 800700a:	f7f9 fc89 	bl	8000920 <_test_assert>
 800700e:	2800      	cmp	r0, #0
 8007010:	d1a3      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
    chFactoryReleaseMailbox(dmp1);
 8007012:	4638      	mov	r0, r7
 8007014:	f7ff ff7c 	bl	8006f10 <chFactoryReleaseMailbox>
    test_assert(dmp->element.refs == 1, "references mismatch");
 8007018:	6870      	ldr	r0, [r6, #4]
 800701a:	4912      	ldr	r1, [pc, #72]	; (8007064 <oslib_test_004_004_execute+0x124>)
 800701c:	1b43      	subs	r3, r0, r5
 800701e:	4258      	negs	r0, r3
 8007020:	4158      	adcs	r0, r3
 8007022:	f7f9 fc7d 	bl	8000920 <_test_assert>
 8007026:	2800      	cmp	r0, #0
 8007028:	d197      	bne.n	8006f5a <oslib_test_004_004_execute+0x1a>
    chFactoryReleaseMailbox(dmp);
 800702a:	4630      	mov	r0, r6
  test_set_step(5);
 800702c:	2305      	movs	r3, #5
 800702e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseMailbox(dmp);
 8007030:	f7ff ff6e 	bl	8006f10 <chFactoryReleaseMailbox>
  test_set_step(6);
 8007034:	2306      	movs	r3, #6
 8007036:	6023      	str	r3, [r4, #0]
    dmp = chFactoryFindMailbox("mymbx");
 8007038:	f7ff f902 	bl	8006240 <chFactoryFindMailbox.constprop.6>
    test_assert(dmp == NULL, "found");
 800703c:	fab0 f080 	clz	r0, r0
 8007040:	0940      	lsrs	r0, r0, #5
 8007042:	4903      	ldr	r1, [pc, #12]	; (8007050 <oslib_test_004_004_execute+0x110>)
}
 8007044:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dmp == NULL, "found");
 8007048:	f7f9 bc6a 	b.w	8000920 <_test_assert>
 800704c:	20001b3c 	.word	0x20001b3c
 8007050:	0800c7e8 	.word	0x0800c7e8
 8007054:	0800c7c8 	.word	0x0800c7c8
 8007058:	0800c7d8 	.word	0x0800c7d8
 800705c:	0800c7e4 	.word	0x0800c7e4
 8007060:	0800c7f0 	.word	0x0800c7f0
 8007064:	0800c80c 	.word	0x0800c80c
	...

08007070 <oslib_test_004_004_teardown>:
static void oslib_test_004_004_teardown(void) {
 8007070:	b510      	push	{r4, lr}
  dmp = chFactoryFindMailbox("mymbx");
 8007072:	f7ff f8e5 	bl	8006240 <chFactoryFindMailbox.constprop.6>
  if (dmp != NULL) {
 8007076:	b140      	cbz	r0, 800708a <oslib_test_004_004_teardown+0x1a>
    while (dmp->element.refs > 0U) {
 8007078:	6843      	ldr	r3, [r0, #4]
 800707a:	4604      	mov	r4, r0
 800707c:	b12b      	cbz	r3, 800708a <oslib_test_004_004_teardown+0x1a>
      chFactoryReleaseMailbox(dmp);
 800707e:	4620      	mov	r0, r4
 8007080:	f7ff ff46 	bl	8006f10 <chFactoryReleaseMailbox>
    while (dmp->element.refs > 0U) {
 8007084:	6863      	ldr	r3, [r4, #4]
 8007086:	2b00      	cmp	r3, #0
 8007088:	d1f9      	bne.n	800707e <oslib_test_004_004_teardown+0xe>
}
 800708a:	bd10      	pop	{r4, pc}
 800708c:	0000      	movs	r0, r0
	...

08007090 <chFactoryReleaseBuffer>:
void chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
 8007090:	b538      	push	{r3, r4, r5, lr}
  F_LOCK();
 8007092:	4c07      	ldr	r4, [pc, #28]	; (80070b0 <chFactoryReleaseBuffer+0x20>)
void chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
 8007094:	4605      	mov	r5, r0
  F_LOCK();
 8007096:	4620      	mov	r0, r4
 8007098:	f7fe fefa 	bl	8005e90 <chMtxLock>
  dyn_release_object_heap(&dbp->element, &ch_factory.buf_list);
 800709c:	4628      	mov	r0, r5
 800709e:	f104 0124 	add.w	r1, r4, #36	; 0x24
 80070a2:	f7ff fe4d 	bl	8006d40 <dyn_release_object_heap>
  F_UNLOCK();
 80070a6:	4620      	mov	r0, r4
}
 80070a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  F_UNLOCK();
 80070ac:	f7fe bdc8 	b.w	8005c40 <chMtxUnlock>
 80070b0:	20001220 	.word	0x20001220
	...

080070c0 <oslib_test_004_002_execute>:
static void oslib_test_004_002_execute(void) {
 80070c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 80070c2:	4c42      	ldr	r4, [pc, #264]	; (80071cc <oslib_test_004_002_execute+0x10c>)
 80070c4:	2501      	movs	r5, #1
 80070c6:	6025      	str	r5, [r4, #0]
    dbp = chFactoryFindBuffer("mybuf");
 80070c8:	f7ff f83a 	bl	8006140 <chFactoryFindBuffer.constprop.10>
    test_assert(dbp == NULL, "found");
 80070cc:	fab0 f080 	clz	r0, r0
 80070d0:	0940      	lsrs	r0, r0, #5
 80070d2:	493f      	ldr	r1, [pc, #252]	; (80071d0 <oslib_test_004_002_execute+0x110>)
 80070d4:	f7f9 fc24 	bl	8000920 <_test_assert>
 80070d8:	b100      	cbz	r0, 80070dc <oslib_test_004_002_execute+0x1c>
}
 80070da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 80070dc:	2302      	movs	r3, #2
 80070de:	6023      	str	r3, [r4, #0]
    dbp = chFactoryCreateBuffer("mybuf", 128U);
 80070e0:	f7ff f80e 	bl	8006100 <chFactoryCreateBuffer.constprop.11>
    test_assert(dbp != NULL, "cannot create");
 80070e4:	4606      	mov	r6, r0
 80070e6:	3000      	adds	r0, #0
 80070e8:	bf18      	it	ne
 80070ea:	2001      	movne	r0, #1
 80070ec:	4939      	ldr	r1, [pc, #228]	; (80071d4 <oslib_test_004_002_execute+0x114>)
 80070ee:	f7f9 fc17 	bl	8000920 <_test_assert>
 80070f2:	2800      	cmp	r0, #0
 80070f4:	d1f1      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
  test_set_step(3);
 80070f6:	2303      	movs	r3, #3
 80070f8:	6023      	str	r3, [r4, #0]
    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
 80070fa:	f7ff f801 	bl	8006100 <chFactoryCreateBuffer.constprop.11>
    test_assert(dbp1 == NULL, "can create");
 80070fe:	fab0 f080 	clz	r0, r0
 8007102:	0940      	lsrs	r0, r0, #5
 8007104:	4934      	ldr	r1, [pc, #208]	; (80071d8 <oslib_test_004_002_execute+0x118>)
 8007106:	f7f9 fc0b 	bl	8000920 <_test_assert>
 800710a:	2800      	cmp	r0, #0
 800710c:	d1e5      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
  test_set_step(4);
 800710e:	2304      	movs	r3, #4
 8007110:	6023      	str	r3, [r4, #0]
    dbp1 = chFactoryFindBuffer("mybuf");
 8007112:	f7ff f815 	bl	8006140 <chFactoryFindBuffer.constprop.10>
    test_assert(dbp1 != NULL, "not found");
 8007116:	4607      	mov	r7, r0
 8007118:	3000      	adds	r0, #0
 800711a:	bf18      	it	ne
 800711c:	2001      	movne	r0, #1
 800711e:	492f      	ldr	r1, [pc, #188]	; (80071dc <oslib_test_004_002_execute+0x11c>)
 8007120:	f7f9 fbfe 	bl	8000920 <_test_assert>
 8007124:	2800      	cmp	r0, #0
 8007126:	d1d8      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
    test_assert(dbp == dbp1, "object reference mismatch");
 8007128:	1bf0      	subs	r0, r6, r7
 800712a:	fab0 f080 	clz	r0, r0
 800712e:	492c      	ldr	r1, [pc, #176]	; (80071e0 <oslib_test_004_002_execute+0x120>)
 8007130:	0940      	lsrs	r0, r0, #5
 8007132:	f7f9 fbf5 	bl	8000920 <_test_assert>
 8007136:	2800      	cmp	r0, #0
 8007138:	d1cf      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
    test_assert(dbp1->element.refs == 2, "object reference mismatch");
 800713a:	6878      	ldr	r0, [r7, #4]
 800713c:	4928      	ldr	r1, [pc, #160]	; (80071e0 <oslib_test_004_002_execute+0x120>)
 800713e:	f1a0 0002 	sub.w	r0, r0, #2
 8007142:	fab0 f080 	clz	r0, r0
 8007146:	0940      	lsrs	r0, r0, #5
 8007148:	f7f9 fbea 	bl	8000920 <_test_assert>
 800714c:	2800      	cmp	r0, #0
 800714e:	d1c4      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
 8007150:	687b      	ldr	r3, [r7, #4]
    test_assert(dbp1 == dbp2, "object reference mismatch");
 8007152:	4923      	ldr	r1, [pc, #140]	; (80071e0 <oslib_test_004_002_execute+0x120>)
 8007154:	442b      	add	r3, r5
 8007156:	4628      	mov	r0, r5
 8007158:	607b      	str	r3, [r7, #4]
 800715a:	f7f9 fbe1 	bl	8000920 <_test_assert>
 800715e:	2800      	cmp	r0, #0
 8007160:	d1bb      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
    test_assert(dbp2->element.refs == 3, "object reference mismatch");
 8007162:	6878      	ldr	r0, [r7, #4]
 8007164:	491e      	ldr	r1, [pc, #120]	; (80071e0 <oslib_test_004_002_execute+0x120>)
 8007166:	f1a0 0c03 	sub.w	ip, r0, #3
 800716a:	f1dc 0000 	rsbs	r0, ip, #0
 800716e:	eb40 000c 	adc.w	r0, r0, ip
 8007172:	f7f9 fbd5 	bl	8000920 <_test_assert>
 8007176:	2800      	cmp	r0, #0
 8007178:	d1af      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
    chFactoryReleaseBuffer(dbp2);
 800717a:	4638      	mov	r0, r7
 800717c:	f7ff ff88 	bl	8007090 <chFactoryReleaseBuffer>
    test_assert(dbp1->element.refs == 2, "references mismatch");
 8007180:	6878      	ldr	r0, [r7, #4]
 8007182:	4918      	ldr	r1, [pc, #96]	; (80071e4 <oslib_test_004_002_execute+0x124>)
 8007184:	1e82      	subs	r2, r0, #2
 8007186:	4250      	negs	r0, r2
 8007188:	4150      	adcs	r0, r2
 800718a:	f7f9 fbc9 	bl	8000920 <_test_assert>
 800718e:	2800      	cmp	r0, #0
 8007190:	d1a3      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
    chFactoryReleaseBuffer(dbp1);
 8007192:	4638      	mov	r0, r7
 8007194:	f7ff ff7c 	bl	8007090 <chFactoryReleaseBuffer>
    test_assert(dbp->element.refs == 1, "references mismatch");
 8007198:	6870      	ldr	r0, [r6, #4]
 800719a:	4912      	ldr	r1, [pc, #72]	; (80071e4 <oslib_test_004_002_execute+0x124>)
 800719c:	1b43      	subs	r3, r0, r5
 800719e:	4258      	negs	r0, r3
 80071a0:	4158      	adcs	r0, r3
 80071a2:	f7f9 fbbd 	bl	8000920 <_test_assert>
 80071a6:	2800      	cmp	r0, #0
 80071a8:	d197      	bne.n	80070da <oslib_test_004_002_execute+0x1a>
    chFactoryReleaseBuffer(dbp);
 80071aa:	4630      	mov	r0, r6
  test_set_step(5);
 80071ac:	2305      	movs	r3, #5
 80071ae:	6023      	str	r3, [r4, #0]
    chFactoryReleaseBuffer(dbp);
 80071b0:	f7ff ff6e 	bl	8007090 <chFactoryReleaseBuffer>
  test_set_step(6);
 80071b4:	2306      	movs	r3, #6
 80071b6:	6023      	str	r3, [r4, #0]
    dbp = chFactoryFindBuffer("mybuf");
 80071b8:	f7fe ffc2 	bl	8006140 <chFactoryFindBuffer.constprop.10>
    test_assert(dbp == NULL, "found");
 80071bc:	fab0 f080 	clz	r0, r0
 80071c0:	0940      	lsrs	r0, r0, #5
 80071c2:	4903      	ldr	r1, [pc, #12]	; (80071d0 <oslib_test_004_002_execute+0x110>)
}
 80071c4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dbp == NULL, "found");
 80071c8:	f7f9 bbaa 	b.w	8000920 <_test_assert>
 80071cc:	20001b3c 	.word	0x20001b3c
 80071d0:	0800c7e8 	.word	0x0800c7e8
 80071d4:	0800c7c8 	.word	0x0800c7c8
 80071d8:	0800c7d8 	.word	0x0800c7d8
 80071dc:	0800c7e4 	.word	0x0800c7e4
 80071e0:	0800c7f0 	.word	0x0800c7f0
 80071e4:	0800c80c 	.word	0x0800c80c
	...

080071f0 <oslib_test_004_002_teardown>:
static void oslib_test_004_002_teardown(void) {
 80071f0:	b510      	push	{r4, lr}
  dbp = chFactoryFindBuffer("mybuf");
 80071f2:	f7fe ffa5 	bl	8006140 <chFactoryFindBuffer.constprop.10>
  if (dbp != NULL) {
 80071f6:	b140      	cbz	r0, 800720a <oslib_test_004_002_teardown+0x1a>
    while (dbp->element.refs > 0U) {
 80071f8:	6843      	ldr	r3, [r0, #4]
 80071fa:	4604      	mov	r4, r0
 80071fc:	b12b      	cbz	r3, 800720a <oslib_test_004_002_teardown+0x1a>
      chFactoryReleaseBuffer(dbp);
 80071fe:	4620      	mov	r0, r4
 8007200:	f7ff ff46 	bl	8007090 <chFactoryReleaseBuffer>
    while (dbp->element.refs > 0U) {
 8007204:	6863      	ldr	r3, [r4, #4]
 8007206:	2b00      	cmp	r3, #0
 8007208:	d1f9      	bne.n	80071fe <oslib_test_004_002_teardown+0xe>
}
 800720a:	bd10      	pop	{r4, pc}
 800720c:	0000      	movs	r0, r0
	...

08007210 <chSemSignal>:
void chSemSignal(semaphore_t *sp) {
 8007210:	b508      	push	{r3, lr}
 8007212:	4601      	mov	r1, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007214:	2320      	movs	r3, #32
 8007216:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800721a:	f7fc fad1 	bl	80037c0 <_dbg_check_lock>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 800721e:	6883      	ldr	r3, [r0, #8]
 8007220:	6800      	ldr	r0, [r0, #0]
 8007222:	2b00      	cmp	r3, #0
 8007224:	db06      	blt.n	8007234 <chSemSignal+0x24>
 8007226:	4288      	cmp	r0, r1
 8007228:	d006      	beq.n	8007238 <chSemSignal+0x28>
  __ASM volatile ("cpsid i" : : : "memory");
 800722a:	b672      	cpsid	i
 800722c:	4b11      	ldr	r3, [pc, #68]	; (8007274 <chSemSignal+0x64>)
 800722e:	4a12      	ldr	r2, [pc, #72]	; (8007278 <chSemSignal+0x68>)
 8007230:	62da      	str	r2, [r3, #44]	; 0x2c
 8007232:	e7fe      	b.n	8007232 <chSemSignal+0x22>
 8007234:	4288      	cmp	r0, r1
 8007236:	d0f8      	beq.n	800722a <chSemSignal+0x1a>
  if (++sp->cnt <= (cnt_t)0) {
 8007238:	3301      	adds	r3, #1
 800723a:	2b00      	cmp	r3, #0
 800723c:	608b      	str	r3, [r1, #8]
 800723e:	dd0e      	ble.n	800725e <chSemSignal+0x4e>
  _dbg_check_unlock();
 8007240:	f7fc fa56 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007244:	4b0b      	ldr	r3, [pc, #44]	; (8007274 <chSemSignal+0x64>)
 8007246:	681a      	ldr	r2, [r3, #0]
 8007248:	429a      	cmp	r2, r3
 800724a:	d004      	beq.n	8007256 <chSemSignal+0x46>
 800724c:	6999      	ldr	r1, [r3, #24]
 800724e:	6892      	ldr	r2, [r2, #8]
 8007250:	6889      	ldr	r1, [r1, #8]
 8007252:	4291      	cmp	r1, r2
 8007254:	d30a      	bcc.n	800726c <chSemSignal+0x5c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007256:	2300      	movs	r3, #0
 8007258:	f383 8811 	msr	BASEPRI, r3
}
 800725c:	bd08      	pop	{r3, pc}
  tqp->next             = tp->queue.next;
 800725e:	6803      	ldr	r3, [r0, #0]
 8007260:	600b      	str	r3, [r1, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8007262:	6059      	str	r1, [r3, #4]
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 8007264:	2100      	movs	r1, #0
 8007266:	f7fb fe3b 	bl	8002ee0 <chSchWakeupS>
 800726a:	e7e9      	b.n	8007240 <chSemSignal+0x30>
  __ASM volatile ("cpsid i" : : : "memory");
 800726c:	b672      	cpsid	i
 800726e:	4a03      	ldr	r2, [pc, #12]	; (800727c <chSemSignal+0x6c>)
 8007270:	62da      	str	r2, [r3, #44]	; 0x2c
 8007272:	e7fe      	b.n	8007272 <chSemSignal+0x62>
 8007274:	200011a0 	.word	0x200011a0
 8007278:	0800be80 	.word	0x0800be80
 800727c:	0800bbf0 	.word	0x0800bbf0

08007280 <chSemWait>:
msg_t chSemWait(semaphore_t *sp) {
 8007280:	b510      	push	{r4, lr}
 8007282:	4601      	mov	r1, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007284:	2320      	movs	r3, #32
 8007286:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800728a:	f7fc fa99 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassS();
 800728e:	f7f9 fc97 	bl	8000bc0 <chDbgCheckClassS>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8007292:	6883      	ldr	r3, [r0, #8]
 8007294:	6802      	ldr	r2, [r0, #0]
 8007296:	2b00      	cmp	r3, #0
 8007298:	db06      	blt.n	80072a8 <chSemWait+0x28>
 800729a:	4282      	cmp	r2, r0
 800729c:	d006      	beq.n	80072ac <chSemWait+0x2c>
  __ASM volatile ("cpsid i" : : : "memory");
 800729e:	b672      	cpsid	i
 80072a0:	4b15      	ldr	r3, [pc, #84]	; (80072f8 <chSemWait+0x78>)
 80072a2:	4a16      	ldr	r2, [pc, #88]	; (80072fc <chSemWait+0x7c>)
 80072a4:	62da      	str	r2, [r3, #44]	; 0x2c
 80072a6:	e7fe      	b.n	80072a6 <chSemWait+0x26>
 80072a8:	4282      	cmp	r2, r0
 80072aa:	d0f8      	beq.n	800729e <chSemWait+0x1e>
  if (--sp->cnt < (cnt_t)0) {
 80072ac:	3b01      	subs	r3, #1
 80072ae:	2b00      	cmp	r3, #0
 80072b0:	608b      	str	r3, [r1, #8]
    currp->u.wtsemp = sp;
 80072b2:	4c11      	ldr	r4, [pc, #68]	; (80072f8 <chSemWait+0x78>)
  if (--sp->cnt < (cnt_t)0) {
 80072b4:	db0e      	blt.n	80072d4 <chSemWait+0x54>
  return MSG_OK;
 80072b6:	2000      	movs	r0, #0
  _dbg_check_unlock();
 80072b8:	f7fc fa1a 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80072bc:	6823      	ldr	r3, [r4, #0]
 80072be:	42a3      	cmp	r3, r4
 80072c0:	d004      	beq.n	80072cc <chSemWait+0x4c>
 80072c2:	69a2      	ldr	r2, [r4, #24]
 80072c4:	689b      	ldr	r3, [r3, #8]
 80072c6:	6892      	ldr	r2, [r2, #8]
 80072c8:	429a      	cmp	r2, r3
 80072ca:	d310      	bcc.n	80072ee <chSemWait+0x6e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80072cc:	2300      	movs	r3, #0
 80072ce:	f383 8811 	msr	BASEPRI, r3
}
 80072d2:	bd10      	pop	{r4, pc}
    currp->u.wtsemp = sp;
 80072d4:	69a3      	ldr	r3, [r4, #24]
 80072d6:	6259      	str	r1, [r3, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 80072d8:	684a      	ldr	r2, [r1, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 80072da:	2005      	movs	r0, #5
 80072dc:	e9c3 1200 	strd	r1, r2, [r3]
  tp->queue.prev->queue.next = tp;
 80072e0:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 80072e2:	604b      	str	r3, [r1, #4]
 80072e4:	f7fb fe2c 	bl	8002f40 <chSchGoSleepS>
    return currp->u.rdymsg;
 80072e8:	69a3      	ldr	r3, [r4, #24]
 80072ea:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80072ec:	e7e4      	b.n	80072b8 <chSemWait+0x38>
  __ASM volatile ("cpsid i" : : : "memory");
 80072ee:	b672      	cpsid	i
 80072f0:	4b03      	ldr	r3, [pc, #12]	; (8007300 <chSemWait+0x80>)
 80072f2:	62e3      	str	r3, [r4, #44]	; 0x2c
 80072f4:	e7fe      	b.n	80072f4 <chSemWait+0x74>
 80072f6:	bf00      	nop
 80072f8:	200011a0 	.word	0x200011a0
 80072fc:	0800be04 	.word	0x0800be04
 8007300:	0800bbf0 	.word	0x0800bbf0
	...

08007310 <bmk_thread7>:
static THD_FUNCTION(bmk_thread7, p) {
 8007310:	b538      	push	{r3, r4, r5, lr}
 8007312:	4c08      	ldr	r4, [pc, #32]	; (8007334 <bmk_thread7+0x24>)
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8007314:	69a3      	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
 8007316:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800731a:	075a      	lsls	r2, r3, #29
 800731c:	d408      	bmi.n	8007330 <bmk_thread7+0x20>
    chSemWait(&sem1);
 800731e:	4d06      	ldr	r5, [pc, #24]	; (8007338 <bmk_thread7+0x28>)
 8007320:	4628      	mov	r0, r5
 8007322:	f7ff ffad 	bl	8007280 <chSemWait>
 8007326:	69a3      	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
 8007328:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800732c:	075b      	lsls	r3, r3, #29
 800732e:	d5f7      	bpl.n	8007320 <bmk_thread7+0x10>
}
 8007330:	bd38      	pop	{r3, r4, r5, pc}
 8007332:	bf00      	nop
 8007334:	200011a0 	.word	0x200011a0
 8007338:	20001414 	.word	0x20001414
 800733c:	00000000 	.word	0x00000000

08007340 <thread3>:
static THD_FUNCTION(thread3, p) {
 8007340:	b510      	push	{r4, lr}
  chSemWait(&sem1);
 8007342:	4c04      	ldr	r4, [pc, #16]	; (8007354 <thread3+0x14>)
 8007344:	4620      	mov	r0, r4
 8007346:	f7ff ff9b 	bl	8007280 <chSemWait>
  chSemSignal(&sem1);
 800734a:	4620      	mov	r0, r4
}
 800734c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chSemSignal(&sem1);
 8007350:	f7ff bf5e 	b.w	8007210 <chSemSignal>
 8007354:	20001408 	.word	0x20001408
	...

08007360 <thread1.lto_priv.178>:
static THD_FUNCTION(thread1, p) {
 8007360:	b510      	push	{r4, lr}
 8007362:	4604      	mov	r4, r0
  chSemWait(&sem1);
 8007364:	4803      	ldr	r0, [pc, #12]	; (8007374 <thread1.lto_priv.178+0x14>)
 8007366:	f7ff ff8b 	bl	8007280 <chSemWait>
  test_emit_token(*(char *)p);
 800736a:	7820      	ldrb	r0, [r4, #0]
}
 800736c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
 8007370:	f7fd b8b6 	b.w	80044e0 <test_emit_token>
 8007374:	20001408 	.word	0x20001408
	...

08007380 <chSemReset>:
void chSemReset(semaphore_t *sp, cnt_t n) {
 8007380:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007382:	2320      	movs	r3, #32
 8007384:	4604      	mov	r4, r0
 8007386:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800738a:	f7fc fa19 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 800738e:	f7f9 fc27 	bl	8000be0 <chDbgCheckClassI>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8007392:	6885      	ldr	r5, [r0, #8]
 8007394:	6803      	ldr	r3, [r0, #0]
 8007396:	2d00      	cmp	r5, #0
 8007398:	db06      	blt.n	80073a8 <chSemReset+0x28>
 800739a:	4283      	cmp	r3, r0
 800739c:	d006      	beq.n	80073ac <chSemReset+0x2c>
  __ASM volatile ("cpsid i" : : : "memory");
 800739e:	b672      	cpsid	i
 80073a0:	4b15      	ldr	r3, [pc, #84]	; (80073f8 <chSemReset+0x78>)
 80073a2:	4a16      	ldr	r2, [pc, #88]	; (80073fc <chSemReset+0x7c>)
 80073a4:	62da      	str	r2, [r3, #44]	; 0x2c
 80073a6:	e7fe      	b.n	80073a6 <chSemReset+0x26>
 80073a8:	4283      	cmp	r3, r0
 80073aa:	d0f8      	beq.n	800739e <chSemReset+0x1e>
  while (++cnt <= (cnt_t)0) {
 80073ac:	3501      	adds	r5, #1
 80073ae:	2d00      	cmp	r5, #0
  sp->cnt = n;
 80073b0:	60a1      	str	r1, [r4, #8]
  while (++cnt <= (cnt_t)0) {
 80073b2:	dc0b      	bgt.n	80073cc <chSemReset+0x4c>
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 80073b4:	f06f 0601 	mvn.w	r6, #1
  thread_t *tp = tqp->prev;
 80073b8:	6860      	ldr	r0, [r4, #4]
  tqp->prev             = tp->queue.prev;
 80073ba:	6843      	ldr	r3, [r0, #4]
 80073bc:	6063      	str	r3, [r4, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 80073be:	601c      	str	r4, [r3, #0]
 80073c0:	f7f9 fcce 	bl	8000d60 <chSchReadyI>
  while (++cnt <= (cnt_t)0) {
 80073c4:	3501      	adds	r5, #1
 80073c6:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 80073c8:	6246      	str	r6, [r0, #36]	; 0x24
  while (++cnt <= (cnt_t)0) {
 80073ca:	d1f5      	bne.n	80073b8 <chSemReset+0x38>
  chSchRescheduleS();
 80073cc:	f7fc f978 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 80073d0:	f7fc f98e 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80073d4:	4b08      	ldr	r3, [pc, #32]	; (80073f8 <chSemReset+0x78>)
 80073d6:	681a      	ldr	r2, [r3, #0]
 80073d8:	429a      	cmp	r2, r3
 80073da:	d004      	beq.n	80073e6 <chSemReset+0x66>
 80073dc:	6999      	ldr	r1, [r3, #24]
 80073de:	6892      	ldr	r2, [r2, #8]
 80073e0:	6889      	ldr	r1, [r1, #8]
 80073e2:	4291      	cmp	r1, r2
 80073e4:	d303      	bcc.n	80073ee <chSemReset+0x6e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80073e6:	2300      	movs	r3, #0
 80073e8:	f383 8811 	msr	BASEPRI, r3
}
 80073ec:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80073ee:	b672      	cpsid	i
 80073f0:	4a03      	ldr	r2, [pc, #12]	; (8007400 <chSemReset+0x80>)
 80073f2:	62da      	str	r2, [r3, #44]	; 0x2c
 80073f4:	e7fe      	b.n	80073f4 <chSemReset+0x74>
 80073f6:	bf00      	nop
 80073f8:	200011a0 	.word	0x200011a0
 80073fc:	0800bd84 	.word	0x0800bd84
 8007400:	0800bbf0 	.word	0x0800bbf0
	...

08007410 <rt_test_005_001_execute>:
static void rt_test_005_001_execute(void) {
 8007410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    msg = chSemWait(&sem1);
 8007412:	4d55      	ldr	r5, [pc, #340]	; (8007568 <rt_test_005_001_execute+0x158>)
  test_set_step(1);
 8007414:	4e55      	ldr	r6, [pc, #340]	; (800756c <rt_test_005_001_execute+0x15c>)
 8007416:	2301      	movs	r3, #1
    msg = chSemWait(&sem1);
 8007418:	4628      	mov	r0, r5
  test_set_step(1);
 800741a:	6033      	str	r3, [r6, #0]
    msg = chSemWait(&sem1);
 800741c:	f7ff ff30 	bl	8007280 <chSemWait>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007420:	2320      	movs	r3, #32
 8007422:	4607      	mov	r7, r0
 8007424:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007428:	f7fc f9ca 	bl	80037c0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(const semaphore_t *sp) {

  chDbgCheckClassI();
 800742c:	f7f9 fbd8 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 8007430:	68a8      	ldr	r0, [r5, #8]
 8007432:	494f      	ldr	r1, [pc, #316]	; (8007570 <rt_test_005_001_execute+0x160>)
 8007434:	fab0 f080 	clz	r0, r0
 8007438:	0940      	lsrs	r0, r0, #5
 800743a:	f7f9 fa71 	bl	8000920 <_test_assert>
 800743e:	b9a8      	cbnz	r0, 800746c <rt_test_005_001_execute+0x5c>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007440:	4c4c      	ldr	r4, [pc, #304]	; (8007574 <rt_test_005_001_execute+0x164>)
  _dbg_check_unlock();
 8007442:	f7fc f955 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007446:	6823      	ldr	r3, [r4, #0]
 8007448:	42a3      	cmp	r3, r4
 800744a:	d004      	beq.n	8007456 <rt_test_005_001_execute+0x46>
 800744c:	69a2      	ldr	r2, [r4, #24]
 800744e:	689b      	ldr	r3, [r3, #8]
 8007450:	6892      	ldr	r2, [r2, #8]
 8007452:	429a      	cmp	r2, r3
 8007454:	d360      	bcc.n	8007518 <rt_test_005_001_execute+0x108>
 8007456:	2300      	movs	r3, #0
 8007458:	f383 8811 	msr	BASEPRI, r3
    test_assert(MSG_OK == msg, "wrong returned message");
 800745c:	fab7 f087 	clz	r0, r7
 8007460:	0940      	lsrs	r0, r0, #5
 8007462:	4945      	ldr	r1, [pc, #276]	; (8007578 <rt_test_005_001_execute+0x168>)
 8007464:	f7f9 fa5c 	bl	8000920 <_test_assert>
 8007468:	b178      	cbz	r0, 800748a <rt_test_005_001_execute+0x7a>
}
 800746a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  _dbg_check_unlock();
 800746c:	f7fc f940 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007470:	4b40      	ldr	r3, [pc, #256]	; (8007574 <rt_test_005_001_execute+0x164>)
 8007472:	681a      	ldr	r2, [r3, #0]
 8007474:	429a      	cmp	r2, r3
 8007476:	d004      	beq.n	8007482 <rt_test_005_001_execute+0x72>
 8007478:	6999      	ldr	r1, [r3, #24]
 800747a:	6892      	ldr	r2, [r2, #8]
 800747c:	6889      	ldr	r1, [r1, #8]
 800747e:	4291      	cmp	r1, r2
 8007480:	d34e      	bcc.n	8007520 <rt_test_005_001_execute+0x110>
 8007482:	2300      	movs	r3, #0
 8007484:	f383 8811 	msr	BASEPRI, r3
 8007488:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 800748a:	2302      	movs	r3, #2
    chSemSignal(&sem1);
 800748c:	4836      	ldr	r0, [pc, #216]	; (8007568 <rt_test_005_001_execute+0x158>)
  test_set_step(2);
 800748e:	6033      	str	r3, [r6, #0]
    chSemSignal(&sem1);
 8007490:	f7ff febe 	bl	8007210 <chSemSignal>
 8007494:	2320      	movs	r3, #32
 8007496:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800749a:	f7fc f991 	bl	80037c0 <_dbg_check_lock>
 800749e:	f7f9 fb9f 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 80074a2:	68a8      	ldr	r0, [r5, #8]
 80074a4:	4932      	ldr	r1, [pc, #200]	; (8007570 <rt_test_005_001_execute+0x160>)
 80074a6:	f1a0 0001 	sub.w	r0, r0, #1
 80074aa:	fab0 f080 	clz	r0, r0
 80074ae:	0940      	lsrs	r0, r0, #5
 80074b0:	f7f9 fa36 	bl	8000920 <_test_assert>
 80074b4:	2800      	cmp	r0, #0
 80074b6:	d137      	bne.n	8007528 <rt_test_005_001_execute+0x118>
  _dbg_check_unlock();
 80074b8:	f7fc f91a 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80074bc:	6823      	ldr	r3, [r4, #0]
 80074be:	42a3      	cmp	r3, r4
 80074c0:	d004      	beq.n	80074cc <rt_test_005_001_execute+0xbc>
 80074c2:	69a2      	ldr	r2, [r4, #24]
 80074c4:	689b      	ldr	r3, [r3, #8]
 80074c6:	6892      	ldr	r2, [r2, #8]
 80074c8:	429a      	cmp	r2, r3
 80074ca:	d33b      	bcc.n	8007544 <rt_test_005_001_execute+0x134>
 80074cc:	2300      	movs	r3, #0
 80074ce:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 80074d2:	2303      	movs	r3, #3
    chSemReset(&sem1, 2);
 80074d4:	2102      	movs	r1, #2
 80074d6:	4824      	ldr	r0, [pc, #144]	; (8007568 <rt_test_005_001_execute+0x158>)
  test_set_step(3);
 80074d8:	6033      	str	r3, [r6, #0]
    chSemReset(&sem1, 2);
 80074da:	f7ff ff51 	bl	8007380 <chSemReset>
 80074de:	2320      	movs	r3, #32
 80074e0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80074e4:	f7fc f96c 	bl	80037c0 <_dbg_check_lock>
 80074e8:	f7f9 fb7a 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 80074ec:	68a8      	ldr	r0, [r5, #8]
 80074ee:	4920      	ldr	r1, [pc, #128]	; (8007570 <rt_test_005_001_execute+0x160>)
 80074f0:	1e83      	subs	r3, r0, #2
 80074f2:	4258      	negs	r0, r3
 80074f4:	4158      	adcs	r0, r3
 80074f6:	f7f9 fa13 	bl	8000920 <_test_assert>
 80074fa:	bb38      	cbnz	r0, 800754c <rt_test_005_001_execute+0x13c>
  _dbg_check_unlock();
 80074fc:	f7fc f8f8 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007500:	6823      	ldr	r3, [r4, #0]
 8007502:	42a3      	cmp	r3, r4
 8007504:	d0bd      	beq.n	8007482 <rt_test_005_001_execute+0x72>
 8007506:	69a2      	ldr	r2, [r4, #24]
 8007508:	689b      	ldr	r3, [r3, #8]
 800750a:	6892      	ldr	r2, [r2, #8]
 800750c:	429a      	cmp	r2, r3
 800750e:	d2b8      	bcs.n	8007482 <rt_test_005_001_execute+0x72>
  __ASM volatile ("cpsid i" : : : "memory");
 8007510:	b672      	cpsid	i
 8007512:	4b1a      	ldr	r3, [pc, #104]	; (800757c <rt_test_005_001_execute+0x16c>)
 8007514:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007516:	e7fe      	b.n	8007516 <rt_test_005_001_execute+0x106>
 8007518:	b672      	cpsid	i
 800751a:	4b18      	ldr	r3, [pc, #96]	; (800757c <rt_test_005_001_execute+0x16c>)
 800751c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800751e:	e7fe      	b.n	800751e <rt_test_005_001_execute+0x10e>
 8007520:	b672      	cpsid	i
 8007522:	4a16      	ldr	r2, [pc, #88]	; (800757c <rt_test_005_001_execute+0x16c>)
 8007524:	62da      	str	r2, [r3, #44]	; 0x2c
 8007526:	e7fe      	b.n	8007526 <rt_test_005_001_execute+0x116>
  _dbg_check_unlock();
 8007528:	f7fc f8e2 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800752c:	6823      	ldr	r3, [r4, #0]
 800752e:	42a3      	cmp	r3, r4
 8007530:	d0a7      	beq.n	8007482 <rt_test_005_001_execute+0x72>
 8007532:	69a2      	ldr	r2, [r4, #24]
 8007534:	689b      	ldr	r3, [r3, #8]
 8007536:	6892      	ldr	r2, [r2, #8]
 8007538:	429a      	cmp	r2, r3
 800753a:	d2a2      	bcs.n	8007482 <rt_test_005_001_execute+0x72>
 800753c:	b672      	cpsid	i
 800753e:	4b0f      	ldr	r3, [pc, #60]	; (800757c <rt_test_005_001_execute+0x16c>)
 8007540:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007542:	e7fe      	b.n	8007542 <rt_test_005_001_execute+0x132>
 8007544:	b672      	cpsid	i
 8007546:	4b0d      	ldr	r3, [pc, #52]	; (800757c <rt_test_005_001_execute+0x16c>)
 8007548:	62e3      	str	r3, [r4, #44]	; 0x2c
 800754a:	e7fe      	b.n	800754a <rt_test_005_001_execute+0x13a>
  _dbg_check_unlock();
 800754c:	f7fc f8d0 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007550:	6823      	ldr	r3, [r4, #0]
 8007552:	42a3      	cmp	r3, r4
 8007554:	d095      	beq.n	8007482 <rt_test_005_001_execute+0x72>
 8007556:	69a2      	ldr	r2, [r4, #24]
 8007558:	689b      	ldr	r3, [r3, #8]
 800755a:	6892      	ldr	r2, [r2, #8]
 800755c:	429a      	cmp	r2, r3
 800755e:	d290      	bcs.n	8007482 <rt_test_005_001_execute+0x72>
 8007560:	b672      	cpsid	i
 8007562:	4b06      	ldr	r3, [pc, #24]	; (800757c <rt_test_005_001_execute+0x16c>)
 8007564:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007566:	e7fe      	b.n	8007566 <rt_test_005_001_execute+0x156>
 8007568:	20001408 	.word	0x20001408
 800756c:	20001b3c 	.word	0x20001b3c
 8007570:	0800d588 	.word	0x0800d588
 8007574:	200011a0 	.word	0x200011a0
 8007578:	0800d59c 	.word	0x0800d59c
 800757c:	0800bc98 	.word	0x0800bc98

08007580 <rt_test_005_001_teardown>:
  chSemReset(&sem1, 0);
 8007580:	2100      	movs	r1, #0
 8007582:	4801      	ldr	r0, [pc, #4]	; (8007588 <rt_test_005_001_teardown+0x8>)
 8007584:	f7ff befc 	b.w	8007380 <chSemReset>
 8007588:	20001408 	.word	0x20001408
 800758c:	00000000 	.word	0x00000000

08007590 <chThdYield>:
void chThdYield(void) {
 8007590:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007592:	2320      	movs	r3, #32
 8007594:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 8007598:	4c16      	ldr	r4, [pc, #88]	; (80075f4 <chThdYield+0x64>)
  _dbg_check_lock();
 800759a:	f7fc f911 	bl	80037c0 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();
 800759e:	f7f9 fb0f 	bl	8000bc0 <chDbgCheckClassS>
  chDbgCheckClassS();
 80075a2:	f7f9 fb0d 	bl	8000bc0 <chDbgCheckClassS>
  return firstprio(&ch.rlist.queue) >= currp->prio;
 80075a6:	6823      	ldr	r3, [r4, #0]
 80075a8:	69a0      	ldr	r0, [r4, #24]

  if (chSchCanYieldS()) {
 80075aa:	6899      	ldr	r1, [r3, #8]
 80075ac:	6882      	ldr	r2, [r0, #8]
 80075ae:	4291      	cmp	r1, r2
 80075b0:	d20d      	bcs.n	80075ce <chThdYield+0x3e>
  _dbg_check_unlock();
 80075b2:	f7fc f89d 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80075b6:	6823      	ldr	r3, [r4, #0]
 80075b8:	42a3      	cmp	r3, r4
 80075ba:	d004      	beq.n	80075c6 <chThdYield+0x36>
 80075bc:	69a2      	ldr	r2, [r4, #24]
 80075be:	689b      	ldr	r3, [r3, #8]
 80075c0:	6892      	ldr	r2, [r2, #8]
 80075c2:	429a      	cmp	r2, r3
 80075c4:	d311      	bcc.n	80075ea <chThdYield+0x5a>
 80075c6:	2300      	movs	r3, #0
 80075c8:	f383 8811 	msr	BASEPRI, r3
}
 80075cc:	bd10      	pop	{r4, pc}
  tqp->next             = tp->queue.next;
 80075ce:	681a      	ldr	r2, [r3, #0]
 80075d0:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 80075d2:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80075d4:	6054      	str	r4, [r2, #4]
 80075d6:	f883 1020 	strb.w	r1, [r3, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 80075da:	61a3      	str	r3, [r4, #24]
  otp = chSchReadyI(otp);
 80075dc:	f7f9 fbc0 	bl	8000d60 <chSchReadyI>
  chSysSwitch(currp, otp);
 80075e0:	4601      	mov	r1, r0
 80075e2:	69a0      	ldr	r0, [r4, #24]
 80075e4:	f7f8 fe4c 	bl	8000280 <_port_switch>
 80075e8:	e7e3      	b.n	80075b2 <chThdYield+0x22>
  __ASM volatile ("cpsid i" : : : "memory");
 80075ea:	b672      	cpsid	i
 80075ec:	4b02      	ldr	r3, [pc, #8]	; (80075f8 <chThdYield+0x68>)
 80075ee:	62e3      	str	r3, [r4, #44]	; 0x2c
 80075f0:	e7fe      	b.n	80075f0 <chThdYield+0x60>
 80075f2:	bf00      	nop
 80075f4:	200011a0 	.word	0x200011a0
 80075f8:	0800bbe4 	.word	0x0800bbe4
 80075fc:	00000000 	.word	0x00000000

08007600 <bmk_thread8>:
static THD_FUNCTION(bmk_thread8, p) {
 8007600:	b538      	push	{r3, r4, r5, lr}
 8007602:	4d09      	ldr	r5, [pc, #36]	; (8007628 <bmk_thread8+0x28>)
 8007604:	4604      	mov	r4, r0
    chThdYield();
 8007606:	f7ff ffc3 	bl	8007590 <chThdYield>
    chThdYield();
 800760a:	f7ff ffc1 	bl	8007590 <chThdYield>
    chThdYield();
 800760e:	f7ff ffbf 	bl	8007590 <chThdYield>
    chThdYield();
 8007612:	f7ff ffbd 	bl	8007590 <chThdYield>
    (*(uint32_t *)p) += 4;
 8007616:	6823      	ldr	r3, [r4, #0]
 8007618:	69aa      	ldr	r2, [r5, #24]
 800761a:	3304      	adds	r3, #4
 800761c:	6023      	str	r3, [r4, #0]
  } while(!chThdShouldTerminateX());
 800761e:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 8007622:	075b      	lsls	r3, r3, #29
 8007624:	d5ef      	bpl.n	8007606 <bmk_thread8+0x6>
}
 8007626:	bd38      	pop	{r3, r4, r5, pc}
 8007628:	200011a0 	.word	0x200011a0
 800762c:	00000000 	.word	0x00000000

08007630 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 8007630:	b508      	push	{r3, lr}
 8007632:	4601      	mov	r1, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007634:	2320      	movs	r3, #32
 8007636:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800763a:	f7fc f8c1 	bl	80037c0 <_dbg_check_lock>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800763e:	2008      	movs	r0, #8
 8007640:	f7fb fd3e 	bl	80030c0 <chSchGoSleepTimeoutS>
  _dbg_check_unlock();
 8007644:	f7fc f854 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007648:	4b08      	ldr	r3, [pc, #32]	; (800766c <chThdSleep+0x3c>)
 800764a:	681a      	ldr	r2, [r3, #0]
 800764c:	429a      	cmp	r2, r3
 800764e:	d004      	beq.n	800765a <chThdSleep+0x2a>
 8007650:	6999      	ldr	r1, [r3, #24]
 8007652:	6892      	ldr	r2, [r2, #8]
 8007654:	6889      	ldr	r1, [r1, #8]
 8007656:	4291      	cmp	r1, r2
 8007658:	d303      	bcc.n	8007662 <chThdSleep+0x32>
 800765a:	2300      	movs	r3, #0
 800765c:	f383 8811 	msr	BASEPRI, r3
}
 8007660:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8007662:	b672      	cpsid	i
 8007664:	4a02      	ldr	r2, [pc, #8]	; (8007670 <chThdSleep+0x40>)
 8007666:	62da      	str	r2, [r3, #44]	; 0x2c
 8007668:	e7fe      	b.n	8007668 <chThdSleep+0x38>
 800766a:	bf00      	nop
 800766c:	200011a0 	.word	0x200011a0
 8007670:	0800bbe4 	.word	0x0800bbe4
	...

08007680 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8007680:	4b0d      	ldr	r3, [pc, #52]	; (80076b8 <Thread1+0x38>)
 8007682:	4a0e      	ldr	r2, [pc, #56]	; (80076bc <Thread1+0x3c>)
 8007684:	699b      	ldr	r3, [r3, #24]
 8007686:	f8df 803c 	ldr.w	r8, [pc, #60]	; 80076c4 <Thread1+0x44>
  chRegSetThreadName("blinker");
  while (true) {
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 50 : 5000;
    palClearLine(PORTAB_BLINK_LED1);
 800768a:	4d0d      	ldr	r5, [pc, #52]	; (80076c0 <Thread1+0x40>)
 800768c:	f44f 7680 	mov.w	r6, #256	; 0x100
static THD_FUNCTION(Thread1, arg) {
 8007690:	b580      	push	{r7, lr}
 8007692:	619a      	str	r2, [r3, #24]
    palClearLine(PORTAB_BLINK_LED1);
 8007694:	4637      	mov	r7, r6
    time = serusbcfg.usbp->state == USB_ACTIVE ? 50 : 5000;
 8007696:	f898 3000 	ldrb.w	r3, [r8]
    palClearLine(PORTAB_BLINK_LED1);
 800769a:	836f      	strh	r7, [r5, #26]
    time = serusbcfg.usbp->state == USB_ACTIVE ? 50 : 5000;
 800769c:	2b04      	cmp	r3, #4
 800769e:	f24c 3450 	movw	r4, #50000	; 0xc350
 80076a2:	bf08      	it	eq
 80076a4:	f44f 74fa 	moveq.w	r4, #500	; 0x1f4
    chThdSleepMilliseconds(time);
 80076a8:	4620      	mov	r0, r4
 80076aa:	f7ff ffc1 	bl	8007630 <chThdSleep>
    palSetLine(PORTAB_BLINK_LED1);
    chThdSleepMilliseconds(time);
 80076ae:	4620      	mov	r0, r4
    palSetLine(PORTAB_BLINK_LED1);
 80076b0:	832e      	strh	r6, [r5, #24]
    chThdSleepMilliseconds(time);
 80076b2:	f7ff ffbd 	bl	8007630 <chThdSleep>
 80076b6:	e7ee      	b.n	8007696 <Thread1+0x16>
 80076b8:	200011a0 	.word	0x200011a0
 80076bc:	0800bbc4 	.word	0x0800bbc4
 80076c0:	48001000 	.word	0x48001000
 80076c4:	20001128 	.word	0x20001128
	...

080076d0 <evt_thread7>:
static THD_FUNCTION(evt_thread7, p) {
 80076d0:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80076d2:	2320      	movs	r3, #32
 80076d4:	f383 8811 	msr	BASEPRI, r3
 80076d8:	4c1d      	ldr	r4, [pc, #116]	; (8007750 <evt_thread7+0x80>)
  _dbg_check_lock();
 80076da:	f7fc f871 	bl	80037c0 <_dbg_check_lock>
  chEvtBroadcastFlagsI(esp, flags);
 80076de:	2100      	movs	r1, #0
 80076e0:	481c      	ldr	r0, [pc, #112]	; (8007754 <evt_thread7+0x84>)
 80076e2:	f7f9 fbfd 	bl	8000ee0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80076e6:	f7fb ffeb 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 80076ea:	f7fc f801 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80076ee:	6823      	ldr	r3, [r4, #0]
 80076f0:	42a3      	cmp	r3, r4
 80076f2:	d004      	beq.n	80076fe <evt_thread7+0x2e>
 80076f4:	69a2      	ldr	r2, [r4, #24]
 80076f6:	689b      	ldr	r3, [r3, #8]
 80076f8:	6892      	ldr	r2, [r2, #8]
 80076fa:	429a      	cmp	r2, r3
 80076fc:	d323      	bcc.n	8007746 <evt_thread7+0x76>
 80076fe:	2500      	movs	r5, #0
 8007700:	f385 8811 	msr	BASEPRI, r5
  chThdSleepMilliseconds(50);
 8007704:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007708:	f7ff ff92 	bl	8007630 <chThdSleep>
 800770c:	2320      	movs	r3, #32
 800770e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007712:	f7fc f855 	bl	80037c0 <_dbg_check_lock>
  chEvtBroadcastFlagsI(esp, flags);
 8007716:	4629      	mov	r1, r5
 8007718:	480f      	ldr	r0, [pc, #60]	; (8007758 <evt_thread7+0x88>)
 800771a:	f7f9 fbe1 	bl	8000ee0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800771e:	f7fb ffcf 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8007722:	f7fb ffe5 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007726:	6823      	ldr	r3, [r4, #0]
 8007728:	42a3      	cmp	r3, r4
 800772a:	d004      	beq.n	8007736 <evt_thread7+0x66>
 800772c:	69a2      	ldr	r2, [r4, #24]
 800772e:	689b      	ldr	r3, [r3, #8]
 8007730:	6892      	ldr	r2, [r2, #8]
 8007732:	429a      	cmp	r2, r3
 8007734:	d303      	bcc.n	800773e <evt_thread7+0x6e>
 8007736:	2300      	movs	r3, #0
 8007738:	f383 8811 	msr	BASEPRI, r3
}
 800773c:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800773e:	b672      	cpsid	i
 8007740:	4b06      	ldr	r3, [pc, #24]	; (800775c <evt_thread7+0x8c>)
 8007742:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007744:	e7fe      	b.n	8007744 <evt_thread7+0x74>
 8007746:	b672      	cpsid	i
 8007748:	4b04      	ldr	r3, [pc, #16]	; (800775c <evt_thread7+0x8c>)
 800774a:	62e3      	str	r3, [r4, #44]	; 0x2c
 800774c:	e7fe      	b.n	800774c <evt_thread7+0x7c>
 800774e:	bf00      	nop
 8007750:	200011a0 	.word	0x200011a0
 8007754:	20000c0c 	.word	0x20000c0c
 8007758:	20000c10 	.word	0x20000c10
 800775c:	0800bc14 	.word	0x0800bc14

08007760 <evt_thread3>:
static THD_FUNCTION(evt_thread3, p) {
 8007760:	b510      	push	{r4, lr}
 8007762:	4604      	mov	r4, r0
  chThdSleepMilliseconds(50);
 8007764:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007768:	f7ff ff62 	bl	8007630 <chThdSleep>
  chDbgCheck(tp != NULL);
 800776c:	b1cc      	cbz	r4, 80077a2 <evt_thread3+0x42>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800776e:	2320      	movs	r3, #32
 8007770:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007774:	f7fc f824 	bl	80037c0 <_dbg_check_lock>
  chEvtSignalI(tp, events);
 8007778:	4620      	mov	r0, r4
 800777a:	2101      	movs	r1, #1
 800777c:	f7f9 fb88 	bl	8000e90 <chEvtSignalI>
  chSchRescheduleS();
 8007780:	f7fb ff9e 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8007784:	f7fb ffb4 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007788:	4b0a      	ldr	r3, [pc, #40]	; (80077b4 <evt_thread3+0x54>)
 800778a:	681a      	ldr	r2, [r3, #0]
 800778c:	429a      	cmp	r2, r3
 800778e:	d004      	beq.n	800779a <evt_thread3+0x3a>
 8007790:	6999      	ldr	r1, [r3, #24]
 8007792:	6892      	ldr	r2, [r2, #8]
 8007794:	6889      	ldr	r1, [r1, #8]
 8007796:	4291      	cmp	r1, r2
 8007798:	d308      	bcc.n	80077ac <evt_thread3+0x4c>
 800779a:	2300      	movs	r3, #0
 800779c:	f383 8811 	msr	BASEPRI, r3
}
 80077a0:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80077a2:	b672      	cpsid	i
 80077a4:	4b03      	ldr	r3, [pc, #12]	; (80077b4 <evt_thread3+0x54>)
 80077a6:	4a04      	ldr	r2, [pc, #16]	; (80077b8 <evt_thread3+0x58>)
 80077a8:	62da      	str	r2, [r3, #44]	; 0x2c
 80077aa:	e7fe      	b.n	80077aa <evt_thread3+0x4a>
 80077ac:	b672      	cpsid	i
 80077ae:	4a03      	ldr	r2, [pc, #12]	; (80077bc <evt_thread3+0x5c>)
 80077b0:	62da      	str	r2, [r3, #44]	; 0x2c
 80077b2:	e7fe      	b.n	80077b2 <evt_thread3+0x52>
 80077b4:	200011a0 	.word	0x200011a0
 80077b8:	0800bee0 	.word	0x0800bee0
 80077bc:	0800bc14 	.word	0x0800bc14

080077c0 <thread4A>:
static THD_FUNCTION(thread4A, p) {
 80077c0:	b510      	push	{r4, lr}
  chMtxLock(&m1);
 80077c2:	4c06      	ldr	r4, [pc, #24]	; (80077dc <thread4A+0x1c>)
  chThdSleepMilliseconds(50);
 80077c4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80077c8:	f7ff ff32 	bl	8007630 <chThdSleep>
  chMtxLock(&m1);
 80077cc:	4620      	mov	r0, r4
 80077ce:	f7fe fb5f 	bl	8005e90 <chMtxLock>
  chMtxUnlock(&m1);
 80077d2:	4620      	mov	r0, r4
}
 80077d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMtxUnlock(&m1);
 80077d8:	f7fe ba32 	b.w	8005c40 <chMtxUnlock>
 80077dc:	20000c38 	.word	0x20000c38

080077e0 <thread4B>:
static THD_FUNCTION(thread4B, p) {
 80077e0:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(150);
 80077e2:	f240 50dc 	movw	r0, #1500	; 0x5dc
 80077e6:	f7ff ff23 	bl	8007630 <chThdSleep>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80077ea:	2320      	movs	r3, #32
 80077ec:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80077f0:	f7fb ffe6 	bl	80037c0 <_dbg_check_lock>
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 80077f4:	480d      	ldr	r0, [pc, #52]	; (800782c <thread4B+0x4c>)
 80077f6:	f7fb fbbb 	bl	8002f70 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 80077fa:	480c      	ldr	r0, [pc, #48]	; (800782c <thread4B+0x4c>)
 80077fc:	f7f9 fb98 	bl	8000f30 <chMtxUnlockS>
  chSchRescheduleS();
 8007800:	f7fb ff5e 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8007804:	f7fb ff74 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007808:	4b09      	ldr	r3, [pc, #36]	; (8007830 <thread4B+0x50>)
 800780a:	681a      	ldr	r2, [r3, #0]
 800780c:	429a      	cmp	r2, r3
 800780e:	d004      	beq.n	800781a <thread4B+0x3a>
 8007810:	6999      	ldr	r1, [r3, #24]
 8007812:	6892      	ldr	r2, [r2, #8]
 8007814:	6889      	ldr	r1, [r1, #8]
 8007816:	4291      	cmp	r1, r2
 8007818:	d303      	bcc.n	8007822 <thread4B+0x42>
 800781a:	2300      	movs	r3, #0
 800781c:	f383 8811 	msr	BASEPRI, r3
}
 8007820:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8007822:	b672      	cpsid	i
 8007824:	4a03      	ldr	r2, [pc, #12]	; (8007834 <thread4B+0x54>)
 8007826:	62da      	str	r2, [r3, #44]	; 0x2c
 8007828:	e7fe      	b.n	8007828 <thread4B+0x48>
 800782a:	bf00      	nop
 800782c:	20000c48 	.word	0x20000c48
 8007830:	200011a0 	.word	0x200011a0
 8007834:	0800bca4 	.word	0x0800bca4
	...

08007840 <thread2>:
static THD_FUNCTION(thread2, p) {
 8007840:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(50);
 8007842:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007846:	f7ff fef3 	bl	8007630 <chThdSleep>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800784a:	2320      	movs	r3, #32
 800784c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007850:	f7fb ffb6 	bl	80037c0 <_dbg_check_lock>
  chSemSignalI(&sem1); /* For coverage reasons */
 8007854:	480b      	ldr	r0, [pc, #44]	; (8007884 <thread2+0x44>)
 8007856:	f7f9 fbbb 	bl	8000fd0 <chSemSignalI>
  chSchRescheduleS();
 800785a:	f7fb ff31 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 800785e:	f7fb ff47 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007862:	4b09      	ldr	r3, [pc, #36]	; (8007888 <thread2+0x48>)
 8007864:	681a      	ldr	r2, [r3, #0]
 8007866:	429a      	cmp	r2, r3
 8007868:	d004      	beq.n	8007874 <thread2+0x34>
 800786a:	6999      	ldr	r1, [r3, #24]
 800786c:	6892      	ldr	r2, [r2, #8]
 800786e:	6889      	ldr	r1, [r1, #8]
 8007870:	4291      	cmp	r1, r2
 8007872:	d303      	bcc.n	800787c <thread2+0x3c>
 8007874:	2300      	movs	r3, #0
 8007876:	f383 8811 	msr	BASEPRI, r3
}
 800787a:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800787c:	b672      	cpsid	i
 800787e:	4a03      	ldr	r2, [pc, #12]	; (800788c <thread2+0x4c>)
 8007880:	62da      	str	r2, [r3, #44]	; 0x2c
 8007882:	e7fe      	b.n	8007882 <thread2+0x42>
 8007884:	20001408 	.word	0x20001408
 8007888:	200011a0 	.word	0x200011a0
 800788c:	0800bc98 	.word	0x0800bc98

08007890 <rt_test_003_001_execute>:
 * - [3.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void rt_test_003_001_execute(void) {
 8007890:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  /* [3.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 8007892:	4e34      	ldr	r6, [pc, #208]	; (8007964 <rt_test_003_001_execute+0xd4>)
 8007894:	2301      	movs	r3, #1
 8007896:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 800789a:	6033      	str	r3, [r6, #0]
 800789c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleep(100);
 800789e:	2064      	movs	r0, #100	; 0x64
 80078a0:	f7ff fec6 	bl	8007630 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, 100),
 80078a4:	f104 0167 	add.w	r1, r4, #103	; 0x67
 80078a8:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80078ac:	f7f8 ff78 	bl	80007a0 <_test_assert_time_window.constprop.1>
 80078b0:	b100      	cbz	r0, 80078b4 <rt_test_003_001_execute+0x24>
    chThdSleepUntil(chTimeAddX(time, 100));
    test_assert_time_window(chTimeAddX(time, 100),
                            chTimeAddX(time, 100 + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
  }
}
 80078b2:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(2);
 80078b4:	2302      	movs	r3, #2
 80078b6:	6033      	str	r3, [r6, #0]
 80078b8:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepMicroseconds(100000);
 80078ba:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80078be:	f7ff feb7 	bl	8007630 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_US2I(100000)),
 80078c2:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 80078c6:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 80078ca:	f7f8 ff69 	bl	80007a0 <_test_assert_time_window.constprop.1>
 80078ce:	2800      	cmp	r0, #0
 80078d0:	d1ef      	bne.n	80078b2 <rt_test_003_001_execute+0x22>
  test_set_step(3);
 80078d2:	2303      	movs	r3, #3
 80078d4:	6033      	str	r3, [r6, #0]
 80078d6:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepMilliseconds(100);
 80078d8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80078dc:	f7ff fea8 	bl	8007630 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(100)),
 80078e0:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 80078e4:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 80078e8:	f7f8 ff5a 	bl	80007a0 <_test_assert_time_window.constprop.1>
 80078ec:	2800      	cmp	r0, #0
 80078ee:	d1e0      	bne.n	80078b2 <rt_test_003_001_execute+0x22>
  test_set_step(4);
 80078f0:	2304      	movs	r3, #4
 80078f2:	6033      	str	r3, [r6, #0]
 80078f4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepSeconds(1);
 80078f6:	f242 7010 	movw	r0, #10000	; 0x2710
 80078fa:	f7ff fe99 	bl	8007630 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_S2I(1)),
 80078fe:	f504 511c 	add.w	r1, r4, #9984	; 0x2700
 8007902:	4608      	mov	r0, r1
 8007904:	3010      	adds	r0, #16
 8007906:	3113      	adds	r1, #19
 8007908:	f7f8 ff4a 	bl	80007a0 <_test_assert_time_window.constprop.1>
 800790c:	2800      	cmp	r0, #0
 800790e:	d1d0      	bne.n	80078b2 <rt_test_003_001_execute+0x22>
  test_set_step(5);
 8007910:	2305      	movs	r3, #5
 8007912:	6033      	str	r3, [r6, #0]
 8007914:	6a6e      	ldr	r6, [r5, #36]	; 0x24
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007916:	2320      	movs	r3, #32
 8007918:	f106 0464 	add.w	r4, r6, #100	; 0x64
 800791c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007920:	f7fb ff4e 	bl	80037c0 <_dbg_check_lock>
 8007924:	6a69      	ldr	r1, [r5, #36]	; 0x24
  if (interval > (sysinterval_t)0) {
 8007926:	1a61      	subs	r1, r4, r1
 8007928:	d114      	bne.n	8007954 <rt_test_003_001_execute+0xc4>
  _dbg_check_unlock();
 800792a:	f7fb fee1 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800792e:	4b0e      	ldr	r3, [pc, #56]	; (8007968 <rt_test_003_001_execute+0xd8>)
 8007930:	681a      	ldr	r2, [r3, #0]
 8007932:	429a      	cmp	r2, r3
 8007934:	d004      	beq.n	8007940 <rt_test_003_001_execute+0xb0>
 8007936:	6999      	ldr	r1, [r3, #24]
 8007938:	6892      	ldr	r2, [r2, #8]
 800793a:	6889      	ldr	r1, [r1, #8]
 800793c:	4291      	cmp	r1, r2
 800793e:	d30d      	bcc.n	800795c <rt_test_003_001_execute+0xcc>
 8007940:	2300      	movs	r3, #0
 8007942:	f383 8811 	msr	BASEPRI, r3
    test_assert_time_window(chTimeAddX(time, 100),
 8007946:	f106 0167 	add.w	r1, r6, #103	; 0x67
 800794a:	4620      	mov	r0, r4
}
 800794c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_time_window(chTimeAddX(time, 100),
 8007950:	f7f8 bf26 	b.w	80007a0 <_test_assert_time_window.constprop.1>
 8007954:	2008      	movs	r0, #8
 8007956:	f7fb fbb3 	bl	80030c0 <chSchGoSleepTimeoutS>
 800795a:	e7e6      	b.n	800792a <rt_test_003_001_execute+0x9a>
  __ASM volatile ("cpsid i" : : : "memory");
 800795c:	b672      	cpsid	i
 800795e:	4a03      	ldr	r2, [pc, #12]	; (800796c <rt_test_003_001_execute+0xdc>)
 8007960:	62da      	str	r2, [r3, #44]	; 0x2c
 8007962:	e7fe      	b.n	8007962 <rt_test_003_001_execute+0xd2>
 8007964:	20001b3c 	.word	0x20001b3c
 8007968:	200011a0 	.word	0x200011a0
 800796c:	0800bbe4 	.word	0x0800bbe4

08007970 <test_wait_tick>:
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 8007970:	b508      	push	{r3, lr}

  chThdSleep(1);
 8007972:	2001      	movs	r0, #1
 8007974:	f7ff fe5c 	bl	8007630 <chThdSleep>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007978:	2320      	movs	r3, #32
 800797a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800797e:	f7fb ff1f 	bl	80037c0 <_dbg_check_lock>
 8007982:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007986:	6a58      	ldr	r0, [r3, #36]	; 0x24
  _dbg_check_unlock();
 8007988:	f7fb feb2 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800798c:	4b08      	ldr	r3, [pc, #32]	; (80079b0 <test_wait_tick+0x40>)
 800798e:	681a      	ldr	r2, [r3, #0]
 8007990:	429a      	cmp	r2, r3
 8007992:	d004      	beq.n	800799e <test_wait_tick+0x2e>
 8007994:	6999      	ldr	r1, [r3, #24]
 8007996:	6892      	ldr	r2, [r2, #8]
 8007998:	6889      	ldr	r1, [r1, #8]
 800799a:	4291      	cmp	r1, r2
 800799c:	d303      	bcc.n	80079a6 <test_wait_tick+0x36>
 800799e:	2300      	movs	r3, #0
 80079a0:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 80079a4:	bd08      	pop	{r3, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80079a6:	b672      	cpsid	i
 80079a8:	4a02      	ldr	r2, [pc, #8]	; (80079b4 <test_wait_tick+0x44>)
 80079aa:	62da      	str	r2, [r3, #44]	; 0x2c
 80079ac:	e7fe      	b.n	80079ac <test_wait_tick+0x3c>
 80079ae:	bf00      	nop
 80079b0:	200011a0 	.word	0x200011a0
 80079b4:	0800bc68 	.word	0x0800bc68
	...

080079c0 <rt_test_010_011_execute>:
static void rt_test_010_011_execute(void) {
 80079c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
 80079c4:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8007a48 <rt_test_010_011_execute+0x88>
      chMtxLock(&mtx1);
 80079c8:	4c1c      	ldr	r4, [pc, #112]	; (8007a3c <rt_test_010_011_execute+0x7c>)
  test_set_step(1);
 80079ca:	2301      	movs	r3, #1
 80079cc:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 80079d0:	f7ff ffce 	bl	8007970 <test_wait_tick>
    n = 0;
 80079d4:	2500      	movs	r5, #0
    start = test_wait_tick();
 80079d6:	4680      	mov	r8, r0
 80079d8:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 80079dc:	f242 760f 	movw	r6, #9999	; 0x270f
      chMtxLock(&mtx1);
 80079e0:	4620      	mov	r0, r4
 80079e2:	f7fe fa55 	bl	8005e90 <chMtxLock>
      chMtxUnlock(&mtx1);
 80079e6:	4620      	mov	r0, r4
 80079e8:	f7fe f92a 	bl	8005c40 <chMtxUnlock>
      chMtxLock(&mtx1);
 80079ec:	4620      	mov	r0, r4
 80079ee:	f7fe fa4f 	bl	8005e90 <chMtxLock>
      chMtxUnlock(&mtx1);
 80079f2:	4620      	mov	r0, r4
 80079f4:	f7fe f924 	bl	8005c40 <chMtxUnlock>
      chMtxLock(&mtx1);
 80079f8:	4620      	mov	r0, r4
 80079fa:	f7fe fa49 	bl	8005e90 <chMtxLock>
      chMtxUnlock(&mtx1);
 80079fe:	4620      	mov	r0, r4
 8007a00:	f7fe f91e 	bl	8005c40 <chMtxUnlock>
      chMtxLock(&mtx1);
 8007a04:	4620      	mov	r0, r4
 8007a06:	f7fe fa43 	bl	8005e90 <chMtxLock>
      chMtxUnlock(&mtx1);
 8007a0a:	4620      	mov	r0, r4
 8007a0c:	f7fe f918 	bl	8005c40 <chMtxUnlock>
 8007a10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  return (bool)((time - start) < (end - start));
 8007a12:	eba3 0308 	sub.w	r3, r3, r8
    } while (chVTIsSystemTimeWithinX(start, end));
 8007a16:	42b3      	cmp	r3, r6
      n++;
 8007a18:	f105 0501 	add.w	r5, r5, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8007a1c:	d9e0      	bls.n	80079e0 <rt_test_010_011_execute+0x20>
  test_set_step(2);
 8007a1e:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8007a20:	4807      	ldr	r0, [pc, #28]	; (8007a40 <rt_test_010_011_execute+0x80>)
  test_set_step(2);
 8007a22:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8007a26:	f7f9 f803 	bl	8000a30 <test_print>
    test_printn(n * 4);
 8007a2a:	00a8      	lsls	r0, r5, #2
 8007a2c:	f7f8 ffd0 	bl	80009d0 <test_printn>
    test_println(" lock+unlock/S");
 8007a30:	4804      	ldr	r0, [pc, #16]	; (8007a44 <rt_test_010_011_execute+0x84>)
}
 8007a32:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" lock+unlock/S");
 8007a36:	f7f8 bfdb 	b.w	80009f0 <test_println>
 8007a3a:	bf00      	nop
 8007a3c:	200013e8 	.word	0x200013e8
 8007a40:	0800da4c 	.word	0x0800da4c
 8007a44:	0800da5c 	.word	0x0800da5c
 8007a48:	20001b3c 	.word	0x20001b3c
 8007a4c:	00000000 	.word	0x00000000

08007a50 <rt_test_010_010_execute>:
static void rt_test_010_010_execute(void) {
 8007a50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
 8007a54:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8007ad8 <rt_test_010_010_execute+0x88>
      chSemWait(&sem1);
 8007a58:	4c1c      	ldr	r4, [pc, #112]	; (8007acc <rt_test_010_010_execute+0x7c>)
  test_set_step(1);
 8007a5a:	2301      	movs	r3, #1
 8007a5c:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 8007a60:	f7ff ff86 	bl	8007970 <test_wait_tick>
    n = 0;
 8007a64:	2500      	movs	r5, #0
    start = test_wait_tick();
 8007a66:	4680      	mov	r8, r0
 8007a68:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 8007a6c:	f242 760f 	movw	r6, #9999	; 0x270f
      chSemWait(&sem1);
 8007a70:	4620      	mov	r0, r4
 8007a72:	f7ff fc05 	bl	8007280 <chSemWait>
      chSemSignal(&sem1);
 8007a76:	4620      	mov	r0, r4
 8007a78:	f7ff fbca 	bl	8007210 <chSemSignal>
      chSemWait(&sem1);
 8007a7c:	4620      	mov	r0, r4
 8007a7e:	f7ff fbff 	bl	8007280 <chSemWait>
      chSemSignal(&sem1);
 8007a82:	4620      	mov	r0, r4
 8007a84:	f7ff fbc4 	bl	8007210 <chSemSignal>
      chSemWait(&sem1);
 8007a88:	4620      	mov	r0, r4
 8007a8a:	f7ff fbf9 	bl	8007280 <chSemWait>
      chSemSignal(&sem1);
 8007a8e:	4620      	mov	r0, r4
 8007a90:	f7ff fbbe 	bl	8007210 <chSemSignal>
      chSemWait(&sem1);
 8007a94:	4620      	mov	r0, r4
 8007a96:	f7ff fbf3 	bl	8007280 <chSemWait>
      chSemSignal(&sem1);
 8007a9a:	4620      	mov	r0, r4
 8007a9c:	f7ff fbb8 	bl	8007210 <chSemSignal>
 8007aa0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007aa2:	eba3 0308 	sub.w	r3, r3, r8
    } while (chVTIsSystemTimeWithinX(start, end));
 8007aa6:	42b3      	cmp	r3, r6
      n++;
 8007aa8:	f105 0501 	add.w	r5, r5, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8007aac:	d9e0      	bls.n	8007a70 <rt_test_010_010_execute+0x20>
  test_set_step(2);
 8007aae:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8007ab0:	4807      	ldr	r0, [pc, #28]	; (8007ad0 <rt_test_010_010_execute+0x80>)
  test_set_step(2);
 8007ab2:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8007ab6:	f7f8 ffbb 	bl	8000a30 <test_print>
    test_printn(n * 4);
 8007aba:	00a8      	lsls	r0, r5, #2
 8007abc:	f7f8 ff88 	bl	80009d0 <test_printn>
    test_println(" wait+signal/S");
 8007ac0:	4804      	ldr	r0, [pc, #16]	; (8007ad4 <rt_test_010_010_execute+0x84>)
}
 8007ac2:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" wait+signal/S");
 8007ac6:	f7f8 bf93 	b.w	80009f0 <test_println>
 8007aca:	bf00      	nop
 8007acc:	20001414 	.word	0x20001414
 8007ad0:	0800da4c 	.word	0x0800da4c
 8007ad4:	0800da2c 	.word	0x0800da2c
 8007ad8:	20001b3c 	.word	0x20001b3c
 8007adc:	00000000 	.word	0x00000000

08007ae0 <rt_test_010_009_execute>:
static void rt_test_010_009_execute(void) {
 8007ae0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(1);
 8007ae4:	4e27      	ldr	r6, [pc, #156]	; (8007b84 <rt_test_010_009_execute+0xa4>)
 8007ae6:	4c28      	ldr	r4, [pc, #160]	; (8007b88 <rt_test_010_009_execute+0xa8>)
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8007ae8:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 8007b9c <rt_test_010_009_execute+0xbc>
 8007aec:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 8007ba0 <rt_test_010_009_execute+0xc0>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8007af0:	4f26      	ldr	r7, [pc, #152]	; (8007b8c <rt_test_010_009_execute+0xac>)
  test_set_step(1);
 8007af2:	2301      	movs	r3, #1
 8007af4:	6033      	str	r3, [r6, #0]
    start = test_wait_tick();
 8007af6:	f7ff ff3b 	bl	8007970 <test_wait_tick>
    n = 0;
 8007afa:	2500      	movs	r5, #0
    start = test_wait_tick();
 8007afc:	4682      	mov	sl, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007afe:	2320      	movs	r3, #32
 8007b00:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007b04:	f7fb fe5c 	bl	80037c0 <_dbg_check_lock>
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8007b08:	464a      	mov	r2, r9
 8007b0a:	4640      	mov	r0, r8
 8007b0c:	2300      	movs	r3, #0
 8007b0e:	2101      	movs	r1, #1
 8007b10:	f7fa f8be 	bl	8001c90 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8007b14:	464a      	mov	r2, r9
 8007b16:	2300      	movs	r3, #0
 8007b18:	f242 7110 	movw	r1, #10000	; 0x2710
 8007b1c:	4638      	mov	r0, r7
 8007b1e:	f7fa f8b7 	bl	8001c90 <chVTDoSetI>
      chVTDoResetI(&vt1);
 8007b22:	4640      	mov	r0, r8
 8007b24:	f7fa f86c 	bl	8001c00 <chVTDoResetI>
      chVTDoResetI(&vt2);
 8007b28:	4638      	mov	r0, r7
 8007b2a:	f7fa f869 	bl	8001c00 <chVTDoResetI>
  _dbg_check_unlock();
 8007b2e:	f7fb fddf 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007b32:	6823      	ldr	r3, [r4, #0]
 8007b34:	42a3      	cmp	r3, r4
 8007b36:	f04f 0200 	mov.w	r2, #0
 8007b3a:	d004      	beq.n	8007b46 <rt_test_010_009_execute+0x66>
 8007b3c:	69a1      	ldr	r1, [r4, #24]
 8007b3e:	689b      	ldr	r3, [r3, #8]
 8007b40:	6889      	ldr	r1, [r1, #8]
 8007b42:	4299      	cmp	r1, r3
 8007b44:	d319      	bcc.n	8007b7a <rt_test_010_009_execute+0x9a>
 8007b46:	f382 8811 	msr	BASEPRI, r2
 8007b4a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 8007b4e:	f242 720f 	movw	r2, #9999	; 0x270f
 8007b52:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007b54:	eba3 030a 	sub.w	r3, r3, sl
 8007b58:	4293      	cmp	r3, r2
      n++;
 8007b5a:	f105 0501 	add.w	r5, r5, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8007b5e:	d9ce      	bls.n	8007afe <rt_test_010_009_execute+0x1e>
  test_set_step(2);
 8007b60:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8007b62:	480b      	ldr	r0, [pc, #44]	; (8007b90 <rt_test_010_009_execute+0xb0>)
  test_set_step(2);
 8007b64:	6033      	str	r3, [r6, #0]
    test_print("--- Score : ");
 8007b66:	f7f8 ff63 	bl	8000a30 <test_print>
    test_printn(n * 2);
 8007b6a:	0068      	lsls	r0, r5, #1
 8007b6c:	f7f8 ff30 	bl	80009d0 <test_printn>
    test_println(" timers/S");
 8007b70:	4808      	ldr	r0, [pc, #32]	; (8007b94 <rt_test_010_009_execute+0xb4>)
}
 8007b72:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_println(" timers/S");
 8007b76:	f7f8 bf3b 	b.w	80009f0 <test_println>
  __ASM volatile ("cpsid i" : : : "memory");
 8007b7a:	b672      	cpsid	i
 8007b7c:	4b06      	ldr	r3, [pc, #24]	; (8007b98 <rt_test_010_009_execute+0xb8>)
 8007b7e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007b80:	e7fe      	b.n	8007b80 <rt_test_010_009_execute+0xa0>
 8007b82:	bf00      	nop
 8007b84:	20001b3c 	.word	0x20001b3c
 8007b88:	200011a0 	.word	0x200011a0
 8007b8c:	20001b80 	.word	0x20001b80
 8007b90:	0800da4c 	.word	0x0800da4c
 8007b94:	0800da10 	.word	0x0800da10
 8007b98:	0800bcbc 	.word	0x0800bcbc
 8007b9c:	080008c1 	.word	0x080008c1
 8007ba0:	20001b6c 	.word	0x20001b6c
	...

08007bb0 <msg_loop_test>:
NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 8007bb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007bb4:	4605      	mov	r5, r0
  start = test_wait_tick();
 8007bb6:	f7ff fedb 	bl	8007970 <test_wait_tick>
  uint32_t n = 0;
 8007bba:	2400      	movs	r4, #0
  start = test_wait_tick();
 8007bbc:	4680      	mov	r8, r0
 8007bbe:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
  } while (chVTIsSystemTimeWithinX(start, end));
 8007bc2:	f242 760f 	movw	r6, #9999	; 0x270f
    (void)chMsgSend(tp, 1);
 8007bc6:	2101      	movs	r1, #1
 8007bc8:	4628      	mov	r0, r5
 8007bca:	f7fd fe99 	bl	8005900 <chMsgSend>
 8007bce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007bd0:	eba3 0308 	sub.w	r3, r3, r8
  } while (chVTIsSystemTimeWithinX(start, end));
 8007bd4:	42b3      	cmp	r3, r6
    n++;
 8007bd6:	f104 0401 	add.w	r4, r4, #1
  } while (chVTIsSystemTimeWithinX(start, end));
 8007bda:	d9f4      	bls.n	8007bc6 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 8007bdc:	4628      	mov	r0, r5
 8007bde:	2100      	movs	r1, #0
 8007be0:	f7fd fe8e 	bl	8005900 <chMsgSend>
}
 8007be4:	4620      	mov	r0, r4
 8007be6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007bea:	bf00      	nop
 8007bec:	0000      	movs	r0, r0
	...

08007bf0 <test_execute>:
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
 8007bf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int tseq, tcase;

  test_chp = stream;
 8007bf4:	4c9d      	ldr	r4, [pc, #628]	; (8007e6c <test_execute+0x27c>)
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
 8007bf6:	4689      	mov	r9, r1
  test_chp = stream;
 8007bf8:	6020      	str	r0, [r4, #0]
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
 8007bfa:	b083      	sub	sp, #12
  test_println("");
 8007bfc:	489c      	ldr	r0, [pc, #624]	; (8007e70 <test_execute+0x280>)
 8007bfe:	f7f8 fef7 	bl	80009f0 <test_println>
  if (tsp->name != NULL) {
 8007c02:	f8d9 3000 	ldr.w	r3, [r9]
 8007c06:	2b00      	cmp	r3, #0
 8007c08:	f000 8186 	beq.w	8007f18 <test_execute+0x328>
 8007c0c:	4d99      	ldr	r5, [pc, #612]	; (8007e74 <test_execute+0x284>)
  while (*msgp)
 8007c0e:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8007c10:	6820      	ldr	r0, [r4, #0]
 8007c12:	6803      	ldr	r3, [r0, #0]
 8007c14:	68db      	ldr	r3, [r3, #12]
 8007c16:	4798      	blx	r3
  while (*msgp)
 8007c18:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007c1c:	2900      	cmp	r1, #0
 8007c1e:	d1f7      	bne.n	8007c10 <test_execute+0x20>
    test_print("*** ");
    test_println(tsp->name);
 8007c20:	f8d9 0000 	ldr.w	r0, [r9]
 8007c24:	f7f8 fee4 	bl	80009f0 <test_println>
  }
  else {
    test_println("*** Test Suite");
  }
  test_println("***");
 8007c28:	4893      	ldr	r0, [pc, #588]	; (8007e78 <test_execute+0x288>)
 8007c2a:	4d94      	ldr	r5, [pc, #592]	; (8007e7c <test_execute+0x28c>)
 8007c2c:	f7f8 fee0 	bl	80009f0 <test_println>
  while (*msgp)
 8007c30:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8007c32:	6820      	ldr	r0, [r4, #0]
 8007c34:	6803      	ldr	r3, [r0, #0]
 8007c36:	68db      	ldr	r3, [r3, #12]
 8007c38:	4798      	blx	r3
  while (*msgp)
 8007c3a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007c3e:	2900      	cmp	r1, #0
 8007c40:	d1f7      	bne.n	8007c32 <test_execute+0x42>
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8007c42:	488f      	ldr	r0, [pc, #572]	; (8007e80 <test_execute+0x290>)
 8007c44:	4d8f      	ldr	r5, [pc, #572]	; (8007e84 <test_execute+0x294>)
 8007c46:	f7f8 fed3 	bl	80009f0 <test_println>
  while (*msgp)
 8007c4a:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8007c4c:	6820      	ldr	r0, [r4, #0]
 8007c4e:	6803      	ldr	r3, [r0, #0]
 8007c50:	68db      	ldr	r3, [r3, #12]
 8007c52:	4798      	blx	r3
  while (*msgp)
 8007c54:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007c58:	2900      	cmp	r1, #0
 8007c5a:	d1f7      	bne.n	8007c4c <test_execute+0x5c>
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8007c5c:	488a      	ldr	r0, [pc, #552]	; (8007e88 <test_execute+0x298>)
 8007c5e:	4d8b      	ldr	r5, [pc, #556]	; (8007e8c <test_execute+0x29c>)
 8007c60:	f7f8 fec6 	bl	80009f0 <test_println>
  while (*msgp)
 8007c64:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8007c66:	6820      	ldr	r0, [r4, #0]
 8007c68:	6803      	ldr	r3, [r0, #0]
 8007c6a:	68db      	ldr	r3, [r3, #12]
 8007c6c:	4798      	blx	r3
  while (*msgp)
 8007c6e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007c72:	2900      	cmp	r1, #0
 8007c74:	d1f7      	bne.n	8007c66 <test_execute+0x76>
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8007c76:	4886      	ldr	r0, [pc, #536]	; (8007e90 <test_execute+0x2a0>)
 8007c78:	9101      	str	r1, [sp, #4]
 8007c7a:	f7f8 feb9 	bl	80009f0 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 8007c7e:	487c      	ldr	r0, [pc, #496]	; (8007e70 <test_execute+0x280>)
  test_tokp = test_tokens_buffer;
 8007c80:	4f84      	ldr	r7, [pc, #528]	; (8007e94 <test_execute+0x2a4>)
  test_println("");
 8007c82:	f7f8 feb5 	bl	80009f0 <test_println>

  test_global_fail = false;
 8007c86:	4b84      	ldr	r3, [pc, #528]	; (8007e98 <test_execute+0x2a8>)
  tseq = 0;
 8007c88:	9901      	ldr	r1, [sp, #4]
  test_global_fail = false;
 8007c8a:	7019      	strb	r1, [r3, #0]
 8007c8c:	f8d9 3004 	ldr.w	r3, [r9, #4]
  tseq = 0;
 8007c90:	468b      	mov	fp, r1
  while (tsp->sequences[tseq] != NULL) {
 8007c92:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
 8007c96:	ea4f 068b 	mov.w	r6, fp, lsl #2
 8007c9a:	2b00      	cmp	r3, #0
 8007c9c:	f000 811a 	beq.w	8007ed4 <test_execute+0x2e4>
 8007ca0:	254c      	movs	r5, #76	; 0x4c
    streamPut(test_chp, '=');
 8007ca2:	6820      	ldr	r0, [r4, #0]
 8007ca4:	6803      	ldr	r3, [r0, #0]
 8007ca6:	213d      	movs	r1, #61	; 0x3d
 8007ca8:	68db      	ldr	r3, [r3, #12]
 8007caa:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 8007cac:	3d01      	subs	r5, #1
 8007cae:	d1f8      	bne.n	8007ca2 <test_execute+0xb2>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8007cb0:	6820      	ldr	r0, [r4, #0]
 8007cb2:	497a      	ldr	r1, [pc, #488]	; (8007e9c <test_execute+0x2ac>)
 8007cb4:	6803      	ldr	r3, [r0, #0]
 8007cb6:	4d7a      	ldr	r5, [pc, #488]	; (8007ea0 <test_execute+0x2b0>)
 8007cb8:	685b      	ldr	r3, [r3, #4]
 8007cba:	2202      	movs	r2, #2
 8007cbc:	4798      	blx	r3
  while (*msgp)
 8007cbe:	213d      	movs	r1, #61	; 0x3d
    streamPut(test_chp, *msgp++);
 8007cc0:	6820      	ldr	r0, [r4, #0]
 8007cc2:	6803      	ldr	r3, [r0, #0]
 8007cc4:	68db      	ldr	r3, [r3, #12]
 8007cc6:	4798      	blx	r3
  while (*msgp)
 8007cc8:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007ccc:	2900      	cmp	r1, #0
 8007cce:	d1f7      	bne.n	8007cc0 <test_execute+0xd0>
#if TEST_SHOW_SEQUENCES == TRUE
    print_fat_line();
    test_print("=== Test Sequence ");
    test_printn(tseq + 1);
 8007cd0:	f10b 0b01 	add.w	fp, fp, #1
 8007cd4:	4658      	mov	r0, fp
 8007cd6:	4d73      	ldr	r5, [pc, #460]	; (8007ea4 <test_execute+0x2b4>)
 8007cd8:	f7f8 fe7a 	bl	80009d0 <test_printn>
  while (*msgp)
 8007cdc:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 8007cde:	6820      	ldr	r0, [r4, #0]
 8007ce0:	6803      	ldr	r3, [r0, #0]
 8007ce2:	68db      	ldr	r3, [r3, #12]
 8007ce4:	4798      	blx	r3
  while (*msgp)
 8007ce6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007cea:	2900      	cmp	r1, #0
 8007cec:	d1f7      	bne.n	8007cde <test_execute+0xee>
    test_print(" (");
    test_print(tsp->sequences[tseq]->name);
 8007cee:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8007cf2:	599b      	ldr	r3, [r3, r6]
 8007cf4:	681d      	ldr	r5, [r3, #0]
  while (*msgp)
 8007cf6:	7829      	ldrb	r1, [r5, #0]
 8007cf8:	b139      	cbz	r1, 8007d0a <test_execute+0x11a>
    streamPut(test_chp, *msgp++);
 8007cfa:	6820      	ldr	r0, [r4, #0]
 8007cfc:	6803      	ldr	r3, [r0, #0]
 8007cfe:	68db      	ldr	r3, [r3, #12]
 8007d00:	4798      	blx	r3
  while (*msgp)
 8007d02:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007d06:	2900      	cmp	r1, #0
 8007d08:	d1f7      	bne.n	8007cfa <test_execute+0x10a>
    test_println(")");
 8007d0a:	4867      	ldr	r0, [pc, #412]	; (8007ea8 <test_execute+0x2b8>)
 8007d0c:	f7f8 fe70 	bl	80009f0 <test_println>
#endif
    tcase = 0;
 8007d10:	2500      	movs	r5, #0
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
 8007d12:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8007d16:	599a      	ldr	r2, [r3, r6]
 8007d18:	6852      	ldr	r2, [r2, #4]
 8007d1a:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
 8007d1e:	ea4f 0885 	mov.w	r8, r5, lsl #2
 8007d22:	2a00      	cmp	r2, #0
 8007d24:	d0b5      	beq.n	8007c92 <test_execute+0xa2>
      print_line();
 8007d26:	f8df a198 	ldr.w	sl, [pc, #408]	; 8007ec0 <test_execute+0x2d0>
 8007d2a:	f7f8 fec1 	bl	8000ab0 <print_line>
  while (*msgp)
 8007d2e:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
 8007d30:	6820      	ldr	r0, [r4, #0]
 8007d32:	6803      	ldr	r3, [r0, #0]
 8007d34:	68db      	ldr	r3, [r3, #12]
 8007d36:	4798      	blx	r3
  while (*msgp)
 8007d38:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 8007d3c:	2900      	cmp	r1, #0
 8007d3e:	d1f7      	bne.n	8007d30 <test_execute+0x140>
      test_print("--- Test Case ");
      test_printn(tseq + 1);
 8007d40:	4658      	mov	r0, fp
 8007d42:	f7f8 fe45 	bl	80009d0 <test_printn>
    streamPut(test_chp, *msgp++);
 8007d46:	6820      	ldr	r0, [r4, #0]
      test_print(".");
      test_printn(tcase + 1);
 8007d48:	f8df a158 	ldr.w	sl, [pc, #344]	; 8007ea4 <test_execute+0x2b4>
    streamPut(test_chp, *msgp++);
 8007d4c:	6803      	ldr	r3, [r0, #0]
 8007d4e:	212e      	movs	r1, #46	; 0x2e
 8007d50:	68db      	ldr	r3, [r3, #12]
      test_printn(tcase + 1);
 8007d52:	3501      	adds	r5, #1
    streamPut(test_chp, *msgp++);
 8007d54:	4798      	blx	r3
      test_printn(tcase + 1);
 8007d56:	4628      	mov	r0, r5
 8007d58:	f7f8 fe3a 	bl	80009d0 <test_printn>
  while (*msgp)
 8007d5c:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 8007d5e:	6820      	ldr	r0, [r4, #0]
 8007d60:	6803      	ldr	r3, [r0, #0]
 8007d62:	68db      	ldr	r3, [r3, #12]
 8007d64:	4798      	blx	r3
  while (*msgp)
 8007d66:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 8007d6a:	2900      	cmp	r1, #0
 8007d6c:	d1f7      	bne.n	8007d5e <test_execute+0x16e>
      test_print(" (");
      test_print(tsp->sequences[tseq]->cases[tcase]->name);
 8007d6e:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8007d72:	599b      	ldr	r3, [r3, r6]
 8007d74:	685b      	ldr	r3, [r3, #4]
 8007d76:	f853 3008 	ldr.w	r3, [r3, r8]
 8007d7a:	f8d3 a000 	ldr.w	sl, [r3]
  while (*msgp)
 8007d7e:	f89a 1000 	ldrb.w	r1, [sl]
 8007d82:	b139      	cbz	r1, 8007d94 <test_execute+0x1a4>
    streamPut(test_chp, *msgp++);
 8007d84:	6820      	ldr	r0, [r4, #0]
 8007d86:	6803      	ldr	r3, [r0, #0]
 8007d88:	68db      	ldr	r3, [r3, #12]
 8007d8a:	4798      	blx	r3
  while (*msgp)
 8007d8c:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 8007d90:	2900      	cmp	r1, #0
 8007d92:	d1f7      	bne.n	8007d84 <test_execute+0x194>
      test_println(")");
 8007d94:	4844      	ldr	r0, [pc, #272]	; (8007ea8 <test_execute+0x2b8>)
  test_local_fail = false;
 8007d96:	f8df a12c 	ldr.w	sl, [pc, #300]	; 8007ec4 <test_execute+0x2d4>
      test_println(")");
 8007d9a:	f7f8 fe29 	bl	80009f0 <test_println>
  chThdSleep(delay);
 8007d9e:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8007da2:	f7ff fc45 	bl	8007630 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8007da6:	f8d9 3004 	ldr.w	r3, [r9, #4]
  test_tokp = test_tokens_buffer;
 8007daa:	4a40      	ldr	r2, [pc, #256]	; (8007eac <test_execute+0x2bc>)
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8007dac:	599b      	ldr	r3, [r3, r6]
  test_tokp = test_tokens_buffer;
 8007dae:	603a      	str	r2, [r7, #0]
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8007db0:	685b      	ldr	r3, [r3, #4]
 8007db2:	f853 8008 	ldr.w	r8, [r3, r8]
  if (tcp->setup != NULL)
 8007db6:	f8d8 3004 	ldr.w	r3, [r8, #4]
  test_local_fail = false;
 8007dba:	2200      	movs	r2, #0
 8007dbc:	f88a 2000 	strb.w	r2, [sl]
  if (tcp->setup != NULL)
 8007dc0:	b103      	cbz	r3, 8007dc4 <test_execute+0x1d4>
    tcp->setup();
 8007dc2:	4798      	blx	r3
  tcp->execute();
 8007dc4:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8007dc8:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8007dca:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8007dce:	b103      	cbz	r3, 8007dd2 <test_execute+0x1e2>
    tcp->teardown();
 8007dd0:	4798      	blx	r3
      if (test_local_fail) {
 8007dd2:	f89a 3000 	ldrb.w	r3, [sl]
 8007dd6:	2b00      	cmp	r3, #0
 8007dd8:	d044      	beq.n	8007e64 <test_execute+0x274>
 8007dda:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 8007ec8 <test_execute+0x2d8>
  while (*msgp)
 8007dde:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
 8007de0:	6820      	ldr	r0, [r4, #0]
 8007de2:	6803      	ldr	r3, [r0, #0]
 8007de4:	68db      	ldr	r3, [r3, #12]
 8007de6:	4798      	blx	r3
  while (*msgp)
 8007de8:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8007dec:	2900      	cmp	r1, #0
 8007dee:	d1f7      	bne.n	8007de0 <test_execute+0x1f0>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
 8007df0:	4b2f      	ldr	r3, [pc, #188]	; (8007eb0 <test_execute+0x2c0>)
 8007df2:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 8007ecc <test_execute+0x2dc>
 8007df6:	6818      	ldr	r0, [r3, #0]
 8007df8:	f7f8 fdea 	bl	80009d0 <test_printn>
  while (*msgp)
 8007dfc:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 8007dfe:	6820      	ldr	r0, [r4, #0]
 8007e00:	6803      	ldr	r3, [r0, #0]
 8007e02:	68db      	ldr	r3, [r3, #12]
 8007e04:	4798      	blx	r3
  while (*msgp)
 8007e06:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8007e0a:	2900      	cmp	r1, #0
 8007e0c:	d1f7      	bne.n	8007dfe <test_execute+0x20e>
  while (cp < test_tokp)
 8007e0e:	683b      	ldr	r3, [r7, #0]
 8007e10:	4a26      	ldr	r2, [pc, #152]	; (8007eac <test_execute+0x2bc>)
 8007e12:	4293      	cmp	r3, r2
 8007e14:	d909      	bls.n	8007e2a <test_execute+0x23a>
  char *cp = test_tokens_buffer;
 8007e16:	4690      	mov	r8, r2
    streamPut(test_chp, *cp++);
 8007e18:	6820      	ldr	r0, [r4, #0]
 8007e1a:	f818 1b01 	ldrb.w	r1, [r8], #1
 8007e1e:	6803      	ldr	r3, [r0, #0]
 8007e20:	68db      	ldr	r3, [r3, #12]
 8007e22:	4798      	blx	r3
  while (cp < test_tokp)
 8007e24:	683b      	ldr	r3, [r7, #0]
 8007e26:	4598      	cmp	r8, r3
 8007e28:	d3f6      	bcc.n	8007e18 <test_execute+0x228>
  while (*msgp)
 8007e2a:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8007ed0 <test_execute+0x2e0>
 8007e2e:	215d      	movs	r1, #93	; 0x5d
    streamPut(test_chp, *msgp++);
 8007e30:	6820      	ldr	r0, [r4, #0]
 8007e32:	6803      	ldr	r3, [r0, #0]
 8007e34:	68db      	ldr	r3, [r3, #12]
 8007e36:	4798      	blx	r3
  while (*msgp)
 8007e38:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8007e3c:	2900      	cmp	r1, #0
 8007e3e:	d1f7      	bne.n	8007e30 <test_execute+0x240>
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
 8007e40:	4b1c      	ldr	r3, [pc, #112]	; (8007eb4 <test_execute+0x2c4>)
 8007e42:	f8d3 8000 	ldr.w	r8, [r3]
  while (*msgp)
 8007e46:	f898 1000 	ldrb.w	r1, [r8]
 8007e4a:	b139      	cbz	r1, 8007e5c <test_execute+0x26c>
    streamPut(test_chp, *msgp++);
 8007e4c:	6820      	ldr	r0, [r4, #0]
 8007e4e:	6803      	ldr	r3, [r0, #0]
 8007e50:	68db      	ldr	r3, [r3, #12]
 8007e52:	4798      	blx	r3
  while (*msgp)
 8007e54:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8007e58:	2900      	cmp	r1, #0
 8007e5a:	d1f7      	bne.n	8007e4c <test_execute+0x25c>
        test_println("\")");
 8007e5c:	4816      	ldr	r0, [pc, #88]	; (8007eb8 <test_execute+0x2c8>)
 8007e5e:	f7f8 fdc7 	bl	80009f0 <test_println>
 8007e62:	e756      	b.n	8007d12 <test_execute+0x122>
      }
      else {
        test_println("--- Result: SUCCESS");
 8007e64:	4815      	ldr	r0, [pc, #84]	; (8007ebc <test_execute+0x2cc>)
 8007e66:	f7f8 fdc3 	bl	80009f0 <test_println>
 8007e6a:	e752      	b.n	8007d12 <test_execute+0x122>
 8007e6c:	20001a90 	.word	0x20001a90
 8007e70:	0800dcec 	.word	0x0800dcec
 8007e74:	0800e6d8 	.word	0x0800e6d8
 8007e78:	0800e784 	.word	0x0800e784
 8007e7c:	0800e6e0 	.word	0x0800e6e0
 8007e80:	0800e788 	.word	0x0800e788
 8007e84:	0800e6f4 	.word	0x0800e6f4
 8007e88:	0800c2b4 	.word	0x0800c2b4
 8007e8c:	0800e708 	.word	0x0800e708
 8007e90:	0800c2e4 	.word	0x0800c2e4
 8007e94:	20001b50 	.word	0x20001b50
 8007e98:	20001a98 	.word	0x20001a98
 8007e9c:	0800c488 	.word	0x0800c488
 8007ea0:	0800e71c 	.word	0x0800e71c
 8007ea4:	0800e730 	.word	0x0800e730
 8007ea8:	0800e7a0 	.word	0x0800e7a0
 8007eac:	20001b40 	.word	0x20001b40
 8007eb0:	20001b3c 	.word	0x20001b3c
 8007eb4:	20001a94 	.word	0x20001a94
 8007eb8:	0800e7a4 	.word	0x0800e7a4
 8007ebc:	0800e7a8 	.word	0x0800e7a8
 8007ec0:	0800e734 	.word	0x0800e734
 8007ec4:	20001b38 	.word	0x20001b38
 8007ec8:	0800e744 	.word	0x0800e744
 8007ecc:	0800e75c 	.word	0x0800e75c
 8007ed0:	0800e760 	.word	0x0800e760
      }
      tcase++;
    }
    tseq++;
  }
  print_line();
 8007ed4:	f7f8 fdec 	bl	8000ab0 <print_line>
  test_println("");
 8007ed8:	4d11      	ldr	r5, [pc, #68]	; (8007f20 <test_execute+0x330>)
 8007eda:	4812      	ldr	r0, [pc, #72]	; (8007f24 <test_execute+0x334>)
 8007edc:	f7f8 fd88 	bl	80009f0 <test_println>
  while (*msgp)
 8007ee0:	2146      	movs	r1, #70	; 0x46
    streamPut(test_chp, *msgp++);
 8007ee2:	6820      	ldr	r0, [r4, #0]
 8007ee4:	6803      	ldr	r3, [r0, #0]
 8007ee6:	68db      	ldr	r3, [r3, #12]
 8007ee8:	4798      	blx	r3
  while (*msgp)
 8007eea:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8007eee:	2900      	cmp	r1, #0
 8007ef0:	d1f7      	bne.n	8007ee2 <test_execute+0x2f2>
  test_print("Final result: ");
  if (test_global_fail)
 8007ef2:	4b0d      	ldr	r3, [pc, #52]	; (8007f28 <test_execute+0x338>)
 8007ef4:	781b      	ldrb	r3, [r3, #0]
 8007ef6:	b93b      	cbnz	r3, 8007f08 <test_execute+0x318>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8007ef8:	480c      	ldr	r0, [pc, #48]	; (8007f2c <test_execute+0x33c>)
 8007efa:	f7f8 fd79 	bl	80009f0 <test_println>
#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
}
 8007efe:	4b0a      	ldr	r3, [pc, #40]	; (8007f28 <test_execute+0x338>)
 8007f00:	7818      	ldrb	r0, [r3, #0]
 8007f02:	b003      	add	sp, #12
 8007f04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    test_println("FAILURE");
 8007f08:	4809      	ldr	r0, [pc, #36]	; (8007f30 <test_execute+0x340>)
 8007f0a:	f7f8 fd71 	bl	80009f0 <test_println>
}
 8007f0e:	4b06      	ldr	r3, [pc, #24]	; (8007f28 <test_execute+0x338>)
 8007f10:	7818      	ldrb	r0, [r3, #0]
 8007f12:	b003      	add	sp, #12
 8007f14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    test_println("*** Test Suite");
 8007f18:	4806      	ldr	r0, [pc, #24]	; (8007f34 <test_execute+0x344>)
 8007f1a:	f7f8 fd69 	bl	80009f0 <test_println>
 8007f1e:	e683      	b.n	8007c28 <test_execute+0x38>
 8007f20:	0800e764 	.word	0x0800e764
 8007f24:	0800dcec 	.word	0x0800dcec
 8007f28:	20001a98 	.word	0x20001a98
 8007f2c:	0800e7b4 	.word	0x0800e7b4
 8007f30:	0800e7bc 	.word	0x0800e7bc
 8007f34:	0800e774 	.word	0x0800e774
	...

08007f40 <test_rt>:
#endif

#if (SHELL_CMD_TEST_ENABLED == TRUE) || defined(__DOXYGEN__)
static THD_FUNCTION(test_rt, arg) {
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
  test_execute(chp, &rt_test_suite);
 8007f40:	4901      	ldr	r1, [pc, #4]	; (8007f48 <test_rt+0x8>)
 8007f42:	f7ff be55 	b.w	8007bf0 <test_execute>
 8007f46:	bf00      	nop
 8007f48:	0800dc44 	.word	0x0800dc44
 8007f4c:	00000000 	.word	0x00000000

08007f50 <test_oslib>:
}

static THD_FUNCTION(test_oslib, arg) {
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
  test_execute(chp, &oslib_test_suite);
 8007f50:	4901      	ldr	r1, [pc, #4]	; (8007f58 <test_oslib+0x8>)
 8007f52:	f7ff be4d 	b.w	8007bf0 <test_execute>
 8007f56:	bf00      	nop
 8007f58:	0800c8a4 	.word	0x0800c8a4
 8007f5c:	00000000 	.word	0x00000000

08007f60 <chThdSetPriority>:
  chDbgCheck(newprio <= HIGHPRIO);
 8007f60:	28ff      	cmp	r0, #255	; 0xff
tprio_t chThdSetPriority(tprio_t newprio) {
 8007f62:	b538      	push	{r3, r4, r5, lr}
  chDbgCheck(newprio <= HIGHPRIO);
 8007f64:	d81f      	bhi.n	8007fa6 <chThdSetPriority+0x46>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007f66:	2320      	movs	r3, #32
 8007f68:	f383 8811 	msr	BASEPRI, r3
  oldprio = currp->realprio;
 8007f6c:	4c12      	ldr	r4, [pc, #72]	; (8007fb8 <chThdSetPriority+0x58>)
  _dbg_check_lock();
 8007f6e:	f7fb fc27 	bl	80037c0 <_dbg_check_lock>
 8007f72:	69a3      	ldr	r3, [r4, #24]
 8007f74:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 8007f76:	689a      	ldr	r2, [r3, #8]
 8007f78:	42aa      	cmp	r2, r5
 8007f7a:	d001      	beq.n	8007f80 <chThdSetPriority+0x20>
 8007f7c:	4282      	cmp	r2, r0
 8007f7e:	d200      	bcs.n	8007f82 <chThdSetPriority+0x22>
    currp->prio = newprio;
 8007f80:	6098      	str	r0, [r3, #8]
  currp->realprio = newprio;
 8007f82:	63d8      	str	r0, [r3, #60]	; 0x3c
  chSchRescheduleS();
 8007f84:	f7fb fb9c 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8007f88:	f7fb fbb2 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007f8c:	6823      	ldr	r3, [r4, #0]
 8007f8e:	42a3      	cmp	r3, r4
 8007f90:	d004      	beq.n	8007f9c <chThdSetPriority+0x3c>
 8007f92:	69a2      	ldr	r2, [r4, #24]
 8007f94:	689b      	ldr	r3, [r3, #8]
 8007f96:	6892      	ldr	r2, [r2, #8]
 8007f98:	429a      	cmp	r2, r3
 8007f9a:	d309      	bcc.n	8007fb0 <chThdSetPriority+0x50>
 8007f9c:	2300      	movs	r3, #0
 8007f9e:	f383 8811 	msr	BASEPRI, r3
}
 8007fa2:	4628      	mov	r0, r5
 8007fa4:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8007fa6:	b672      	cpsid	i
 8007fa8:	4b03      	ldr	r3, [pc, #12]	; (8007fb8 <chThdSetPriority+0x58>)
 8007faa:	4a04      	ldr	r2, [pc, #16]	; (8007fbc <chThdSetPriority+0x5c>)
 8007fac:	62da      	str	r2, [r3, #44]	; 0x2c
 8007fae:	e7fe      	b.n	8007fae <chThdSetPriority+0x4e>
 8007fb0:	b672      	cpsid	i
 8007fb2:	4b03      	ldr	r3, [pc, #12]	; (8007fc0 <chThdSetPriority+0x60>)
 8007fb4:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007fb6:	e7fe      	b.n	8007fb6 <chThdSetPriority+0x56>
 8007fb8:	200011a0 	.word	0x200011a0
 8007fbc:	0800bf60 	.word	0x0800bf60
 8007fc0:	0800bbe4 	.word	0x0800bbe4
	...

08007fd0 <rt_test_003_004_execute>:
 * - [3.4.3] Raising thread priority above the boosted level.
 * - [3.4.4] Restoring original conditions.
 * .
 */

static void rt_test_003_004_execute(void) {
 8007fd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8007fd4:	4d38      	ldr	r5, [pc, #224]	; (80080b8 <rt_test_003_004_execute+0xe8>)
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8007fd6:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 80080d0 <rt_test_003_004_execute+0x100>
 8007fda:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 8007fdc:	689c      	ldr	r4, [r3, #8]
    chThdGetSelfX()->prio += 2;
 8007fde:	1ca6      	adds	r6, r4, #2
  {
    p1 = chThdSetPriority(prio + 1);
 8007fe0:	1c67      	adds	r7, r4, #1
    chThdGetSelfX()->prio += 2;
 8007fe2:	609e      	str	r6, [r3, #8]
    p1 = chThdSetPriority(prio + 1);
 8007fe4:	4638      	mov	r0, r7
  test_set_step(2);
 8007fe6:	2302      	movs	r3, #2
 8007fe8:	f8c8 3000 	str.w	r3, [r8]
    p1 = chThdSetPriority(prio + 1);
 8007fec:	f7ff ffb8 	bl	8007f60 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8007ff0:	1b00      	subs	r0, r0, r4
 8007ff2:	fab0 f080 	clz	r0, r0
 8007ff6:	4931      	ldr	r1, [pc, #196]	; (80080bc <rt_test_003_004_execute+0xec>)
 8007ff8:	0940      	lsrs	r0, r0, #5
 8007ffa:	f7f8 fc91 	bl	8000920 <_test_assert>
 8007ffe:	b108      	cbz	r0, 8008004 <rt_test_003_004_execute+0x34>
    chSysLock();
    chThdGetSelfX()->prio = prio;
    chThdGetSelfX()->realprio = prio;
    chSysUnlock();
  }
}
 8008000:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8008004:	69ab      	ldr	r3, [r5, #24]
 8008006:	492e      	ldr	r1, [pc, #184]	; (80080c0 <rt_test_003_004_execute+0xf0>)
 8008008:	6898      	ldr	r0, [r3, #8]
 800800a:	1b80      	subs	r0, r0, r6
 800800c:	fab0 f080 	clz	r0, r0
 8008010:	0940      	lsrs	r0, r0, #5
 8008012:	f7f8 fc85 	bl	8000920 <_test_assert>
 8008016:	2800      	cmp	r0, #0
 8008018:	d1f2      	bne.n	8008000 <rt_test_003_004_execute+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 800801a:	69ab      	ldr	r3, [r5, #24]
 800801c:	4929      	ldr	r1, [pc, #164]	; (80080c4 <rt_test_003_004_execute+0xf4>)
 800801e:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8008020:	1bc0      	subs	r0, r0, r7
 8008022:	fab0 f080 	clz	r0, r0
 8008026:	0940      	lsrs	r0, r0, #5
 8008028:	f7f8 fc7a 	bl	8000920 <_test_assert>
 800802c:	2800      	cmp	r0, #0
 800802e:	d1e7      	bne.n	8008000 <rt_test_003_004_execute+0x30>
    p1 = chThdSetPriority(prio + 3);
 8008030:	1ce6      	adds	r6, r4, #3
  test_set_step(3);
 8008032:	2303      	movs	r3, #3
    p1 = chThdSetPriority(prio + 3);
 8008034:	4630      	mov	r0, r6
  test_set_step(3);
 8008036:	f8c8 3000 	str.w	r3, [r8]
    p1 = chThdSetPriority(prio + 3);
 800803a:	f7ff ff91 	bl	8007f60 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 800803e:	1a38      	subs	r0, r7, r0
 8008040:	fab0 f080 	clz	r0, r0
 8008044:	491d      	ldr	r1, [pc, #116]	; (80080bc <rt_test_003_004_execute+0xec>)
 8008046:	0940      	lsrs	r0, r0, #5
 8008048:	f7f8 fc6a 	bl	8000920 <_test_assert>
 800804c:	2800      	cmp	r0, #0
 800804e:	d1d7      	bne.n	8008000 <rt_test_003_004_execute+0x30>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8008050:	69ab      	ldr	r3, [r5, #24]
 8008052:	491b      	ldr	r1, [pc, #108]	; (80080c0 <rt_test_003_004_execute+0xf0>)
 8008054:	6898      	ldr	r0, [r3, #8]
 8008056:	1b80      	subs	r0, r0, r6
 8008058:	fab0 f080 	clz	r0, r0
 800805c:	0940      	lsrs	r0, r0, #5
 800805e:	f7f8 fc5f 	bl	8000920 <_test_assert>
 8008062:	2800      	cmp	r0, #0
 8008064:	d1cc      	bne.n	8008000 <rt_test_003_004_execute+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8008066:	69ab      	ldr	r3, [r5, #24]
 8008068:	4917      	ldr	r1, [pc, #92]	; (80080c8 <rt_test_003_004_execute+0xf8>)
 800806a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 800806c:	1b80      	subs	r0, r0, r6
 800806e:	fab0 f080 	clz	r0, r0
 8008072:	0940      	lsrs	r0, r0, #5
 8008074:	f7f8 fc54 	bl	8000920 <_test_assert>
 8008078:	2800      	cmp	r0, #0
 800807a:	d1c1      	bne.n	8008000 <rt_test_003_004_execute+0x30>
  test_set_step(4);
 800807c:	2304      	movs	r3, #4
 800807e:	f8c8 3000 	str.w	r3, [r8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008082:	2320      	movs	r3, #32
 8008084:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008088:	f7fb fb9a 	bl	80037c0 <_dbg_check_lock>
  return ch.rlist.current;
 800808c:	69ab      	ldr	r3, [r5, #24]
    chThdGetSelfX()->prio = prio;
 800808e:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 8008090:	63dc      	str	r4, [r3, #60]	; 0x3c
  _dbg_check_unlock();
 8008092:	f7fb fb2d 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008096:	682b      	ldr	r3, [r5, #0]
 8008098:	42ab      	cmp	r3, r5
 800809a:	d004      	beq.n	80080a6 <rt_test_003_004_execute+0xd6>
 800809c:	69aa      	ldr	r2, [r5, #24]
 800809e:	689b      	ldr	r3, [r3, #8]
 80080a0:	6892      	ldr	r2, [r2, #8]
 80080a2:	429a      	cmp	r2, r3
 80080a4:	d303      	bcc.n	80080ae <rt_test_003_004_execute+0xde>
 80080a6:	2300      	movs	r3, #0
 80080a8:	f383 8811 	msr	BASEPRI, r3
 80080ac:	e7a8      	b.n	8008000 <rt_test_003_004_execute+0x30>
  __ASM volatile ("cpsid i" : : : "memory");
 80080ae:	b672      	cpsid	i
 80080b0:	4b06      	ldr	r3, [pc, #24]	; (80080cc <rt_test_003_004_execute+0xfc>)
 80080b2:	62eb      	str	r3, [r5, #44]	; 0x2c
 80080b4:	e7fe      	b.n	80080b4 <rt_test_003_004_execute+0xe4>
 80080b6:	bf00      	nop
 80080b8:	200011a0 	.word	0x200011a0
 80080bc:	0800d4d4 	.word	0x0800d4d4
 80080c0:	0800d4f8 	.word	0x0800d4f8
 80080c4:	0800d514 	.word	0x0800d514
 80080c8:	0800d53c 	.word	0x0800d53c
 80080cc:	0800bc80 	.word	0x0800bc80
 80080d0:	20001b3c 	.word	0x20001b3c
	...

080080e0 <rt_test_003_003_execute>:
static void rt_test_003_003_execute(void) {
 80080e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80080e4:	4e1c      	ldr	r6, [pc, #112]	; (8008158 <rt_test_003_003_execute+0x78>)
  test_set_step(1);
 80080e6:	4f1d      	ldr	r7, [pc, #116]	; (800815c <rt_test_003_003_execute+0x7c>)
  return chThdGetSelfX()->prio;
 80080e8:	69b3      	ldr	r3, [r6, #24]
 80080ea:	689c      	ldr	r4, [r3, #8]
    p1 = chThdSetPriority(prio + 1);
 80080ec:	1c65      	adds	r5, r4, #1
  test_set_step(1);
 80080ee:	2301      	movs	r3, #1
    p1 = chThdSetPriority(prio + 1);
 80080f0:	4628      	mov	r0, r5
  test_set_step(1);
 80080f2:	603b      	str	r3, [r7, #0]
    p1 = chThdSetPriority(prio + 1);
 80080f4:	f7ff ff34 	bl	8007f60 <chThdSetPriority>
 80080f8:	4680      	mov	r8, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 80080fa:	1b00      	subs	r0, r0, r4
 80080fc:	fab0 f080 	clz	r0, r0
 8008100:	0940      	lsrs	r0, r0, #5
 8008102:	4917      	ldr	r1, [pc, #92]	; (8008160 <rt_test_003_003_execute+0x80>)
 8008104:	f7f8 fc0c 	bl	8000920 <_test_assert>
 8008108:	b108      	cbz	r0, 800810e <rt_test_003_003_execute+0x2e>
}
 800810a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800810e:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 8008110:	4914      	ldr	r1, [pc, #80]	; (8008164 <rt_test_003_003_execute+0x84>)
 8008112:	6898      	ldr	r0, [r3, #8]
 8008114:	1b40      	subs	r0, r0, r5
 8008116:	fab0 f080 	clz	r0, r0
 800811a:	0940      	lsrs	r0, r0, #5
 800811c:	f7f8 fc00 	bl	8000920 <_test_assert>
 8008120:	2800      	cmp	r0, #0
 8008122:	d1f2      	bne.n	800810a <rt_test_003_003_execute+0x2a>
  test_set_step(2);
 8008124:	2302      	movs	r3, #2
    p1 = chThdSetPriority(p1);
 8008126:	4640      	mov	r0, r8
  test_set_step(2);
 8008128:	603b      	str	r3, [r7, #0]
    p1 = chThdSetPriority(p1);
 800812a:	f7ff ff19 	bl	8007f60 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 800812e:	1a28      	subs	r0, r5, r0
 8008130:	fab0 f080 	clz	r0, r0
 8008134:	490a      	ldr	r1, [pc, #40]	; (8008160 <rt_test_003_003_execute+0x80>)
 8008136:	0940      	lsrs	r0, r0, #5
 8008138:	f7f8 fbf2 	bl	8000920 <_test_assert>
 800813c:	2800      	cmp	r0, #0
 800813e:	d1e4      	bne.n	800810a <rt_test_003_003_execute+0x2a>
 8008140:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8008142:	4908      	ldr	r1, [pc, #32]	; (8008164 <rt_test_003_003_execute+0x84>)
 8008144:	6898      	ldr	r0, [r3, #8]
 8008146:	1b00      	subs	r0, r0, r4
 8008148:	fab0 f080 	clz	r0, r0
 800814c:	0940      	lsrs	r0, r0, #5
}
 800814e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8008152:	f7f8 bbe5 	b.w	8000920 <_test_assert>
 8008156:	bf00      	nop
 8008158:	200011a0 	.word	0x200011a0
 800815c:	20001b3c 	.word	0x20001b3c
 8008160:	0800d4d4 	.word	0x0800d4d4
 8008164:	0800d4f8 	.word	0x0800d4f8
	...

08008170 <chThdExit>:
void chThdExit(msg_t msg) {
 8008170:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008172:	2320      	movs	r3, #32
 8008174:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008178:	f7fb fb22 	bl	80037c0 <_dbg_check_lock>
  chThdExitS(msg);
 800817c:	f7fa ff78 	bl	8003070 <chThdExitS>

08008180 <bmk_thread3>:
static THD_FUNCTION(bmk_thread3, p) {
 8008180:	b508      	push	{r3, lr}
  chThdExit((msg_t)p);
 8008182:	f7ff fff5 	bl	8008170 <chThdExit>
 8008186:	bf00      	nop
	...

08008190 <chThdRelease>:
void chThdRelease(thread_t *tp) {
 8008190:	b508      	push	{r3, lr}
 8008192:	2320      	movs	r3, #32
 8008194:	f383 8811 	msr	BASEPRI, r3
 8008198:	f7fb fb12 	bl	80037c0 <_dbg_check_lock>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800819c:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 80081a0:	2b00      	cmp	r3, #0
 80081a2:	d037      	beq.n	8008214 <chThdRelease+0x84>
  tp->refs--;
 80081a4:	3b01      	subs	r3, #1
 80081a6:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80081aa:	6a03      	ldr	r3, [r0, #32]
 80081ac:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 80081b0:	2b0f      	cmp	r3, #15
 80081b2:	d00e      	beq.n	80081d2 <chThdRelease+0x42>
  _dbg_check_unlock();
 80081b4:	f7fb fa9c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80081b8:	4b1f      	ldr	r3, [pc, #124]	; (8008238 <chThdRelease+0xa8>)
 80081ba:	681a      	ldr	r2, [r3, #0]
 80081bc:	429a      	cmp	r2, r3
 80081be:	d004      	beq.n	80081ca <chThdRelease+0x3a>
 80081c0:	6999      	ldr	r1, [r3, #24]
 80081c2:	6892      	ldr	r2, [r2, #8]
 80081c4:	6889      	ldr	r1, [r1, #8]
 80081c6:	4291      	cmp	r1, r2
 80081c8:	d329      	bcc.n	800821e <chThdRelease+0x8e>
 80081ca:	2300      	movs	r3, #0
 80081cc:	f383 8811 	msr	BASEPRI, r3
}
 80081d0:	bd08      	pop	{r3, pc}
    REG_REMOVE(tp);
 80081d2:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
 80081d6:	611a      	str	r2, [r3, #16]
 80081d8:	6902      	ldr	r2, [r0, #16]
 80081da:	6153      	str	r3, [r2, #20]
  _dbg_check_unlock();
 80081dc:	f7fb fa88 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80081e0:	4b15      	ldr	r3, [pc, #84]	; (8008238 <chThdRelease+0xa8>)
 80081e2:	681a      	ldr	r2, [r3, #0]
 80081e4:	429a      	cmp	r2, r3
 80081e6:	d004      	beq.n	80081f2 <chThdRelease+0x62>
 80081e8:	6999      	ldr	r1, [r3, #24]
 80081ea:	6892      	ldr	r2, [r2, #8]
 80081ec:	6889      	ldr	r1, [r1, #8]
 80081ee:	4291      	cmp	r1, r2
 80081f0:	d31e      	bcc.n	8008230 <chThdRelease+0xa0>
 80081f2:	2300      	movs	r3, #0
 80081f4:	f383 8811 	msr	BASEPRI, r3
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80081f8:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 80081fc:	f003 0303 	and.w	r3, r3, #3
 8008200:	2b01      	cmp	r3, #1
 8008202:	d010      	beq.n	8008226 <chThdRelease+0x96>
 8008204:	2b02      	cmp	r3, #2
 8008206:	d1e3      	bne.n	80081d0 <chThdRelease+0x40>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8008208:	69c1      	ldr	r1, [r0, #28]
 800820a:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 800820c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8008210:	f7fd b95e 	b.w	80054d0 <chPoolFree>
  __ASM volatile ("cpsid i" : : : "memory");
 8008214:	b672      	cpsid	i
 8008216:	4b08      	ldr	r3, [pc, #32]	; (8008238 <chThdRelease+0xa8>)
 8008218:	4a08      	ldr	r2, [pc, #32]	; (800823c <chThdRelease+0xac>)
 800821a:	62da      	str	r2, [r3, #44]	; 0x2c
 800821c:	e7fe      	b.n	800821c <chThdRelease+0x8c>
 800821e:	b672      	cpsid	i
 8008220:	4a07      	ldr	r2, [pc, #28]	; (8008240 <chThdRelease+0xb0>)
 8008222:	62da      	str	r2, [r3, #44]	; 0x2c
 8008224:	e7fe      	b.n	8008224 <chThdRelease+0x94>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8008226:	69c0      	ldr	r0, [r0, #28]
}
 8008228:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      chHeapFree(chThdGetWorkingAreaX(tp));
 800822c:	f7fe bb58 	b.w	80068e0 <chHeapFree>
 8008230:	b672      	cpsid	i
 8008232:	4a03      	ldr	r2, [pc, #12]	; (8008240 <chThdRelease+0xb0>)
 8008234:	62da      	str	r2, [r3, #44]	; 0x2c
 8008236:	e7fe      	b.n	8008236 <chThdRelease+0xa6>
 8008238:	200011a0 	.word	0x200011a0
 800823c:	0800be9c 	.word	0x0800be9c
 8008240:	0800bbe4 	.word	0x0800bbe4
	...

08008250 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8008250:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008252:	2320      	movs	r3, #32
 8008254:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008258:	f7fb fab2 	bl	80037c0 <_dbg_check_lock>
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800825c:	4c12      	ldr	r4, [pc, #72]	; (80082a8 <chRegNextThread+0x58>)
  ntp = tp->newer;
 800825e:	6905      	ldr	r5, [r0, #16]
  if (ntp == (thread_t *)&ch.rlist) {
 8008260:	42a5      	cmp	r5, r4
 8008262:	d01f      	beq.n	80082a4 <chRegNextThread+0x54>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8008264:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 8008268:	2bff      	cmp	r3, #255	; 0xff
 800826a:	d013      	beq.n	8008294 <chRegNextThread+0x44>
    ntp->refs++;
 800826c:	3301      	adds	r3, #1
 800826e:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
  _dbg_check_unlock();
 8008272:	f7fb fa3d 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008276:	6823      	ldr	r3, [r4, #0]
 8008278:	42a3      	cmp	r3, r4
 800827a:	d004      	beq.n	8008286 <chRegNextThread+0x36>
 800827c:	69a2      	ldr	r2, [r4, #24]
 800827e:	689b      	ldr	r3, [r3, #8]
 8008280:	6892      	ldr	r2, [r2, #8]
 8008282:	429a      	cmp	r2, r3
 8008284:	d30a      	bcc.n	800829c <chRegNextThread+0x4c>
 8008286:	2300      	movs	r3, #0
 8008288:	f383 8811 	msr	BASEPRI, r3
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 800828c:	f7ff ff80 	bl	8008190 <chThdRelease>
#endif

  return ntp;
}
 8008290:	4628      	mov	r0, r5
 8008292:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8008294:	b672      	cpsid	i
 8008296:	4b05      	ldr	r3, [pc, #20]	; (80082ac <chRegNextThread+0x5c>)
 8008298:	62e3      	str	r3, [r4, #44]	; 0x2c
 800829a:	e7fe      	b.n	800829a <chRegNextThread+0x4a>
 800829c:	b672      	cpsid	i
 800829e:	4b04      	ldr	r3, [pc, #16]	; (80082b0 <chRegNextThread+0x60>)
 80082a0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80082a2:	e7fe      	b.n	80082a2 <chRegNextThread+0x52>
    ntp = NULL;
 80082a4:	2500      	movs	r5, #0
 80082a6:	e7e4      	b.n	8008272 <chRegNextThread+0x22>
 80082a8:	200011a0 	.word	0x200011a0
 80082ac:	0800bf9c 	.word	0x0800bf9c
 80082b0:	0800bd0c 	.word	0x0800bd0c
	...

080082c0 <cmd_threads>:
  if (argc > 0) {
 80082c0:	2900      	cmp	r1, #0
 80082c2:	dd03      	ble.n	80082cc <cmd_threads+0xc>
    shellUsage(chp, "threads");
 80082c4:	4a26      	ldr	r2, [pc, #152]	; (8008360 <cmd_threads+0xa0>)
 80082c6:	4927      	ldr	r1, [pc, #156]	; (8008364 <cmd_threads+0xa4>)
 80082c8:	f7fa bb62 	b.w	8002990 <chprintf>
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 80082cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
 80082d0:	4925      	ldr	r1, [pc, #148]	; (8008368 <cmd_threads+0xa8>)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 80082d2:	b087      	sub	sp, #28
 80082d4:	4605      	mov	r5, r0
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
 80082d6:	f7fa fb5b 	bl	8002990 <chprintf>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80082da:	2320      	movs	r3, #32
 80082dc:	f383 8811 	msr	BASEPRI, r3
  tp = ch.rlist.newer;
 80082e0:	4822      	ldr	r0, [pc, #136]	; (800836c <cmd_threads+0xac>)
  _dbg_check_lock();
 80082e2:	f7fb fa6d 	bl	80037c0 <_dbg_check_lock>
 80082e6:	6904      	ldr	r4, [r0, #16]
  tp->refs++;
 80082e8:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 80082ec:	3301      	adds	r3, #1
 80082ee:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  _dbg_check_unlock();
 80082f2:	f7fb f9fd 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80082f6:	6803      	ldr	r3, [r0, #0]
 80082f8:	4283      	cmp	r3, r0
 80082fa:	d004      	beq.n	8008306 <cmd_threads+0x46>
 80082fc:	6982      	ldr	r2, [r0, #24]
 80082fe:	689b      	ldr	r3, [r3, #8]
 8008300:	6892      	ldr	r2, [r2, #8]
 8008302:	429a      	cmp	r2, r3
 8008304:	d327      	bcc.n	8008356 <cmd_threads+0x96>
 8008306:	2300      	movs	r3, #0
 8008308:	f383 8811 	msr	BASEPRI, r3
 800830c:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8008378 <cmd_threads+0xb8>
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8008310:	4f17      	ldr	r7, [pc, #92]	; (8008370 <cmd_threads+0xb0>)
 8008312:	f8df 9068 	ldr.w	r9, [pc, #104]	; 800837c <cmd_threads+0xbc>
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8008316:	f894 c020 	ldrb.w	ip, [r4, #32]
 800831a:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 800831e:	f858 c02c 	ldr.w	ip, [r8, ip, lsl #2]
 8008322:	68a6      	ldr	r6, [r4, #8]
 8008324:	68e3      	ldr	r3, [r4, #12]
    uint32_t stklimit = (uint32_t)tp->wabase;
 8008326:	e9d4 1206 	ldrd	r1, r2, [r4, #24]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 800832a:	3801      	subs	r0, #1
 800832c:	2900      	cmp	r1, #0
 800832e:	bf08      	it	eq
 8008330:	4639      	moveq	r1, r7
 8008332:	e9cd c103 	strd	ip, r1, [sp, #12]
 8008336:	9001      	str	r0, [sp, #4]
 8008338:	9400      	str	r4, [sp, #0]
 800833a:	4649      	mov	r1, r9
 800833c:	9602      	str	r6, [sp, #8]
 800833e:	4628      	mov	r0, r5
 8008340:	f7fa fb26 	bl	8002990 <chprintf>
    tp = chRegNextThread(tp);
 8008344:	4620      	mov	r0, r4
 8008346:	f7ff ff83 	bl	8008250 <chRegNextThread>
  } while (tp != NULL);
 800834a:	4604      	mov	r4, r0
 800834c:	2800      	cmp	r0, #0
 800834e:	d1e2      	bne.n	8008316 <cmd_threads+0x56>
}
 8008350:	b007      	add	sp, #28
 8008352:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8008356:	b672      	cpsid	i
 8008358:	4b06      	ldr	r3, [pc, #24]	; (8008374 <cmd_threads+0xb4>)
 800835a:	62c3      	str	r3, [r0, #44]	; 0x2c
 800835c:	e7fe      	b.n	800835c <cmd_threads+0x9c>
 800835e:	bf00      	nop
 8008360:	0800e348 	.word	0x0800e348
 8008364:	0800c234 	.word	0x0800c234
 8008368:	0800c404 	.word	0x0800c404
 800836c:	200011a0 	.word	0x200011a0
 8008370:	0800dcec 	.word	0x0800dcec
 8008374:	0800bd0c 	.word	0x0800bd0c
 8008378:	0800dd38 	.word	0x0800dd38
 800837c:	0800c444 	.word	0x0800c444

08008380 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8008380:	b538      	push	{r3, r4, r5, lr}
 8008382:	4605      	mov	r5, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008384:	2320      	movs	r3, #32
 8008386:	f383 8811 	msr	BASEPRI, r3
  tp = ch.rlist.newer;
 800838a:	4812      	ldr	r0, [pc, #72]	; (80083d4 <chRegFindThreadByWorkingArea+0x54>)
  _dbg_check_lock();
 800838c:	f7fb fa18 	bl	80037c0 <_dbg_check_lock>
 8008390:	6904      	ldr	r4, [r0, #16]
  tp->refs++;
 8008392:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8008396:	3301      	adds	r3, #1
 8008398:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  _dbg_check_unlock();
 800839c:	f7fb f9a8 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80083a0:	6803      	ldr	r3, [r0, #0]
 80083a2:	4283      	cmp	r3, r0
 80083a4:	d004      	beq.n	80083b0 <chRegFindThreadByWorkingArea+0x30>
 80083a6:	6982      	ldr	r2, [r0, #24]
 80083a8:	689b      	ldr	r3, [r3, #8]
 80083aa:	6892      	ldr	r2, [r2, #8]
 80083ac:	429a      	cmp	r2, r3
 80083ae:	d30d      	bcc.n	80083cc <chRegFindThreadByWorkingArea+0x4c>
 80083b0:	2300      	movs	r3, #0
 80083b2:	f383 8811 	msr	BASEPRI, r3
 80083b6:	e003      	b.n	80083c0 <chRegFindThreadByWorkingArea+0x40>
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
 80083b8:	f7ff ff4a 	bl	8008250 <chRegNextThread>
  } while (ctp != NULL);
 80083bc:	4604      	mov	r4, r0
 80083be:	b118      	cbz	r0, 80083c8 <chRegFindThreadByWorkingArea+0x48>
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80083c0:	69e3      	ldr	r3, [r4, #28]
 80083c2:	429d      	cmp	r5, r3
    ctp = chRegNextThread(ctp);
 80083c4:	4620      	mov	r0, r4
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80083c6:	d1f7      	bne.n	80083b8 <chRegFindThreadByWorkingArea+0x38>

  return NULL;
}
 80083c8:	4620      	mov	r0, r4
 80083ca:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80083cc:	b672      	cpsid	i
 80083ce:	4b02      	ldr	r3, [pc, #8]	; (80083d8 <chRegFindThreadByWorkingArea+0x58>)
 80083d0:	62c3      	str	r3, [r0, #44]	; 0x2c
 80083d2:	e7fe      	b.n	80083d2 <chRegFindThreadByWorkingArea+0x52>
 80083d4:	200011a0 	.word	0x200011a0
 80083d8:	0800bd0c 	.word	0x0800bd0c
 80083dc:	00000000 	.word	0x00000000

080083e0 <chThdCreateStatic.constprop.60>:
  chDbgCheck((wsp != NULL) &&
 80083e0:	2800      	cmp	r0, #0
 80083e2:	d066      	beq.n	80084b2 <chThdCreateStatic.constprop.60+0xd2>
thread_t *chThdCreateStatic(void *wsp, size_t size,
 80083e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  chDbgCheck((wsp != NULL) &&
 80083e8:	0745      	lsls	r5, r0, #29
 80083ea:	4604      	mov	r4, r0
 80083ec:	d10d      	bne.n	800840a <chThdCreateStatic.constprop.60+0x2a>
 80083ee:	29ff      	cmp	r1, #255	; 0xff
 80083f0:	d80b      	bhi.n	800840a <chThdCreateStatic.constprop.60+0x2a>
 80083f2:	460d      	mov	r5, r1
 80083f4:	461f      	mov	r7, r3
 80083f6:	4616      	mov	r6, r2
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 80083f8:	f7ff ffc2 	bl	8008380 <chRegFindThreadByWorkingArea>
 80083fc:	4601      	mov	r1, r0
 80083fe:	b148      	cbz	r0, 8008414 <chThdCreateStatic.constprop.60+0x34>
 8008400:	b672      	cpsid	i
 8008402:	4b31      	ldr	r3, [pc, #196]	; (80084c8 <chThdCreateStatic.constprop.60+0xe8>)
 8008404:	4a31      	ldr	r2, [pc, #196]	; (80084cc <chThdCreateStatic.constprop.60+0xec>)
 8008406:	62da      	str	r2, [r3, #44]	; 0x2c
 8008408:	e7fe      	b.n	8008408 <chThdCreateStatic.constprop.60+0x28>
 800840a:	b672      	cpsid	i
 800840c:	4b2e      	ldr	r3, [pc, #184]	; (80084c8 <chThdCreateStatic.constprop.60+0xe8>)
 800840e:	4a2f      	ldr	r2, [pc, #188]	; (80084cc <chThdCreateStatic.constprop.60+0xec>)
 8008410:	62da      	str	r2, [r3, #44]	; 0x2c
 8008412:	e7fe      	b.n	8008412 <chThdCreateStatic.constprop.60+0x32>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008414:	2320      	movs	r3, #32
 8008416:	f383 8811 	msr	BASEPRI, r3
  REG_INSERT(tp);
 800841a:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 80084c8 <chThdCreateStatic.constprop.60+0xe8>
  _dbg_check_lock();
 800841e:	f7fb f9cf 	bl	80037c0 <_dbg_check_lock>
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8008422:	f104 00dc 	add.w	r0, r4, #220	; 0xdc
 8008426:	4b2a      	ldr	r3, [pc, #168]	; (80084d0 <chThdCreateStatic.constprop.60+0xf0>)
  REG_INSERT(tp);
 8008428:	f8d8 2014 	ldr.w	r2, [r8, #20]
  tp->prio      = prio;
 800842c:	f8c4 5108 	str.w	r5, [r4, #264]	; 0x108
  tp->realprio  = prio;
 8008430:	f8c4 513c 	str.w	r5, [r4, #316]	; 0x13c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8008434:	f8c4 010c 	str.w	r0, [r4, #268]	; 0x10c
 8008438:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
  tp->state     = CH_STATE_WTSTART;
 800843c:	2502      	movs	r5, #2
  tp->flags     = CH_FLAG_MODE_STATIC;
 800843e:	2001      	movs	r0, #1
  tp->name      = name;
 8008440:	4b24      	ldr	r3, [pc, #144]	; (80084d4 <chThdCreateStatic.constprop.60+0xf4>)
  tp->state     = CH_STATE_WTSTART;
 8008442:	f8a4 5120 	strh.w	r5, [r4, #288]	; 0x120
  tp->flags     = CH_FLAG_MODE_STATIC;
 8008446:	f884 0122 	strb.w	r0, [r4, #290]	; 0x122
  tp = (thread_t *)((uint8_t *)wsp + size -
 800844a:	f504 7580 	add.w	r5, r4, #256	; 0x100
  tp->name      = name;
 800844e:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
  list_init(&tp->waiting);
 8008452:	f504 7094 	add.w	r0, r4, #296	; 0x128
  queue_init(&tp->msgqueue);
 8008456:	f504 7396 	add.w	r3, r4, #300	; 0x12c
  tp->mtxlist   = NULL;
 800845a:	f8c4 1138 	str.w	r1, [r4, #312]	; 0x138
  tp->epending  = (eventmask_t)0;
 800845e:	f8c4 1134 	str.w	r1, [r4, #308]	; 0x134
  REG_INSERT(tp);
 8008462:	f8c4 2114 	str.w	r2, [r4, #276]	; 0x114
  tp->wabase = (stkalign_t *)wsp;
 8008466:	f8c4 411c 	str.w	r4, [r4, #284]	; 0x11c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800846a:	f8c4 60dc 	str.w	r6, [r4, #220]	; 0xdc
 800846e:	f8c4 70e0 	str.w	r7, [r4, #224]	; 0xe0
  REG_INSERT(tp);
 8008472:	f8c4 8110 	str.w	r8, [r4, #272]	; 0x110
 8008476:	6115      	str	r5, [r2, #16]
  tqp->next = (thread_t *)tqp;
 8008478:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
 800847c:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130
  tlp->next = (thread_t *)tlp;
 8008480:	f8c4 0128 	str.w	r0, [r4, #296]	; 0x128
  chSchWakeupS(tp, MSG_OK);
 8008484:	4628      	mov	r0, r5
  REG_INSERT(tp);
 8008486:	f8c8 5014 	str.w	r5, [r8, #20]
  chSchWakeupS(tp, MSG_OK);
 800848a:	f7fa fd29 	bl	8002ee0 <chSchWakeupS>
  _dbg_check_unlock();
 800848e:	f7fb f92f 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008492:	f8d8 3000 	ldr.w	r3, [r8]
 8008496:	4543      	cmp	r3, r8
 8008498:	d005      	beq.n	80084a6 <chThdCreateStatic.constprop.60+0xc6>
 800849a:	f8d8 2018 	ldr.w	r2, [r8, #24]
 800849e:	689b      	ldr	r3, [r3, #8]
 80084a0:	6892      	ldr	r2, [r2, #8]
 80084a2:	429a      	cmp	r2, r3
 80084a4:	d30a      	bcc.n	80084bc <chThdCreateStatic.constprop.60+0xdc>
 80084a6:	2300      	movs	r3, #0
 80084a8:	f383 8811 	msr	BASEPRI, r3
}
 80084ac:	4628      	mov	r0, r5
 80084ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80084b2:	b672      	cpsid	i
 80084b4:	4b04      	ldr	r3, [pc, #16]	; (80084c8 <chThdCreateStatic.constprop.60+0xe8>)
 80084b6:	4a05      	ldr	r2, [pc, #20]	; (80084cc <chThdCreateStatic.constprop.60+0xec>)
 80084b8:	62da      	str	r2, [r3, #44]	; 0x2c
 80084ba:	e7fe      	b.n	80084ba <chThdCreateStatic.constprop.60+0xda>
 80084bc:	b672      	cpsid	i
 80084be:	4b06      	ldr	r3, [pc, #24]	; (80084d8 <chThdCreateStatic.constprop.60+0xf8>)
 80084c0:	f8c8 302c 	str.w	r3, [r8, #44]	; 0x2c
 80084c4:	e7fe      	b.n	80084c4 <chThdCreateStatic.constprop.60+0xe4>
 80084c6:	bf00      	nop
 80084c8:	200011a0 	.word	0x200011a0
 80084cc:	0800be1c 	.word	0x0800be1c
 80084d0:	08000291 	.word	0x08000291
 80084d4:	0800c1fc 	.word	0x0800c1fc
 80084d8:	0800bbe4 	.word	0x0800bbe4
 80084dc:	00000000 	.word	0x00000000

080084e0 <rt_test_010_006_execute>:
static void rt_test_010_006_execute(void) {
 80084e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 80084e4:	4b17      	ldr	r3, [pc, #92]	; (8008544 <rt_test_010_006_execute+0x64>)
  test_set_step(1);
 80084e6:	f8df 906c 	ldr.w	r9, [pc, #108]	; 8008554 <rt_test_010_006_execute+0x74>
  return chThdGetSelfX()->prio;
 80084ea:	699b      	ldr	r3, [r3, #24]
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80084ec:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8008558 <rt_test_010_006_execute+0x78>
  tprio_t prio = chThdGetPriorityX() + 1;
 80084f0:	689d      	ldr	r5, [r3, #8]
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80084f2:	4f15      	ldr	r7, [pc, #84]	; (8008548 <rt_test_010_006_execute+0x68>)
  test_set_step(1);
 80084f4:	2301      	movs	r3, #1
  tprio_t prio = chThdGetPriorityX() + 1;
 80084f6:	441d      	add	r5, r3
  test_set_step(1);
 80084f8:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 80084fc:	f7ff fa38 	bl	8007970 <test_wait_tick>
    n = 0;
 8008500:	2400      	movs	r4, #0
    start = test_wait_tick();
 8008502:	4606      	mov	r6, r0
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8008504:	2300      	movs	r3, #0
 8008506:	4642      	mov	r2, r8
 8008508:	4629      	mov	r1, r5
 800850a:	4638      	mov	r0, r7
 800850c:	f7ff ff68 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8008510:	f7ff fe3e 	bl	8008190 <chThdRelease>
 8008514:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 8008518:	f242 720f 	movw	r2, #9999	; 0x270f
 800851c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800851e:	1b9b      	subs	r3, r3, r6
 8008520:	4293      	cmp	r3, r2
      n++;
 8008522:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8008526:	d9ed      	bls.n	8008504 <rt_test_010_006_execute+0x24>
  test_set_step(2);
 8008528:	2302      	movs	r3, #2
    test_print("--- Score : ");
 800852a:	4808      	ldr	r0, [pc, #32]	; (800854c <rt_test_010_006_execute+0x6c>)
  test_set_step(2);
 800852c:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8008530:	f7f8 fa7e 	bl	8000a30 <test_print>
    test_printn(n);
 8008534:	4620      	mov	r0, r4
 8008536:	f7f8 fa4b 	bl	80009d0 <test_printn>
    test_println(" threads/S");
 800853a:	4805      	ldr	r0, [pc, #20]	; (8008550 <rt_test_010_006_execute+0x70>)
}
 800853c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" threads/S");
 8008540:	f7f8 ba56 	b.w	80009f0 <test_println>
 8008544:	200011a0 	.word	0x200011a0
 8008548:	20001428 	.word	0x20001428
 800854c:	0800da4c 	.word	0x0800da4c
 8008550:	0800d9b4 	.word	0x0800d9b4
 8008554:	20001b3c 	.word	0x20001b3c
 8008558:	08008181 	.word	0x08008181
 800855c:	00000000 	.word	0x00000000

08008560 <rt_test_006_004_execute>:
static void rt_test_006_004_execute(void) {
 8008560:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 8008564:	4d40      	ldr	r5, [pc, #256]	; (8008668 <rt_test_006_004_execute+0x108>)
  test_set_step(2);
 8008566:	4e41      	ldr	r6, [pc, #260]	; (800866c <rt_test_006_004_execute+0x10c>)
  return chThdGetSelfX()->prio;
 8008568:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800856a:	4b41      	ldr	r3, [pc, #260]	; (8008670 <rt_test_006_004_execute+0x110>)
 800856c:	6894      	ldr	r4, [r2, #8]
 800856e:	4841      	ldr	r0, [pc, #260]	; (8008674 <rt_test_006_004_execute+0x114>)
 8008570:	4a41      	ldr	r2, [pc, #260]	; (8008678 <rt_test_006_004_execute+0x118>)
 8008572:	4f42      	ldr	r7, [pc, #264]	; (800867c <rt_test_006_004_execute+0x11c>)
    pa = p + 1;
 8008574:	f104 0801 	add.w	r8, r4, #1
  test_set_step(2);
 8008578:	f04f 0c02 	mov.w	ip, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800857c:	4641      	mov	r1, r8
  test_set_step(2);
 800857e:	f8c6 c000 	str.w	ip, [r6]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8008582:	f7ff ff2d 	bl	80083e0 <chThdCreateStatic.constprop.60>
    pb = p + 2;
 8008586:	f104 0902 	add.w	r9, r4, #2
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800858a:	4649      	mov	r1, r9
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800858c:	6038      	str	r0, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800858e:	4b3c      	ldr	r3, [pc, #240]	; (8008680 <rt_test_006_004_execute+0x120>)
 8008590:	4a3c      	ldr	r2, [pc, #240]	; (8008684 <rt_test_006_004_execute+0x124>)
 8008592:	483d      	ldr	r0, [pc, #244]	; (8008688 <rt_test_006_004_execute+0x128>)
 8008594:	f7ff ff24 	bl	80083e0 <chThdCreateStatic.constprop.60>
  test_set_step(3);
 8008598:	2303      	movs	r3, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800859a:	6078      	str	r0, [r7, #4]
    chMtxLock(&m1);
 800859c:	483b      	ldr	r0, [pc, #236]	; (800868c <rt_test_006_004_execute+0x12c>)
  test_set_step(3);
 800859e:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
 80085a0:	f7fd fc76 	bl	8005e90 <chMtxLock>
 80085a4:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80085a6:	493a      	ldr	r1, [pc, #232]	; (8008690 <rt_test_006_004_execute+0x130>)
 80085a8:	6898      	ldr	r0, [r3, #8]
 80085aa:	1b00      	subs	r0, r0, r4
 80085ac:	fab0 f080 	clz	r0, r0
 80085b0:	0940      	lsrs	r0, r0, #5
 80085b2:	f7f8 f9b5 	bl	8000920 <_test_assert>
 80085b6:	b108      	cbz	r0, 80085bc <rt_test_006_004_execute+0x5c>
}
 80085b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  test_set_step(4);
 80085bc:	2304      	movs	r3, #4
    chThdSleepMilliseconds(100);
 80085be:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(4);
 80085c2:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
 80085c4:	f7ff f834 	bl	8007630 <chThdSleep>
 80085c8:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80085ca:	4931      	ldr	r1, [pc, #196]	; (8008690 <rt_test_006_004_execute+0x130>)
 80085cc:	6898      	ldr	r0, [r3, #8]
 80085ce:	eba0 0008 	sub.w	r0, r0, r8
 80085d2:	fab0 f080 	clz	r0, r0
 80085d6:	0940      	lsrs	r0, r0, #5
 80085d8:	f7f8 f9a2 	bl	8000920 <_test_assert>
 80085dc:	2800      	cmp	r0, #0
 80085de:	d1eb      	bne.n	80085b8 <rt_test_006_004_execute+0x58>
  test_set_step(5);
 80085e0:	2305      	movs	r3, #5
    chMtxLock(&m2);
 80085e2:	482c      	ldr	r0, [pc, #176]	; (8008694 <rt_test_006_004_execute+0x134>)
  test_set_step(5);
 80085e4:	6033      	str	r3, [r6, #0]
    chMtxLock(&m2);
 80085e6:	f7fd fc53 	bl	8005e90 <chMtxLock>
 80085ea:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80085ec:	4928      	ldr	r1, [pc, #160]	; (8008690 <rt_test_006_004_execute+0x130>)
 80085ee:	6898      	ldr	r0, [r3, #8]
 80085f0:	eba0 0008 	sub.w	r0, r0, r8
 80085f4:	fab0 f080 	clz	r0, r0
 80085f8:	0940      	lsrs	r0, r0, #5
 80085fa:	f7f8 f991 	bl	8000920 <_test_assert>
 80085fe:	2800      	cmp	r0, #0
 8008600:	d1da      	bne.n	80085b8 <rt_test_006_004_execute+0x58>
  test_set_step(6);
 8008602:	2306      	movs	r3, #6
    chThdSleepMilliseconds(100);
 8008604:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(6);
 8008608:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
 800860a:	f7ff f811 	bl	8007630 <chThdSleep>
 800860e:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8008610:	491f      	ldr	r1, [pc, #124]	; (8008690 <rt_test_006_004_execute+0x130>)
 8008612:	6898      	ldr	r0, [r3, #8]
 8008614:	eba0 0009 	sub.w	r0, r0, r9
 8008618:	fab0 f080 	clz	r0, r0
 800861c:	0940      	lsrs	r0, r0, #5
 800861e:	f7f8 f97f 	bl	8000920 <_test_assert>
 8008622:	2800      	cmp	r0, #0
 8008624:	d1c8      	bne.n	80085b8 <rt_test_006_004_execute+0x58>
  test_set_step(7);
 8008626:	2307      	movs	r3, #7
    chMtxUnlock(&m2);
 8008628:	481a      	ldr	r0, [pc, #104]	; (8008694 <rt_test_006_004_execute+0x134>)
  test_set_step(7);
 800862a:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m2);
 800862c:	f7fd fb08 	bl	8005c40 <chMtxUnlock>
 8008630:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8008632:	4917      	ldr	r1, [pc, #92]	; (8008690 <rt_test_006_004_execute+0x130>)
 8008634:	6898      	ldr	r0, [r3, #8]
 8008636:	eba0 0008 	sub.w	r0, r0, r8
 800863a:	fab0 f080 	clz	r0, r0
 800863e:	0940      	lsrs	r0, r0, #5
 8008640:	f7f8 f96e 	bl	8000920 <_test_assert>
 8008644:	2800      	cmp	r0, #0
 8008646:	d1b7      	bne.n	80085b8 <rt_test_006_004_execute+0x58>
  test_set_step(8);
 8008648:	2308      	movs	r3, #8
    chMtxUnlock(&m1);
 800864a:	4810      	ldr	r0, [pc, #64]	; (800868c <rt_test_006_004_execute+0x12c>)
  test_set_step(8);
 800864c:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
 800864e:	f7fd faf7 	bl	8005c40 <chMtxUnlock>
 8008652:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8008654:	490e      	ldr	r1, [pc, #56]	; (8008690 <rt_test_006_004_execute+0x130>)
 8008656:	6898      	ldr	r0, [r3, #8]
 8008658:	1b00      	subs	r0, r0, r4
 800865a:	fab0 f080 	clz	r0, r0
 800865e:	0940      	lsrs	r0, r0, #5
}
 8008660:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8008664:	f7f8 b95c 	b.w	8000920 <_test_assert>
 8008668:	200011a0 	.word	0x200011a0
 800866c:	20001b3c 	.word	0x20001b3c
 8008670:	0800d688 	.word	0x0800d688
 8008674:	20001428 	.word	0x20001428
 8008678:	080077c1 	.word	0x080077c1
 800867c:	20001b54 	.word	0x20001b54
 8008680:	0800d68c 	.word	0x0800d68c
 8008684:	080077e1 	.word	0x080077e1
 8008688:	20001570 	.word	0x20001570
 800868c:	20000c38 	.word	0x20000c38
 8008690:	0800d6d8 	.word	0x0800d6d8
 8008694:	20000c48 	.word	0x20000c48
	...

080086a0 <rt_test_005_006_execute>:

static void rt_test_005_006_teardown(void) {
  test_wait_threads();
}

static void rt_test_005_006_execute(void) {
 80086a0:	b5f0      	push	{r4, r5, r6, r7, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 80086a2:	4e94      	ldr	r6, [pc, #592]	; (80088f4 <rt_test_005_006_execute+0x254>)
static void rt_test_005_006_execute(void) {
 80086a4:	b085      	sub	sp, #20
  test_set_step(1);
 80086a6:	2201      	movs	r2, #1
  tqp->next = (thread_t *)tqp;
 80086a8:	ad01      	add	r5, sp, #4
  sp->cnt = n;
 80086aa:	2300      	movs	r3, #0
 80086ac:	9303      	str	r3, [sp, #12]
 80086ae:	6032      	str	r2, [r6, #0]
  tqp->prev = (thread_t *)tqp;
 80086b0:	e9cd 5501 	strd	r5, r5, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80086b4:	2320      	movs	r3, #32
 80086b6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80086ba:	f7fb f881 	bl	80037c0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 80086be:	f7f8 fa8f 	bl	8000be0 <chDbgCheckClassI>

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 80086c2:	9803      	ldr	r0, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80086c4:	498c      	ldr	r1, [pc, #560]	; (80088f8 <rt_test_005_006_execute+0x258>)
 80086c6:	2800      	cmp	r0, #0
 80086c8:	bfcc      	ite	gt
 80086ca:	2000      	movgt	r0, #0
 80086cc:	2001      	movle	r0, #1
 80086ce:	f7f8 f927 	bl	8000920 <_test_assert>
 80086d2:	b178      	cbz	r0, 80086f4 <rt_test_005_006_execute+0x54>
  _dbg_check_unlock();
 80086d4:	f7fb f80c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80086d8:	4b88      	ldr	r3, [pc, #544]	; (80088fc <rt_test_005_006_execute+0x25c>)
 80086da:	681a      	ldr	r2, [r3, #0]
 80086dc:	429a      	cmp	r2, r3
 80086de:	d004      	beq.n	80086ea <rt_test_005_006_execute+0x4a>
 80086e0:	6999      	ldr	r1, [r3, #24]
 80086e2:	6892      	ldr	r2, [r2, #8]
 80086e4:	6889      	ldr	r1, [r1, #8]
 80086e6:	4291      	cmp	r1, r2
 80086e8:	d378      	bcc.n	80087dc <rt_test_005_006_execute+0x13c>
 80086ea:	2300      	movs	r3, #0
 80086ec:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 80086f0:	b005      	add	sp, #20
 80086f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80086f4:	4c81      	ldr	r4, [pc, #516]	; (80088fc <rt_test_005_006_execute+0x25c>)
  _dbg_check_unlock();
 80086f6:	f7fa fffb 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80086fa:	6823      	ldr	r3, [r4, #0]
 80086fc:	42a3      	cmp	r3, r4
 80086fe:	d004      	beq.n	800870a <rt_test_005_006_execute+0x6a>
 8008700:	69a2      	ldr	r2, [r4, #24]
 8008702:	689b      	ldr	r3, [r3, #8]
 8008704:	6892      	ldr	r2, [r2, #8]
 8008706:	429a      	cmp	r2, r3
 8008708:	d364      	bcc.n	80087d4 <rt_test_005_006_execute+0x134>
 800870a:	2100      	movs	r1, #0
 800870c:	f381 8811 	msr	BASEPRI, r1
  test_set_step(2);
 8008710:	2302      	movs	r3, #2
  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8008712:	4628      	mov	r0, r5
 8008714:	6033      	str	r3, [r6, #0]
 8008716:	f7fe fe33 	bl	8007380 <chSemReset>
 800871a:	2320      	movs	r3, #32
 800871c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008720:	f7fb f84e 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8008724:	f7f8 fa5c 	bl	8000be0 <chDbgCheckClassI>
  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8008728:	9803      	ldr	r0, [sp, #12]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 800872a:	4973      	ldr	r1, [pc, #460]	; (80088f8 <rt_test_005_006_execute+0x258>)
 800872c:	2800      	cmp	r0, #0
 800872e:	bfcc      	ite	gt
 8008730:	2000      	movgt	r0, #0
 8008732:	2001      	movle	r0, #1
 8008734:	f7f8 f8f4 	bl	8000920 <_test_assert>
 8008738:	2800      	cmp	r0, #0
 800873a:	d13d      	bne.n	80087b8 <rt_test_005_006_execute+0x118>
  _dbg_check_unlock();
 800873c:	f7fa ffd8 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008740:	6823      	ldr	r3, [r4, #0]
 8008742:	42a3      	cmp	r3, r4
 8008744:	d004      	beq.n	8008750 <rt_test_005_006_execute+0xb0>
 8008746:	69a2      	ldr	r2, [r4, #24]
 8008748:	689b      	ldr	r3, [r3, #8]
 800874a:	6892      	ldr	r2, [r2, #8]
 800874c:	429a      	cmp	r2, r3
 800874e:	d349      	bcc.n	80087e4 <rt_test_005_006_execute+0x144>
 8008750:	2300      	movs	r3, #0
 8008752:	f383 8811 	msr	BASEPRI, r3
 8008756:	69a3      	ldr	r3, [r4, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8008758:	4a69      	ldr	r2, [pc, #420]	; (8008900 <rt_test_005_006_execute+0x260>)
 800875a:	6899      	ldr	r1, [r3, #8]
 800875c:	4869      	ldr	r0, [pc, #420]	; (8008904 <rt_test_005_006_execute+0x264>)
 800875e:	3901      	subs	r1, #1
 8008760:	462b      	mov	r3, r5
  test_set_step(3);
 8008762:	2703      	movs	r7, #3
 8008764:	6037      	str	r7, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8008766:	f7ff fe3b 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800876a:	4a67      	ldr	r2, [pc, #412]	; (8008908 <rt_test_005_006_execute+0x268>)
  test_set_step(4);
 800876c:	2304      	movs	r3, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800876e:	6010      	str	r0, [r2, #0]
  return chSemWait(&bsp->sem);
 8008770:	4628      	mov	r0, r5
  test_set_step(4);
 8008772:	6033      	str	r3, [r6, #0]
 8008774:	f7fe fd84 	bl	8007280 <chSemWait>
 8008778:	2320      	movs	r3, #32
 800877a:	4607      	mov	r7, r0
 800877c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008780:	f7fb f81e 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8008784:	f7f8 fa2c 	bl	8000be0 <chDbgCheckClassI>
  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8008788:	9803      	ldr	r0, [sp, #12]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 800878a:	495b      	ldr	r1, [pc, #364]	; (80088f8 <rt_test_005_006_execute+0x258>)
 800878c:	2800      	cmp	r0, #0
 800878e:	bfcc      	ite	gt
 8008790:	2000      	movgt	r0, #0
 8008792:	2001      	movle	r0, #1
 8008794:	f7f8 f8c4 	bl	8000920 <_test_assert>
 8008798:	2800      	cmp	r0, #0
 800879a:	d027      	beq.n	80087ec <rt_test_005_006_execute+0x14c>
  _dbg_check_unlock();
 800879c:	f7fa ffa8 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80087a0:	6823      	ldr	r3, [r4, #0]
 80087a2:	42a3      	cmp	r3, r4
 80087a4:	d0a1      	beq.n	80086ea <rt_test_005_006_execute+0x4a>
 80087a6:	69a2      	ldr	r2, [r4, #24]
 80087a8:	689b      	ldr	r3, [r3, #8]
 80087aa:	6892      	ldr	r2, [r2, #8]
 80087ac:	429a      	cmp	r2, r3
 80087ae:	d29c      	bcs.n	80086ea <rt_test_005_006_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
 80087b0:	b672      	cpsid	i
 80087b2:	4b56      	ldr	r3, [pc, #344]	; (800890c <rt_test_005_006_execute+0x26c>)
 80087b4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80087b6:	e7fe      	b.n	80087b6 <rt_test_005_006_execute+0x116>
  _dbg_check_unlock();
 80087b8:	f7fa ff9a 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80087bc:	6823      	ldr	r3, [r4, #0]
 80087be:	42a3      	cmp	r3, r4
 80087c0:	d093      	beq.n	80086ea <rt_test_005_006_execute+0x4a>
 80087c2:	69a2      	ldr	r2, [r4, #24]
 80087c4:	689b      	ldr	r3, [r3, #8]
 80087c6:	6892      	ldr	r2, [r2, #8]
 80087c8:	429a      	cmp	r2, r3
 80087ca:	d28e      	bcs.n	80086ea <rt_test_005_006_execute+0x4a>
 80087cc:	b672      	cpsid	i
 80087ce:	4b4f      	ldr	r3, [pc, #316]	; (800890c <rt_test_005_006_execute+0x26c>)
 80087d0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80087d2:	e7fe      	b.n	80087d2 <rt_test_005_006_execute+0x132>
 80087d4:	b672      	cpsid	i
 80087d6:	4b4d      	ldr	r3, [pc, #308]	; (800890c <rt_test_005_006_execute+0x26c>)
 80087d8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80087da:	e7fe      	b.n	80087da <rt_test_005_006_execute+0x13a>
 80087dc:	b672      	cpsid	i
 80087de:	4a4b      	ldr	r2, [pc, #300]	; (800890c <rt_test_005_006_execute+0x26c>)
 80087e0:	62da      	str	r2, [r3, #44]	; 0x2c
 80087e2:	e7fe      	b.n	80087e2 <rt_test_005_006_execute+0x142>
 80087e4:	b672      	cpsid	i
 80087e6:	4b49      	ldr	r3, [pc, #292]	; (800890c <rt_test_005_006_execute+0x26c>)
 80087e8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80087ea:	e7fe      	b.n	80087ea <rt_test_005_006_execute+0x14a>
  _dbg_check_unlock();
 80087ec:	f7fa ff80 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80087f0:	6823      	ldr	r3, [r4, #0]
 80087f2:	42a3      	cmp	r3, r4
 80087f4:	d005      	beq.n	8008802 <rt_test_005_006_execute+0x162>
 80087f6:	69a2      	ldr	r2, [r4, #24]
 80087f8:	689b      	ldr	r3, [r3, #8]
 80087fa:	6892      	ldr	r2, [r2, #8]
 80087fc:	429a      	cmp	r2, r3
 80087fe:	f0c0 8115 	bcc.w	8008a2c <rt_test_005_006_execute+0x38c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008802:	2300      	movs	r3, #0
 8008804:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg == MSG_OK, "unexpected message");
 8008808:	fab7 f087 	clz	r0, r7
 800880c:	0940      	lsrs	r0, r0, #5
 800880e:	4940      	ldr	r1, [pc, #256]	; (8008910 <rt_test_005_006_execute+0x270>)
 8008810:	f7f8 f886 	bl	8000920 <_test_assert>
 8008814:	2800      	cmp	r0, #0
 8008816:	f47f af6b 	bne.w	80086f0 <rt_test_005_006_execute+0x50>
  test_set_step(5);
 800881a:	2305      	movs	r3, #5
 800881c:	6033      	str	r3, [r6, #0]
 800881e:	2320      	movs	r3, #32
 8008820:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008824:	f7fa ffcc 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8008828:	f7f8 f9da 	bl	8000be0 <chDbgCheckClassI>
  if (bsp->sem.cnt < (cnt_t)1) {
 800882c:	9b03      	ldr	r3, [sp, #12]
 800882e:	2b00      	cmp	r3, #0
 8008830:	dc02      	bgt.n	8008838 <rt_test_005_006_execute+0x198>
    chSemSignalI(&bsp->sem);
 8008832:	4628      	mov	r0, r5
 8008834:	f7f8 fbcc 	bl	8000fd0 <chSemSignalI>
  chSchRescheduleS();
 8008838:	f7fa ff42 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 800883c:	f7fa ff58 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008840:	6823      	ldr	r3, [r4, #0]
 8008842:	42a3      	cmp	r3, r4
 8008844:	d005      	beq.n	8008852 <rt_test_005_006_execute+0x1b2>
 8008846:	69a2      	ldr	r2, [r4, #24]
 8008848:	689b      	ldr	r3, [r3, #8]
 800884a:	6892      	ldr	r2, [r2, #8]
 800884c:	429a      	cmp	r2, r3
 800884e:	f0c0 80f1 	bcc.w	8008a34 <rt_test_005_006_execute+0x394>
 8008852:	2300      	movs	r3, #0
 8008854:	f383 8811 	msr	BASEPRI, r3
 8008858:	2320      	movs	r3, #32
 800885a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800885e:	f7fa ffaf 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8008862:	f7f8 f9bd 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 8008866:	9803      	ldr	r0, [sp, #12]
 8008868:	492a      	ldr	r1, [pc, #168]	; (8008914 <rt_test_005_006_execute+0x274>)
 800886a:	2800      	cmp	r0, #0
 800886c:	bfd4      	ite	le
 800886e:	2000      	movle	r0, #0
 8008870:	2001      	movgt	r0, #1
 8008872:	f7f8 f855 	bl	8000920 <_test_assert>
 8008876:	b178      	cbz	r0, 8008898 <rt_test_005_006_execute+0x1f8>
  _dbg_check_unlock();
 8008878:	f7fa ff3a 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800887c:	6823      	ldr	r3, [r4, #0]
 800887e:	42a3      	cmp	r3, r4
 8008880:	f43f af33 	beq.w	80086ea <rt_test_005_006_execute+0x4a>
 8008884:	69a2      	ldr	r2, [r4, #24]
 8008886:	689b      	ldr	r3, [r3, #8]
 8008888:	6892      	ldr	r2, [r2, #8]
 800888a:	429a      	cmp	r2, r3
 800888c:	f4bf af2d 	bcs.w	80086ea <rt_test_005_006_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
 8008890:	b672      	cpsid	i
 8008892:	4b1e      	ldr	r3, [pc, #120]	; (800890c <rt_test_005_006_execute+0x26c>)
 8008894:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008896:	e7fe      	b.n	8008896 <rt_test_005_006_execute+0x1f6>
  _dbg_check_unlock();
 8008898:	f7fa ff2a 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800889c:	6823      	ldr	r3, [r4, #0]
 800889e:	42a3      	cmp	r3, r4
 80088a0:	d005      	beq.n	80088ae <rt_test_005_006_execute+0x20e>
 80088a2:	69a2      	ldr	r2, [r4, #24]
 80088a4:	689b      	ldr	r3, [r3, #8]
 80088a6:	6892      	ldr	r2, [r2, #8]
 80088a8:	429a      	cmp	r2, r3
 80088aa:	f0c0 80c7 	bcc.w	8008a3c <rt_test_005_006_execute+0x39c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80088ae:	2300      	movs	r3, #0
 80088b0:	f383 8811 	msr	BASEPRI, r3
 80088b4:	2320      	movs	r3, #32
 80088b6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80088ba:	f7fa ff81 	bl	80037c0 <_dbg_check_lock>
 80088be:	f7f8 f98f 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 80088c2:	9803      	ldr	r0, [sp, #12]
 80088c4:	4914      	ldr	r1, [pc, #80]	; (8008918 <rt_test_005_006_execute+0x278>)
 80088c6:	1e42      	subs	r2, r0, #1
 80088c8:	4250      	negs	r0, r2
 80088ca:	4150      	adcs	r0, r2
 80088cc:	f7f8 f828 	bl	8000920 <_test_assert>
 80088d0:	b320      	cbz	r0, 800891c <rt_test_005_006_execute+0x27c>
  _dbg_check_unlock();
 80088d2:	f7fa ff0d 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80088d6:	6823      	ldr	r3, [r4, #0]
 80088d8:	42a3      	cmp	r3, r4
 80088da:	f43f af06 	beq.w	80086ea <rt_test_005_006_execute+0x4a>
 80088de:	69a2      	ldr	r2, [r4, #24]
 80088e0:	689b      	ldr	r3, [r3, #8]
 80088e2:	6892      	ldr	r2, [r2, #8]
 80088e4:	429a      	cmp	r2, r3
 80088e6:	f4bf af00 	bcs.w	80086ea <rt_test_005_006_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
 80088ea:	b672      	cpsid	i
 80088ec:	4b07      	ldr	r3, [pc, #28]	; (800890c <rt_test_005_006_execute+0x26c>)
 80088ee:	62e3      	str	r3, [r4, #44]	; 0x2c
 80088f0:	e7fe      	b.n	80088f0 <rt_test_005_006_execute+0x250>
 80088f2:	bf00      	nop
 80088f4:	20001b3c 	.word	0x20001b3c
 80088f8:	0800d628 	.word	0x0800d628
 80088fc:	200011a0 	.word	0x200011a0
 8008900:	080042f1 	.word	0x080042f1
 8008904:	20001428 	.word	0x20001428
 8008908:	20001b54 	.word	0x20001b54
 800890c:	0800bc98 	.word	0x0800bc98
 8008910:	0800d634 	.word	0x0800d634
 8008914:	0800d648 	.word	0x0800d648
 8008918:	0800d654 	.word	0x0800d654
  _dbg_check_unlock();
 800891c:	f7fa fee8 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008920:	6823      	ldr	r3, [r4, #0]
 8008922:	42a3      	cmp	r3, r4
 8008924:	d005      	beq.n	8008932 <rt_test_005_006_execute+0x292>
 8008926:	69a2      	ldr	r2, [r4, #24]
 8008928:	689b      	ldr	r3, [r3, #8]
 800892a:	6892      	ldr	r2, [r2, #8]
 800892c:	429a      	cmp	r2, r3
 800892e:	f0c0 8089 	bcc.w	8008a44 <rt_test_005_006_execute+0x3a4>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008932:	2300      	movs	r3, #0
 8008934:	f383 8811 	msr	BASEPRI, r3
  test_set_step(6);
 8008938:	2306      	movs	r3, #6
 800893a:	6033      	str	r3, [r6, #0]
 800893c:	2320      	movs	r3, #32
 800893e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008942:	f7fa ff3d 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8008946:	f7f8 f94b 	bl	8000be0 <chDbgCheckClassI>
  if (bsp->sem.cnt < (cnt_t)1) {
 800894a:	9b03      	ldr	r3, [sp, #12]
 800894c:	2b00      	cmp	r3, #0
 800894e:	dc02      	bgt.n	8008956 <rt_test_005_006_execute+0x2b6>
    chSemSignalI(&bsp->sem);
 8008950:	4628      	mov	r0, r5
 8008952:	f7f8 fb3d 	bl	8000fd0 <chSemSignalI>
  chSchRescheduleS();
 8008956:	f7fa feb3 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 800895a:	f7fa fec9 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800895e:	6823      	ldr	r3, [r4, #0]
 8008960:	42a3      	cmp	r3, r4
 8008962:	d004      	beq.n	800896e <rt_test_005_006_execute+0x2ce>
 8008964:	69a2      	ldr	r2, [r4, #24]
 8008966:	689b      	ldr	r3, [r3, #8]
 8008968:	6892      	ldr	r2, [r2, #8]
 800896a:	429a      	cmp	r2, r3
 800896c:	d36e      	bcc.n	8008a4c <rt_test_005_006_execute+0x3ac>
 800896e:	2300      	movs	r3, #0
 8008970:	f383 8811 	msr	BASEPRI, r3
 8008974:	2320      	movs	r3, #32
 8008976:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800897a:	f7fa ff21 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 800897e:	f7f8 f92f 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8008982:	9803      	ldr	r0, [sp, #12]
 8008984:	4935      	ldr	r1, [pc, #212]	; (8008a5c <rt_test_005_006_execute+0x3bc>)
 8008986:	2800      	cmp	r0, #0
 8008988:	bfd4      	ite	le
 800898a:	2000      	movle	r0, #0
 800898c:	2001      	movgt	r0, #1
 800898e:	f7f7 ffc7 	bl	8000920 <_test_assert>
 8008992:	b178      	cbz	r0, 80089b4 <rt_test_005_006_execute+0x314>
  _dbg_check_unlock();
 8008994:	f7fa feac 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008998:	6823      	ldr	r3, [r4, #0]
 800899a:	42a3      	cmp	r3, r4
 800899c:	f43f aea5 	beq.w	80086ea <rt_test_005_006_execute+0x4a>
 80089a0:	69a2      	ldr	r2, [r4, #24]
 80089a2:	689b      	ldr	r3, [r3, #8]
 80089a4:	6892      	ldr	r2, [r2, #8]
 80089a6:	429a      	cmp	r2, r3
 80089a8:	f4bf ae9f 	bcs.w	80086ea <rt_test_005_006_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
 80089ac:	b672      	cpsid	i
 80089ae:	4b2c      	ldr	r3, [pc, #176]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 80089b0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80089b2:	e7fe      	b.n	80089b2 <rt_test_005_006_execute+0x312>
  _dbg_check_unlock();
 80089b4:	f7fa fe9c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80089b8:	6823      	ldr	r3, [r4, #0]
 80089ba:	42a3      	cmp	r3, r4
 80089bc:	d004      	beq.n	80089c8 <rt_test_005_006_execute+0x328>
 80089be:	69a2      	ldr	r2, [r4, #24]
 80089c0:	689b      	ldr	r3, [r3, #8]
 80089c2:	6892      	ldr	r2, [r2, #8]
 80089c4:	429a      	cmp	r2, r3
 80089c6:	d345      	bcc.n	8008a54 <rt_test_005_006_execute+0x3b4>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80089c8:	2300      	movs	r3, #0
 80089ca:	f383 8811 	msr	BASEPRI, r3
 80089ce:	2320      	movs	r3, #32
 80089d0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80089d4:	f7fa fef4 	bl	80037c0 <_dbg_check_lock>
 80089d8:	f7f8 f902 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 80089dc:	9803      	ldr	r0, [sp, #12]
 80089de:	4921      	ldr	r1, [pc, #132]	; (8008a64 <rt_test_005_006_execute+0x3c4>)
 80089e0:	1e43      	subs	r3, r0, #1
 80089e2:	4258      	negs	r0, r3
 80089e4:	4158      	adcs	r0, r3
 80089e6:	f7f7 ff9b 	bl	8000920 <_test_assert>
 80089ea:	b178      	cbz	r0, 8008a0c <rt_test_005_006_execute+0x36c>
  _dbg_check_unlock();
 80089ec:	f7fa fe80 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80089f0:	6823      	ldr	r3, [r4, #0]
 80089f2:	42a3      	cmp	r3, r4
 80089f4:	f43f ae79 	beq.w	80086ea <rt_test_005_006_execute+0x4a>
 80089f8:	69a2      	ldr	r2, [r4, #24]
 80089fa:	689b      	ldr	r3, [r3, #8]
 80089fc:	6892      	ldr	r2, [r2, #8]
 80089fe:	429a      	cmp	r2, r3
 8008a00:	f4bf ae73 	bcs.w	80086ea <rt_test_005_006_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
 8008a04:	b672      	cpsid	i
 8008a06:	4b16      	ldr	r3, [pc, #88]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 8008a08:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008a0a:	e7fe      	b.n	8008a0a <rt_test_005_006_execute+0x36a>
  _dbg_check_unlock();
 8008a0c:	f7fa fe70 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008a10:	6823      	ldr	r3, [r4, #0]
 8008a12:	42a3      	cmp	r3, r4
 8008a14:	f43f ae69 	beq.w	80086ea <rt_test_005_006_execute+0x4a>
 8008a18:	69a2      	ldr	r2, [r4, #24]
 8008a1a:	689b      	ldr	r3, [r3, #8]
 8008a1c:	6892      	ldr	r2, [r2, #8]
 8008a1e:	429a      	cmp	r2, r3
 8008a20:	f4bf ae63 	bcs.w	80086ea <rt_test_005_006_execute+0x4a>
 8008a24:	b672      	cpsid	i
 8008a26:	4b0e      	ldr	r3, [pc, #56]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 8008a28:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008a2a:	e7fe      	b.n	8008a2a <rt_test_005_006_execute+0x38a>
 8008a2c:	b672      	cpsid	i
 8008a2e:	4b0c      	ldr	r3, [pc, #48]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 8008a30:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008a32:	e7fe      	b.n	8008a32 <rt_test_005_006_execute+0x392>
 8008a34:	b672      	cpsid	i
 8008a36:	4b0a      	ldr	r3, [pc, #40]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 8008a38:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008a3a:	e7fe      	b.n	8008a3a <rt_test_005_006_execute+0x39a>
 8008a3c:	b672      	cpsid	i
 8008a3e:	4b08      	ldr	r3, [pc, #32]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 8008a40:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008a42:	e7fe      	b.n	8008a42 <rt_test_005_006_execute+0x3a2>
 8008a44:	b672      	cpsid	i
 8008a46:	4b06      	ldr	r3, [pc, #24]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 8008a48:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008a4a:	e7fe      	b.n	8008a4a <rt_test_005_006_execute+0x3aa>
 8008a4c:	b672      	cpsid	i
 8008a4e:	4b04      	ldr	r3, [pc, #16]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 8008a50:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008a52:	e7fe      	b.n	8008a52 <rt_test_005_006_execute+0x3b2>
 8008a54:	b672      	cpsid	i
 8008a56:	4b02      	ldr	r3, [pc, #8]	; (8008a60 <rt_test_005_006_execute+0x3c0>)
 8008a58:	62e3      	str	r3, [r4, #44]	; 0x2c
 8008a5a:	e7fe      	b.n	8008a5a <rt_test_005_006_execute+0x3ba>
 8008a5c:	0800d62c 	.word	0x0800d62c
 8008a60:	0800bc98 	.word	0x0800bc98
 8008a64:	0800d654 	.word	0x0800d654
	...

08008a70 <rt_test_005_005_execute>:
static void rt_test_005_005_execute(void) {
 8008a70:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 8008a72:	4b1e      	ldr	r3, [pc, #120]	; (8008aec <rt_test_005_005_execute+0x7c>)
  test_set_step(1);
 8008a74:	4d1e      	ldr	r5, [pc, #120]	; (8008af0 <rt_test_005_005_execute+0x80>)
  return chThdGetSelfX()->prio;
 8008a76:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8008a78:	4a1e      	ldr	r2, [pc, #120]	; (8008af4 <rt_test_005_005_execute+0x84>)
 8008a7a:	6899      	ldr	r1, [r3, #8]
 8008a7c:	481e      	ldr	r0, [pc, #120]	; (8008af8 <rt_test_005_005_execute+0x88>)
  return (bool)(tqp->next == (const thread_t *)tqp);
 8008a7e:	4c1f      	ldr	r4, [pc, #124]	; (8008afc <rt_test_005_005_execute+0x8c>)
  test_set_step(1);
 8008a80:	2301      	movs	r3, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8008a82:	3101      	adds	r1, #1
  test_set_step(1);
 8008a84:	602b      	str	r3, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8008a86:	2300      	movs	r3, #0
 8008a88:	f7ff fcaa 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8008a8c:	4a1c      	ldr	r2, [pc, #112]	; (8008b00 <rt_test_005_005_execute+0x90>)
  test_set_step(2);
 8008a8e:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8008a90:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 8008a92:	602b      	str	r3, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
 8008a94:	f7fa fea4 	bl	80037e0 <chSemSignalWait.constprop.55>
 8008a98:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8008a9a:	491a      	ldr	r1, [pc, #104]	; (8008b04 <rt_test_005_005_execute+0x94>)
 8008a9c:	1b00      	subs	r0, r0, r4
 8008a9e:	fab0 f080 	clz	r0, r0
 8008aa2:	0940      	lsrs	r0, r0, #5
 8008aa4:	f7f7 ff3c 	bl	8000920 <_test_assert>
 8008aa8:	b100      	cbz	r0, 8008aac <rt_test_005_005_execute+0x3c>
}
 8008aaa:	bd38      	pop	{r3, r4, r5, pc}
    test_assert(sem1.cnt == 0, "counter not zero");
 8008aac:	68a0      	ldr	r0, [r4, #8]
 8008aae:	4916      	ldr	r1, [pc, #88]	; (8008b08 <rt_test_005_005_execute+0x98>)
 8008ab0:	fab0 f080 	clz	r0, r0
 8008ab4:	0940      	lsrs	r0, r0, #5
 8008ab6:	f7f7 ff33 	bl	8000920 <_test_assert>
 8008aba:	2800      	cmp	r0, #0
 8008abc:	d1f5      	bne.n	8008aaa <rt_test_005_005_execute+0x3a>
  test_set_step(3);
 8008abe:	2303      	movs	r3, #3
 8008ac0:	602b      	str	r3, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
 8008ac2:	f7fa fe8d 	bl	80037e0 <chSemSignalWait.constprop.55>
 8008ac6:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8008ac8:	490e      	ldr	r1, [pc, #56]	; (8008b04 <rt_test_005_005_execute+0x94>)
 8008aca:	1b00      	subs	r0, r0, r4
 8008acc:	fab0 f080 	clz	r0, r0
 8008ad0:	0940      	lsrs	r0, r0, #5
 8008ad2:	f7f7 ff25 	bl	8000920 <_test_assert>
 8008ad6:	2800      	cmp	r0, #0
 8008ad8:	d1e7      	bne.n	8008aaa <rt_test_005_005_execute+0x3a>
    test_assert(sem1.cnt == 0, "counter not zero");
 8008ada:	68a0      	ldr	r0, [r4, #8]
 8008adc:	490a      	ldr	r1, [pc, #40]	; (8008b08 <rt_test_005_005_execute+0x98>)
 8008ade:	fab0 f080 	clz	r0, r0
 8008ae2:	0940      	lsrs	r0, r0, #5
}
 8008ae4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert(sem1.cnt == 0, "counter not zero");
 8008ae8:	f7f7 bf1a 	b.w	8000920 <_test_assert>
 8008aec:	200011a0 	.word	0x200011a0
 8008af0:	20001b3c 	.word	0x20001b3c
 8008af4:	08007341 	.word	0x08007341
 8008af8:	20001428 	.word	0x20001428
 8008afc:	20001408 	.word	0x20001408
 8008b00:	20001b54 	.word	0x20001b54
 8008b04:	0800d6c8 	.word	0x0800d6c8
 8008b08:	0800d604 	.word	0x0800d604
 8008b0c:	00000000 	.word	0x00000000

08008b10 <chThdWait>:
  chDbgCheck(tp != NULL);
 8008b10:	2800      	cmp	r0, #0
 8008b12:	d036      	beq.n	8008b82 <chThdWait+0x72>
msg_t chThdWait(thread_t *tp) {
 8008b14:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008b16:	2320      	movs	r3, #32
 8008b18:	4604      	mov	r4, r0
 8008b1a:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp != currp, "waiting self");
 8008b1e:	4d1b      	ldr	r5, [pc, #108]	; (8008b8c <chThdWait+0x7c>)
  _dbg_check_lock();
 8008b20:	f7fa fe4e 	bl	80037c0 <_dbg_check_lock>
 8008b24:	69ab      	ldr	r3, [r5, #24]
 8008b26:	4283      	cmp	r3, r0
 8008b28:	d027      	beq.n	8008b7a <chThdWait+0x6a>
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
 8008b2a:	f890 2022 	ldrb.w	r2, [r0, #34]	; 0x22
 8008b2e:	b302      	cbz	r2, 8008b72 <chThdWait+0x62>
  if (tp->state != CH_STATE_FINAL) {
 8008b30:	f890 2020 	ldrb.w	r2, [r0, #32]
 8008b34:	2a0f      	cmp	r2, #15
 8008b36:	d005      	beq.n	8008b44 <chThdWait+0x34>
  tp->queue.next = tlp->next;
 8008b38:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8008b3a:	601a      	str	r2, [r3, #0]
    chSchGoSleepS(CH_STATE_WTEXIT);
 8008b3c:	2009      	movs	r0, #9
  tlp->next = tp;
 8008b3e:	62a3      	str	r3, [r4, #40]	; 0x28
 8008b40:	f7fa f9fe 	bl	8002f40 <chSchGoSleepS>
  msg = tp->u.exitcode;
 8008b44:	6a66      	ldr	r6, [r4, #36]	; 0x24
  _dbg_check_unlock();
 8008b46:	f7fa fdd3 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008b4a:	682b      	ldr	r3, [r5, #0]
 8008b4c:	42ab      	cmp	r3, r5
 8008b4e:	d008      	beq.n	8008b62 <chThdWait+0x52>
 8008b50:	69aa      	ldr	r2, [r5, #24]
 8008b52:	689b      	ldr	r3, [r3, #8]
 8008b54:	6892      	ldr	r2, [r2, #8]
 8008b56:	429a      	cmp	r2, r3
 8008b58:	d203      	bcs.n	8008b62 <chThdWait+0x52>
  __ASM volatile ("cpsid i" : : : "memory");
 8008b5a:	b672      	cpsid	i
 8008b5c:	4b0c      	ldr	r3, [pc, #48]	; (8008b90 <chThdWait+0x80>)
 8008b5e:	62eb      	str	r3, [r5, #44]	; 0x2c
 8008b60:	e7fe      	b.n	8008b60 <chThdWait+0x50>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008b62:	2300      	movs	r3, #0
 8008b64:	f383 8811 	msr	BASEPRI, r3
  chThdRelease(tp);
 8008b68:	4620      	mov	r0, r4
 8008b6a:	f7ff fb11 	bl	8008190 <chThdRelease>
}
 8008b6e:	4630      	mov	r0, r6
 8008b70:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8008b72:	b672      	cpsid	i
 8008b74:	4b07      	ldr	r3, [pc, #28]	; (8008b94 <chThdWait+0x84>)
 8008b76:	62eb      	str	r3, [r5, #44]	; 0x2c
 8008b78:	e7fe      	b.n	8008b78 <chThdWait+0x68>
 8008b7a:	b672      	cpsid	i
 8008b7c:	4b05      	ldr	r3, [pc, #20]	; (8008b94 <chThdWait+0x84>)
 8008b7e:	62eb      	str	r3, [r5, #44]	; 0x2c
 8008b80:	e7fe      	b.n	8008b80 <chThdWait+0x70>
 8008b82:	b672      	cpsid	i
 8008b84:	4b01      	ldr	r3, [pc, #4]	; (8008b8c <chThdWait+0x7c>)
 8008b86:	4a03      	ldr	r2, [pc, #12]	; (8008b94 <chThdWait+0x84>)
 8008b88:	62da      	str	r2, [r3, #44]	; 0x2c
 8008b8a:	e7fe      	b.n	8008b8a <chThdWait+0x7a>
 8008b8c:	200011a0 	.word	0x200011a0
 8008b90:	0800bbe4 	.word	0x0800bbe4
 8008b94:	0800bf44 	.word	0x0800bf44
	...

08008ba0 <main>:
void hal_lld_init(void) {

  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~0);
 8008ba0:	4baa      	ldr	r3, [pc, #680]	; (8008e4c <main+0x2ac>)
 8008ba2:	2200      	movs	r2, #0
 8008ba4:	f04f 31ff 	mov.w	r1, #4294967295
 8008ba8:	6a98      	ldr	r0, [r3, #40]	; 0x28
}

/*
 * Application entry point.
 */
int main(void) {
 8008baa:	b580      	push	{r7, lr}
 8008bac:	6299      	str	r1, [r3, #40]	; 0x28
 8008bae:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 8008bb0:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8008bb2:	f060 00ff 	orn	r0, r0, #255	; 0xff
 8008bb6:	62d8      	str	r0, [r3, #44]	; 0x2c
 8008bb8:	62da      	str	r2, [r3, #44]	; 0x2c
  rccResetAHB3(~0);
 8008bba:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8008bbc:	6319      	str	r1, [r3, #48]	; 0x30
 8008bbe:	631a      	str	r2, [r3, #48]	; 0x30
  rccResetAPB1R1(~RCC_APB1RSTR1_PWRRST);
 8008bc0:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8008bc2:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8008bc6:	6398      	str	r0, [r3, #56]	; 0x38
 8008bc8:	639a      	str	r2, [r3, #56]	; 0x38
  rccResetAPB1R2(~0);
 8008bca:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8008bcc:	63d9      	str	r1, [r3, #60]	; 0x3c
 8008bce:	63da      	str	r2, [r3, #60]	; 0x3c
  rccResetAPB2(~0);
 8008bd0:	6c18      	ldr	r0, [r3, #64]	; 0x40
 8008bd2:	6419      	str	r1, [r3, #64]	; 0x40
 8008bd4:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8008bd6:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8008bd8:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8008bdc:	6599      	str	r1, [r3, #88]	; 0x58
 8008bde:	6f99      	ldr	r1, [r3, #120]	; 0x78
 8008be0:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8008be4:	6799      	str	r1, [r3, #120]	; 0x78
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8008be6:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
 8008bea:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8008bee:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8008bf2:	b088      	sub	sp, #32
 8008bf4:	d005      	beq.n	8008c02 <main+0x62>
    RCC->BDCR = RCC_BDCR_BDRST;
 8008bf6:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8008bfa:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
    RCC->BDCR = 0;
 8008bfe:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 8008c02:	4b92      	ldr	r3, [pc, #584]	; (8008e4c <main+0x2ac>)
 8008c04:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008c08:	f042 0219 	orr.w	r2, r2, #25
 8008c0c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 8008c10:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008c14:	0792      	lsls	r2, r2, #30
 8008c16:	d5fb      	bpl.n	8008c10 <main+0x70>
  RCC->CR |= RCC_CR_MSIPLLEN;
 8008c18:	681a      	ldr	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8008c1a:	498c      	ldr	r1, [pc, #560]	; (8008e4c <main+0x2ac>)
  RCC->CR |= RCC_CR_MSIPLLEN;
 8008c1c:	f042 0204 	orr.w	r2, r2, #4
 8008c20:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8008c22:	680b      	ldr	r3, [r1, #0]
 8008c24:	079b      	lsls	r3, r3, #30
 8008c26:	d5fc      	bpl.n	8008c22 <main+0x82>

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008c28:	4b89      	ldr	r3, [pc, #548]	; (8008e50 <main+0x2b0>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR2 = PWR_CR2_PVDE | (STM32_PLS & STM32_PLS_MASK);
#else
  PWR->CR2 = 0;
 8008c2a:	488a      	ldr	r0, [pc, #552]	; (8008e54 <main+0x2b4>)
  usbp->state        = USB_STOP;
 8008c2c:	4e8a      	ldr	r6, [pc, #552]	; (8008e58 <main+0x2b8>)

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8008c2e:	f8df c25c 	ldr.w	ip, [pc, #604]	; 8008e8c <main+0x2ec>
  tqp->next = (thread_t *)tqp;
 8008c32:	4d8a      	ldr	r5, [pc, #552]	; (8008e5c <main+0x2bc>)
 8008c34:	2260      	movs	r2, #96	; 0x60
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c36:	2440      	movs	r4, #64	; 0x40
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008c38:	f883 2306 	strb.w	r2, [r3, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c3c:	f04f 0880 	mov.w	r8, #128	; 0x80
 8008c40:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
 8008c44:	f44f 7780 	mov.w	r7, #256	; 0x100
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008c48:	601c      	str	r4, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c4a:	f44f 7400 	mov.w	r4, #512	; 0x200
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008c4e:	f883 2307 	strb.w	r2, [r3, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c52:	f8c3 8180 	str.w	r8, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008c56:	f8c3 8000 	str.w	r8, [r3]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008c5a:	f883 2308 	strb.w	r2, [r3, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c5e:	f8c3 7180 	str.w	r7, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008c62:	601f      	str	r7, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008c64:	f883 2309 	strb.w	r2, [r3, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c68:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008c6c:	601c      	str	r4, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c6e:	f44f 6480 	mov.w	r4, #1024	; 0x400
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008c72:	f883 230a 	strb.w	r2, [r3, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c76:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008c7a:	601c      	str	r4, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c7c:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008c80:	f883 2317 	strb.w	r2, [r3, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c84:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008c88:	601c      	str	r4, [r3, #0]
 8008c8a:	2400      	movs	r4, #0
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008c8c:	f883 2328 	strb.w	r2, [r3, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008c90:	f8c3 7184 	str.w	r7, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008c94:	605f      	str	r7, [r3, #4]
 8008c96:	6044      	str	r4, [r0, #4]
#endif /* STM32_PVD_ENABLE */

  /* Enabling independent VDDUSB.*/
#if HAL_USE_USB
  PWR->CR2 |= PWR_CR2_USV;
 8008c98:	6842      	ldr	r2, [r0, #4]
    usbp->in_params[i]  = NULL;
 8008c9a:	6274      	str	r4, [r6, #36]	; 0x24
 8008c9c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8008ca0:	6042      	str	r2, [r0, #4]
#endif /* HAL_USE_USB */

  /* Enabling independent VDDIO2 required by GPIOG.*/
#if STM32_HAS_GPIOG
  PWR->CR2 |= PWR_CR2_IOSV;
 8008ca2:	6842      	ldr	r2, [r0, #4]
    usbp->out_params[i] = NULL;
 8008ca4:	63b4      	str	r4, [r6, #56]	; 0x38
  usbp->state        = USB_STOP;
 8008ca6:	2701      	movs	r7, #1
 8008ca8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8008cac:	6042      	str	r2, [r0, #4]
    usbp->in_params[i]  = NULL;
 8008cae:	62b4      	str	r4, [r6, #40]	; 0x28
    usbp->out_params[i] = NULL;
 8008cb0:	63f4      	str	r4, [r6, #60]	; 0x3c
    usbp->in_params[i]  = NULL;
 8008cb2:	62f4      	str	r4, [r6, #44]	; 0x2c
  usbp->state        = USB_STOP;
 8008cb4:	7037      	strb	r7, [r6, #0]
    usbp->out_params[i] = NULL;
 8008cb6:	6434      	str	r4, [r6, #64]	; 0x40
  ST_ENABLE_CLOCK();
 8008cb8:	6d8a      	ldr	r2, [r1, #88]	; 0x58
    usbp->in_params[i]  = NULL;
 8008cba:	6334      	str	r4, [r6, #48]	; 0x30
 8008cbc:	433a      	orrs	r2, r7
 8008cbe:	658a      	str	r2, [r1, #88]	; 0x58
 8008cc0:	6f8a      	ldr	r2, [r1, #120]	; 0x78
    usbp->out_params[i] = NULL;
 8008cc2:	6474      	str	r4, [r6, #68]	; 0x44
 8008cc4:	433a      	orrs	r2, r7
 8008cc6:	678a      	str	r2, [r1, #120]	; 0x78
  ST_ENABLE_STOP();
 8008cc8:	f8dc 1008 	ldr.w	r1, [ip, #8]
  USBD1.otgparams = &fsparams;
 8008ccc:	4864      	ldr	r0, [pc, #400]	; (8008e60 <main+0x2c0>)
 8008cce:	6730      	str	r0, [r6, #112]	; 0x70
  USBD1.otg       = OTG_FS;
 8008cd0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8008cd4:	66f2      	str	r2, [r6, #108]	; 0x6c
 8008cd6:	4339      	orrs	r1, r7

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8008cd8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    usbp->in_params[i]  = NULL;
 8008cdc:	6374      	str	r4, [r6, #52]	; 0x34
    usbp->out_params[i] = NULL;
 8008cde:	64b4      	str	r4, [r6, #72]	; 0x48
  usbp->config       = NULL;
 8008ce0:	e9c6 4401 	strd	r4, r4, [r6, #4]
 8008ce4:	f641 703f 	movw	r0, #7999	; 0x1f3f
  ST_ENABLE_STOP();
 8008ce8:	f8cc 1008 	str.w	r1, [ip, #8]
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8008cec:	f04f 31ff 	mov.w	r1, #4294967295
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8008cf0:	6290      	str	r0, [r2, #40]	; 0x28
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008cf2:	f04f 5c80 	mov.w	ip, #268435456	; 0x10000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8008cf6:	62d1      	str	r1, [r2, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
 8008cf8:	606d      	str	r5, [r5, #4]
  STM32_ST_TIM->CCMR1  = 0;
 8008cfa:	6194      	str	r4, [r2, #24]
  ch.rlist.prio = NOPRIO;
 8008cfc:	60ac      	str	r4, [r5, #8]
  STM32_ST_TIM->CCR[0] = 0;
 8008cfe:	6354      	str	r4, [r2, #52]	; 0x34
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8008d00:	612d      	str	r5, [r5, #16]
  STM32_ST_TIM->DIER   = 0;
 8008d02:	60d4      	str	r4, [r2, #12]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8008d04:	616d      	str	r5, [r5, #20]
  STM32_ST_TIM->CR2    = 0;
 8008d06:	6054      	str	r4, [r2, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8008d08:	6157      	str	r7, [r2, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8008d0a:	6017      	str	r7, [r2, #0]
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8008d0c:	f105 021c 	add.w	r2, r5, #28
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008d10:	f883 831c 	strb.w	r8, [r3, #796]	; 0x31c
  chTMStartMeasurementX(&tm);
 8008d14:	a802      	add	r0, sp, #8
 8008d16:	61ea      	str	r2, [r5, #28]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008d18:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8008d1c:	622a      	str	r2, [r5, #32]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008d1e:	f8c3 c000 	str.w	ip, [r3]
  tmp->cumulative = (rttime_t)0;
 8008d22:	2200      	movs	r2, #0
 8008d24:	2300      	movs	r3, #0
  tqp->next = (thread_t *)tqp;
 8008d26:	602d      	str	r5, [r5, #0]
  ch.vtlist.lasttime = (systime_t)0;
 8008d28:	e9c5 1409 	strd	r1, r4, [r5, #36]	; 0x24
 8008d2c:	e9cd 2306 	strd	r2, r3, [sp, #24]
  tmp->worst      = (rtcnt_t)0;
 8008d30:	e9cd 1402 	strd	r1, r4, [sp, #8]
  ch.dbg.lock_cnt = (cnt_t)0;
 8008d34:	e9c5 440c 	strd	r4, r4, [r5, #48]	; 0x30
  ch.tm.offset = (rtcnt_t)0;
 8008d38:	67ec      	str	r4, [r5, #124]	; 0x7c
  tmp->n          = (ucnt_t)0;
 8008d3a:	e9cd 4404 	strd	r4, r4, [sp, #16]
  chTMStartMeasurementX(&tm);
 8008d3e:	f7f7 fd27 	bl	8000790 <chTMStartMeasurementX.constprop.61>
  chTMStopMeasurementX(&tm);
 8008d42:	a802      	add	r0, sp, #8
 8008d44:	f7f7 ff14 	bl	8000b70 <chTMStopMeasurementX>
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8008d48:	4a46      	ldr	r2, [pc, #280]	; (8008e64 <main+0x2c4>)
 8008d4a:	4b47      	ldr	r3, [pc, #284]	; (8008e68 <main+0x2c8>)
  ch.tm.offset = tm.last;
 8008d4c:	9904      	ldr	r1, [sp, #16]
 8008d4e:	67e9      	str	r1, [r5, #124]	; 0x7c
 8008d50:	f8df e13c 	ldr.w	lr, [pc, #316]	; 8008e90 <main+0x2f0>
 8008d54:	f8c2 e000 	str.w	lr, [r2]
 8008d58:	f102 010c 	add.w	r1, r2, #12
  dlp->next = (dyn_element_t *)dlp;
 8008d5c:	f103 0e10 	add.w	lr, r3, #16
  tqp->prev = (thread_t *)tqp;
 8008d60:	e9c2 1103 	strd	r1, r1, [r2, #12]
  mp->object_size = size;
 8008d64:	2114      	movs	r1, #20
  H_PAGES(&default_heap.header) = 0;
 8008d66:	e9c2 4401 	strd	r4, r4, [r2, #4]
  mp->owner = NULL;
 8008d6a:	6154      	str	r4, [r2, #20]
 8008d6c:	f8c3 e010 	str.w	lr, [r3, #16]
 8008d70:	f103 0224 	add.w	r2, r3, #36	; 0x24
 8008d74:	f103 0e28 	add.w	lr, r3, #40	; 0x28
 8008d78:	6199      	str	r1, [r3, #24]
 8008d7a:	211c      	movs	r1, #28
 8008d7c:	625a      	str	r2, [r3, #36]	; 0x24
 8008d7e:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
 8008d82:	f103 023c 	add.w	r2, r3, #60	; 0x3c
 8008d86:	f103 0e40 	add.w	lr, r3, #64	; 0x40
 8008d8a:	6319      	str	r1, [r3, #48]	; 0x30
  mp->align = align;
 8008d8c:	2104      	movs	r1, #4
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8008d8e:	4837      	ldr	r0, [pc, #220]	; (8008e6c <main+0x2cc>)
 8008d90:	63da      	str	r2, [r3, #60]	; 0x3c
 8008d92:	f8c3 e040 	str.w	lr, [r3, #64]	; 0x40
  mp->provider = provider;
 8008d96:	4a36      	ldr	r2, [pc, #216]	; (8008e70 <main+0x2d0>)
  mp->align = align;
 8008d98:	61d9      	str	r1, [r3, #28]
 8008d9a:	6359      	str	r1, [r3, #52]	; 0x34
  ch_memcore.nextmem = __heap_base__;
 8008d9c:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 8008e94 <main+0x2f4>
 8008da0:	f8df e0f4 	ldr.w	lr, [pc, #244]	; 8008e98 <main+0x2f8>
  ch_memcore.endmem  = __heap_end__;
 8008da4:	4933      	ldr	r1, [pc, #204]	; (8008e74 <main+0x2d4>)
 8008da6:	609c      	str	r4, [r3, #8]
  mp->next = NULL;
 8008da8:	615c      	str	r4, [r3, #20]
 8008daa:	62dc      	str	r4, [r3, #44]	; 0x2c
  mp->provider = provider;
 8008dac:	621a      	str	r2, [r3, #32]
 8008dae:	639a      	str	r2, [r3, #56]	; 0x38
 8008db0:	e9c3 3300 	strd	r3, r3, [r3]
  tp->name      = name;
 8008db4:	4b30      	ldr	r3, [pc, #192]	; (8008e78 <main+0x2d8>)
  tp->prio      = prio;
 8008db6:	f8c5 8040 	str.w	r8, [r5, #64]	; 0x40
 8008dba:	e9cc e100 	strd	lr, r1, [ip]
  tp->realprio  = prio;
 8008dbe:	f8c5 8074 	str.w	r8, [r5, #116]	; 0x74
  tp->flags     = CH_FLAG_MODE_STATIC;
 8008dc2:	f885 4059 	strb.w	r4, [r5, #89]	; 0x59
  tp->epending  = (eventmask_t)0;
 8008dc6:	e9c5 441b 	strd	r4, r4, [r5, #108]	; 0x6c
  tp->refs      = (trefs_t)1;
 8008dca:	f885 705a 	strb.w	r7, [r5, #90]	; 0x5a
  tp->name      = name;
 8008dce:	652b      	str	r3, [r5, #80]	; 0x50
 8008dd0:	68c1      	ldr	r1, [r0, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8008dd2:	4b2a      	ldr	r3, [pc, #168]	; (8008e7c <main+0x2dc>)
  REG_INSERT(tp);
 8008dd4:	f8d5 e014 	ldr.w	lr, [r5, #20]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8008dd8:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 8008e9c <main+0x2fc>
 8008ddc:	64ad      	str	r5, [r5, #72]	; 0x48
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8008dde:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
 8008de2:	4011      	ands	r1, r2
  reg_value  =  (reg_value                                   |
 8008de4:	430b      	orrs	r3, r1
 8008de6:	f105 0238 	add.w	r2, r5, #56	; 0x38
 8008dea:	f8c5 e04c 	str.w	lr, [r5, #76]	; 0x4c
 8008dee:	f8ce 2010 	str.w	r2, [lr, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8008df2:	60c3      	str	r3, [r0, #12]
 8008df4:	f8dc 300c 	ldr.w	r3, [ip, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8008df8:	4921      	ldr	r1, [pc, #132]	; (8008e80 <main+0x2e0>)
 8008dfa:	616a      	str	r2, [r5, #20]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8008dfc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008e00:	f8cc 300c 	str.w	r3, [ip, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8008e04:	680b      	ldr	r3, [r1, #0]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8008e06:	61aa      	str	r2, [r5, #24]
 8008e08:	433b      	orrs	r3, r7
 8008e0a:	600b      	str	r3, [r1, #0]
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008e0c:	f04f 0c10 	mov.w	ip, #16
  tqp->next = (thread_t *)tqp;
 8008e10:	f105 0364 	add.w	r3, r5, #100	; 0x64
  tlp->next = (thread_t *)tlp;
 8008e14:	f105 0260 	add.w	r2, r5, #96	; 0x60
 8008e18:	f04f 0820 	mov.w	r8, #32
 8008e1c:	f880 c01f 	strb.w	ip, [r0, #31]
 8008e20:	f880 8022 	strb.w	r8, [r0, #34]	; 0x22
  currp->wabase = NULL;
 8008e24:	656c      	str	r4, [r5, #84]	; 0x54
  currp->state = CH_STATE_CURRENT;
 8008e26:	f885 7058 	strb.w	r7, [r5, #88]	; 0x58
  tqp->next = (thread_t *)tqp;
 8008e2a:	e9c5 2318 	strd	r2, r3, [r5, #96]	; 0x60
  tqp->prev = (thread_t *)tqp;
 8008e2e:	66ab      	str	r3, [r5, #104]	; 0x68
  _dbg_check_enable();
 8008e30:	f7f8 f98e 	bl	8001150 <_dbg_check_enable>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008e34:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 8008e38:	b662      	cpsie	i
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8008e3a:	4812      	ldr	r0, [pc, #72]	; (8008e84 <main+0x2e4>)
 8008e3c:	f7ff faa0 	bl	8008380 <chRegFindThreadByWorkingArea>
 8008e40:	4604      	mov	r4, r0
 8008e42:	b368      	cbz	r0, 8008ea0 <main+0x300>
  __ASM volatile ("cpsid i" : : : "memory");
 8008e44:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 8008e46:	4b10      	ldr	r3, [pc, #64]	; (8008e88 <main+0x2e8>)
 8008e48:	62eb      	str	r3, [r5, #44]	; 0x2c
 8008e4a:	e7fe      	b.n	8008e4a <main+0x2aa>
 8008e4c:	40021000 	.word	0x40021000
 8008e50:	e000e100 	.word	0xe000e100
 8008e54:	40007000 	.word	0x40007000
 8008e58:	20001128 	.word	0x20001128
 8008e5c:	200011a0 	.word	0x200011a0
 8008e60:	0800c514 	.word	0x0800c514
 8008e64:	20001348 	.word	0x20001348
 8008e68:	20001220 	.word	0x20001220
 8008e6c:	e000ed00 	.word	0xe000ed00
 8008e70:	08000c91 	.word	0x08000c91
 8008e74:	20018000 	.word	0x20018000
 8008e78:	0800c204 	.word	0x0800c204
 8008e7c:	05fa0300 	.word	0x05fa0300
 8008e80:	e0001000 	.word	0xe0001000
 8008e84:	20001268 	.word	0x20001268
 8008e88:	0800bdf8 	.word	0x0800bdf8
 8008e8c:	e0042000 	.word	0xe0042000
 8008e90:	08003ee1 	.word	0x08003ee1
 8008e94:	20001340 	.word	0x20001340
 8008e98:	20001ce0 	.word	0x20001ce0
 8008e9c:	e000edf0 	.word	0xe000edf0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008ea0:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock();
 8008ea4:	f7fa fc8c 	bl	80037c0 <_dbg_check_lock>
  tp = chThdCreateSuspendedI(tdp);
 8008ea8:	489d      	ldr	r0, [pc, #628]	; (8009120 <main+0x580>)
 8008eaa:	f7f7 fef9 	bl	8000ca0 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8008eae:	4621      	mov	r1, r4
 8008eb0:	f7fa f816 	bl	8002ee0 <chSchWakeupS>
  _dbg_check_unlock();
 8008eb4:	f7fa fc1c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008eb8:	682b      	ldr	r3, [r5, #0]
 8008eba:	42ab      	cmp	r3, r5
 8008ebc:	d004      	beq.n	8008ec8 <main+0x328>
 8008ebe:	69aa      	ldr	r2, [r5, #24]
 8008ec0:	689b      	ldr	r3, [r3, #8]
 8008ec2:	6892      	ldr	r2, [r2, #8]
 8008ec4:	429a      	cmp	r2, r3
 8008ec6:	d355      	bcc.n	8008f74 <main+0x3d4>
 8008ec8:	2300      	movs	r3, #0
 8008eca:	f383 8811 	msr	BASEPRI, r3
  sdup->vmt = &vmt;
 8008ece:	4c95      	ldr	r4, [pc, #596]	; (8009124 <main+0x584>)
 8008ed0:	4a95      	ldr	r2, [pc, #596]	; (8009128 <main+0x588>)
  ibqp->bcounter  = 0;
 8008ed2:	61a3      	str	r3, [r4, #24]
 8008ed4:	4621      	mov	r1, r4
  ibqp->ptr       = NULL;
 8008ed6:	6363      	str	r3, [r4, #52]	; 0x34
 8008ed8:	f841 2b04 	str.w	r2, [r1], #4
  ibqp->top       = NULL;
 8008edc:	63a3      	str	r3, [r4, #56]	; 0x38
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8008ede:	f204 428c 	addw	r2, r4, #1164	; 0x48c
  obqp->top       = NULL;
 8008ee2:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
  obqp->notify    = onfy;
 8008ee6:	4b91      	ldr	r3, [pc, #580]	; (800912c <main+0x58c>)
  ibqp->notify    = infy;
 8008ee8:	4891      	ldr	r0, [pc, #580]	; (8009130 <main+0x590>)
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8008eea:	65e2      	str	r2, [r4, #92]	; 0x5c
  obqp->notify    = onfy;
 8008eec:	6763      	str	r3, [r4, #116]	; 0x74
  ibqp->brdptr    = bp;
 8008eee:	f104 027c 	add.w	r2, r4, #124	; 0x7c
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8008ef2:	f504 7321 	add.w	r3, r4, #644	; 0x284
  esp->next = (event_listener_t *)esp;
 8008ef6:	6061      	str	r1, [r4, #4]
  tqp->next = (thread_t *)tqp;
 8008ef8:	f104 0144 	add.w	r1, r4, #68	; 0x44
  ibqp->notify    = infy;
 8008efc:	63e0      	str	r0, [r4, #60]	; 0x3c
  ibqp->bwrptr    = bp;
 8008efe:	e9c4 2207 	strd	r2, r2, [r4, #28]
 8008f02:	f104 000c 	add.w	r0, r4, #12
  ibqp->buffers   = bp;
 8008f06:	6322      	str	r2, [r4, #48]	; 0x30
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8008f08:	6263      	str	r3, [r4, #36]	; 0x24
  sdup->state = SDU_STOP;
 8008f0a:	2201      	movs	r2, #1
  obqp->bwrptr    = bp;
 8008f0c:	e9c4 3315 	strd	r3, r3, [r4, #84]	; 0x54
  obqp->buffers   = bp;
 8008f10:	66a3      	str	r3, [r4, #104]	; 0x68
  tqp->prev = (thread_t *)tqp;
 8008f12:	e9c4 1111 	strd	r1, r1, [r4, #68]	; 0x44
  ibqp->bsize     = size + sizeof (size_t);
 8008f16:	f44f 7382 	mov.w	r3, #260	; 0x104
  ibqp->bn        = n;
 8008f1a:	2102      	movs	r1, #2
  ibqp->bsize     = size + sizeof (size_t);
 8008f1c:	62a3      	str	r3, [r4, #40]	; 0x28
  obqp->bsize     = size + sizeof (size_t);
 8008f1e:	6623      	str	r3, [r4, #96]	; 0x60
  ibqp->link      = link;
 8008f20:	6424      	str	r4, [r4, #64]	; 0x40
  obqp->link      = link;
 8008f22:	67a4      	str	r4, [r4, #120]	; 0x78
 8008f24:	e9c4 0003 	strd	r0, r0, [r4, #12]
 8008f28:	7222      	strb	r2, [r4, #8]
  ibqp->suspended = suspended;
 8008f2a:	7522      	strb	r2, [r4, #20]
  obqp->suspended = suspended;
 8008f2c:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
  ibqp->bn        = n;
 8008f30:	62e1      	str	r1, [r4, #44]	; 0x2c
  obqp->bcounter  = n;
 8008f32:	6521      	str	r1, [r4, #80]	; 0x50
  obqp->bn        = n;
 8008f34:	6661      	str	r1, [r4, #100]	; 0x64
 8008f36:	2320      	movs	r3, #32
 8008f38:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008f3c:	f7fa fc40 	bl	80037c0 <_dbg_check_lock>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 8008f40:	7a23      	ldrb	r3, [r4, #8]
 8008f42:	3b01      	subs	r3, #1
 8008f44:	2b01      	cmp	r3, #1
 8008f46:	f200 80e0 	bhi.w	800910a <main+0x56a>
  sdup->config = config;
 8008f4a:	4b7a      	ldr	r3, [pc, #488]	; (8009134 <main+0x594>)
 8008f4c:	f8c4 348c 	str.w	r3, [r4, #1164]	; 0x48c
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8008f50:	6274      	str	r4, [r6, #36]	; 0x24
  usbp->out_params[config->bulk_out - 1U] = sdup;
 8008f52:	63b4      	str	r4, [r6, #56]	; 0x38
    usbp->in_params[config->int_in - 1U]  = sdup;
 8008f54:	62b4      	str	r4, [r6, #40]	; 0x28
  sdup->state = SDU_READY;
 8008f56:	7221      	strb	r1, [r4, #8]
  _dbg_check_unlock();
 8008f58:	f7fa fbca 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008f5c:	682b      	ldr	r3, [r5, #0]
 8008f5e:	42ab      	cmp	r3, r5
 8008f60:	d00c      	beq.n	8008f7c <main+0x3dc>
 8008f62:	69aa      	ldr	r2, [r5, #24]
 8008f64:	689b      	ldr	r3, [r3, #8]
 8008f66:	6892      	ldr	r2, [r2, #8]
 8008f68:	429a      	cmp	r2, r3
 8008f6a:	d207      	bcs.n	8008f7c <main+0x3dc>
  __ASM volatile ("cpsid i" : : : "memory");
 8008f6c:	b672      	cpsid	i
 8008f6e:	4b72      	ldr	r3, [pc, #456]	; (8009138 <main+0x598>)
 8008f70:	62eb      	str	r3, [r5, #44]	; 0x2c
 8008f72:	e7fe      	b.n	8008f72 <main+0x3d2>
 8008f74:	b672      	cpsid	i
 8008f76:	4b71      	ldr	r3, [pc, #452]	; (800913c <main+0x59c>)
 8008f78:	62eb      	str	r3, [r5, #44]	; 0x2c
 8008f7a:	e7fe      	b.n	8008f7a <main+0x3da>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008f7c:	f04f 0800 	mov.w	r8, #0
 8008f80:	f388 8811 	msr	BASEPRI, r8
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
 8008f84:	6ef2      	ldr	r2, [r6, #108]	; 0x6c
 8008f86:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
 8008f8a:	f043 0302 	orr.w	r3, r3, #2
 8008f8e:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
  chThdSleepMilliseconds(1500);
 8008f92:	f643 2098 	movw	r0, #15000	; 0x3a98
 8008f96:	f7fe fb4b 	bl	8007630 <chThdSleep>
 8008f9a:	2020      	movs	r0, #32
 8008f9c:	f380 8811 	msr	BASEPRI, r0
  _dbg_check_lock();
 8008fa0:	f7fa fc0e 	bl	80037c0 <_dbg_check_lock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 8008fa4:	f896 9000 	ldrb.w	r9, [r6]
 8008fa8:	f109 33ff 	add.w	r3, r9, #4294967295
 8008fac:	2b01      	cmp	r3, #1
 8008fae:	f200 80a8 	bhi.w	8009102 <main+0x562>
  usbp->config = config;
 8008fb2:	4b63      	ldr	r3, [pc, #396]	; (8009140 <main+0x5a0>)
 8008fb4:	6073      	str	r3, [r6, #4]
  if (usbp->state == USB_STOP) {
 8008fb6:	f1b9 0f01 	cmp.w	r9, #1
    usbp->epc[i] = NULL;
 8008fba:	e9c6 8803 	strd	r8, r8, [r6, #12]
 8008fbe:	e9c6 8805 	strd	r8, r8, [r6, #20]
 8008fc2:	e9c6 8807 	strd	r8, r8, [r6, #28]
  stm32_otg_t *otgp = usbp->otg;
 8008fc6:	6ef7      	ldr	r7, [r6, #108]	; 0x6c
  if (usbp->state == USB_STOP) {
 8008fc8:	d037      	beq.n	800903a <main+0x49a>
  usbp->state = USB_READY;
 8008fca:	2302      	movs	r3, #2
 8008fcc:	7033      	strb	r3, [r6, #0]
  _dbg_check_unlock();
 8008fce:	f7fa fb8f 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008fd2:	682b      	ldr	r3, [r5, #0]
 8008fd4:	42ab      	cmp	r3, r5
 8008fd6:	d005      	beq.n	8008fe4 <main+0x444>
 8008fd8:	69aa      	ldr	r2, [r5, #24]
 8008fda:	689b      	ldr	r3, [r3, #8]
 8008fdc:	6892      	ldr	r2, [r2, #8]
 8008fde:	429a      	cmp	r2, r3
 8008fe0:	f0c0 8097 	bcc.w	8009112 <main+0x572>
 8008fe4:	2300      	movs	r3, #0
 8008fe6:	f383 8811 	msr	BASEPRI, r3
  usbStart(serusbcfg.usbp, &usbcfg);
  usbConnectBus(serusbcfg.usbp);
 8008fea:	6ef1      	ldr	r1, [r6, #108]	; 0x6c
 8008fec:	4855      	ldr	r0, [pc, #340]	; (8009144 <main+0x5a4>)
 8008fee:	f8d1 2804 	ldr.w	r2, [r1, #2052]	; 0x804
 8008ff2:	6000      	str	r0, [r0, #0]
 8008ff4:	f022 0202 	bic.w	r2, r2, #2
 8008ff8:	f8c1 2804 	str.w	r2, [r1, #2052]	; 0x804
  shellInit();

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8008ffc:	4852      	ldr	r0, [pc, #328]	; (8009148 <main+0x5a8>)
 8008ffe:	4a53      	ldr	r2, [pc, #332]	; (800914c <main+0x5ac>)
 8009000:	4f53      	ldr	r7, [pc, #332]	; (8009150 <main+0x5b0>)
 8009002:	4e54      	ldr	r6, [pc, #336]	; (8009154 <main+0x5b4>)
  /*
   * Normal main() thread activity, spawning shells.
   */
  while (true) {
    if (PORTAB_SDU1.config->usbp->state == USB_ACTIVE) {
      thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
 8009004:	4d54      	ldr	r5, [pc, #336]	; (8009158 <main+0x5b8>)
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8009006:	2180      	movs	r1, #128	; 0x80
 8009008:	f7ff f9ea 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800900c:	e003      	b.n	8009016 <main+0x476>
                                              "shell", NORMALPRIO + 1,
                                              shellThread, (void *)&shell_cfg1);
      chThdWait(shelltp);               /* Waiting termination.             */
    }
    chThdSleepMilliseconds(1000);
 800900e:	f242 7010 	movw	r0, #10000	; 0x2710
 8009012:	f7fe fb0d 	bl	8007630 <chThdSleep>
    if (PORTAB_SDU1.config->usbp->state == USB_ACTIVE) {
 8009016:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
 800901a:	681b      	ldr	r3, [r3, #0]
 800901c:	781b      	ldrb	r3, [r3, #0]
 800901e:	2b04      	cmp	r3, #4
 8009020:	d1f5      	bne.n	800900e <main+0x46e>
      thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
 8009022:	2381      	movs	r3, #129	; 0x81
 8009024:	462a      	mov	r2, r5
 8009026:	f640 01c8 	movw	r1, #2248	; 0x8c8
 800902a:	e9cd 6700 	strd	r6, r7, [sp]
 800902e:	2000      	movs	r0, #0
 8009030:	f7fc fff6 	bl	8006020 <chThdCreateFromHeap>
      chThdWait(shelltp);               /* Waiting termination.             */
 8009034:	f7ff fd6c 	bl	8008b10 <chThdWait>
 8009038:	e7e9      	b.n	800900e <main+0x46e>
      rccEnableOTG_FS(true);
 800903a:	4b48      	ldr	r3, [pc, #288]	; (800915c <main+0x5bc>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800903c:	4a48      	ldr	r2, [pc, #288]	; (8009160 <main+0x5c0>)
 800903e:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8009040:	f8df c138 	ldr.w	ip, [pc, #312]	; 800917c <main+0x5dc>
      rccEnableOTG_FS(true);
 8009044:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8009048:	64d9      	str	r1, [r3, #76]	; 0x4c
 800904a:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800904c:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8009050:	66d9      	str	r1, [r3, #108]	; 0x6c
      rccResetOTG_FS();
 8009052:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8009054:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8009058:	62d9      	str	r1, [r3, #44]	; 0x2c
 800905a:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
 800905e:	23e0      	movs	r3, #224	; 0xe0
 8009060:	f882 3343 	strb.w	r3, [r2, #835]	; 0x343
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8009064:	2308      	movs	r3, #8
 8009066:	f8c2 3188 	str.w	r3, [r2, #392]	; 0x188
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800906a:	493e      	ldr	r1, [pc, #248]	; (8009164 <main+0x5c4>)
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800906c:	6093      	str	r3, [r2, #8]
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 800906e:	22c0      	movs	r2, #192	; 0xc0
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8009070:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8009074:	f8c7 c00c 	str.w	ip, [r7, #12]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8009078:	f8c7 1800 	str.w	r1, [r7, #2048]	; 0x800
    otgp->PCGCCTL = 0;
 800907c:	f8c7 8e00 	str.w	r8, [r7, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8009080:	603a      	str	r2, [r7, #0]
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8009082:	63bb      	str	r3, [r7, #56]	; 0x38
  chSysPolledDelayX(cycles);
 8009084:	f7f8 f8ac 	bl	80011e0 <chSysPolledDelayX>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8009088:	f8c7 9010 	str.w	r9, [r7, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 800908c:	693b      	ldr	r3, [r7, #16]
 800908e:	f013 0801 	ands.w	r8, r3, #1
 8009092:	d1fb      	bne.n	800908c <main+0x4ec>
 8009094:	2012      	movs	r0, #18
 8009096:	f7f8 f8a3 	bl	80011e0 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800909a:	693b      	ldr	r3, [r7, #16]
 800909c:	2b00      	cmp	r3, #0
 800909e:	dafc      	bge.n	800909a <main+0x4fa>
 80090a0:	e9d6 131b 	ldrd	r1, r3, [r6, #108]	; 0x6c
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80090a4:	f8d3 c008 	ldr.w	ip, [r3, #8]
    otgp->GAHBCFG = 0;
 80090a8:	2300      	movs	r3, #0
 80090aa:	60bb      	str	r3, [r7, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80090ac:	f04f 30ff 	mov.w	r0, #4294967295
 80090b0:	eb01 1248 	add.w	r2, r1, r8, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80090b4:	f108 0801 	add.w	r8, r8, #1
 80090b8:	45e0      	cmp	r8, ip
    otgp->ie[i].DIEPCTL = 0;
 80090ba:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
 80090be:	f8c2 3910 	str.w	r3, [r2, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80090c2:	f8c2 0908 	str.w	r0, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
 80090c6:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 80090ca:	f8c2 3b10 	str.w	r3, [r2, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80090ce:	f8c2 0b08 	str.w	r0, [r2, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80090d2:	d9ed      	bls.n	80090b0 <main+0x510>
    if (usbp->config->sof_cb == NULL)
 80090d4:	6872      	ldr	r2, [r6, #4]
 80090d6:	68d2      	ldr	r2, [r2, #12]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80090d8:	f04f 1001 	mov.w	r0, #65537	; 0x10001
 80090dc:	f8c1 081c 	str.w	r0, [r1, #2076]	; 0x81c
    otgp->DIEPMSK  = 0;
 80090e0:	f8c7 3810 	str.w	r3, [r7, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 80090e4:	f8c7 3814 	str.w	r3, [r7, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 80090e8:	f8c7 381c 	str.w	r3, [r7, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 80090ec:	b1aa      	cbz	r2, 800911a <main+0x57a>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 80090ee:	4b1e      	ldr	r3, [pc, #120]	; (8009168 <main+0x5c8>)
 80090f0:	61bb      	str	r3, [r7, #24]
    otgp->GINTSTS  = 0xFFFFFFFF;
 80090f2:	f04f 33ff 	mov.w	r3, #4294967295
 80090f6:	617b      	str	r3, [r7, #20]
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 80090f8:	68bb      	ldr	r3, [r7, #8]
 80090fa:	f043 0301 	orr.w	r3, r3, #1
 80090fe:	60bb      	str	r3, [r7, #8]
 8009100:	e763      	b.n	8008fca <main+0x42a>
  __ASM volatile ("cpsid i" : : : "memory");
 8009102:	b672      	cpsid	i
 8009104:	4b19      	ldr	r3, [pc, #100]	; (800916c <main+0x5cc>)
 8009106:	62eb      	str	r3, [r5, #44]	; 0x2c
 8009108:	e7fe      	b.n	8009108 <main+0x568>
 800910a:	b672      	cpsid	i
 800910c:	4b18      	ldr	r3, [pc, #96]	; (8009170 <main+0x5d0>)
 800910e:	62eb      	str	r3, [r5, #44]	; 0x2c
 8009110:	e7fe      	b.n	8009110 <main+0x570>
 8009112:	b672      	cpsid	i
 8009114:	4b17      	ldr	r3, [pc, #92]	; (8009174 <main+0x5d4>)
 8009116:	62eb      	str	r3, [r5, #44]	; 0x2c
 8009118:	e7fe      	b.n	8009118 <main+0x578>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 800911a:	4b17      	ldr	r3, [pc, #92]	; (8009178 <main+0x5d8>)
 800911c:	61bb      	str	r3, [r7, #24]
 800911e:	e7e8      	b.n	80090f2 <main+0x552>
 8009120:	0800c524 	.word	0x0800c524
 8009124:	20000c98 	.word	0x20000c98
 8009128:	0800e8c8 	.word	0x0800e8c8
 800912c:	080019c1 	.word	0x080019c1
 8009130:	08001881 	.word	0x08001881
 8009134:	0800dc78 	.word	0x0800dc78
 8009138:	0800bbcc 	.word	0x0800bbcc
 800913c:	0800bbe4 	.word	0x0800bbe4
 8009140:	0800e7c4 	.word	0x0800e7c4
 8009144:	20001420 	.word	0x20001420
 8009148:	20001b98 	.word	0x20001b98
 800914c:	08007681 	.word	0x08007681
 8009150:	0800dcf0 	.word	0x0800dcf0
 8009154:	080050e1 	.word	0x080050e1
 8009158:	0800c53c 	.word	0x0800c53c
 800915c:	40021000 	.word	0x40021000
 8009160:	e000e100 	.word	0xe000e100
 8009164:	02200003 	.word	0x02200003
 8009168:	c0303c08 	.word	0xc0303c08
 800916c:	0800c09c 	.word	0x0800c09c
 8009170:	0800c000 	.word	0x0800c000
 8009174:	0800bd00 	.word	0x0800bd00
 8009178:	c0303c00 	.word	0xc0303c00
 800917c:	40001440 	.word	0x40001440

08009180 <rt_test_010_005_execute>:
static void rt_test_010_005_execute(void) {
 8009180:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 8009184:	4b17      	ldr	r3, [pc, #92]	; (80091e4 <rt_test_010_005_execute+0x64>)
  test_set_step(1);
 8009186:	f8df 906c 	ldr.w	r9, [pc, #108]	; 80091f4 <rt_test_010_005_execute+0x74>
  return chThdGetSelfX()->prio;
 800918a:	699b      	ldr	r3, [r3, #24]
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 800918c:	f8df 8068 	ldr.w	r8, [pc, #104]	; 80091f8 <rt_test_010_005_execute+0x78>
  tprio_t prio = chThdGetPriorityX() - 1;
 8009190:	689d      	ldr	r5, [r3, #8]
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8009192:	4f15      	ldr	r7, [pc, #84]	; (80091e8 <rt_test_010_005_execute+0x68>)
  test_set_step(1);
 8009194:	2301      	movs	r3, #1
 8009196:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 800919a:	f7fe fbe9 	bl	8007970 <test_wait_tick>
  tprio_t prio = chThdGetPriorityX() - 1;
 800919e:	3d01      	subs	r5, #1
    n = 0;
 80091a0:	2400      	movs	r4, #0
    start = test_wait_tick();
 80091a2:	4606      	mov	r6, r0
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80091a4:	2300      	movs	r3, #0
 80091a6:	4642      	mov	r2, r8
 80091a8:	4629      	mov	r1, r5
 80091aa:	4638      	mov	r0, r7
 80091ac:	f7ff f918 	bl	80083e0 <chThdCreateStatic.constprop.60>
 80091b0:	f7ff fcae 	bl	8008b10 <chThdWait>
 80091b4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 80091b8:	f242 720f 	movw	r2, #9999	; 0x270f
 80091bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80091be:	1b9b      	subs	r3, r3, r6
 80091c0:	4293      	cmp	r3, r2
      n++;
 80091c2:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 80091c6:	d9ed      	bls.n	80091a4 <rt_test_010_005_execute+0x24>
  test_set_step(2);
 80091c8:	2302      	movs	r3, #2
    test_print("--- Score : ");
 80091ca:	4808      	ldr	r0, [pc, #32]	; (80091ec <rt_test_010_005_execute+0x6c>)
  test_set_step(2);
 80091cc:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 80091d0:	f7f7 fc2e 	bl	8000a30 <test_print>
    test_printn(n);
 80091d4:	4620      	mov	r0, r4
 80091d6:	f7f7 fbfb 	bl	80009d0 <test_printn>
    test_println(" threads/S");
 80091da:	4805      	ldr	r0, [pc, #20]	; (80091f0 <rt_test_010_005_execute+0x70>)
}
 80091dc:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" threads/S");
 80091e0:	f7f7 bc06 	b.w	80009f0 <test_println>
 80091e4:	200011a0 	.word	0x200011a0
 80091e8:	20001428 	.word	0x20001428
 80091ec:	0800da4c 	.word	0x0800da4c
 80091f0:	0800d9b4 	.word	0x0800d9b4
 80091f4:	20001b3c 	.word	0x20001b3c
 80091f8:	08008181 	.word	0x08008181
 80091fc:	00000000 	.word	0x00000000

08009200 <test_wait_threads>:
void test_wait_threads(void) {
 8009200:	b570      	push	{r4, r5, r6, lr}
 8009202:	4c07      	ldr	r4, [pc, #28]	; (8009220 <test_wait_threads+0x20>)
      threads[i] = NULL;
 8009204:	2600      	movs	r6, #0
 8009206:	f104 0514 	add.w	r5, r4, #20
    if (threads[i] != NULL) {
 800920a:	f854 0b04 	ldr.w	r0, [r4], #4
 800920e:	b118      	cbz	r0, 8009218 <test_wait_threads+0x18>
      chThdWait(threads[i]);
 8009210:	f7ff fc7e 	bl	8008b10 <chThdWait>
      threads[i] = NULL;
 8009214:	f844 6c04 	str.w	r6, [r4, #-4]
  for (i = 0; i < MAX_THREADS; i++)
 8009218:	42ac      	cmp	r4, r5
 800921a:	d1f6      	bne.n	800920a <test_wait_threads+0xa>
}
 800921c:	bd70      	pop	{r4, r5, r6, pc}
 800921e:	bf00      	nop
 8009220:	20001b54 	.word	0x20001b54
	...

08009230 <rt_test_010_008_execute>:
static void rt_test_010_008_execute(void) {
 8009230:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009234:	b083      	sub	sp, #12
    n = 0;
 8009236:	ac02      	add	r4, sp, #8
  return ch.rlist.current;
 8009238:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800930c <rt_test_010_008_execute+0xdc>
  test_set_step(1);
 800923c:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8009310 <rt_test_010_008_execute+0xe0>
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8009240:	4f2d      	ldr	r7, [pc, #180]	; (80092f8 <rt_test_010_008_execute+0xc8>)
 8009242:	4e2e      	ldr	r6, [pc, #184]	; (80092fc <rt_test_010_008_execute+0xcc>)
 8009244:	4d2e      	ldr	r5, [pc, #184]	; (8009300 <rt_test_010_008_execute+0xd0>)
  test_set_step(1);
 8009246:	2201      	movs	r2, #1
    n = 0;
 8009248:	2300      	movs	r3, #0
 800924a:	f844 3d04 	str.w	r3, [r4, #-4]!
  test_set_step(1);
 800924e:	f8c9 2000 	str.w	r2, [r9]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8009252:	f7fe fb8d 	bl	8007970 <test_wait_tick>
  return chThdGetSelfX()->prio;
 8009256:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800925a:	6899      	ldr	r1, [r3, #8]
 800925c:	463a      	mov	r2, r7
 800925e:	4623      	mov	r3, r4
 8009260:	3901      	subs	r1, #1
 8009262:	4630      	mov	r0, r6
 8009264:	f7ff f8bc 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009268:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800926c:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800926e:	6899      	ldr	r1, [r3, #8]
 8009270:	463a      	mov	r2, r7
 8009272:	4623      	mov	r3, r4
 8009274:	3901      	subs	r1, #1
 8009276:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 800927a:	f7ff f8b1 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800927e:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8009282:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8009284:	6899      	ldr	r1, [r3, #8]
 8009286:	463a      	mov	r2, r7
 8009288:	4623      	mov	r3, r4
 800928a:	3901      	subs	r1, #1
 800928c:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8009290:	f7ff f8a6 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009294:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8009298:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800929a:	6899      	ldr	r1, [r3, #8]
 800929c:	463a      	mov	r2, r7
 800929e:	4623      	mov	r3, r4
 80092a0:	3901      	subs	r1, #1
 80092a2:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 80092a6:	f7ff f89b 	bl	80083e0 <chThdCreateStatic.constprop.60>
 80092aa:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80092ae:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80092b0:	6899      	ldr	r1, [r3, #8]
 80092b2:	463a      	mov	r2, r7
 80092b4:	3901      	subs	r1, #1
 80092b6:	4623      	mov	r3, r4
 80092b8:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 80092bc:	f7ff f890 	bl	80083e0 <chThdCreateStatic.constprop.60>
  test_set_step(2);
 80092c0:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80092c2:	6128      	str	r0, [r5, #16]
    chThdSleepSeconds(1);
 80092c4:	f242 7010 	movw	r0, #10000	; 0x2710
  test_set_step(2);
 80092c8:	f8c9 3000 	str.w	r3, [r9]
    chThdSleepSeconds(1);
 80092cc:	f7fe f9b0 	bl	8007630 <chThdSleep>
    test_terminate_threads();
 80092d0:	f7fb f8d6 	bl	8004480 <test_terminate_threads>
    test_wait_threads();
 80092d4:	f7ff ff94 	bl	8009200 <test_wait_threads>
  test_set_step(3);
 80092d8:	2303      	movs	r3, #3
    test_print("--- Score : ");
 80092da:	480a      	ldr	r0, [pc, #40]	; (8009304 <rt_test_010_008_execute+0xd4>)
  test_set_step(3);
 80092dc:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 80092e0:	f7f7 fba6 	bl	8000a30 <test_print>
    test_printn(n);
 80092e4:	9801      	ldr	r0, [sp, #4]
 80092e6:	f7f7 fb73 	bl	80009d0 <test_printn>
    test_println(" ctxswc/S");
 80092ea:	4807      	ldr	r0, [pc, #28]	; (8009308 <rt_test_010_008_execute+0xd8>)
 80092ec:	f7f7 fb80 	bl	80009f0 <test_println>
}
 80092f0:	b003      	add	sp, #12
 80092f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80092f6:	bf00      	nop
 80092f8:	08007601 	.word	0x08007601
 80092fc:	20001428 	.word	0x20001428
 8009300:	20001b54 	.word	0x20001b54
 8009304:	0800da4c 	.word	0x0800da4c
 8009308:	0800d9f4 	.word	0x0800d9f4
 800930c:	200011a0 	.word	0x200011a0
 8009310:	20001b3c 	.word	0x20001b3c
	...

08009320 <rt_test_010_007_execute>:
static void rt_test_010_007_execute(void) {
 8009320:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8009324:	4d35      	ldr	r5, [pc, #212]	; (80093fc <rt_test_010_007_execute+0xdc>)
  test_set_step(1);
 8009326:	f8df 8104 	ldr.w	r8, [pc, #260]	; 800942c <rt_test_010_007_execute+0x10c>
  return chThdGetSelfX()->prio;
 800932a:	69ab      	ldr	r3, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 800932c:	4a34      	ldr	r2, [pc, #208]	; (8009400 <rt_test_010_007_execute+0xe0>)
 800932e:	6899      	ldr	r1, [r3, #8]
 8009330:	4834      	ldr	r0, [pc, #208]	; (8009404 <rt_test_010_007_execute+0xe4>)
 8009332:	4c35      	ldr	r4, [pc, #212]	; (8009408 <rt_test_010_007_execute+0xe8>)
      chSemReset(&sem1, 0);
 8009334:	4f35      	ldr	r7, [pc, #212]	; (800940c <rt_test_010_007_execute+0xec>)
  test_set_step(1);
 8009336:	2301      	movs	r3, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8009338:	3105      	adds	r1, #5
  test_set_step(1);
 800933a:	f8c8 3000 	str.w	r3, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 800933e:	2300      	movs	r3, #0
 8009340:	f7ff f84e 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009344:	69ab      	ldr	r3, [r5, #24]
 8009346:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8009348:	6899      	ldr	r1, [r3, #8]
 800934a:	4a2d      	ldr	r2, [pc, #180]	; (8009400 <rt_test_010_007_execute+0xe0>)
 800934c:	4830      	ldr	r0, [pc, #192]	; (8009410 <rt_test_010_007_execute+0xf0>)
 800934e:	3104      	adds	r1, #4
 8009350:	2300      	movs	r3, #0
 8009352:	f7ff f845 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009356:	69ab      	ldr	r3, [r5, #24]
 8009358:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 800935a:	6899      	ldr	r1, [r3, #8]
 800935c:	4a28      	ldr	r2, [pc, #160]	; (8009400 <rt_test_010_007_execute+0xe0>)
 800935e:	482d      	ldr	r0, [pc, #180]	; (8009414 <rt_test_010_007_execute+0xf4>)
 8009360:	3103      	adds	r1, #3
 8009362:	2300      	movs	r3, #0
 8009364:	f7ff f83c 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009368:	69ab      	ldr	r3, [r5, #24]
 800936a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 800936c:	6899      	ldr	r1, [r3, #8]
 800936e:	4a24      	ldr	r2, [pc, #144]	; (8009400 <rt_test_010_007_execute+0xe0>)
 8009370:	4829      	ldr	r0, [pc, #164]	; (8009418 <rt_test_010_007_execute+0xf8>)
 8009372:	3102      	adds	r1, #2
 8009374:	2300      	movs	r3, #0
 8009376:	f7ff f833 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800937a:	69ab      	ldr	r3, [r5, #24]
 800937c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800937e:	6899      	ldr	r1, [r3, #8]
 8009380:	4a1f      	ldr	r2, [pc, #124]	; (8009400 <rt_test_010_007_execute+0xe0>)
 8009382:	4826      	ldr	r0, [pc, #152]	; (800941c <rt_test_010_007_execute+0xfc>)
 8009384:	3101      	adds	r1, #1
 8009386:	2300      	movs	r3, #0
 8009388:	f7ff f82a 	bl	80083e0 <chThdCreateStatic.constprop.60>
  test_set_step(2);
 800938c:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800938e:	6120      	str	r0, [r4, #16]
  test_set_step(2);
 8009390:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
 8009394:	f7fe faec 	bl	8007970 <test_wait_tick>
    n = 0;
 8009398:	2400      	movs	r4, #0
    start = test_wait_tick();
 800939a:	4606      	mov	r6, r0
 800939c:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
      chSemReset(&sem1, 0);
 80093a0:	2100      	movs	r1, #0
 80093a2:	4638      	mov	r0, r7
 80093a4:	f7fd ffec 	bl	8007380 <chSemReset>
 80093a8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    } while (chVTIsSystemTimeWithinX(start, end));
 80093aa:	f242 720f 	movw	r2, #9999	; 0x270f
 80093ae:	1b9b      	subs	r3, r3, r6
 80093b0:	4293      	cmp	r3, r2
      n++;
 80093b2:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 80093b6:	d9f3      	bls.n	80093a0 <rt_test_010_007_execute+0x80>
  test_set_step(3);
 80093b8:	2303      	movs	r3, #3
 80093ba:	f8c8 3000 	str.w	r3, [r8]
    test_terminate_threads();
 80093be:	f7fb f85f 	bl	8004480 <test_terminate_threads>
    chSemReset(&sem1, 0);
 80093c2:	2100      	movs	r1, #0
 80093c4:	4811      	ldr	r0, [pc, #68]	; (800940c <rt_test_010_007_execute+0xec>)
 80093c6:	f7fd ffdb 	bl	8007380 <chSemReset>
    test_wait_threads();
 80093ca:	f7ff ff19 	bl	8009200 <test_wait_threads>
  test_set_step(4);
 80093ce:	2304      	movs	r3, #4
    test_print("--- Score : ");
 80093d0:	4813      	ldr	r0, [pc, #76]	; (8009420 <rt_test_010_007_execute+0x100>)
  test_set_step(4);
 80093d2:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
 80093d6:	f7f7 fb2b 	bl	8000a30 <test_print>
    test_printn(n);
 80093da:	4620      	mov	r0, r4
 80093dc:	f7f7 faf8 	bl	80009d0 <test_printn>
    test_printn(n * 6);
 80093e0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    test_print(" reschedules/S, ");
 80093e4:	480f      	ldr	r0, [pc, #60]	; (8009424 <rt_test_010_007_execute+0x104>)
 80093e6:	f7f7 fb23 	bl	8000a30 <test_print>
    test_printn(n * 6);
 80093ea:	0060      	lsls	r0, r4, #1
 80093ec:	f7f7 faf0 	bl	80009d0 <test_printn>
    test_println(" ctxswc/S");
 80093f0:	480d      	ldr	r0, [pc, #52]	; (8009428 <rt_test_010_007_execute+0x108>)
}
 80093f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" ctxswc/S");
 80093f6:	f7f7 bafb 	b.w	80009f0 <test_println>
 80093fa:	bf00      	nop
 80093fc:	200011a0 	.word	0x200011a0
 8009400:	08007311 	.word	0x08007311
 8009404:	20001428 	.word	0x20001428
 8009408:	20001b54 	.word	0x20001b54
 800940c:	20001414 	.word	0x20001414
 8009410:	20001570 	.word	0x20001570
 8009414:	200016b8 	.word	0x200016b8
 8009418:	20001800 	.word	0x20001800
 800941c:	20001948 	.word	0x20001948
 8009420:	0800da4c 	.word	0x0800da4c
 8009424:	0800d9d0 	.word	0x0800d9d0
 8009428:	0800d9f4 	.word	0x0800d9f4
 800942c:	20001b3c 	.word	0x20001b3c

08009430 <rt_test_010_004_execute>:
static void rt_test_010_004_execute(void) {
 8009430:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return ch.rlist.current;
 8009434:	4c39      	ldr	r4, [pc, #228]	; (800951c <rt_test_010_004_execute+0xec>)
  test_set_step(1);
 8009436:	4f3a      	ldr	r7, [pc, #232]	; (8009520 <rt_test_010_004_execute+0xf0>)
  return chThdGetSelfX()->prio;
 8009438:	69a3      	ldr	r3, [r4, #24]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800943a:	4a3a      	ldr	r2, [pc, #232]	; (8009524 <rt_test_010_004_execute+0xf4>)
 800943c:	6899      	ldr	r1, [r3, #8]
 800943e:	483a      	ldr	r0, [pc, #232]	; (8009528 <rt_test_010_004_execute+0xf8>)
 8009440:	3101      	adds	r1, #1
  test_set_step(1);
 8009442:	2501      	movs	r5, #1
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8009444:	2300      	movs	r3, #0
  test_set_step(1);
 8009446:	603d      	str	r5, [r7, #0]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8009448:	f7fe ffca 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800944c:	4a37      	ldr	r2, [pc, #220]	; (800952c <rt_test_010_004_execute+0xfc>)
  test_set_step(2);
 800944e:	2302      	movs	r3, #2
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8009450:	4605      	mov	r5, r0
 8009452:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 8009454:	603b      	str	r3, [r7, #0]
    start = test_wait_tick();
 8009456:	f7fe fa8b 	bl	8007970 <test_wait_tick>
    n = 0;
 800945a:	2600      	movs	r6, #0
      chSchWakeupS(tp, MSG_OK);
 800945c:	46b1      	mov	r9, r6
    start = test_wait_tick();
 800945e:	4683      	mov	fp, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009460:	f04f 0a20 	mov.w	sl, #32
 8009464:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 8009468:	f38a 8811 	msr	BASEPRI, sl
  _dbg_check_lock();
 800946c:	f7fa f9a8 	bl	80037c0 <_dbg_check_lock>
      chSchWakeupS(tp, MSG_OK);
 8009470:	4628      	mov	r0, r5
 8009472:	2100      	movs	r1, #0
 8009474:	f7f9 fd34 	bl	8002ee0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8009478:	4628      	mov	r0, r5
 800947a:	2100      	movs	r1, #0
 800947c:	f7f9 fd30 	bl	8002ee0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8009480:	4628      	mov	r0, r5
 8009482:	2100      	movs	r1, #0
 8009484:	f7f9 fd2c 	bl	8002ee0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8009488:	4628      	mov	r0, r5
 800948a:	2100      	movs	r1, #0
 800948c:	f7f9 fd28 	bl	8002ee0 <chSchWakeupS>
  _dbg_check_unlock();
 8009490:	f7fa f92e 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009494:	6823      	ldr	r3, [r4, #0]
 8009496:	42a3      	cmp	r3, r4
 8009498:	d004      	beq.n	80094a4 <rt_test_010_004_execute+0x74>
 800949a:	69a2      	ldr	r2, [r4, #24]
 800949c:	689b      	ldr	r3, [r3, #8]
 800949e:	6892      	ldr	r2, [r2, #8]
 80094a0:	429a      	cmp	r2, r3
 80094a2:	d333      	bcc.n	800950c <rt_test_010_004_execute+0xdc>
 80094a4:	f389 8811 	msr	BASEPRI, r9
 80094a8:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
    } while (chVTIsSystemTimeWithinX(start, end));
 80094ac:	f242 720f 	movw	r2, #9999	; 0x270f
 80094b0:	eba3 030b 	sub.w	r3, r3, fp
 80094b4:	4293      	cmp	r3, r2
      n += 4;
 80094b6:	f106 0604 	add.w	r6, r6, #4
    } while (chVTIsSystemTimeWithinX(start, end));
 80094ba:	d9d5      	bls.n	8009468 <rt_test_010_004_execute+0x38>
  test_set_step(3);
 80094bc:	2303      	movs	r3, #3
 80094be:	603b      	str	r3, [r7, #0]
 80094c0:	2320      	movs	r3, #32
 80094c2:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80094c6:	f7fa f97b 	bl	80037c0 <_dbg_check_lock>
    chSchWakeupS(tp, MSG_TIMEOUT);
 80094ca:	4628      	mov	r0, r5
 80094cc:	f04f 31ff 	mov.w	r1, #4294967295
 80094d0:	f7f9 fd06 	bl	8002ee0 <chSchWakeupS>
  _dbg_check_unlock();
 80094d4:	f7fa f90c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80094d8:	6823      	ldr	r3, [r4, #0]
 80094da:	42a3      	cmp	r3, r4
 80094dc:	d004      	beq.n	80094e8 <rt_test_010_004_execute+0xb8>
 80094de:	69a2      	ldr	r2, [r4, #24]
 80094e0:	689b      	ldr	r3, [r3, #8]
 80094e2:	6892      	ldr	r2, [r2, #8]
 80094e4:	429a      	cmp	r2, r3
 80094e6:	d315      	bcc.n	8009514 <rt_test_010_004_execute+0xe4>
 80094e8:	2300      	movs	r3, #0
 80094ea:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 80094ee:	f7ff fe87 	bl	8009200 <test_wait_threads>
  test_set_step(4);
 80094f2:	2304      	movs	r3, #4
    test_print("--- Score : ");
 80094f4:	480e      	ldr	r0, [pc, #56]	; (8009530 <rt_test_010_004_execute+0x100>)
  test_set_step(4);
 80094f6:	603b      	str	r3, [r7, #0]
    test_print("--- Score : ");
 80094f8:	f7f7 fa9a 	bl	8000a30 <test_print>
    test_printn(n * 2);
 80094fc:	0070      	lsls	r0, r6, #1
 80094fe:	f7f7 fa67 	bl	80009d0 <test_printn>
    test_println(" ctxswc/S");
 8009502:	480c      	ldr	r0, [pc, #48]	; (8009534 <rt_test_010_004_execute+0x104>)
}
 8009504:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_println(" ctxswc/S");
 8009508:	f7f7 ba72 	b.w	80009f0 <test_println>
  __ASM volatile ("cpsid i" : : : "memory");
 800950c:	b672      	cpsid	i
 800950e:	4b0a      	ldr	r3, [pc, #40]	; (8009538 <rt_test_010_004_execute+0x108>)
 8009510:	62e3      	str	r3, [r4, #44]	; 0x2c
 8009512:	e7fe      	b.n	8009512 <rt_test_010_004_execute+0xe2>
 8009514:	b672      	cpsid	i
 8009516:	4b08      	ldr	r3, [pc, #32]	; (8009538 <rt_test_010_004_execute+0x108>)
 8009518:	62e3      	str	r3, [r4, #44]	; 0x2c
 800951a:	e7fe      	b.n	800951a <rt_test_010_004_execute+0xea>
 800951c:	200011a0 	.word	0x200011a0
 8009520:	20001b3c 	.word	0x20001b3c
 8009524:	080040b1 	.word	0x080040b1
 8009528:	20001428 	.word	0x20001428
 800952c:	20001b54 	.word	0x20001b54
 8009530:	0800da4c 	.word	0x0800da4c
 8009534:	0800d9f4 	.word	0x0800d9f4
 8009538:	0800bcbc 	.word	0x0800bcbc
 800953c:	00000000 	.word	0x00000000

08009540 <rt_test_010_003_execute>:
static void rt_test_010_003_execute(void) {
 8009540:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8009544:	4e2c      	ldr	r6, [pc, #176]	; (80095f8 <rt_test_010_003_execute+0xb8>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8009546:	4d2d      	ldr	r5, [pc, #180]	; (80095fc <rt_test_010_003_execute+0xbc>)
  return chThdGetSelfX()->prio;
 8009548:	69b3      	ldr	r3, [r6, #24]
  test_set_step(1);
 800954a:	4f2d      	ldr	r7, [pc, #180]	; (8009600 <rt_test_010_003_execute+0xc0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800954c:	6899      	ldr	r1, [r3, #8]
 800954e:	4a2d      	ldr	r2, [pc, #180]	; (8009604 <rt_test_010_003_execute+0xc4>)
 8009550:	4c2d      	ldr	r4, [pc, #180]	; (8009608 <rt_test_010_003_execute+0xc8>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8009552:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 8009618 <rt_test_010_003_execute+0xd8>
  test_set_step(1);
 8009556:	f04f 0c01 	mov.w	ip, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800955a:	3101      	adds	r1, #1
 800955c:	4628      	mov	r0, r5
 800955e:	2300      	movs	r3, #0
  test_set_step(1);
 8009560:	f8c7 c000 	str.w	ip, [r7]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8009564:	f7fe ff3c 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009568:	69b3      	ldr	r3, [r6, #24]
 800956a:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 800956c:	6899      	ldr	r1, [r3, #8]
  test_set_step(2);
 800956e:	f04f 0c02 	mov.w	ip, #2
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8009572:	4642      	mov	r2, r8
 8009574:	3902      	subs	r1, #2
 8009576:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 800957a:	2300      	movs	r3, #0
  test_set_step(2);
 800957c:	f8c7 c000 	str.w	ip, [r7]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8009580:	f7fe ff2e 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009584:	69b3      	ldr	r3, [r6, #24]
 8009586:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8009588:	6899      	ldr	r1, [r3, #8]
 800958a:	4642      	mov	r2, r8
 800958c:	3903      	subs	r1, #3
 800958e:	f505 7024 	add.w	r0, r5, #656	; 0x290
 8009592:	2300      	movs	r3, #0
 8009594:	f7fe ff24 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009598:	69b3      	ldr	r3, [r6, #24]
 800959a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 800959c:	6899      	ldr	r1, [r3, #8]
 800959e:	4642      	mov	r2, r8
 80095a0:	3904      	subs	r1, #4
 80095a2:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 80095a6:	2300      	movs	r3, #0
 80095a8:	f7fe ff1a 	bl	80083e0 <chThdCreateStatic.constprop.60>
 80095ac:	69b3      	ldr	r3, [r6, #24]
 80095ae:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80095b0:	6899      	ldr	r1, [r3, #8]
 80095b2:	4642      	mov	r2, r8
 80095b4:	3905      	subs	r1, #5
 80095b6:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 80095ba:	2300      	movs	r3, #0
 80095bc:	f7fe ff10 	bl	80083e0 <chThdCreateStatic.constprop.60>
  test_set_step(3);
 80095c0:	2303      	movs	r3, #3
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80095c2:	6120      	str	r0, [r4, #16]
    n = msg_loop_test(threads[0]);
 80095c4:	6820      	ldr	r0, [r4, #0]
  test_set_step(3);
 80095c6:	603b      	str	r3, [r7, #0]
    n = msg_loop_test(threads[0]);
 80095c8:	f7fe faf2 	bl	8007bb0 <msg_loop_test>
 80095cc:	4604      	mov	r4, r0
    test_wait_threads();
 80095ce:	f7ff fe17 	bl	8009200 <test_wait_threads>
  test_set_step(4);
 80095d2:	2304      	movs	r3, #4
    test_print("--- Score : ");
 80095d4:	480d      	ldr	r0, [pc, #52]	; (800960c <rt_test_010_003_execute+0xcc>)
  test_set_step(4);
 80095d6:	603b      	str	r3, [r7, #0]
    test_print("--- Score : ");
 80095d8:	f7f7 fa2a 	bl	8000a30 <test_print>
    test_printn(n);
 80095dc:	4620      	mov	r0, r4
 80095de:	f7f7 f9f7 	bl	80009d0 <test_printn>
    test_print(" msgs/S, ");
 80095e2:	480b      	ldr	r0, [pc, #44]	; (8009610 <rt_test_010_003_execute+0xd0>)
 80095e4:	f7f7 fa24 	bl	8000a30 <test_print>
    test_printn(n << 1);
 80095e8:	0060      	lsls	r0, r4, #1
 80095ea:	f7f7 f9f1 	bl	80009d0 <test_printn>
    test_println(" ctxswc/S");
 80095ee:	4809      	ldr	r0, [pc, #36]	; (8009614 <rt_test_010_003_execute+0xd4>)
}
 80095f0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" ctxswc/S");
 80095f4:	f7f7 b9fc 	b.w	80009f0 <test_println>
 80095f8:	200011a0 	.word	0x200011a0
 80095fc:	20001428 	.word	0x20001428
 8009600:	20001b3c 	.word	0x20001b3c
 8009604:	080058d1 	.word	0x080058d1
 8009608:	20001b54 	.word	0x20001b54
 800960c:	0800da4c 	.word	0x0800da4c
 8009610:	0800d978 	.word	0x0800d978
 8009614:	0800d9f4 	.word	0x0800d9f4
 8009618:	08008181 	.word	0x08008181
 800961c:	00000000 	.word	0x00000000

08009620 <rt_test_010_002_execute>:
static void rt_test_010_002_execute(void) {
 8009620:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 8009622:	4b14      	ldr	r3, [pc, #80]	; (8009674 <rt_test_010_002_execute+0x54>)
  test_set_step(1);
 8009624:	4c14      	ldr	r4, [pc, #80]	; (8009678 <rt_test_010_002_execute+0x58>)
  return chThdGetSelfX()->prio;
 8009626:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8009628:	4a14      	ldr	r2, [pc, #80]	; (800967c <rt_test_010_002_execute+0x5c>)
 800962a:	6899      	ldr	r1, [r3, #8]
 800962c:	4814      	ldr	r0, [pc, #80]	; (8009680 <rt_test_010_002_execute+0x60>)
 800962e:	3101      	adds	r1, #1
  test_set_step(1);
 8009630:	2501      	movs	r5, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8009632:	2300      	movs	r3, #0
  test_set_step(1);
 8009634:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8009636:	f7fe fed3 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800963a:	4a12      	ldr	r2, [pc, #72]	; (8009684 <rt_test_010_002_execute+0x64>)
  test_set_step(2);
 800963c:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800963e:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 8009640:	6023      	str	r3, [r4, #0]
    n = msg_loop_test(threads[0]);
 8009642:	f7fe fab5 	bl	8007bb0 <msg_loop_test>
 8009646:	4605      	mov	r5, r0
    test_wait_threads();
 8009648:	f7ff fdda 	bl	8009200 <test_wait_threads>
  test_set_step(3);
 800964c:	2303      	movs	r3, #3
    test_print("--- Score : ");
 800964e:	480e      	ldr	r0, [pc, #56]	; (8009688 <rt_test_010_002_execute+0x68>)
  test_set_step(3);
 8009650:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
 8009652:	f7f7 f9ed 	bl	8000a30 <test_print>
    test_printn(n);
 8009656:	4628      	mov	r0, r5
 8009658:	f7f7 f9ba 	bl	80009d0 <test_printn>
    test_print(" msgs/S, ");
 800965c:	480b      	ldr	r0, [pc, #44]	; (800968c <rt_test_010_002_execute+0x6c>)
 800965e:	f7f7 f9e7 	bl	8000a30 <test_print>
    test_printn(n << 1);
 8009662:	0068      	lsls	r0, r5, #1
 8009664:	f7f7 f9b4 	bl	80009d0 <test_printn>
    test_println(" ctxswc/S");
 8009668:	4809      	ldr	r0, [pc, #36]	; (8009690 <rt_test_010_002_execute+0x70>)
}
 800966a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println(" ctxswc/S");
 800966e:	f7f7 b9bf 	b.w	80009f0 <test_println>
 8009672:	bf00      	nop
 8009674:	200011a0 	.word	0x200011a0
 8009678:	20001b3c 	.word	0x20001b3c
 800967c:	080058d1 	.word	0x080058d1
 8009680:	20001428 	.word	0x20001428
 8009684:	20001b54 	.word	0x20001b54
 8009688:	0800da4c 	.word	0x0800da4c
 800968c:	0800d978 	.word	0x0800d978
 8009690:	0800d9f4 	.word	0x0800d9f4
	...

080096a0 <rt_test_010_001_execute>:
static void rt_test_010_001_execute(void) {
 80096a0:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 80096a2:	4b14      	ldr	r3, [pc, #80]	; (80096f4 <rt_test_010_001_execute+0x54>)
  test_set_step(1);
 80096a4:	4c14      	ldr	r4, [pc, #80]	; (80096f8 <rt_test_010_001_execute+0x58>)
  return chThdGetSelfX()->prio;
 80096a6:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80096a8:	4a14      	ldr	r2, [pc, #80]	; (80096fc <rt_test_010_001_execute+0x5c>)
 80096aa:	6899      	ldr	r1, [r3, #8]
 80096ac:	4814      	ldr	r0, [pc, #80]	; (8009700 <rt_test_010_001_execute+0x60>)
 80096ae:	3901      	subs	r1, #1
  test_set_step(1);
 80096b0:	2501      	movs	r5, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80096b2:	2300      	movs	r3, #0
  test_set_step(1);
 80096b4:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80096b6:	f7fe fe93 	bl	80083e0 <chThdCreateStatic.constprop.60>
 80096ba:	4a12      	ldr	r2, [pc, #72]	; (8009704 <rt_test_010_001_execute+0x64>)
  test_set_step(2);
 80096bc:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80096be:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 80096c0:	6023      	str	r3, [r4, #0]
    n = msg_loop_test(threads[0]);
 80096c2:	f7fe fa75 	bl	8007bb0 <msg_loop_test>
 80096c6:	4605      	mov	r5, r0
    test_wait_threads();
 80096c8:	f7ff fd9a 	bl	8009200 <test_wait_threads>
  test_set_step(3);
 80096cc:	2303      	movs	r3, #3
    test_print("--- Score : ");
 80096ce:	480e      	ldr	r0, [pc, #56]	; (8009708 <rt_test_010_001_execute+0x68>)
  test_set_step(3);
 80096d0:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
 80096d2:	f7f7 f9ad 	bl	8000a30 <test_print>
    test_printn(n);
 80096d6:	4628      	mov	r0, r5
 80096d8:	f7f7 f97a 	bl	80009d0 <test_printn>
    test_print(" msgs/S, ");
 80096dc:	480b      	ldr	r0, [pc, #44]	; (800970c <rt_test_010_001_execute+0x6c>)
 80096de:	f7f7 f9a7 	bl	8000a30 <test_print>
    test_printn(n << 1);
 80096e2:	0068      	lsls	r0, r5, #1
 80096e4:	f7f7 f974 	bl	80009d0 <test_printn>
    test_println(" ctxswc/S");
 80096e8:	4809      	ldr	r0, [pc, #36]	; (8009710 <rt_test_010_001_execute+0x70>)
}
 80096ea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println(" ctxswc/S");
 80096ee:	f7f7 b97f 	b.w	80009f0 <test_println>
 80096f2:	bf00      	nop
 80096f4:	200011a0 	.word	0x200011a0
 80096f8:	20001b3c 	.word	0x20001b3c
 80096fc:	080058d1 	.word	0x080058d1
 8009700:	20001428 	.word	0x20001428
 8009704:	20001b54 	.word	0x20001b54
 8009708:	0800da4c 	.word	0x0800da4c
 800970c:	0800d978 	.word	0x0800d978
 8009710:	0800d9f4 	.word	0x0800d9f4
	...

08009720 <rt_test_009_002_execute>:

static void rt_test_009_002_execute(void) {
 8009720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [9.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  {
    for (i = 0; i < 4; i++)
      chPoolFree(&mp1, wa[i]);
 8009722:	493b      	ldr	r1, [pc, #236]	; (8009810 <rt_test_009_002_execute+0xf0>)
 8009724:	483b      	ldr	r0, [pc, #236]	; (8009814 <rt_test_009_002_execute+0xf4>)
  {
    prio = chThdGetPriorityX();
  }

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
 8009726:	4e3c      	ldr	r6, [pc, #240]	; (8009818 <rt_test_009_002_execute+0xf8>)
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8009728:	4c3c      	ldr	r4, [pc, #240]	; (800981c <rt_test_009_002_execute+0xfc>)
      chPoolFree(&mp1, wa[i]);
 800972a:	f7fb fed1 	bl	80054d0 <chPoolFree>
 800972e:	493c      	ldr	r1, [pc, #240]	; (8009820 <rt_test_009_002_execute+0x100>)
 8009730:	4838      	ldr	r0, [pc, #224]	; (8009814 <rt_test_009_002_execute+0xf4>)
 8009732:	f7fb fecd 	bl	80054d0 <chPoolFree>
 8009736:	493b      	ldr	r1, [pc, #236]	; (8009824 <rt_test_009_002_execute+0x104>)
 8009738:	4836      	ldr	r0, [pc, #216]	; (8009814 <rt_test_009_002_execute+0xf4>)
 800973a:	f7fb fec9 	bl	80054d0 <chPoolFree>
 800973e:	493a      	ldr	r1, [pc, #232]	; (8009828 <rt_test_009_002_execute+0x108>)
 8009740:	4834      	ldr	r0, [pc, #208]	; (8009814 <rt_test_009_002_execute+0xf4>)
 8009742:	f7fb fec5 	bl	80054d0 <chPoolFree>
  return ch.rlist.current;
 8009746:	4b39      	ldr	r3, [pc, #228]	; (800982c <rt_test_009_002_execute+0x10c>)
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8009748:	4a39      	ldr	r2, [pc, #228]	; (8009830 <rt_test_009_002_execute+0x110>)
  return chThdGetSelfX()->prio;
 800974a:	699b      	ldr	r3, [r3, #24]
 800974c:	4839      	ldr	r0, [pc, #228]	; (8009834 <rt_test_009_002_execute+0x114>)
 800974e:	689d      	ldr	r5, [r3, #8]
  test_set_step(3);
 8009750:	2303      	movs	r3, #3
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8009752:	1e69      	subs	r1, r5, #1
  test_set_step(3);
 8009754:	6033      	str	r3, [r6, #0]
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8009756:	f7fb ff3b 	bl	80055d0 <chThdCreateFromMemoryPool.constprop.30>
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 800975a:	1ea9      	subs	r1, r5, #2
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800975c:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 800975e:	4a36      	ldr	r2, [pc, #216]	; (8009838 <rt_test_009_002_execute+0x118>)
 8009760:	4836      	ldr	r0, [pc, #216]	; (800983c <rt_test_009_002_execute+0x11c>)
 8009762:	f7fb ff35 	bl	80055d0 <chThdCreateFromMemoryPool.constprop.30>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8009766:	1ee9      	subs	r1, r5, #3
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8009768:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800976a:	4a35      	ldr	r2, [pc, #212]	; (8009840 <rt_test_009_002_execute+0x120>)
 800976c:	4835      	ldr	r0, [pc, #212]	; (8009844 <rt_test_009_002_execute+0x124>)
 800976e:	f7fb ff2f 	bl	80055d0 <chThdCreateFromMemoryPool.constprop.30>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8009772:	1f29      	subs	r1, r5, #4
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8009774:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8009776:	4a34      	ldr	r2, [pc, #208]	; (8009848 <rt_test_009_002_execute+0x128>)
 8009778:	4834      	ldr	r0, [pc, #208]	; (800984c <rt_test_009_002_execute+0x12c>)
 800977a:	f7fb ff29 	bl	80055d0 <chThdCreateFromMemoryPool.constprop.30>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800977e:	1f69      	subs	r1, r5, #5
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8009780:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8009782:	4a33      	ldr	r2, [pc, #204]	; (8009850 <rt_test_009_002_execute+0x130>)
 8009784:	4833      	ldr	r0, [pc, #204]	; (8009854 <rt_test_009_002_execute+0x134>)
 8009786:	f7fb ff23 	bl	80055d0 <chThdCreateFromMemoryPool.constprop.30>
 800978a:	4605      	mov	r5, r0
  }

  /* [9.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 800978c:	6820      	ldr	r0, [r4, #0]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800978e:	6125      	str	r5, [r4, #16]
  test_set_step(4);
 8009790:	2304      	movs	r3, #4
 8009792:	6033      	str	r3, [r6, #0]
    test_assert((threads[0] != NULL) &&
 8009794:	b138      	cbz	r0, 80097a6 <rt_test_009_002_execute+0x86>
 8009796:	6860      	ldr	r0, [r4, #4]
 8009798:	b128      	cbz	r0, 80097a6 <rt_test_009_002_execute+0x86>
 800979a:	68a0      	ldr	r0, [r4, #8]
 800979c:	b118      	cbz	r0, 80097a6 <rt_test_009_002_execute+0x86>
 800979e:	68e0      	ldr	r0, [r4, #12]
 80097a0:	3000      	adds	r0, #0
 80097a2:	bf18      	it	ne
 80097a4:	2001      	movne	r0, #1
 80097a6:	492c      	ldr	r1, [pc, #176]	; (8009858 <rt_test_009_002_execute+0x138>)
 80097a8:	f7f7 f8ba 	bl	8000920 <_test_assert>
 80097ac:	b100      	cbz	r0, 80097b0 <rt_test_009_002_execute+0x90>
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  }
}
 80097ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert(threads[4] == NULL,
 80097b0:	fab5 f085 	clz	r0, r5
 80097b4:	0940      	lsrs	r0, r0, #5
 80097b6:	4929      	ldr	r1, [pc, #164]	; (800985c <rt_test_009_002_execute+0x13c>)
 80097b8:	f7f7 f8b2 	bl	8000920 <_test_assert>
 80097bc:	2800      	cmp	r0, #0
 80097be:	d1f6      	bne.n	80097ae <rt_test_009_002_execute+0x8e>
  test_set_step(5);
 80097c0:	2305      	movs	r3, #5
 80097c2:	6033      	str	r3, [r6, #0]
    test_wait_threads();
 80097c4:	f7ff fd1c 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 80097c8:	4925      	ldr	r1, [pc, #148]	; (8009860 <rt_test_009_002_execute+0x140>)
 80097ca:	4826      	ldr	r0, [pc, #152]	; (8009864 <rt_test_009_002_execute+0x144>)
 80097cc:	f7f7 f948 	bl	8000a60 <_test_assert_sequence>
 80097d0:	2800      	cmp	r0, #0
 80097d2:	d1ec      	bne.n	80097ae <rt_test_009_002_execute+0x8e>
  test_set_step(6);
 80097d4:	2306      	movs	r3, #6
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 80097d6:	4f0f      	ldr	r7, [pc, #60]	; (8009814 <rt_test_009_002_execute+0xf4>)
 80097d8:	4d23      	ldr	r5, [pc, #140]	; (8009868 <rt_test_009_002_execute+0x148>)
  test_set_step(6);
 80097da:	6033      	str	r3, [r6, #0]
 80097dc:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 80097de:	4638      	mov	r0, r7
 80097e0:	f7fb fec6 	bl	8005570 <chPoolAlloc>
 80097e4:	3000      	adds	r0, #0
 80097e6:	bf18      	it	ne
 80097e8:	2001      	movne	r0, #1
 80097ea:	4629      	mov	r1, r5
 80097ec:	f7f7 f898 	bl	8000920 <_test_assert>
 80097f0:	2800      	cmp	r0, #0
 80097f2:	d1dc      	bne.n	80097ae <rt_test_009_002_execute+0x8e>
    for (i = 0; i < 4; i++)
 80097f4:	3c01      	subs	r4, #1
 80097f6:	d1f2      	bne.n	80097de <rt_test_009_002_execute+0xbe>
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 80097f8:	4806      	ldr	r0, [pc, #24]	; (8009814 <rt_test_009_002_execute+0xf4>)
 80097fa:	f7fb feb9 	bl	8005570 <chPoolAlloc>
 80097fe:	fab0 f080 	clz	r0, r0
 8009802:	0940      	lsrs	r0, r0, #5
 8009804:	4919      	ldr	r1, [pc, #100]	; (800986c <rt_test_009_002_execute+0x14c>)
}
 8009806:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800980a:	f7f7 b889 	b.w	8000920 <_test_assert>
 800980e:	bf00      	nop
 8009810:	20001428 	.word	0x20001428
 8009814:	200013d8 	.word	0x200013d8
 8009818:	20001b3c 	.word	0x20001b3c
 800981c:	20001b54 	.word	0x20001b54
 8009820:	20001570 	.word	0x20001570
 8009824:	200016b8 	.word	0x200016b8
 8009828:	20001800 	.word	0x20001800
 800982c:	200011a0 	.word	0x200011a0
 8009830:	0800d688 	.word	0x0800d688
 8009834:	0800d8c4 	.word	0x0800d8c4
 8009838:	0800d68c 	.word	0x0800d68c
 800983c:	0800d8cc 	.word	0x0800d8cc
 8009840:	0800d8d4 	.word	0x0800d8d4
 8009844:	0800d8d8 	.word	0x0800d8d8
 8009848:	0800e62c 	.word	0x0800e62c
 800984c:	0800d8e0 	.word	0x0800d8e0
 8009850:	0800d714 	.word	0x0800d714
 8009854:	0800d8e8 	.word	0x0800d8e8
 8009858:	0800d8f0 	.word	0x0800d8f0
 800985c:	0800d908 	.word	0x0800d908
 8009860:	0800d774 	.word	0x0800d774
 8009864:	0800c628 	.word	0x0800c628
 8009868:	0800d924 	.word	0x0800d924
 800986c:	0800d934 	.word	0x0800d934

08009870 <rt_test_009_001_execute>:
static void rt_test_009_001_execute(void) {
 8009870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8009874:	4b45      	ldr	r3, [pc, #276]	; (800998c <rt_test_009_001_execute+0x11c>)
  test_set_step(2);
 8009876:	4c46      	ldr	r4, [pc, #280]	; (8009990 <rt_test_009_001_execute+0x120>)
  return chThdGetSelfX()->prio;
 8009878:	699b      	ldr	r3, [r3, #24]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800987a:	4846      	ldr	r0, [pc, #280]	; (8009994 <rt_test_009_001_execute+0x124>)
 800987c:	689e      	ldr	r6, [r3, #8]
static void rt_test_009_001_execute(void) {
 800987e:	b086      	sub	sp, #24
  test_set_step(2);
 8009880:	2302      	movs	r3, #2
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8009882:	a905      	add	r1, sp, #20
 8009884:	aa04      	add	r2, sp, #16
  test_set_step(2);
 8009886:	6023      	str	r3, [r4, #0]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8009888:	f7fc ffba 	bl	8006800 <chHeapStatus>
 800988c:	4605      	mov	r5, r0
    test_assert(n1 == 1, "heap fragmented");
 800988e:	f1a0 0001 	sub.w	r0, r0, #1
 8009892:	fab0 f080 	clz	r0, r0
 8009896:	0940      	lsrs	r0, r0, #5
 8009898:	493f      	ldr	r1, [pc, #252]	; (8009998 <rt_test_009_001_execute+0x128>)
 800989a:	f7f7 f841 	bl	8000920 <_test_assert>
 800989e:	b110      	cbz	r0, 80098a6 <rt_test_009_001_execute+0x36>
}
 80098a0:	b006      	add	sp, #24
 80098a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    threads[0] = chThdCreateFromHeap(&heap1,
 80098a6:	4b3d      	ldr	r3, [pc, #244]	; (800999c <rt_test_009_001_execute+0x12c>)
 80098a8:	f8df 8128 	ldr.w	r8, [pc, #296]	; 80099d4 <rt_test_009_001_execute+0x164>
 80098ac:	4a3c      	ldr	r2, [pc, #240]	; (80099a0 <rt_test_009_001_execute+0x130>)
 80098ae:	4839      	ldr	r0, [pc, #228]	; (8009994 <rt_test_009_001_execute+0x124>)
 80098b0:	4f3c      	ldr	r7, [pc, #240]	; (80099a4 <rt_test_009_001_execute+0x134>)
  test_set_step(3);
 80098b2:	2103      	movs	r1, #3
    threads[0] = chThdCreateFromHeap(&heap1,
 80098b4:	e9cd 8300 	strd	r8, r3, [sp]
  test_set_step(3);
 80098b8:	6021      	str	r1, [r4, #0]
    threads[0] = chThdCreateFromHeap(&heap1,
 80098ba:	1e73      	subs	r3, r6, #1
 80098bc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80098c0:	f7fc fbae 	bl	8006020 <chThdCreateFromHeap>
 80098c4:	6038      	str	r0, [r7, #0]
    test_assert(threads[0] != NULL, "thread creation failed");
 80098c6:	3000      	adds	r0, #0
 80098c8:	bf18      	it	ne
 80098ca:	2001      	movne	r0, #1
 80098cc:	4936      	ldr	r1, [pc, #216]	; (80099a8 <rt_test_009_001_execute+0x138>)
 80098ce:	f7f7 f827 	bl	8000920 <_test_assert>
 80098d2:	2800      	cmp	r0, #0
 80098d4:	d1e4      	bne.n	80098a0 <rt_test_009_001_execute+0x30>
    threads[1] = chThdCreateFromHeap(&heap1,
 80098d6:	4b35      	ldr	r3, [pc, #212]	; (80099ac <rt_test_009_001_execute+0x13c>)
 80098d8:	4a35      	ldr	r2, [pc, #212]	; (80099b0 <rt_test_009_001_execute+0x140>)
 80098da:	482e      	ldr	r0, [pc, #184]	; (8009994 <rt_test_009_001_execute+0x124>)
  test_set_step(4);
 80098dc:	2104      	movs	r1, #4
    threads[1] = chThdCreateFromHeap(&heap1,
 80098de:	e9cd 8300 	strd	r8, r3, [sp]
  test_set_step(4);
 80098e2:	6021      	str	r1, [r4, #0]
    threads[1] = chThdCreateFromHeap(&heap1,
 80098e4:	1eb3      	subs	r3, r6, #2
 80098e6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80098ea:	f7fc fb99 	bl	8006020 <chThdCreateFromHeap>
 80098ee:	4603      	mov	r3, r0
    test_assert(threads[1] != NULL, "thread creation failed");
 80098f0:	3000      	adds	r0, #0
 80098f2:	bf18      	it	ne
 80098f4:	2001      	movne	r0, #1
 80098f6:	492c      	ldr	r1, [pc, #176]	; (80099a8 <rt_test_009_001_execute+0x138>)
    threads[1] = chThdCreateFromHeap(&heap1,
 80098f8:	607b      	str	r3, [r7, #4]
    test_assert(threads[1] != NULL, "thread creation failed");
 80098fa:	f7f7 f811 	bl	8000920 <_test_assert>
 80098fe:	2800      	cmp	r0, #0
 8009900:	d1ce      	bne.n	80098a0 <rt_test_009_001_execute+0x30>
    threads[2] = chThdCreateFromHeap(&heap1,
 8009902:	4a2c      	ldr	r2, [pc, #176]	; (80099b4 <rt_test_009_001_execute+0x144>)
 8009904:	9201      	str	r2, [sp, #4]
  test_set_step(5);
 8009906:	2105      	movs	r1, #5
    threads[2] = chThdCreateFromHeap(&heap1,
 8009908:	1ef3      	subs	r3, r6, #3
  test_set_step(5);
 800990a:	6021      	str	r1, [r4, #0]
    threads[2] = chThdCreateFromHeap(&heap1,
 800990c:	f8cd 8000 	str.w	r8, [sp]
 8009910:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8009914:	4a28      	ldr	r2, [pc, #160]	; (80099b8 <rt_test_009_001_execute+0x148>)
 8009916:	481f      	ldr	r0, [pc, #124]	; (8009994 <rt_test_009_001_execute+0x124>)
 8009918:	f7fc fb82 	bl	8006020 <chThdCreateFromHeap>
 800991c:	4603      	mov	r3, r0
    test_assert(threads[2] == NULL, "thread creation not failed");
 800991e:	fab0 f080 	clz	r0, r0
 8009922:	0940      	lsrs	r0, r0, #5
 8009924:	4925      	ldr	r1, [pc, #148]	; (80099bc <rt_test_009_001_execute+0x14c>)
    threads[2] = chThdCreateFromHeap(&heap1,
 8009926:	60bb      	str	r3, [r7, #8]
    test_assert(threads[2] == NULL, "thread creation not failed");
 8009928:	f7f6 fffa 	bl	8000920 <_test_assert>
 800992c:	2800      	cmp	r0, #0
 800992e:	d1b7      	bne.n	80098a0 <rt_test_009_001_execute+0x30>
  test_set_step(6);
 8009930:	2306      	movs	r3, #6
 8009932:	6023      	str	r3, [r4, #0]
    test_wait_threads();
 8009934:	f7ff fc64 	bl	8009200 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 8009938:	4921      	ldr	r1, [pc, #132]	; (80099c0 <rt_test_009_001_execute+0x150>)
 800993a:	4822      	ldr	r0, [pc, #136]	; (80099c4 <rt_test_009_001_execute+0x154>)
 800993c:	f7f7 f890 	bl	8000a60 <_test_assert_sequence>
 8009940:	2800      	cmp	r0, #0
 8009942:	d1ad      	bne.n	80098a0 <rt_test_009_001_execute+0x30>
  test_set_step(7);
 8009944:	2307      	movs	r3, #7
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8009946:	a903      	add	r1, sp, #12
 8009948:	aa02      	add	r2, sp, #8
 800994a:	4812      	ldr	r0, [pc, #72]	; (8009994 <rt_test_009_001_execute+0x124>)
  test_set_step(7);
 800994c:	6023      	str	r3, [r4, #0]
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 800994e:	f7fc ff57 	bl	8006800 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 8009952:	1a28      	subs	r0, r5, r0
 8009954:	fab0 f080 	clz	r0, r0
 8009958:	491b      	ldr	r1, [pc, #108]	; (80099c8 <rt_test_009_001_execute+0x158>)
 800995a:	0940      	lsrs	r0, r0, #5
 800995c:	f7f6 ffe0 	bl	8000920 <_test_assert>
 8009960:	2800      	cmp	r0, #0
 8009962:	d19d      	bne.n	80098a0 <rt_test_009_001_execute+0x30>
    test_assert(total1 == total2, "total free space changed");
 8009964:	9805      	ldr	r0, [sp, #20]
 8009966:	9b03      	ldr	r3, [sp, #12]
 8009968:	4918      	ldr	r1, [pc, #96]	; (80099cc <rt_test_009_001_execute+0x15c>)
 800996a:	1ac0      	subs	r0, r0, r3
 800996c:	fab0 f080 	clz	r0, r0
 8009970:	0940      	lsrs	r0, r0, #5
 8009972:	f7f6 ffd5 	bl	8000920 <_test_assert>
 8009976:	2800      	cmp	r0, #0
 8009978:	d192      	bne.n	80098a0 <rt_test_009_001_execute+0x30>
    test_assert(largest1 == largest2, "largest fragment size changed");
 800997a:	9804      	ldr	r0, [sp, #16]
 800997c:	9b02      	ldr	r3, [sp, #8]
 800997e:	4914      	ldr	r1, [pc, #80]	; (80099d0 <rt_test_009_001_execute+0x160>)
 8009980:	1ac3      	subs	r3, r0, r3
 8009982:	4258      	negs	r0, r3
 8009984:	4158      	adcs	r0, r3
 8009986:	f7f6 ffcb 	bl	8000920 <_test_assert>
 800998a:	e789      	b.n	80098a0 <rt_test_009_001_execute+0x30>
 800998c:	200011a0 	.word	0x200011a0
 8009990:	20001b3c 	.word	0x20001b3c
 8009994:	200013ac 	.word	0x200013ac
 8009998:	0800c6d0 	.word	0x0800c6d0
 800999c:	0800d688 	.word	0x0800d688
 80099a0:	0800d8c4 	.word	0x0800d8c4
 80099a4:	20001b54 	.word	0x20001b54
 80099a8:	0800d8f0 	.word	0x0800d8f0
 80099ac:	0800d68c 	.word	0x0800d68c
 80099b0:	0800d8cc 	.word	0x0800d8cc
 80099b4:	0800d8d4 	.word	0x0800d8d4
 80099b8:	0800d8d8 	.word	0x0800d8d8
 80099bc:	0800d908 	.word	0x0800d908
 80099c0:	0800d774 	.word	0x0800d774
 80099c4:	0800d85c 	.word	0x0800d85c
 80099c8:	0800d860 	.word	0x0800d860
 80099cc:	0800d878 	.word	0x0800d878
 80099d0:	0800d894 	.word	0x0800d894
 80099d4:	08005061 	.word	0x08005061
	...

080099e0 <rt_test_008_007_execute>:

static void rt_test_008_007_execute(void) {
 80099e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 80099e4:	f8df 8154 	ldr.w	r8, [pc, #340]	; 8009b3c <rt_test_008_007_execute+0x15c>
 80099e8:	2101      	movs	r1, #1
static void rt_test_008_007_execute(void) {
 80099ea:	b08a      	sub	sp, #40	; 0x28
  test_set_step(1);
 80099ec:	f8c8 1000 	str.w	r1, [r8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80099f0:	2320      	movs	r3, #32
 80099f2:	f383 8811 	msr	BASEPRI, r3
  elp->next     = esp->next;
 80099f6:	4e47      	ldr	r6, [pc, #284]	; (8009b14 <rt_test_008_007_execute+0x134>)
  elp->listener = currp;
 80099f8:	4c47      	ldr	r4, [pc, #284]	; (8009b18 <rt_test_008_007_execute+0x138>)
  elp->next     = esp->next;
 80099fa:	f10d 0928 	add.w	r9, sp, #40	; 0x28
  _dbg_check_lock();
 80099fe:	f7f9 fedf 	bl	80037c0 <_dbg_check_lock>
 8009a02:	6833      	ldr	r3, [r6, #0]
 8009a04:	f849 3d14 	str.w	r3, [r9, #-20]!
  elp->listener = currp;
 8009a08:	69a3      	ldr	r3, [r4, #24]
 8009a0a:	9306      	str	r3, [sp, #24]
  elp->flags    = (eventflags_t)0;
 8009a0c:	2200      	movs	r2, #0
  elp->wflags   = wflags;
 8009a0e:	f04f 33ff 	mov.w	r3, #4294967295
 8009a12:	e9cd 2308 	strd	r2, r3, [sp, #32]
  elp->events   = events;
 8009a16:	9107      	str	r1, [sp, #28]
  esp->next     = elp;
 8009a18:	f8c6 9000 	str.w	r9, [r6]
  _dbg_check_unlock();
 8009a1c:	f7f9 fe68 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009a20:	6823      	ldr	r3, [r4, #0]
 8009a22:	42a3      	cmp	r3, r4
 8009a24:	d004      	beq.n	8009a30 <rt_test_008_007_execute+0x50>
 8009a26:	69a2      	ldr	r2, [r4, #24]
 8009a28:	689b      	ldr	r3, [r3, #8]
 8009a2a:	6892      	ldr	r2, [r2, #8]
 8009a2c:	429a      	cmp	r2, r3
 8009a2e:	d36d      	bcc.n	8009b0c <rt_test_008_007_execute+0x12c>
 8009a30:	2100      	movs	r1, #0
 8009a32:	f381 8811 	msr	BASEPRI, r1
 8009a36:	2320      	movs	r3, #32
 8009a38:	f383 8811 	msr	BASEPRI, r3
  elp->next     = esp->next;
 8009a3c:	4d37      	ldr	r5, [pc, #220]	; (8009b1c <rt_test_008_007_execute+0x13c>)
 8009a3e:	af0a      	add	r7, sp, #40	; 0x28
  _dbg_check_lock();
 8009a40:	f7f9 febe 	bl	80037c0 <_dbg_check_lock>
 8009a44:	682b      	ldr	r3, [r5, #0]
 8009a46:	f847 3d28 	str.w	r3, [r7, #-40]!
  elp->listener = currp;
 8009a4a:	69a3      	ldr	r3, [r4, #24]
 8009a4c:	9301      	str	r3, [sp, #4]
  elp->events   = events;
 8009a4e:	2204      	movs	r2, #4
  elp->wflags   = wflags;
 8009a50:	f04f 33ff 	mov.w	r3, #4294967295
 8009a54:	9304      	str	r3, [sp, #16]
  elp->flags    = (eventflags_t)0;
 8009a56:	9103      	str	r1, [sp, #12]
  elp->events   = events;
 8009a58:	9202      	str	r2, [sp, #8]
  esp->next     = elp;
 8009a5a:	602f      	str	r7, [r5, #0]
  _dbg_check_unlock();
 8009a5c:	f7f9 fe48 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009a60:	6823      	ldr	r3, [r4, #0]
 8009a62:	42a3      	cmp	r3, r4
 8009a64:	d004      	beq.n	8009a70 <rt_test_008_007_execute+0x90>
 8009a66:	69a2      	ldr	r2, [r4, #24]
 8009a68:	689b      	ldr	r3, [r3, #8]
 8009a6a:	6892      	ldr	r2, [r2, #8]
 8009a6c:	429a      	cmp	r2, r3
 8009a6e:	d349      	bcc.n	8009b04 <rt_test_008_007_execute+0x124>
 8009a70:	2300      	movs	r3, #0
 8009a72:	f383 8811 	msr	BASEPRI, r3
  }

  /* [8.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8009a76:	2302      	movs	r3, #2
 8009a78:	f8c8 3000 	str.w	r3, [r8]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009a7c:	f7fd ff78 	bl	8007970 <test_wait_tick>
 8009a80:	69a2      	ldr	r2, [r4, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009a82:	4b27      	ldr	r3, [pc, #156]	; (8009b20 <rt_test_008_007_execute+0x140>)
 8009a84:	6891      	ldr	r1, [r2, #8]
 8009a86:	4a27      	ldr	r2, [pc, #156]	; (8009b24 <rt_test_008_007_execute+0x144>)
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009a88:	4682      	mov	sl, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009a8a:	3901      	subs	r1, #1
 8009a8c:	4826      	ldr	r0, [pc, #152]	; (8009b28 <rt_test_008_007_execute+0x148>)
 8009a8e:	f7fe fca7 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009a92:	4a26      	ldr	r2, [pc, #152]	; (8009b2c <rt_test_008_007_execute+0x14c>)
  }

  /* [8.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8009a94:	2303      	movs	r3, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009a96:	6010      	str	r0, [r2, #0]
  test_set_step(3);
 8009a98:	f8c8 3000 	str.w	r3, [r8]
  {
    m = chEvtWaitAll(5);
 8009a9c:	f7fa f810 	bl	8003ac0 <chEvtWaitAll.constprop.35>
    test_assert_time_window(target_time,
 8009aa0:	f50a 7102 	add.w	r1, sl, #520	; 0x208
 8009aa4:	f50a 70fa 	add.w	r0, sl, #500	; 0x1f4
 8009aa8:	f7f6 fe7a 	bl	80007a0 <_test_assert_time_window.constprop.1>
 8009aac:	b110      	cbz	r0, 8009ab4 <rt_test_008_007_execute+0xd4>
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
}
 8009aae:	b00a      	add	sp, #40	; 0x28
 8009ab0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009ab4:	f7f9 ff44 	bl	8003940 <chEvtGetAndClearEvents.constprop.41>
    test_assert(m == 0, "stuck event");
 8009ab8:	fab0 f080 	clz	r0, r0
 8009abc:	0940      	lsrs	r0, r0, #5
 8009abe:	491c      	ldr	r1, [pc, #112]	; (8009b30 <rt_test_008_007_execute+0x150>)
 8009ac0:	f7f6 ff2e 	bl	8000920 <_test_assert>
 8009ac4:	2800      	cmp	r0, #0
 8009ac6:	d1f2      	bne.n	8009aae <rt_test_008_007_execute+0xce>
    test_wait_threads();
 8009ac8:	f7ff fb9a 	bl	8009200 <test_wait_threads>
  test_set_step(4);
 8009acc:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el1);
 8009ace:	4649      	mov	r1, r9
 8009ad0:	4810      	ldr	r0, [pc, #64]	; (8009b14 <rt_test_008_007_execute+0x134>)
  test_set_step(4);
 8009ad2:	f8c8 3000 	str.w	r3, [r8]
    chEvtUnregister(&es1, &el1);
 8009ad6:	f7fb ff93 	bl	8005a00 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 8009ada:	4639      	mov	r1, r7
 8009adc:	480f      	ldr	r0, [pc, #60]	; (8009b1c <rt_test_008_007_execute+0x13c>)
 8009ade:	f7fb ff8f 	bl	8005a00 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 8009ae2:	6830      	ldr	r0, [r6, #0]
 8009ae4:	4913      	ldr	r1, [pc, #76]	; (8009b34 <rt_test_008_007_execute+0x154>)
 8009ae6:	1b82      	subs	r2, r0, r6
 8009ae8:	4250      	negs	r0, r2
 8009aea:	4150      	adcs	r0, r2
 8009aec:	f7f6 ff18 	bl	8000920 <_test_assert>
 8009af0:	2800      	cmp	r0, #0
 8009af2:	d1dc      	bne.n	8009aae <rt_test_008_007_execute+0xce>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 8009af4:	6828      	ldr	r0, [r5, #0]
 8009af6:	490f      	ldr	r1, [pc, #60]	; (8009b34 <rt_test_008_007_execute+0x154>)
 8009af8:	1b43      	subs	r3, r0, r5
 8009afa:	4258      	negs	r0, r3
 8009afc:	4158      	adcs	r0, r3
 8009afe:	f7f6 ff0f 	bl	8000920 <_test_assert>
 8009b02:	e7d4      	b.n	8009aae <rt_test_008_007_execute+0xce>
  __ASM volatile ("cpsid i" : : : "memory");
 8009b04:	b672      	cpsid	i
 8009b06:	4b0c      	ldr	r3, [pc, #48]	; (8009b38 <rt_test_008_007_execute+0x158>)
 8009b08:	62e3      	str	r3, [r4, #44]	; 0x2c
 8009b0a:	e7fe      	b.n	8009b0a <rt_test_008_007_execute+0x12a>
 8009b0c:	b672      	cpsid	i
 8009b0e:	4b0a      	ldr	r3, [pc, #40]	; (8009b38 <rt_test_008_007_execute+0x158>)
 8009b10:	62e3      	str	r3, [r4, #44]	; 0x2c
 8009b12:	e7fe      	b.n	8009b12 <rt_test_008_007_execute+0x132>
 8009b14:	20000c0c 	.word	0x20000c0c
 8009b18:	200011a0 	.word	0x200011a0
 8009b1c:	20000c10 	.word	0x20000c10
 8009b20:	0800d688 	.word	0x0800d688
 8009b24:	080076d1 	.word	0x080076d1
 8009b28:	20001428 	.word	0x20001428
 8009b2c:	20001b54 	.word	0x20001b54
 8009b30:	0800d840 	.word	0x0800d840
 8009b34:	0800d754 	.word	0x0800d754
 8009b38:	0800bc14 	.word	0x0800bc14
 8009b3c:	20001b3c 	.word	0x20001b3c

08009b40 <rt_test_008_005_execute>:
static void rt_test_008_005_execute(void) {
 8009b40:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(5);
 8009b42:	2005      	movs	r0, #5
  test_set_step(2);
 8009b44:	4c28      	ldr	r4, [pc, #160]	; (8009be8 <rt_test_008_005_execute+0xa8>)
    chEvtAddEvents(5);
 8009b46:	f7fb ff33 	bl	80059b0 <chEvtAddEvents>
  test_set_step(2);
 8009b4a:	2302      	movs	r3, #2
 8009b4c:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAll(5);
 8009b4e:	f7f9 ffb7 	bl	8003ac0 <chEvtWaitAll.constprop.35>
    test_assert(m == 5, "unexpected pending bit");
 8009b52:	f1a0 0005 	sub.w	r0, r0, #5
 8009b56:	fab0 f080 	clz	r0, r0
 8009b5a:	4924      	ldr	r1, [pc, #144]	; (8009bec <rt_test_008_005_execute+0xac>)
 8009b5c:	0940      	lsrs	r0, r0, #5
 8009b5e:	f7f6 fedf 	bl	8000920 <_test_assert>
 8009b62:	b100      	cbz	r0, 8009b66 <rt_test_008_005_execute+0x26>
}
 8009b64:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009b66:	f7f9 feeb 	bl	8003940 <chEvtGetAndClearEvents.constprop.41>
    test_assert(m == 0, "stuck event");
 8009b6a:	fab0 f080 	clz	r0, r0
 8009b6e:	0940      	lsrs	r0, r0, #5
 8009b70:	491f      	ldr	r1, [pc, #124]	; (8009bf0 <rt_test_008_005_execute+0xb0>)
 8009b72:	f7f6 fed5 	bl	8000920 <_test_assert>
 8009b76:	2800      	cmp	r0, #0
 8009b78:	d1f4      	bne.n	8009b64 <rt_test_008_005_execute+0x24>
    chEvtAddEvents(4);
 8009b7a:	2004      	movs	r0, #4
 8009b7c:	f7fb ff18 	bl	80059b0 <chEvtAddEvents>
  test_set_step(4);
 8009b80:	2304      	movs	r3, #4
 8009b82:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009b84:	f7fd fef4 	bl	8007970 <test_wait_tick>
  return ch.rlist.current;
 8009b88:	4b1a      	ldr	r3, [pc, #104]	; (8009bf4 <rt_test_008_005_execute+0xb4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009b8a:	4a1b      	ldr	r2, [pc, #108]	; (8009bf8 <rt_test_008_005_execute+0xb8>)
 8009b8c:	699b      	ldr	r3, [r3, #24]
 8009b8e:	6899      	ldr	r1, [r3, #8]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009b90:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009b92:	3901      	subs	r1, #1
 8009b94:	4819      	ldr	r0, [pc, #100]	; (8009bfc <rt_test_008_005_execute+0xbc>)
 8009b96:	f7fe fc23 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009b9a:	4a19      	ldr	r2, [pc, #100]	; (8009c00 <rt_test_008_005_execute+0xc0>)
  test_set_step(5);
 8009b9c:	2305      	movs	r3, #5
 8009b9e:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009ba0:	6010      	str	r0, [r2, #0]
    m = chEvtWaitAll(5);
 8009ba2:	f7f9 ff8d 	bl	8003ac0 <chEvtWaitAll.constprop.35>
    test_assert_time_window(target_time,
 8009ba6:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitAll(5);
 8009baa:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
 8009bac:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8009bb0:	f7f6 fdf6 	bl	80007a0 <_test_assert_time_window.constprop.1>
 8009bb4:	2800      	cmp	r0, #0
 8009bb6:	d1d5      	bne.n	8009b64 <rt_test_008_005_execute+0x24>
    test_assert(m == 5, "event flags error");
 8009bb8:	f1a4 0005 	sub.w	r0, r4, #5
 8009bbc:	fab0 f080 	clz	r0, r0
 8009bc0:	0940      	lsrs	r0, r0, #5
 8009bc2:	4910      	ldr	r1, [pc, #64]	; (8009c04 <rt_test_008_005_execute+0xc4>)
 8009bc4:	f7f6 feac 	bl	8000920 <_test_assert>
 8009bc8:	2800      	cmp	r0, #0
 8009bca:	d1cb      	bne.n	8009b64 <rt_test_008_005_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009bcc:	f7f9 feb8 	bl	8003940 <chEvtGetAndClearEvents.constprop.41>
    test_assert(m == 0, "stuck event");
 8009bd0:	fab0 f080 	clz	r0, r0
 8009bd4:	0940      	lsrs	r0, r0, #5
 8009bd6:	4906      	ldr	r1, [pc, #24]	; (8009bf0 <rt_test_008_005_execute+0xb0>)
 8009bd8:	f7f6 fea2 	bl	8000920 <_test_assert>
 8009bdc:	2800      	cmp	r0, #0
 8009bde:	d1c1      	bne.n	8009b64 <rt_test_008_005_execute+0x24>
}
 8009be0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 8009be4:	f7ff bb0c 	b.w	8009200 <test_wait_threads>
 8009be8:	20001b3c 	.word	0x20001b3c
 8009bec:	0800d7e4 	.word	0x0800d7e4
 8009bf0:	0800d840 	.word	0x0800d840
 8009bf4:	200011a0 	.word	0x200011a0
 8009bf8:	08007761 	.word	0x08007761
 8009bfc:	20001428 	.word	0x20001428
 8009c00:	20001b54 	.word	0x20001b54
 8009c04:	0800d7fc 	.word	0x0800d7fc
	...

08009c10 <rt_test_008_004_execute>:
static void rt_test_008_004_execute(void) {
 8009c10:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(5);
 8009c12:	2005      	movs	r0, #5
  test_set_step(2);
 8009c14:	4c27      	ldr	r4, [pc, #156]	; (8009cb4 <rt_test_008_004_execute+0xa4>)
    chEvtAddEvents(5);
 8009c16:	f7fb fecb 	bl	80059b0 <chEvtAddEvents>
  test_set_step(2);
 8009c1a:	2302      	movs	r3, #2
 8009c1c:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 8009c1e:	f7f9 ff1f 	bl	8003a60 <chEvtWaitAny.constprop.36>
    test_assert(m == 5, "unexpected pending bit");
 8009c22:	f1a0 0005 	sub.w	r0, r0, #5
 8009c26:	fab0 f080 	clz	r0, r0
 8009c2a:	4923      	ldr	r1, [pc, #140]	; (8009cb8 <rt_test_008_004_execute+0xa8>)
 8009c2c:	0940      	lsrs	r0, r0, #5
 8009c2e:	f7f6 fe77 	bl	8000920 <_test_assert>
 8009c32:	b100      	cbz	r0, 8009c36 <rt_test_008_004_execute+0x26>
}
 8009c34:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009c36:	f7f9 fe83 	bl	8003940 <chEvtGetAndClearEvents.constprop.41>
    test_assert(m == 0, "stuck event");
 8009c3a:	fab0 f080 	clz	r0, r0
 8009c3e:	0940      	lsrs	r0, r0, #5
 8009c40:	491e      	ldr	r1, [pc, #120]	; (8009cbc <rt_test_008_004_execute+0xac>)
 8009c42:	f7f6 fe6d 	bl	8000920 <_test_assert>
 8009c46:	2800      	cmp	r0, #0
 8009c48:	d1f4      	bne.n	8009c34 <rt_test_008_004_execute+0x24>
  test_set_step(3);
 8009c4a:	2303      	movs	r3, #3
 8009c4c:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009c4e:	f7fd fe8f 	bl	8007970 <test_wait_tick>
 8009c52:	4b1b      	ldr	r3, [pc, #108]	; (8009cc0 <rt_test_008_004_execute+0xb0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009c54:	4a1b      	ldr	r2, [pc, #108]	; (8009cc4 <rt_test_008_004_execute+0xb4>)
 8009c56:	699b      	ldr	r3, [r3, #24]
 8009c58:	6899      	ldr	r1, [r3, #8]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009c5a:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009c5c:	3901      	subs	r1, #1
 8009c5e:	481a      	ldr	r0, [pc, #104]	; (8009cc8 <rt_test_008_004_execute+0xb8>)
 8009c60:	f7fe fbbe 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009c64:	4a19      	ldr	r2, [pc, #100]	; (8009ccc <rt_test_008_004_execute+0xbc>)
  test_set_step(4);
 8009c66:	2304      	movs	r3, #4
 8009c68:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009c6a:	6010      	str	r0, [r2, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 8009c6c:	f7f9 fef8 	bl	8003a60 <chEvtWaitAny.constprop.36>
    test_assert_time_window(target_time,
 8009c70:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitAny(ALL_EVENTS);
 8009c74:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
 8009c76:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8009c7a:	f7f6 fd91 	bl	80007a0 <_test_assert_time_window.constprop.1>
 8009c7e:	2800      	cmp	r0, #0
 8009c80:	d1d8      	bne.n	8009c34 <rt_test_008_004_execute+0x24>
    test_assert(m == 1, "event flag error");
 8009c82:	f1a4 0001 	sub.w	r0, r4, #1
 8009c86:	fab0 f080 	clz	r0, r0
 8009c8a:	0940      	lsrs	r0, r0, #5
 8009c8c:	4910      	ldr	r1, [pc, #64]	; (8009cd0 <rt_test_008_004_execute+0xc0>)
 8009c8e:	f7f6 fe47 	bl	8000920 <_test_assert>
 8009c92:	2800      	cmp	r0, #0
 8009c94:	d1ce      	bne.n	8009c34 <rt_test_008_004_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009c96:	f7f9 fe53 	bl	8003940 <chEvtGetAndClearEvents.constprop.41>
    test_assert(m == 0, "stuck event");
 8009c9a:	fab0 f080 	clz	r0, r0
 8009c9e:	0940      	lsrs	r0, r0, #5
 8009ca0:	4906      	ldr	r1, [pc, #24]	; (8009cbc <rt_test_008_004_execute+0xac>)
 8009ca2:	f7f6 fe3d 	bl	8000920 <_test_assert>
 8009ca6:	2800      	cmp	r0, #0
 8009ca8:	d1c4      	bne.n	8009c34 <rt_test_008_004_execute+0x24>
}
 8009caa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 8009cae:	f7ff baa7 	b.w	8009200 <test_wait_threads>
 8009cb2:	bf00      	nop
 8009cb4:	20001b3c 	.word	0x20001b3c
 8009cb8:	0800d7e4 	.word	0x0800d7e4
 8009cbc:	0800d840 	.word	0x0800d840
 8009cc0:	200011a0 	.word	0x200011a0
 8009cc4:	08007761 	.word	0x08007761
 8009cc8:	20001428 	.word	0x20001428
 8009ccc:	20001b54 	.word	0x20001b54
 8009cd0:	0800d7c0 	.word	0x0800d7c0
	...

08009ce0 <rt_test_008_003_execute>:
static void rt_test_008_003_execute(void) {
 8009ce0:	b538      	push	{r3, r4, r5, lr}
    chEvtAddEvents(7);
 8009ce2:	2007      	movs	r0, #7
  test_set_step(2);
 8009ce4:	4c33      	ldr	r4, [pc, #204]	; (8009db4 <rt_test_008_003_execute+0xd4>)
    chEvtAddEvents(7);
 8009ce6:	f7fb fe63 	bl	80059b0 <chEvtAddEvents>
  test_set_step(2);
 8009cea:	2302      	movs	r3, #2
 8009cec:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 8009cee:	f7f9 fe87 	bl	8003a00 <chEvtWaitOne.constprop.37>
    test_assert(m == 1, "single event error");
 8009cf2:	f1a0 0001 	sub.w	r0, r0, #1
 8009cf6:	fab0 f080 	clz	r0, r0
 8009cfa:	492f      	ldr	r1, [pc, #188]	; (8009db8 <rt_test_008_003_execute+0xd8>)
 8009cfc:	0940      	lsrs	r0, r0, #5
 8009cfe:	f7f6 fe0f 	bl	8000920 <_test_assert>
 8009d02:	b100      	cbz	r0, 8009d06 <rt_test_008_003_execute+0x26>
}
 8009d04:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtWaitOne(ALL_EVENTS);
 8009d06:	f7f9 fe7b 	bl	8003a00 <chEvtWaitOne.constprop.37>
    test_assert(m == 2, "single event error");
 8009d0a:	f1a0 0002 	sub.w	r0, r0, #2
 8009d0e:	fab0 f080 	clz	r0, r0
 8009d12:	4929      	ldr	r1, [pc, #164]	; (8009db8 <rt_test_008_003_execute+0xd8>)
 8009d14:	0940      	lsrs	r0, r0, #5
 8009d16:	f7f6 fe03 	bl	8000920 <_test_assert>
 8009d1a:	2800      	cmp	r0, #0
 8009d1c:	d1f2      	bne.n	8009d04 <rt_test_008_003_execute+0x24>
    m = chEvtWaitOne(ALL_EVENTS);
 8009d1e:	f7f9 fe6f 	bl	8003a00 <chEvtWaitOne.constprop.37>
    test_assert(m == 4, "single event error");
 8009d22:	f1a0 0004 	sub.w	r0, r0, #4
 8009d26:	fab0 f080 	clz	r0, r0
 8009d2a:	4923      	ldr	r1, [pc, #140]	; (8009db8 <rt_test_008_003_execute+0xd8>)
 8009d2c:	0940      	lsrs	r0, r0, #5
 8009d2e:	f7f6 fdf7 	bl	8000920 <_test_assert>
 8009d32:	2800      	cmp	r0, #0
 8009d34:	d1e6      	bne.n	8009d04 <rt_test_008_003_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009d36:	f7f9 fe03 	bl	8003940 <chEvtGetAndClearEvents.constprop.41>
    test_assert(m == 0, "stuck event");
 8009d3a:	fab0 f080 	clz	r0, r0
 8009d3e:	0940      	lsrs	r0, r0, #5
 8009d40:	491e      	ldr	r1, [pc, #120]	; (8009dbc <rt_test_008_003_execute+0xdc>)
 8009d42:	f7f6 fded 	bl	8000920 <_test_assert>
 8009d46:	2800      	cmp	r0, #0
 8009d48:	d1dc      	bne.n	8009d04 <rt_test_008_003_execute+0x24>
  test_set_step(3);
 8009d4a:	2303      	movs	r3, #3
 8009d4c:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009d4e:	f7fd fe0f 	bl	8007970 <test_wait_tick>
 8009d52:	4b1b      	ldr	r3, [pc, #108]	; (8009dc0 <rt_test_008_003_execute+0xe0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009d54:	4a1b      	ldr	r2, [pc, #108]	; (8009dc4 <rt_test_008_003_execute+0xe4>)
 8009d56:	699b      	ldr	r3, [r3, #24]
 8009d58:	6899      	ldr	r1, [r3, #8]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8009d5a:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009d5c:	3901      	subs	r1, #1
 8009d5e:	481a      	ldr	r0, [pc, #104]	; (8009dc8 <rt_test_008_003_execute+0xe8>)
 8009d60:	f7fe fb3e 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009d64:	4a19      	ldr	r2, [pc, #100]	; (8009dcc <rt_test_008_003_execute+0xec>)
  test_set_step(4);
 8009d66:	2304      	movs	r3, #4
 8009d68:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8009d6a:	6010      	str	r0, [r2, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 8009d6c:	f7f9 fe48 	bl	8003a00 <chEvtWaitOne.constprop.37>
    test_assert_time_window(target_time,
 8009d70:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitOne(ALL_EVENTS);
 8009d74:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
 8009d76:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8009d7a:	f7f6 fd11 	bl	80007a0 <_test_assert_time_window.constprop.1>
 8009d7e:	2800      	cmp	r0, #0
 8009d80:	d1c0      	bne.n	8009d04 <rt_test_008_003_execute+0x24>
    test_assert(m == 1, "event flag error");
 8009d82:	f1a4 0001 	sub.w	r0, r4, #1
 8009d86:	fab0 f080 	clz	r0, r0
 8009d8a:	0940      	lsrs	r0, r0, #5
 8009d8c:	4910      	ldr	r1, [pc, #64]	; (8009dd0 <rt_test_008_003_execute+0xf0>)
 8009d8e:	f7f6 fdc7 	bl	8000920 <_test_assert>
 8009d92:	2800      	cmp	r0, #0
 8009d94:	d1b6      	bne.n	8009d04 <rt_test_008_003_execute+0x24>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8009d96:	f7f9 fdd3 	bl	8003940 <chEvtGetAndClearEvents.constprop.41>
    test_assert(m == 0, "stuck event");
 8009d9a:	fab0 f080 	clz	r0, r0
 8009d9e:	0940      	lsrs	r0, r0, #5
 8009da0:	4906      	ldr	r1, [pc, #24]	; (8009dbc <rt_test_008_003_execute+0xdc>)
 8009da2:	f7f6 fdbd 	bl	8000920 <_test_assert>
 8009da6:	2800      	cmp	r0, #0
 8009da8:	d1ac      	bne.n	8009d04 <rt_test_008_003_execute+0x24>
}
 8009daa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 8009dae:	f7ff ba27 	b.w	8009200 <test_wait_threads>
 8009db2:	bf00      	nop
 8009db4:	20001b3c 	.word	0x20001b3c
 8009db8:	0800d79c 	.word	0x0800d79c
 8009dbc:	0800d840 	.word	0x0800d840
 8009dc0:	200011a0 	.word	0x200011a0
 8009dc4:	08007761 	.word	0x08007761
 8009dc8:	20001428 	.word	0x20001428
 8009dcc:	20001b54 	.word	0x20001b54
 8009dd0:	0800d7c0 	.word	0x0800d7c0
	...

08009de0 <rt_test_007_001_execute>:
 * - [7.1.1] Starting the messenger thread.
 * - [7.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void rt_test_007_001_execute(void) {
 8009de0:	b570      	push	{r4, r5, r6, lr}
 8009de2:	4d15      	ldr	r5, [pc, #84]	; (8009e38 <rt_test_007_001_execute+0x58>)
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8009de4:	4c15      	ldr	r4, [pc, #84]	; (8009e3c <rt_test_007_001_execute+0x5c>)
 8009de6:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8009de8:	4a15      	ldr	r2, [pc, #84]	; (8009e40 <rt_test_007_001_execute+0x60>)
 8009dea:	6899      	ldr	r1, [r3, #8]
 8009dec:	4815      	ldr	r0, [pc, #84]	; (8009e44 <rt_test_007_001_execute+0x64>)
 8009dee:	3101      	adds	r1, #1
  test_set_step(1);
 8009df0:	2601      	movs	r6, #1
 8009df2:	6026      	str	r6, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8009df4:	f7fe faf4 	bl	80083e0 <chThdCreateStatic.constprop.60>
 8009df8:	4a13      	ldr	r2, [pc, #76]	; (8009e48 <rt_test_007_001_execute+0x68>)
                                   msg_thread1, chThdGetSelfX());
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8009dfa:	2302      	movs	r3, #2
 8009dfc:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8009dfe:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 8009e00:	2404      	movs	r4, #4
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
 8009e02:	f7fb fd2d 	bl	8005860 <chMsgWait>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 8009e06:	f890 2020 	ldrb.w	r2, [r0, #32]
 8009e0a:	2a0d      	cmp	r2, #13
 8009e0c:	d003      	beq.n	8009e16 <rt_test_007_001_execute+0x36>
 8009e0e:	b672      	cpsid	i
 8009e10:	4b0e      	ldr	r3, [pc, #56]	; (8009e4c <rt_test_007_001_execute+0x6c>)
 8009e12:	62eb      	str	r3, [r5, #44]	; 0x2c
 8009e14:	e7fe      	b.n	8009e14 <rt_test_007_001_execute+0x34>
  return tp->u.sentmsg;
 8009e16:	6a46      	ldr	r6, [r0, #36]	; 0x24
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
 8009e18:	4631      	mov	r1, r6
 8009e1a:	f7fb fcf1 	bl	8005800 <chMsgRelease>
      test_emit_token(msg);
 8009e1e:	b2f0      	uxtb	r0, r6
 8009e20:	f7fa fb5e 	bl	80044e0 <test_emit_token>
    for (i = 0; i < 4; i++) {
 8009e24:	3c01      	subs	r4, #1
 8009e26:	d1ec      	bne.n	8009e02 <rt_test_007_001_execute+0x22>
    }
    test_wait_threads();
 8009e28:	f7ff f9ea 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8009e2c:	4908      	ldr	r1, [pc, #32]	; (8009e50 <rt_test_007_001_execute+0x70>)
 8009e2e:	4809      	ldr	r0, [pc, #36]	; (8009e54 <rt_test_007_001_execute+0x74>)
  }
}
 8009e30:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_sequence("ABCD", "invalid sequence");
 8009e34:	f7f6 be14 	b.w	8000a60 <_test_assert_sequence>
 8009e38:	200011a0 	.word	0x200011a0
 8009e3c:	20001b3c 	.word	0x20001b3c
 8009e40:	08005981 	.word	0x08005981
 8009e44:	20001428 	.word	0x20001428
 8009e48:	20001b54 	.word	0x20001b54
 8009e4c:	0800bd24 	.word	0x0800bd24
 8009e50:	0800d774 	.word	0x0800d774
 8009e54:	0800c628 	.word	0x0800c628
	...

08009e60 <rt_test_006_009_execute>:

static void rt_test_006_009_execute(void) {
 8009e60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009e62:	4b1c      	ldr	r3, [pc, #112]	; (8009ed4 <rt_test_006_009_execute+0x74>)

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009e64:	4e1c      	ldr	r6, [pc, #112]	; (8009ed8 <rt_test_006_009_execute+0x78>)
  return chThdGetSelfX()->prio;
 8009e66:	699b      	ldr	r3, [r3, #24]
  test_set_step(2);
 8009e68:	4c1c      	ldr	r4, [pc, #112]	; (8009edc <rt_test_006_009_execute+0x7c>)
 8009e6a:	689f      	ldr	r7, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009e6c:	4a1c      	ldr	r2, [pc, #112]	; (8009ee0 <rt_test_006_009_execute+0x80>)
 8009e6e:	4b1d      	ldr	r3, [pc, #116]	; (8009ee4 <rt_test_006_009_execute+0x84>)
 8009e70:	4d1d      	ldr	r5, [pc, #116]	; (8009ee8 <rt_test_006_009_execute+0x88>)
 8009e72:	1c79      	adds	r1, r7, #1
  test_set_step(2);
 8009e74:	f04f 0c02 	mov.w	ip, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009e78:	4630      	mov	r0, r6
  test_set_step(2);
 8009e7a:	f8c4 c000 	str.w	ip, [r4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009e7e:	f7fe faaf 	bl	80083e0 <chThdCreateStatic.constprop.60>
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8009e82:	f04f 0c03 	mov.w	ip, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8009e86:	6028      	str	r0, [r5, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8009e88:	1cb9      	adds	r1, r7, #2
 8009e8a:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 8009e8e:	4b17      	ldr	r3, [pc, #92]	; (8009eec <rt_test_006_009_execute+0x8c>)
 8009e90:	4a17      	ldr	r2, [pc, #92]	; (8009ef0 <rt_test_006_009_execute+0x90>)
  test_set_step(3);
 8009e92:	f8c4 c000 	str.w	ip, [r4]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8009e96:	f7fe faa3 	bl	80083e0 <chThdCreateStatic.constprop.60>

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8009e9a:	1cf9      	adds	r1, r7, #3
 8009e9c:	4a15      	ldr	r2, [pc, #84]	; (8009ef4 <rt_test_006_009_execute+0x94>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8009e9e:	6068      	str	r0, [r5, #4]
  test_set_step(4);
 8009ea0:	2704      	movs	r7, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8009ea2:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8009ea6:	4b14      	ldr	r3, [pc, #80]	; (8009ef8 <rt_test_006_009_execute+0x98>)
  test_set_step(4);
 8009ea8:	6027      	str	r7, [r4, #0]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8009eaa:	f7fe fa99 	bl	80083e0 <chThdCreateStatic.constprop.60>
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 8009eae:	2305      	movs	r3, #5
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8009eb0:	60a8      	str	r0, [r5, #8]
  test_set_step(5);
 8009eb2:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8009eb4:	f7f9 fd14 	bl	80038e0 <chCondSignal.constprop.50>
  }

  /* [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 8009eb8:	2306      	movs	r3, #6
 8009eba:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8009ebc:	f7f9 fd10 	bl	80038e0 <chCondSignal.constprop.50>
  }

  /* [6.9.7] Checking the order of operations.*/
  test_set_step(7);
 8009ec0:	2307      	movs	r3, #7
 8009ec2:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8009ec4:	f7ff f99c 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 8009ec8:	490c      	ldr	r1, [pc, #48]	; (8009efc <rt_test_006_009_execute+0x9c>)
 8009eca:	480d      	ldr	r0, [pc, #52]	; (8009f00 <rt_test_006_009_execute+0xa0>)
  }
}
 8009ecc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
 8009ed0:	f7f6 bdc6 	b.w	8000a60 <_test_assert_sequence>
 8009ed4:	200011a0 	.word	0x200011a0
 8009ed8:	20001428 	.word	0x20001428
 8009edc:	20001b3c 	.word	0x20001b3c
 8009ee0:	08006311 	.word	0x08006311
 8009ee4:	0800d688 	.word	0x0800d688
 8009ee8:	20001b54 	.word	0x20001b54
 8009eec:	0800d8d4 	.word	0x0800d8d4
 8009ef0:	080063d1 	.word	0x080063d1
 8009ef4:	08006471 	.word	0x08006471
 8009ef8:	0800d68c 	.word	0x0800d68c
 8009efc:	0800d774 	.word	0x0800d774
 8009f00:	0800d788 	.word	0x0800d788
	...

08009f10 <rt_test_006_008_execute>:
static void rt_test_006_008_execute(void) {
 8009f10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 8009f12:	4d30      	ldr	r5, [pc, #192]	; (8009fd4 <rt_test_006_008_execute+0xc4>)
  test_set_step(1);
 8009f14:	4f30      	ldr	r7, [pc, #192]	; (8009fd8 <rt_test_006_008_execute+0xc8>)
  return chThdGetSelfX()->prio;
 8009f16:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8009f18:	4b30      	ldr	r3, [pc, #192]	; (8009fdc <rt_test_006_008_execute+0xcc>)
 8009f1a:	6896      	ldr	r6, [r2, #8]
 8009f1c:	4830      	ldr	r0, [pc, #192]	; (8009fe0 <rt_test_006_008_execute+0xd0>)
 8009f1e:	4a31      	ldr	r2, [pc, #196]	; (8009fe4 <rt_test_006_008_execute+0xd4>)
 8009f20:	4c31      	ldr	r4, [pc, #196]	; (8009fe8 <rt_test_006_008_execute+0xd8>)
  test_set_step(1);
 8009f22:	f04f 0c01 	mov.w	ip, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8009f26:	1c71      	adds	r1, r6, #1
  test_set_step(1);
 8009f28:	f8c7 c000 	str.w	ip, [r7]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8009f2c:	f7fe fa58 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8009f30:	1cb1      	adds	r1, r6, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8009f32:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8009f34:	4b2d      	ldr	r3, [pc, #180]	; (8009fec <rt_test_006_008_execute+0xdc>)
 8009f36:	4a2b      	ldr	r2, [pc, #172]	; (8009fe4 <rt_test_006_008_execute+0xd4>)
 8009f38:	482d      	ldr	r0, [pc, #180]	; (8009ff0 <rt_test_006_008_execute+0xe0>)
 8009f3a:	f7fe fa51 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8009f3e:	1cf1      	adds	r1, r6, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8009f40:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8009f42:	4b2c      	ldr	r3, [pc, #176]	; (8009ff4 <rt_test_006_008_execute+0xe4>)
 8009f44:	4a27      	ldr	r2, [pc, #156]	; (8009fe4 <rt_test_006_008_execute+0xd4>)
 8009f46:	482c      	ldr	r0, [pc, #176]	; (8009ff8 <rt_test_006_008_execute+0xe8>)
 8009f48:	f7fe fa4a 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009f4c:	1d31      	adds	r1, r6, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8009f4e:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009f50:	4b2a      	ldr	r3, [pc, #168]	; (8009ffc <rt_test_006_008_execute+0xec>)
 8009f52:	4a24      	ldr	r2, [pc, #144]	; (8009fe4 <rt_test_006_008_execute+0xd4>)
 8009f54:	482a      	ldr	r0, [pc, #168]	; (800a000 <rt_test_006_008_execute+0xf0>)
 8009f56:	f7fe fa43 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009f5a:	1d71      	adds	r1, r6, #5
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009f5c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009f5e:	4b29      	ldr	r3, [pc, #164]	; (800a004 <rt_test_006_008_execute+0xf4>)
 8009f60:	4a20      	ldr	r2, [pc, #128]	; (8009fe4 <rt_test_006_008_execute+0xd4>)
 8009f62:	4829      	ldr	r0, [pc, #164]	; (800a008 <rt_test_006_008_execute+0xf8>)
 8009f64:	f7fe fa3c 	bl	80083e0 <chThdCreateStatic.constprop.60>
  test_set_step(2);
 8009f68:	2302      	movs	r3, #2
 8009f6a:	603b      	str	r3, [r7, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009f6c:	6120      	str	r0, [r4, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009f6e:	2320      	movs	r3, #32
 8009f70:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 8009f74:	4c25      	ldr	r4, [pc, #148]	; (800a00c <rt_test_006_008_execute+0xfc>)
  _dbg_check_lock();
 8009f76:	f7f9 fc23 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 8009f7a:	f7f6 fe31 	bl	8000be0 <chDbgCheckClassI>
 8009f7e:	6823      	ldr	r3, [r4, #0]
  while (queue_notempty(&cp->queue)) {
 8009f80:	42a3      	cmp	r3, r4
 8009f82:	d00b      	beq.n	8009f9c <rt_test_006_008_execute+0x8c>
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8009f84:	f06f 0601 	mvn.w	r6, #1
  tqp->next             = tp->queue.next;
 8009f88:	681a      	ldr	r2, [r3, #0]
 8009f8a:	6022      	str	r2, [r4, #0]
 8009f8c:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 8009f8e:	6054      	str	r4, [r2, #4]
 8009f90:	f7f6 fee6 	bl	8000d60 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8009f94:	6823      	ldr	r3, [r4, #0]
 8009f96:	6246      	str	r6, [r0, #36]	; 0x24
  while (queue_notempty(&cp->queue)) {
 8009f98:	42a3      	cmp	r3, r4
 8009f9a:	d1f5      	bne.n	8009f88 <rt_test_006_008_execute+0x78>
  chSchRescheduleS();
 8009f9c:	f7f9 fb90 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 8009fa0:	f7f9 fba6 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009fa4:	682b      	ldr	r3, [r5, #0]
 8009fa6:	42ab      	cmp	r3, r5
 8009fa8:	d004      	beq.n	8009fb4 <rt_test_006_008_execute+0xa4>
 8009faa:	69aa      	ldr	r2, [r5, #24]
 8009fac:	689b      	ldr	r3, [r3, #8]
 8009fae:	6892      	ldr	r2, [r2, #8]
 8009fb0:	429a      	cmp	r2, r3
 8009fb2:	d30a      	bcc.n	8009fca <rt_test_006_008_execute+0xba>
 8009fb4:	2300      	movs	r3, #0
 8009fb6:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 8009fba:	f7ff f921 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8009fbe:	4914      	ldr	r1, [pc, #80]	; (800a010 <rt_test_006_008_execute+0x100>)
 8009fc0:	4814      	ldr	r0, [pc, #80]	; (800a014 <rt_test_006_008_execute+0x104>)
}
 8009fc2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8009fc6:	f7f6 bd4b 	b.w	8000a60 <_test_assert_sequence>
  __ASM volatile ("cpsid i" : : : "memory");
 8009fca:	b672      	cpsid	i
 8009fcc:	4b12      	ldr	r3, [pc, #72]	; (800a018 <rt_test_006_008_execute+0x108>)
 8009fce:	62eb      	str	r3, [r5, #44]	; 0x2c
 8009fd0:	e7fe      	b.n	8009fd0 <rt_test_006_008_execute+0xc0>
 8009fd2:	bf00      	nop
 8009fd4:	200011a0 	.word	0x200011a0
 8009fd8:	20001b3c 	.word	0x20001b3c
 8009fdc:	0800d714 	.word	0x0800d714
 8009fe0:	20001428 	.word	0x20001428
 8009fe4:	080063d1 	.word	0x080063d1
 8009fe8:	20001b54 	.word	0x20001b54
 8009fec:	0800e62c 	.word	0x0800e62c
 8009ff0:	20001570 	.word	0x20001570
 8009ff4:	0800d8d4 	.word	0x0800d8d4
 8009ff8:	200016b8 	.word	0x200016b8
 8009ffc:	0800d68c 	.word	0x0800d68c
 800a000:	20001800 	.word	0x20001800
 800a004:	0800d688 	.word	0x0800d688
 800a008:	20001948 	.word	0x20001948
 800a00c:	20000c04 	.word	0x20000c04
 800a010:	0800d774 	.word	0x0800d774
 800a014:	0800d710 	.word	0x0800d710
 800a018:	0800bc08 	.word	0x0800bc08
 800a01c:	00000000 	.word	0x00000000

0800a020 <rt_test_006_007_execute>:
static void rt_test_006_007_execute(void) {
 800a020:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 800a022:	4c2c      	ldr	r4, [pc, #176]	; (800a0d4 <rt_test_006_007_execute+0xb4>)
  test_set_step(1);
 800a024:	4f2c      	ldr	r7, [pc, #176]	; (800a0d8 <rt_test_006_007_execute+0xb8>)
  return chThdGetSelfX()->prio;
 800a026:	69a2      	ldr	r2, [r4, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800a028:	4b2c      	ldr	r3, [pc, #176]	; (800a0dc <rt_test_006_007_execute+0xbc>)
 800a02a:	6896      	ldr	r6, [r2, #8]
 800a02c:	482c      	ldr	r0, [pc, #176]	; (800a0e0 <rt_test_006_007_execute+0xc0>)
 800a02e:	4a2d      	ldr	r2, [pc, #180]	; (800a0e4 <rt_test_006_007_execute+0xc4>)
 800a030:	4d2d      	ldr	r5, [pc, #180]	; (800a0e8 <rt_test_006_007_execute+0xc8>)
  test_set_step(1);
 800a032:	f04f 0c01 	mov.w	ip, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800a036:	1c71      	adds	r1, r6, #1
  test_set_step(1);
 800a038:	f8c7 c000 	str.w	ip, [r7]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800a03c:	f7fe f9d0 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800a040:	1cb1      	adds	r1, r6, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800a042:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800a044:	4b29      	ldr	r3, [pc, #164]	; (800a0ec <rt_test_006_007_execute+0xcc>)
 800a046:	4a27      	ldr	r2, [pc, #156]	; (800a0e4 <rt_test_006_007_execute+0xc4>)
 800a048:	4829      	ldr	r0, [pc, #164]	; (800a0f0 <rt_test_006_007_execute+0xd0>)
 800a04a:	f7fe f9c9 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800a04e:	1cf1      	adds	r1, r6, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800a050:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800a052:	4b28      	ldr	r3, [pc, #160]	; (800a0f4 <rt_test_006_007_execute+0xd4>)
 800a054:	4a23      	ldr	r2, [pc, #140]	; (800a0e4 <rt_test_006_007_execute+0xc4>)
 800a056:	4828      	ldr	r0, [pc, #160]	; (800a0f8 <rt_test_006_007_execute+0xd8>)
 800a058:	f7fe f9c2 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800a05c:	1d31      	adds	r1, r6, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800a05e:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800a060:	4b26      	ldr	r3, [pc, #152]	; (800a0fc <rt_test_006_007_execute+0xdc>)
 800a062:	4a20      	ldr	r2, [pc, #128]	; (800a0e4 <rt_test_006_007_execute+0xc4>)
 800a064:	4826      	ldr	r0, [pc, #152]	; (800a100 <rt_test_006_007_execute+0xe0>)
 800a066:	f7fe f9bb 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800a06a:	1d71      	adds	r1, r6, #5
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800a06c:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800a06e:	4b25      	ldr	r3, [pc, #148]	; (800a104 <rt_test_006_007_execute+0xe4>)
 800a070:	4a1c      	ldr	r2, [pc, #112]	; (800a0e4 <rt_test_006_007_execute+0xc4>)
 800a072:	4825      	ldr	r0, [pc, #148]	; (800a108 <rt_test_006_007_execute+0xe8>)
 800a074:	f7fe f9b4 	bl	80083e0 <chThdCreateStatic.constprop.60>
  test_set_step(2);
 800a078:	2302      	movs	r3, #2
 800a07a:	603b      	str	r3, [r7, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800a07c:	6128      	str	r0, [r5, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a07e:	2320      	movs	r3, #32
 800a080:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a084:	f7f9 fb9c 	bl	80037c0 <_dbg_check_lock>
    chCondSignalI(&c1);
 800a088:	f7f7 fe6a 	bl	8001d60 <chCondSignalI.constprop.49>
    chCondSignalI(&c1);
 800a08c:	f7f7 fe68 	bl	8001d60 <chCondSignalI.constprop.49>
    chCondSignalI(&c1);
 800a090:	f7f7 fe66 	bl	8001d60 <chCondSignalI.constprop.49>
    chCondSignalI(&c1);
 800a094:	f7f7 fe64 	bl	8001d60 <chCondSignalI.constprop.49>
    chCondSignalI(&c1);
 800a098:	f7f7 fe62 	bl	8001d60 <chCondSignalI.constprop.49>
    chSchRescheduleS();
 800a09c:	f7f9 fb10 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 800a0a0:	f7f9 fb26 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a0a4:	6823      	ldr	r3, [r4, #0]
 800a0a6:	42a3      	cmp	r3, r4
 800a0a8:	d004      	beq.n	800a0b4 <rt_test_006_007_execute+0x94>
 800a0aa:	69a2      	ldr	r2, [r4, #24]
 800a0ac:	689b      	ldr	r3, [r3, #8]
 800a0ae:	6892      	ldr	r2, [r2, #8]
 800a0b0:	429a      	cmp	r2, r3
 800a0b2:	d30a      	bcc.n	800a0ca <rt_test_006_007_execute+0xaa>
 800a0b4:	2300      	movs	r3, #0
 800a0b6:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 800a0ba:	f7ff f8a1 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800a0be:	4913      	ldr	r1, [pc, #76]	; (800a10c <rt_test_006_007_execute+0xec>)
 800a0c0:	4813      	ldr	r0, [pc, #76]	; (800a110 <rt_test_006_007_execute+0xf0>)
}
 800a0c2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 800a0c6:	f7f6 bccb 	b.w	8000a60 <_test_assert_sequence>
  __ASM volatile ("cpsid i" : : : "memory");
 800a0ca:	b672      	cpsid	i
 800a0cc:	4b11      	ldr	r3, [pc, #68]	; (800a114 <rt_test_006_007_execute+0xf4>)
 800a0ce:	62e3      	str	r3, [r4, #44]	; 0x2c
 800a0d0:	e7fe      	b.n	800a0d0 <rt_test_006_007_execute+0xb0>
 800a0d2:	bf00      	nop
 800a0d4:	200011a0 	.word	0x200011a0
 800a0d8:	20001b3c 	.word	0x20001b3c
 800a0dc:	0800d714 	.word	0x0800d714
 800a0e0:	20001428 	.word	0x20001428
 800a0e4:	080063d1 	.word	0x080063d1
 800a0e8:	20001b54 	.word	0x20001b54
 800a0ec:	0800e62c 	.word	0x0800e62c
 800a0f0:	20001570 	.word	0x20001570
 800a0f4:	0800d8d4 	.word	0x0800d8d4
 800a0f8:	200016b8 	.word	0x200016b8
 800a0fc:	0800d68c 	.word	0x0800d68c
 800a100:	20001800 	.word	0x20001800
 800a104:	0800d688 	.word	0x0800d688
 800a108:	20001948 	.word	0x20001948
 800a10c:	0800d774 	.word	0x0800d774
 800a110:	0800d710 	.word	0x0800d710
 800a114:	0800bca4 	.word	0x0800bca4
	...

0800a120 <rt_test_005_006_teardown>:
  test_wait_threads();
 800a120:	f7ff b86e 	b.w	8009200 <test_wait_threads>
	...

0800a130 <rt_test_006_004_teardown>:
 800a130:	f7ff b866 	b.w	8009200 <test_wait_threads>
	...

0800a140 <rt_test_006_001_execute>:
static void rt_test_006_001_execute(void) {
 800a140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 800a142:	4f24      	ldr	r7, [pc, #144]	; (800a1d4 <rt_test_006_001_execute+0x94>)
  test_set_step(2);
 800a144:	4e24      	ldr	r6, [pc, #144]	; (800a1d8 <rt_test_006_001_execute+0x98>)
  return chThdGetSelfX()->prio;
 800a146:	69bb      	ldr	r3, [r7, #24]
    chMtxLock(&m1);
 800a148:	4824      	ldr	r0, [pc, #144]	; (800a1dc <rt_test_006_001_execute+0x9c>)
 800a14a:	689c      	ldr	r4, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800a14c:	4d24      	ldr	r5, [pc, #144]	; (800a1e0 <rt_test_006_001_execute+0xa0>)
  test_set_step(2);
 800a14e:	2302      	movs	r3, #2
 800a150:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
 800a152:	f7fb fe9d 	bl	8005e90 <chMtxLock>
  test_set_step(3);
 800a156:	f04f 0c03 	mov.w	ip, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800a15a:	1c61      	adds	r1, r4, #1
 800a15c:	4b21      	ldr	r3, [pc, #132]	; (800a1e4 <rt_test_006_001_execute+0xa4>)
 800a15e:	4a22      	ldr	r2, [pc, #136]	; (800a1e8 <rt_test_006_001_execute+0xa8>)
 800a160:	4822      	ldr	r0, [pc, #136]	; (800a1ec <rt_test_006_001_execute+0xac>)
  test_set_step(3);
 800a162:	f8c6 c000 	str.w	ip, [r6]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800a166:	f7fe f93b 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800a16a:	1ca1      	adds	r1, r4, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800a16c:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800a16e:	4b20      	ldr	r3, [pc, #128]	; (800a1f0 <rt_test_006_001_execute+0xb0>)
 800a170:	4a1d      	ldr	r2, [pc, #116]	; (800a1e8 <rt_test_006_001_execute+0xa8>)
 800a172:	4820      	ldr	r0, [pc, #128]	; (800a1f4 <rt_test_006_001_execute+0xb4>)
 800a174:	f7fe f934 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800a178:	1ce1      	adds	r1, r4, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800a17a:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800a17c:	4b1e      	ldr	r3, [pc, #120]	; (800a1f8 <rt_test_006_001_execute+0xb8>)
 800a17e:	4a1a      	ldr	r2, [pc, #104]	; (800a1e8 <rt_test_006_001_execute+0xa8>)
 800a180:	481e      	ldr	r0, [pc, #120]	; (800a1fc <rt_test_006_001_execute+0xbc>)
 800a182:	f7fe f92d 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800a186:	1d21      	adds	r1, r4, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800a188:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800a18a:	4b1d      	ldr	r3, [pc, #116]	; (800a200 <rt_test_006_001_execute+0xc0>)
 800a18c:	4a16      	ldr	r2, [pc, #88]	; (800a1e8 <rt_test_006_001_execute+0xa8>)
 800a18e:	481d      	ldr	r0, [pc, #116]	; (800a204 <rt_test_006_001_execute+0xc4>)
 800a190:	f7fe f926 	bl	80083e0 <chThdCreateStatic.constprop.60>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800a194:	1d61      	adds	r1, r4, #5
 800a196:	4a14      	ldr	r2, [pc, #80]	; (800a1e8 <rt_test_006_001_execute+0xa8>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800a198:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800a19a:	4b1b      	ldr	r3, [pc, #108]	; (800a208 <rt_test_006_001_execute+0xc8>)
 800a19c:	481b      	ldr	r0, [pc, #108]	; (800a20c <rt_test_006_001_execute+0xcc>)
 800a19e:	f7fe f91f 	bl	80083e0 <chThdCreateStatic.constprop.60>
  test_set_step(4);
 800a1a2:	2304      	movs	r3, #4
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800a1a4:	6128      	str	r0, [r5, #16]
    chMtxUnlock(&m1);
 800a1a6:	480d      	ldr	r0, [pc, #52]	; (800a1dc <rt_test_006_001_execute+0x9c>)
  test_set_step(4);
 800a1a8:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
 800a1aa:	f7fb fd49 	bl	8005c40 <chMtxUnlock>
    test_wait_threads();
 800a1ae:	f7ff f827 	bl	8009200 <test_wait_threads>
 800a1b2:	69bb      	ldr	r3, [r7, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 800a1b4:	4916      	ldr	r1, [pc, #88]	; (800a210 <rt_test_006_001_execute+0xd0>)
 800a1b6:	6898      	ldr	r0, [r3, #8]
 800a1b8:	1b00      	subs	r0, r0, r4
 800a1ba:	fab0 f080 	clz	r0, r0
 800a1be:	0940      	lsrs	r0, r0, #5
 800a1c0:	f7f6 fbae 	bl	8000920 <_test_assert>
 800a1c4:	b100      	cbz	r0, 800a1c8 <rt_test_006_001_execute+0x88>
}
 800a1c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
 800a1c8:	4912      	ldr	r1, [pc, #72]	; (800a214 <rt_test_006_001_execute+0xd4>)
 800a1ca:	4813      	ldr	r0, [pc, #76]	; (800a218 <rt_test_006_001_execute+0xd8>)
}
 800a1cc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 800a1d0:	f7f6 bc46 	b.w	8000a60 <_test_assert_sequence>
 800a1d4:	200011a0 	.word	0x200011a0
 800a1d8:	20001b3c 	.word	0x20001b3c
 800a1dc:	20000c38 	.word	0x20000c38
 800a1e0:	20001b54 	.word	0x20001b54
 800a1e4:	0800d714 	.word	0x0800d714
 800a1e8:	08006491 	.word	0x08006491
 800a1ec:	20001428 	.word	0x20001428
 800a1f0:	0800e62c 	.word	0x0800e62c
 800a1f4:	20001570 	.word	0x20001570
 800a1f8:	0800d8d4 	.word	0x0800d8d4
 800a1fc:	200016b8 	.word	0x200016b8
 800a200:	0800d68c 	.word	0x0800d68c
 800a204:	20001800 	.word	0x20001800
 800a208:	0800d688 	.word	0x0800d688
 800a20c:	20001948 	.word	0x20001948
 800a210:	0800d6d8 	.word	0x0800d6d8
 800a214:	0800d774 	.word	0x0800d774
 800a218:	0800d710 	.word	0x0800d710
 800a21c:	00000000 	.word	0x00000000

0800a220 <rt_test_005_005_teardown>:
 800a220:	f7fe bfee 	b.w	8009200 <test_wait_threads>
	...

0800a230 <rt_test_005_004_execute>:
static void rt_test_005_004_execute(void) {
 800a230:	b570      	push	{r4, r5, r6, lr}
  return ch.rlist.current;
 800a232:	4d47      	ldr	r5, [pc, #284]	; (800a350 <rt_test_005_004_execute+0x120>)
  test_set_step(1);
 800a234:	4c47      	ldr	r4, [pc, #284]	; (800a354 <rt_test_005_004_execute+0x124>)
  return chThdGetSelfX()->prio;
 800a236:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 800a238:	4b47      	ldr	r3, [pc, #284]	; (800a358 <rt_test_005_004_execute+0x128>)
 800a23a:	6891      	ldr	r1, [r2, #8]
 800a23c:	4847      	ldr	r0, [pc, #284]	; (800a35c <rt_test_005_004_execute+0x12c>)
 800a23e:	4a48      	ldr	r2, [pc, #288]	; (800a360 <rt_test_005_004_execute+0x130>)
 800a240:	3101      	adds	r1, #1
  test_set_step(1);
 800a242:	2601      	movs	r6, #1
 800a244:	6026      	str	r6, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 800a246:	f7fe f8cb 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a24a:	4a46      	ldr	r2, [pc, #280]	; (800a364 <rt_test_005_004_execute+0x134>)
  test_set_step(2);
 800a24c:	2302      	movs	r3, #2
 800a24e:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 800a250:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a252:	2320      	movs	r3, #32
 800a254:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 800a258:	4c43      	ldr	r4, [pc, #268]	; (800a368 <rt_test_005_004_execute+0x138>)
  _dbg_check_lock();
 800a25a:	f7f9 fab1 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 800a25e:	f7f6 fcbf 	bl	8000be0 <chDbgCheckClassI>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 800a262:	68a3      	ldr	r3, [r4, #8]
 800a264:	6822      	ldr	r2, [r4, #0]
 800a266:	2b00      	cmp	r3, #0
 800a268:	db05      	blt.n	800a276 <rt_test_005_004_execute+0x46>
 800a26a:	42a2      	cmp	r2, r4
 800a26c:	d005      	beq.n	800a27a <rt_test_005_004_execute+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
 800a26e:	b672      	cpsid	i
 800a270:	4b3e      	ldr	r3, [pc, #248]	; (800a36c <rt_test_005_004_execute+0x13c>)
 800a272:	62eb      	str	r3, [r5, #44]	; 0x2c
 800a274:	e7fe      	b.n	800a274 <rt_test_005_004_execute+0x44>
 800a276:	42a2      	cmp	r2, r4
 800a278:	d0f9      	beq.n	800a26e <rt_test_005_004_execute+0x3e>
    if (++sp->cnt <= (cnt_t)0) {
 800a27a:	3301      	adds	r3, #1
 800a27c:	2b00      	cmp	r3, #0
 800a27e:	60a3      	str	r3, [r4, #8]
 800a280:	dd34      	ble.n	800a2ec <rt_test_005_004_execute+0xbc>
 800a282:	68a3      	ldr	r3, [r4, #8]
 800a284:	3301      	adds	r3, #1
 800a286:	2b00      	cmp	r3, #0
 800a288:	60a3      	str	r3, [r4, #8]
 800a28a:	dd57      	ble.n	800a33c <rt_test_005_004_execute+0x10c>
    chSchRescheduleS();
 800a28c:	f7f9 fa18 	bl	80036c0 <chSchRescheduleS>
  _dbg_check_unlock();
 800a290:	f7f9 fa2e 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a294:	682b      	ldr	r3, [r5, #0]
 800a296:	42ab      	cmp	r3, r5
 800a298:	d004      	beq.n	800a2a4 <rt_test_005_004_execute+0x74>
 800a29a:	69aa      	ldr	r2, [r5, #24]
 800a29c:	689b      	ldr	r3, [r3, #8]
 800a29e:	6892      	ldr	r2, [r2, #8]
 800a2a0:	429a      	cmp	r2, r3
 800a2a2:	d347      	bcc.n	800a334 <rt_test_005_004_execute+0x104>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a2a4:	2300      	movs	r3, #0
 800a2a6:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 800a2aa:	f7fe ffa9 	bl	8009200 <test_wait_threads>
 800a2ae:	2320      	movs	r3, #32
 800a2b0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a2b4:	f7f9 fa84 	bl	80037c0 <_dbg_check_lock>
 800a2b8:	f7f6 fc92 	bl	8000be0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 800a2bc:	68a0      	ldr	r0, [r4, #8]
 800a2be:	492c      	ldr	r1, [pc, #176]	; (800a370 <rt_test_005_004_execute+0x140>)
 800a2c0:	f1a0 0001 	sub.w	r0, r0, #1
 800a2c4:	fab0 f080 	clz	r0, r0
 800a2c8:	0940      	lsrs	r0, r0, #5
 800a2ca:	f7f6 fb29 	bl	8000920 <_test_assert>
 800a2ce:	b9f8      	cbnz	r0, 800a310 <rt_test_005_004_execute+0xe0>
  _dbg_check_unlock();
 800a2d0:	f7f9 fa0e 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a2d4:	682b      	ldr	r3, [r5, #0]
 800a2d6:	42ab      	cmp	r3, r5
 800a2d8:	d011      	beq.n	800a2fe <rt_test_005_004_execute+0xce>
 800a2da:	69aa      	ldr	r2, [r5, #24]
 800a2dc:	689b      	ldr	r3, [r3, #8]
 800a2de:	6892      	ldr	r2, [r2, #8]
 800a2e0:	429a      	cmp	r2, r3
 800a2e2:	d20c      	bcs.n	800a2fe <rt_test_005_004_execute+0xce>
  __ASM volatile ("cpsid i" : : : "memory");
 800a2e4:	b672      	cpsid	i
 800a2e6:	4b23      	ldr	r3, [pc, #140]	; (800a374 <rt_test_005_004_execute+0x144>)
 800a2e8:	62eb      	str	r3, [r5, #44]	; 0x2c
 800a2ea:	e7fe      	b.n	800a2ea <rt_test_005_004_execute+0xba>
  thread_t *tp = tqp->next;
 800a2ec:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 800a2ee:	6803      	ldr	r3, [r0, #0]
 800a2f0:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800a2f2:	605c      	str	r4, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 800a2f4:	f7f6 fd34 	bl	8000d60 <chSchReadyI>
 800a2f8:	2300      	movs	r3, #0
 800a2fa:	6243      	str	r3, [r0, #36]	; 0x24
 800a2fc:	e7c1      	b.n	800a282 <rt_test_005_004_execute+0x52>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a2fe:	2300      	movs	r3, #0
 800a300:	f383 8811 	msr	BASEPRI, r3
    test_assert_sequence("A", "invalid sequence");
 800a304:	491c      	ldr	r1, [pc, #112]	; (800a378 <rt_test_005_004_execute+0x148>)
 800a306:	4814      	ldr	r0, [pc, #80]	; (800a358 <rt_test_005_004_execute+0x128>)
}
 800a308:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_sequence("A", "invalid sequence");
 800a30c:	f7f6 bba8 	b.w	8000a60 <_test_assert_sequence>
  _dbg_check_unlock();
 800a310:	f7f9 f9ee 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a314:	682b      	ldr	r3, [r5, #0]
 800a316:	42ab      	cmp	r3, r5
 800a318:	d004      	beq.n	800a324 <rt_test_005_004_execute+0xf4>
 800a31a:	69aa      	ldr	r2, [r5, #24]
 800a31c:	689b      	ldr	r3, [r3, #8]
 800a31e:	6892      	ldr	r2, [r2, #8]
 800a320:	429a      	cmp	r2, r3
 800a322:	d303      	bcc.n	800a32c <rt_test_005_004_execute+0xfc>
 800a324:	2300      	movs	r3, #0
 800a326:	f383 8811 	msr	BASEPRI, r3
}
 800a32a:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800a32c:	b672      	cpsid	i
 800a32e:	4b11      	ldr	r3, [pc, #68]	; (800a374 <rt_test_005_004_execute+0x144>)
 800a330:	62eb      	str	r3, [r5, #44]	; 0x2c
 800a332:	e7fe      	b.n	800a332 <rt_test_005_004_execute+0x102>
 800a334:	b672      	cpsid	i
 800a336:	4b0f      	ldr	r3, [pc, #60]	; (800a374 <rt_test_005_004_execute+0x144>)
 800a338:	62eb      	str	r3, [r5, #44]	; 0x2c
 800a33a:	e7fe      	b.n	800a33a <rt_test_005_004_execute+0x10a>
  thread_t *tp = tqp->next;
 800a33c:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 800a33e:	6803      	ldr	r3, [r0, #0]
 800a340:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800a342:	605c      	str	r4, [r3, #4]
 800a344:	f7f6 fd0c 	bl	8000d60 <chSchReadyI>
 800a348:	2300      	movs	r3, #0
 800a34a:	6243      	str	r3, [r0, #36]	; 0x24
 800a34c:	e79e      	b.n	800a28c <rt_test_005_004_execute+0x5c>
 800a34e:	bf00      	nop
 800a350:	200011a0 	.word	0x200011a0
 800a354:	20001b3c 	.word	0x20001b3c
 800a358:	0800d688 	.word	0x0800d688
 800a35c:	20001428 	.word	0x20001428
 800a360:	08007361 	.word	0x08007361
 800a364:	20001b54 	.word	0x20001b54
 800a368:	20001408 	.word	0x20001408
 800a36c:	0800bf04 	.word	0x0800bf04
 800a370:	0800d5e4 	.word	0x0800d5e4
 800a374:	0800bc98 	.word	0x0800bc98
 800a378:	0800d774 	.word	0x0800d774
 800a37c:	00000000 	.word	0x00000000

0800a380 <rt_test_005_003_execute>:
static void rt_test_005_003_execute(void) {
 800a380:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_set_step(1);
 800a384:	4e6e      	ldr	r6, [pc, #440]	; (800a540 <rt_test_005_003_execute+0x1c0>)
 800a386:	2301      	movs	r3, #1
 800a388:	6033      	str	r3, [r6, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a38a:	2320      	movs	r3, #32
 800a38c:	f383 8811 	msr	BASEPRI, r3
 800a390:	4c6c      	ldr	r4, [pc, #432]	; (800a544 <rt_test_005_003_execute+0x1c4>)
  _dbg_check_lock();
 800a392:	f7f9 fa15 	bl	80037c0 <_dbg_check_lock>
  msg = chSemWaitTimeoutS(sp, timeout);
 800a396:	2100      	movs	r1, #0
 800a398:	486b      	ldr	r0, [pc, #428]	; (800a548 <rt_test_005_003_execute+0x1c8>)
 800a39a:	f7f8 feb9 	bl	8003110 <chSemWaitTimeoutS>
  _dbg_check_unlock();
 800a39e:	f7f9 f9a7 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a3a2:	6823      	ldr	r3, [r4, #0]
 800a3a4:	42a3      	cmp	r3, r4
 800a3a6:	d004      	beq.n	800a3b2 <rt_test_005_003_execute+0x32>
 800a3a8:	69a2      	ldr	r2, [r4, #24]
 800a3aa:	689b      	ldr	r3, [r3, #8]
 800a3ac:	6892      	ldr	r2, [r2, #8]
 800a3ae:	429a      	cmp	r2, r3
 800a3b0:	d30d      	bcc.n	800a3ce <rt_test_005_003_execute+0x4e>
 800a3b2:	2300      	movs	r3, #0
 800a3b4:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 800a3b8:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 800a3bc:	fab0 f080 	clz	r0, r0
 800a3c0:	4962      	ldr	r1, [pc, #392]	; (800a54c <rt_test_005_003_execute+0x1cc>)
 800a3c2:	0940      	lsrs	r0, r0, #5
 800a3c4:	f7f6 faac 	bl	8000920 <_test_assert>
 800a3c8:	b128      	cbz	r0, 800a3d6 <rt_test_005_003_execute+0x56>
}
 800a3ca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800a3ce:	b672      	cpsid	i
 800a3d0:	4b5f      	ldr	r3, [pc, #380]	; (800a550 <rt_test_005_003_execute+0x1d0>)
 800a3d2:	62e3      	str	r3, [r4, #44]	; 0x2c
 800a3d4:	e7fe      	b.n	800a3d4 <rt_test_005_003_execute+0x54>
  return (bool)(tqp->next == (const thread_t *)tqp);
 800a3d6:	4d5c      	ldr	r5, [pc, #368]	; (800a548 <rt_test_005_003_execute+0x1c8>)
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800a3d8:	495e      	ldr	r1, [pc, #376]	; (800a554 <rt_test_005_003_execute+0x1d4>)
 800a3da:	6828      	ldr	r0, [r5, #0]
 800a3dc:	1b40      	subs	r0, r0, r5
 800a3de:	fab0 f080 	clz	r0, r0
 800a3e2:	0940      	lsrs	r0, r0, #5
 800a3e4:	f7f6 fa9c 	bl	8000920 <_test_assert>
 800a3e8:	2800      	cmp	r0, #0
 800a3ea:	d1ee      	bne.n	800a3ca <rt_test_005_003_execute+0x4a>
    test_assert(sem1.cnt == 0, "counter not zero");
 800a3ec:	68a8      	ldr	r0, [r5, #8]
 800a3ee:	495a      	ldr	r1, [pc, #360]	; (800a558 <rt_test_005_003_execute+0x1d8>)
 800a3f0:	fab0 f080 	clz	r0, r0
 800a3f4:	0940      	lsrs	r0, r0, #5
 800a3f6:	f7f6 fa93 	bl	8000920 <_test_assert>
 800a3fa:	4603      	mov	r3, r0
 800a3fc:	2800      	cmp	r0, #0
 800a3fe:	d1e4      	bne.n	800a3ca <rt_test_005_003_execute+0x4a>
 800a400:	69a1      	ldr	r1, [r4, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800a402:	4a56      	ldr	r2, [pc, #344]	; (800a55c <rt_test_005_003_execute+0x1dc>)
 800a404:	6889      	ldr	r1, [r1, #8]
 800a406:	4856      	ldr	r0, [pc, #344]	; (800a560 <rt_test_005_003_execute+0x1e0>)
 800a408:	3901      	subs	r1, #1
  test_set_step(2);
 800a40a:	2702      	movs	r7, #2
 800a40c:	6037      	str	r7, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800a40e:	f7fd ffe7 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a412:	4a54      	ldr	r2, [pc, #336]	; (800a564 <rt_test_005_003_execute+0x1e4>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a414:	2320      	movs	r3, #32
 800a416:	6010      	str	r0, [r2, #0]
 800a418:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a41c:	f7f9 f9d0 	bl	80037c0 <_dbg_check_lock>
 800a420:	f241 3188 	movw	r1, #5000	; 0x1388
 800a424:	4628      	mov	r0, r5
 800a426:	f7f8 fe73 	bl	8003110 <chSemWaitTimeoutS>
 800a42a:	4607      	mov	r7, r0
  _dbg_check_unlock();
 800a42c:	f7f9 f960 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a430:	6823      	ldr	r3, [r4, #0]
 800a432:	42a3      	cmp	r3, r4
 800a434:	d004      	beq.n	800a440 <rt_test_005_003_execute+0xc0>
 800a436:	69a2      	ldr	r2, [r4, #24]
 800a438:	689b      	ldr	r3, [r3, #8]
 800a43a:	6892      	ldr	r2, [r2, #8]
 800a43c:	429a      	cmp	r2, r3
 800a43e:	d376      	bcc.n	800a52e <rt_test_005_003_execute+0x1ae>
 800a440:	2300      	movs	r3, #0
 800a442:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 800a446:	f7fe fedb 	bl	8009200 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 800a44a:	fab7 f087 	clz	r0, r7
 800a44e:	0940      	lsrs	r0, r0, #5
 800a450:	493e      	ldr	r1, [pc, #248]	; (800a54c <rt_test_005_003_execute+0x1cc>)
 800a452:	f7f6 fa65 	bl	8000920 <_test_assert>
 800a456:	2800      	cmp	r0, #0
 800a458:	d1b7      	bne.n	800a3ca <rt_test_005_003_execute+0x4a>
 800a45a:	6828      	ldr	r0, [r5, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800a45c:	493d      	ldr	r1, [pc, #244]	; (800a554 <rt_test_005_003_execute+0x1d4>)
 800a45e:	1b47      	subs	r7, r0, r5
 800a460:	4278      	negs	r0, r7
 800a462:	4178      	adcs	r0, r7
 800a464:	f7f6 fa5c 	bl	8000920 <_test_assert>
 800a468:	2800      	cmp	r0, #0
 800a46a:	d1ae      	bne.n	800a3ca <rt_test_005_003_execute+0x4a>
    test_assert(sem1.cnt == 0, "counter not zero");
 800a46c:	68a8      	ldr	r0, [r5, #8]
 800a46e:	493a      	ldr	r1, [pc, #232]	; (800a558 <rt_test_005_003_execute+0x1d8>)
 800a470:	fab0 f080 	clz	r0, r0
 800a474:	0940      	lsrs	r0, r0, #5
 800a476:	f7f6 fa53 	bl	8000920 <_test_assert>
 800a47a:	2800      	cmp	r0, #0
 800a47c:	d1a5      	bne.n	800a3ca <rt_test_005_003_execute+0x4a>
  test_set_step(3);
 800a47e:	2303      	movs	r3, #3
 800a480:	6033      	str	r3, [r6, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
 800a482:	f7fd fa75 	bl	8007970 <test_wait_tick>
 800a486:	f8df b0c0 	ldr.w	fp, [pc, #192]	; 800a548 <rt_test_005_003_execute+0x1c8>
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 800a48a:	f8df a0c0 	ldr.w	sl, [pc, #192]	; 800a54c <rt_test_005_003_execute+0x1cc>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800a48e:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 800a554 <rt_test_005_003_execute+0x1d4>
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
 800a492:	4607      	mov	r7, r0
  return systime + (systime_t)interval;
 800a494:	f600 18c4 	addw	r8, r0, #2500	; 0x9c4
 800a498:	2641      	movs	r6, #65	; 0x41
      test_emit_token('A' + i);
 800a49a:	4630      	mov	r0, r6
 800a49c:	f7fa f820 	bl	80044e0 <test_emit_token>
 800a4a0:	2320      	movs	r3, #32
 800a4a2:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a4a6:	f7f9 f98b 	bl	80037c0 <_dbg_check_lock>
 800a4aa:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800a4ae:	4658      	mov	r0, fp
 800a4b0:	f7f8 fe2e 	bl	8003110 <chSemWaitTimeoutS>
  _dbg_check_unlock();
 800a4b4:	f7f9 f91c 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a4b8:	6823      	ldr	r3, [r4, #0]
 800a4ba:	42a3      	cmp	r3, r4
 800a4bc:	f04f 0200 	mov.w	r2, #0
 800a4c0:	d004      	beq.n	800a4cc <rt_test_005_003_execute+0x14c>
 800a4c2:	69a1      	ldr	r1, [r4, #24]
 800a4c4:	689b      	ldr	r3, [r3, #8]
 800a4c6:	6889      	ldr	r1, [r1, #8]
 800a4c8:	4299      	cmp	r1, r3
 800a4ca:	d334      	bcc.n	800a536 <rt_test_005_003_execute+0x1b6>
 800a4cc:	f382 8811 	msr	BASEPRI, r2
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 800a4d0:	1c42      	adds	r2, r0, #1
 800a4d2:	4250      	negs	r0, r2
 800a4d4:	4651      	mov	r1, sl
 800a4d6:	4150      	adcs	r0, r2
 800a4d8:	f7f6 fa22 	bl	8000920 <_test_assert>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800a4dc:	4649      	mov	r1, r9
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 800a4de:	2800      	cmp	r0, #0
 800a4e0:	f47f af73 	bne.w	800a3ca <rt_test_005_003_execute+0x4a>
 800a4e4:	6828      	ldr	r0, [r5, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800a4e6:	1b43      	subs	r3, r0, r5
 800a4e8:	4258      	negs	r0, r3
 800a4ea:	4158      	adcs	r0, r3
 800a4ec:	f7f6 fa18 	bl	8000920 <_test_assert>
      test_assert(sem1.cnt == 0, "counter not zero");
 800a4f0:	4919      	ldr	r1, [pc, #100]	; (800a558 <rt_test_005_003_execute+0x1d8>)
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800a4f2:	2800      	cmp	r0, #0
 800a4f4:	f47f af69 	bne.w	800a3ca <rt_test_005_003_execute+0x4a>
      test_assert(sem1.cnt == 0, "counter not zero");
 800a4f8:	68a8      	ldr	r0, [r5, #8]
 800a4fa:	fab0 f080 	clz	r0, r0
 800a4fe:	0940      	lsrs	r0, r0, #5
 800a500:	f7f6 fa0e 	bl	8000920 <_test_assert>
 800a504:	3601      	adds	r6, #1
 800a506:	b2f6      	uxtb	r6, r6
 800a508:	2800      	cmp	r0, #0
 800a50a:	f47f af5e 	bne.w	800a3ca <rt_test_005_003_execute+0x4a>
    for (i = 0; i < 5; i++) {
 800a50e:	2e46      	cmp	r6, #70	; 0x46
 800a510:	d1c3      	bne.n	800a49a <rt_test_005_003_execute+0x11a>
    test_assert_sequence("ABCDE", "invalid sequence");
 800a512:	4915      	ldr	r1, [pc, #84]	; (800a568 <rt_test_005_003_execute+0x1e8>)
 800a514:	4815      	ldr	r0, [pc, #84]	; (800a56c <rt_test_005_003_execute+0x1ec>)
 800a516:	f7f6 faa3 	bl	8000a60 <_test_assert_sequence>
 800a51a:	2800      	cmp	r0, #0
 800a51c:	f47f af55 	bne.w	800a3ca <rt_test_005_003_execute+0x4a>
    test_assert_time_window(target_time,
 800a520:	f607 11d8 	addw	r1, r7, #2520	; 0x9d8
 800a524:	4640      	mov	r0, r8
}
 800a526:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert_time_window(target_time,
 800a52a:	f7f6 b939 	b.w	80007a0 <_test_assert_time_window.constprop.1>
  __ASM volatile ("cpsid i" : : : "memory");
 800a52e:	b672      	cpsid	i
 800a530:	4b07      	ldr	r3, [pc, #28]	; (800a550 <rt_test_005_003_execute+0x1d0>)
 800a532:	62e3      	str	r3, [r4, #44]	; 0x2c
 800a534:	e7fe      	b.n	800a534 <rt_test_005_003_execute+0x1b4>
 800a536:	b672      	cpsid	i
 800a538:	4b05      	ldr	r3, [pc, #20]	; (800a550 <rt_test_005_003_execute+0x1d0>)
 800a53a:	62e3      	str	r3, [r4, #44]	; 0x2c
 800a53c:	e7fe      	b.n	800a53c <rt_test_005_003_execute+0x1bc>
 800a53e:	bf00      	nop
 800a540:	20001b3c 	.word	0x20001b3c
 800a544:	200011a0 	.word	0x200011a0
 800a548:	20001408 	.word	0x20001408
 800a54c:	0800c640 	.word	0x0800c640
 800a550:	0800bbf0 	.word	0x0800bbf0
 800a554:	0800d6c8 	.word	0x0800d6c8
 800a558:	0800d604 	.word	0x0800d604
 800a55c:	08007841 	.word	0x08007841
 800a560:	20001428 	.word	0x20001428
 800a564:	20001b54 	.word	0x20001b54
 800a568:	0800d774 	.word	0x0800d774
 800a56c:	0800d710 	.word	0x0800d710

0800a570 <rt_test_005_002_execute>:
static void rt_test_005_002_execute(void) {
 800a570:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 800a574:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 800a658 <rt_test_005_002_execute+0xe8>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800a578:	4f2c      	ldr	r7, [pc, #176]	; (800a62c <rt_test_005_002_execute+0xbc>)
  return chThdGetSelfX()->prio;
 800a57a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800a57e:	4e2c      	ldr	r6, [pc, #176]	; (800a630 <rt_test_005_002_execute+0xc0>)
 800a580:	6899      	ldr	r1, [r3, #8]
  test_set_step(1);
 800a582:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 800a65c <rt_test_005_002_execute+0xec>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800a586:	4b2b      	ldr	r3, [pc, #172]	; (800a634 <rt_test_005_002_execute+0xc4>)
 800a588:	4d2b      	ldr	r5, [pc, #172]	; (800a638 <rt_test_005_002_execute+0xc8>)
 800a58a:	463a      	mov	r2, r7
 800a58c:	3105      	adds	r1, #5
 800a58e:	4630      	mov	r0, r6
  test_set_step(1);
 800a590:	2401      	movs	r4, #1
 800a592:	f8c9 4000 	str.w	r4, [r9]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800a596:	f7fd ff23 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a59a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800a59e:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800a5a0:	6899      	ldr	r1, [r3, #8]
 800a5a2:	4b26      	ldr	r3, [pc, #152]	; (800a63c <rt_test_005_002_execute+0xcc>)
    chSemSignal(&sem1);
 800a5a4:	4c26      	ldr	r4, [pc, #152]	; (800a640 <rt_test_005_002_execute+0xd0>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800a5a6:	463a      	mov	r2, r7
 800a5a8:	3101      	adds	r1, #1
 800a5aa:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 800a5ae:	f7fd ff17 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a5b2:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800a5b6:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800a5b8:	6899      	ldr	r1, [r3, #8]
 800a5ba:	4b22      	ldr	r3, [pc, #136]	; (800a644 <rt_test_005_002_execute+0xd4>)
 800a5bc:	463a      	mov	r2, r7
 800a5be:	3103      	adds	r1, #3
 800a5c0:	f506 7024 	add.w	r0, r6, #656	; 0x290
 800a5c4:	f7fd ff0c 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a5c8:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800a5cc:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800a5ce:	6899      	ldr	r1, [r3, #8]
 800a5d0:	4b1d      	ldr	r3, [pc, #116]	; (800a648 <rt_test_005_002_execute+0xd8>)
 800a5d2:	463a      	mov	r2, r7
 800a5d4:	3104      	adds	r1, #4
 800a5d6:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 800a5da:	f7fd ff01 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a5de:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800a5e2:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800a5e4:	6899      	ldr	r1, [r3, #8]
 800a5e6:	4b19      	ldr	r3, [pc, #100]	; (800a64c <rt_test_005_002_execute+0xdc>)
 800a5e8:	3102      	adds	r1, #2
 800a5ea:	463a      	mov	r2, r7
 800a5ec:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 800a5f0:	f7fd fef6 	bl	80083e0 <chThdCreateStatic.constprop.60>
  test_set_step(2);
 800a5f4:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800a5f6:	6128      	str	r0, [r5, #16]
    chSemSignal(&sem1);
 800a5f8:	4620      	mov	r0, r4
  test_set_step(2);
 800a5fa:	f8c9 3000 	str.w	r3, [r9]
    chSemSignal(&sem1);
 800a5fe:	f7fc fe07 	bl	8007210 <chSemSignal>
    chSemSignal(&sem1);
 800a602:	4620      	mov	r0, r4
 800a604:	f7fc fe04 	bl	8007210 <chSemSignal>
    chSemSignal(&sem1);
 800a608:	4620      	mov	r0, r4
 800a60a:	f7fc fe01 	bl	8007210 <chSemSignal>
    chSemSignal(&sem1);
 800a60e:	4620      	mov	r0, r4
 800a610:	f7fc fdfe 	bl	8007210 <chSemSignal>
    chSemSignal(&sem1);
 800a614:	4620      	mov	r0, r4
 800a616:	f7fc fdfb 	bl	8007210 <chSemSignal>
    test_wait_threads();
 800a61a:	f7fe fdf1 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800a61e:	490c      	ldr	r1, [pc, #48]	; (800a650 <rt_test_005_002_execute+0xe0>)
 800a620:	480c      	ldr	r0, [pc, #48]	; (800a654 <rt_test_005_002_execute+0xe4>)
}
 800a622:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 800a626:	f7f6 ba1b 	b.w	8000a60 <_test_assert_sequence>
 800a62a:	bf00      	nop
 800a62c:	08007361 	.word	0x08007361
 800a630:	20001428 	.word	0x20001428
 800a634:	0800d688 	.word	0x0800d688
 800a638:	20001b54 	.word	0x20001b54
 800a63c:	0800d68c 	.word	0x0800d68c
 800a640:	20001408 	.word	0x20001408
 800a644:	0800d8d4 	.word	0x0800d8d4
 800a648:	0800e62c 	.word	0x0800e62c
 800a64c:	0800d714 	.word	0x0800d714
 800a650:	0800d774 	.word	0x0800d774
 800a654:	0800d710 	.word	0x0800d710
 800a658:	200011a0 	.word	0x200011a0
 800a65c:	20001b3c 	.word	0x20001b3c

0800a660 <rt_test_004_001_execute>:

static void rt_test_004_001_execute(void) {
 800a660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 800a662:	4c45      	ldr	r4, [pc, #276]	; (800a778 <rt_test_004_001_execute+0x118>)
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 800a664:	4e45      	ldr	r6, [pc, #276]	; (800a77c <rt_test_004_001_execute+0x11c>)
  return chThdGetSelfX()->prio;
 800a666:	69a2      	ldr	r2, [r4, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 800a668:	4b45      	ldr	r3, [pc, #276]	; (800a780 <rt_test_004_001_execute+0x120>)
 800a66a:	6891      	ldr	r1, [r2, #8]
 800a66c:	4845      	ldr	r0, [pc, #276]	; (800a784 <rt_test_004_001_execute+0x124>)
 800a66e:	4a46      	ldr	r2, [pc, #280]	; (800a788 <rt_test_004_001_execute+0x128>)
 800a670:	3901      	subs	r1, #1
  test_set_step(1);
 800a672:	2501      	movs	r5, #1
 800a674:	6035      	str	r5, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 800a676:	f7fd feb3 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a67a:	4a44      	ldr	r2, [pc, #272]	; (800a78c <rt_test_004_001_execute+0x12c>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a67c:	2320      	movs	r3, #32
 800a67e:	6010      	str	r0, [r2, #0]
 800a680:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(*trp == NULL, "not NULL");
 800a684:	4d42      	ldr	r5, [pc, #264]	; (800a790 <rt_test_004_001_execute+0x130>)
  _dbg_check_lock();
 800a686:	f7f9 f89b 	bl	80037c0 <_dbg_check_lock>
 800a68a:	682b      	ldr	r3, [r5, #0]
 800a68c:	b11b      	cbz	r3, 800a696 <rt_test_004_001_execute+0x36>
  __ASM volatile ("cpsid i" : : : "memory");
 800a68e:	b672      	cpsid	i
 800a690:	4b40      	ldr	r3, [pc, #256]	; (800a794 <rt_test_004_001_execute+0x134>)
 800a692:	62e3      	str	r3, [r4, #44]	; 0x2c
 800a694:	e7fe      	b.n	800a694 <rt_test_004_001_execute+0x34>
  return ch.rlist.current;
 800a696:	69a3      	ldr	r3, [r4, #24]
  *trp = tp;
 800a698:	602b      	str	r3, [r5, #0]
  tp->u.wttrp = trp;
 800a69a:	625d      	str	r5, [r3, #36]	; 0x24
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800a69c:	f04f 31ff 	mov.w	r1, #4294967295
 800a6a0:	2003      	movs	r0, #3
 800a6a2:	f7f8 fd0d 	bl	80030c0 <chSchGoSleepTimeoutS>
 800a6a6:	4607      	mov	r7, r0
  _dbg_check_unlock();
 800a6a8:	f7f9 f822 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a6ac:	6823      	ldr	r3, [r4, #0]
 800a6ae:	42a3      	cmp	r3, r4
 800a6b0:	d004      	beq.n	800a6bc <rt_test_004_001_execute+0x5c>
 800a6b2:	69a2      	ldr	r2, [r4, #24]
 800a6b4:	689b      	ldr	r3, [r3, #8]
 800a6b6:	6892      	ldr	r2, [r2, #8]
 800a6b8:	429a      	cmp	r2, r3
 800a6ba:	d30b      	bcc.n	800a6d4 <rt_test_004_001_execute+0x74>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a6bc:	2300      	movs	r3, #0
 800a6be:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 800a6c2:	6828      	ldr	r0, [r5, #0]
 800a6c4:	4934      	ldr	r1, [pc, #208]	; (800a798 <rt_test_004_001_execute+0x138>)
 800a6c6:	fab0 f080 	clz	r0, r0
 800a6ca:	0940      	lsrs	r0, r0, #5
 800a6cc:	f7f6 f928 	bl	8000920 <_test_assert>
 800a6d0:	b120      	cbz	r0, 800a6dc <rt_test_004_001_execute+0x7c>
                            chTimeAddX(time, TIME_MS2I(1000) + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  }
}
 800a6d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800a6d4:	b672      	cpsid	i
 800a6d6:	4b31      	ldr	r3, [pc, #196]	; (800a79c <rt_test_004_001_execute+0x13c>)
 800a6d8:	62e3      	str	r3, [r4, #44]	; 0x2c
 800a6da:	e7fe      	b.n	800a6da <rt_test_004_001_execute+0x7a>
    test_assert(MSG_OK == msg,"wrong returned message");
 800a6dc:	fab7 f087 	clz	r0, r7
 800a6e0:	0940      	lsrs	r0, r0, #5
 800a6e2:	492f      	ldr	r1, [pc, #188]	; (800a7a0 <rt_test_004_001_execute+0x140>)
 800a6e4:	f7f6 f91c 	bl	8000920 <_test_assert>
 800a6e8:	2800      	cmp	r0, #0
 800a6ea:	d1f2      	bne.n	800a6d2 <rt_test_004_001_execute+0x72>
    test_wait_threads();
 800a6ec:	f7fe fd88 	bl	8009200 <test_wait_threads>
  test_set_step(2);
 800a6f0:	2302      	movs	r3, #2
 800a6f2:	6033      	str	r3, [r6, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a6f4:	2320      	movs	r3, #32
 800a6f6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a6fa:	f7f9 f861 	bl	80037c0 <_dbg_check_lock>
 800a6fe:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  chDbgAssert(*trp == NULL, "not NULL");
 800a702:	682a      	ldr	r2, [r5, #0]
 800a704:	69a3      	ldr	r3, [r4, #24]
 800a706:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 800a708:	b11a      	cbz	r2, 800a712 <rt_test_004_001_execute+0xb2>
  __ASM volatile ("cpsid i" : : : "memory");
 800a70a:	b672      	cpsid	i
 800a70c:	4b21      	ldr	r3, [pc, #132]	; (800a794 <rt_test_004_001_execute+0x134>)
 800a70e:	62e3      	str	r3, [r4, #44]	; 0x2c
 800a710:	e7fe      	b.n	800a710 <rt_test_004_001_execute+0xb0>
  tp->u.wttrp = trp;
 800a712:	625d      	str	r5, [r3, #36]	; 0x24
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800a714:	f242 7110 	movw	r1, #10000	; 0x2710
 800a718:	2003      	movs	r0, #3
  *trp = tp;
 800a71a:	602b      	str	r3, [r5, #0]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800a71c:	f7f8 fcd0 	bl	80030c0 <chSchGoSleepTimeoutS>
 800a720:	4607      	mov	r7, r0
  _dbg_check_unlock();
 800a722:	f7f8 ffe5 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a726:	6823      	ldr	r3, [r4, #0]
 800a728:	42a3      	cmp	r3, r4
 800a72a:	d004      	beq.n	800a736 <rt_test_004_001_execute+0xd6>
 800a72c:	69a2      	ldr	r2, [r4, #24]
 800a72e:	689b      	ldr	r3, [r3, #8]
 800a730:	6892      	ldr	r2, [r2, #8]
 800a732:	429a      	cmp	r2, r3
 800a734:	d31c      	bcc.n	800a770 <rt_test_004_001_execute+0x110>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a736:	2300      	movs	r3, #0
 800a738:	f383 8811 	msr	BASEPRI, r3
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(1000)),
 800a73c:	f506 511c 	add.w	r1, r6, #9984	; 0x2700
 800a740:	4608      	mov	r0, r1
 800a742:	3010      	adds	r0, #16
 800a744:	3113      	adds	r1, #19
 800a746:	f7f6 f82b 	bl	80007a0 <_test_assert_time_window.constprop.1>
 800a74a:	2800      	cmp	r0, #0
 800a74c:	d1c1      	bne.n	800a6d2 <rt_test_004_001_execute+0x72>
    test_assert(NULL == tr1, "not NULL");
 800a74e:	6828      	ldr	r0, [r5, #0]
 800a750:	4911      	ldr	r1, [pc, #68]	; (800a798 <rt_test_004_001_execute+0x138>)
 800a752:	fab0 f080 	clz	r0, r0
 800a756:	0940      	lsrs	r0, r0, #5
 800a758:	f7f6 f8e2 	bl	8000920 <_test_assert>
 800a75c:	2800      	cmp	r0, #0
 800a75e:	d1b8      	bne.n	800a6d2 <rt_test_004_001_execute+0x72>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 800a760:	1c7b      	adds	r3, r7, #1
 800a762:	4258      	negs	r0, r3
 800a764:	4158      	adcs	r0, r3
 800a766:	490e      	ldr	r1, [pc, #56]	; (800a7a0 <rt_test_004_001_execute+0x140>)
}
 800a768:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 800a76c:	f7f6 b8d8 	b.w	8000920 <_test_assert>
  __ASM volatile ("cpsid i" : : : "memory");
 800a770:	b672      	cpsid	i
 800a772:	4b0a      	ldr	r3, [pc, #40]	; (800a79c <rt_test_004_001_execute+0x13c>)
 800a774:	62e3      	str	r3, [r4, #44]	; 0x2c
 800a776:	e7fe      	b.n	800a776 <rt_test_004_001_execute+0x116>
 800a778:	200011a0 	.word	0x200011a0
 800a77c:	20001b3c 	.word	0x20001b3c
 800a780:	0800d688 	.word	0x0800d688
 800a784:	20001428 	.word	0x20001428
 800a788:	08004fd1 	.word	0x08004fd1
 800a78c:	20001b54 	.word	0x20001b54
 800a790:	20001b68 	.word	0x20001b68
 800a794:	0800bf74 	.word	0x0800bf74
 800a798:	0800d56c 	.word	0x0800d56c
 800a79c:	0800bc8c 	.word	0x0800bc8c
 800a7a0:	0800d59c 	.word	0x0800d59c
	...

0800a7b0 <rt_test_003_002_execute>:
static void rt_test_003_002_execute(void) {
 800a7b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a7b2:	4d54      	ldr	r5, [pc, #336]	; (800a904 <rt_test_003_002_execute+0x154>)
  test_set_step(1);
 800a7b4:	4e54      	ldr	r6, [pc, #336]	; (800a908 <rt_test_003_002_execute+0x158>)
  return chThdGetSelfX()->prio;
 800a7b6:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800a7b8:	4b54      	ldr	r3, [pc, #336]	; (800a90c <rt_test_003_002_execute+0x15c>)
 800a7ba:	6891      	ldr	r1, [r2, #8]
 800a7bc:	4854      	ldr	r0, [pc, #336]	; (800a910 <rt_test_003_002_execute+0x160>)
 800a7be:	4a55      	ldr	r2, [pc, #340]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a7c0:	4c55      	ldr	r4, [pc, #340]	; (800a918 <rt_test_003_002_execute+0x168>)
 800a7c2:	3905      	subs	r1, #5
  test_set_step(1);
 800a7c4:	2701      	movs	r7, #1
 800a7c6:	6037      	str	r7, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800a7c8:	f7fd fe0a 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a7cc:	69ab      	ldr	r3, [r5, #24]
 800a7ce:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800a7d0:	6899      	ldr	r1, [r3, #8]
 800a7d2:	4a50      	ldr	r2, [pc, #320]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a7d4:	4b51      	ldr	r3, [pc, #324]	; (800a91c <rt_test_003_002_execute+0x16c>)
 800a7d6:	4852      	ldr	r0, [pc, #328]	; (800a920 <rt_test_003_002_execute+0x170>)
 800a7d8:	3904      	subs	r1, #4
 800a7da:	f7fd fe01 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a7de:	69ab      	ldr	r3, [r5, #24]
 800a7e0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800a7e2:	6899      	ldr	r1, [r3, #8]
 800a7e4:	4a4b      	ldr	r2, [pc, #300]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a7e6:	4b4f      	ldr	r3, [pc, #316]	; (800a924 <rt_test_003_002_execute+0x174>)
 800a7e8:	484f      	ldr	r0, [pc, #316]	; (800a928 <rt_test_003_002_execute+0x178>)
 800a7ea:	3903      	subs	r1, #3
 800a7ec:	f7fd fdf8 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a7f0:	69ab      	ldr	r3, [r5, #24]
 800a7f2:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800a7f4:	6899      	ldr	r1, [r3, #8]
 800a7f6:	4a47      	ldr	r2, [pc, #284]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a7f8:	4b4c      	ldr	r3, [pc, #304]	; (800a92c <rt_test_003_002_execute+0x17c>)
 800a7fa:	484d      	ldr	r0, [pc, #308]	; (800a930 <rt_test_003_002_execute+0x180>)
 800a7fc:	3902      	subs	r1, #2
 800a7fe:	f7fd fdef 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a802:	69ab      	ldr	r3, [r5, #24]
 800a804:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800a806:	6899      	ldr	r1, [r3, #8]
 800a808:	4a42      	ldr	r2, [pc, #264]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a80a:	4b4a      	ldr	r3, [pc, #296]	; (800a934 <rt_test_003_002_execute+0x184>)
 800a80c:	484a      	ldr	r0, [pc, #296]	; (800a938 <rt_test_003_002_execute+0x188>)
 800a80e:	3901      	subs	r1, #1
 800a810:	f7fd fde6 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a814:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 800a816:	f7fe fcf3 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800a81a:	4948      	ldr	r1, [pc, #288]	; (800a93c <rt_test_003_002_execute+0x18c>)
 800a81c:	4848      	ldr	r0, [pc, #288]	; (800a940 <rt_test_003_002_execute+0x190>)
 800a81e:	f7f6 f91f 	bl	8000a60 <_test_assert_sequence>
 800a822:	b100      	cbz	r0, 800a826 <rt_test_003_002_execute+0x76>
}
 800a824:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a826:	69aa      	ldr	r2, [r5, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800a828:	4b42      	ldr	r3, [pc, #264]	; (800a934 <rt_test_003_002_execute+0x184>)
 800a82a:	6891      	ldr	r1, [r2, #8]
 800a82c:	4842      	ldr	r0, [pc, #264]	; (800a938 <rt_test_003_002_execute+0x188>)
 800a82e:	4a39      	ldr	r2, [pc, #228]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a830:	3901      	subs	r1, #1
  test_set_step(2);
 800a832:	2702      	movs	r7, #2
 800a834:	6037      	str	r7, [r6, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800a836:	f7fd fdd3 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a83a:	69ab      	ldr	r3, [r5, #24]
 800a83c:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800a83e:	6899      	ldr	r1, [r3, #8]
 800a840:	4a34      	ldr	r2, [pc, #208]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a842:	4b3a      	ldr	r3, [pc, #232]	; (800a92c <rt_test_003_002_execute+0x17c>)
 800a844:	483a      	ldr	r0, [pc, #232]	; (800a930 <rt_test_003_002_execute+0x180>)
 800a846:	3902      	subs	r1, #2
 800a848:	f7fd fdca 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a84c:	69ab      	ldr	r3, [r5, #24]
 800a84e:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800a850:	6899      	ldr	r1, [r3, #8]
 800a852:	4a30      	ldr	r2, [pc, #192]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a854:	4b33      	ldr	r3, [pc, #204]	; (800a924 <rt_test_003_002_execute+0x174>)
 800a856:	4834      	ldr	r0, [pc, #208]	; (800a928 <rt_test_003_002_execute+0x178>)
 800a858:	3903      	subs	r1, #3
 800a85a:	f7fd fdc1 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a85e:	69ab      	ldr	r3, [r5, #24]
 800a860:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800a862:	6899      	ldr	r1, [r3, #8]
 800a864:	4a2b      	ldr	r2, [pc, #172]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a866:	4b2d      	ldr	r3, [pc, #180]	; (800a91c <rt_test_003_002_execute+0x16c>)
 800a868:	482d      	ldr	r0, [pc, #180]	; (800a920 <rt_test_003_002_execute+0x170>)
 800a86a:	3904      	subs	r1, #4
 800a86c:	f7fd fdb8 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a870:	69ab      	ldr	r3, [r5, #24]
 800a872:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800a874:	6899      	ldr	r1, [r3, #8]
 800a876:	4a27      	ldr	r2, [pc, #156]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a878:	4b24      	ldr	r3, [pc, #144]	; (800a90c <rt_test_003_002_execute+0x15c>)
 800a87a:	4825      	ldr	r0, [pc, #148]	; (800a910 <rt_test_003_002_execute+0x160>)
 800a87c:	3905      	subs	r1, #5
 800a87e:	f7fd fdaf 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a882:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 800a884:	f7fe fcbc 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800a888:	492c      	ldr	r1, [pc, #176]	; (800a93c <rt_test_003_002_execute+0x18c>)
 800a88a:	482d      	ldr	r0, [pc, #180]	; (800a940 <rt_test_003_002_execute+0x190>)
 800a88c:	f7f6 f8e8 	bl	8000a60 <_test_assert_sequence>
 800a890:	2800      	cmp	r0, #0
 800a892:	d1c7      	bne.n	800a824 <rt_test_003_002_execute+0x74>
 800a894:	69aa      	ldr	r2, [r5, #24]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800a896:	4b21      	ldr	r3, [pc, #132]	; (800a91c <rt_test_003_002_execute+0x16c>)
 800a898:	6891      	ldr	r1, [r2, #8]
 800a89a:	4821      	ldr	r0, [pc, #132]	; (800a920 <rt_test_003_002_execute+0x170>)
 800a89c:	4a1d      	ldr	r2, [pc, #116]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a89e:	3904      	subs	r1, #4
  test_set_step(3);
 800a8a0:	2703      	movs	r7, #3
 800a8a2:	6037      	str	r7, [r6, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800a8a4:	f7fd fd9c 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a8a8:	69ab      	ldr	r3, [r5, #24]
 800a8aa:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800a8ac:	6899      	ldr	r1, [r3, #8]
 800a8ae:	4a19      	ldr	r2, [pc, #100]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a8b0:	4b16      	ldr	r3, [pc, #88]	; (800a90c <rt_test_003_002_execute+0x15c>)
 800a8b2:	4817      	ldr	r0, [pc, #92]	; (800a910 <rt_test_003_002_execute+0x160>)
 800a8b4:	3905      	subs	r1, #5
 800a8b6:	f7fd fd93 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a8ba:	69ab      	ldr	r3, [r5, #24]
 800a8bc:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800a8be:	6899      	ldr	r1, [r3, #8]
 800a8c0:	4a14      	ldr	r2, [pc, #80]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a8c2:	4b1c      	ldr	r3, [pc, #112]	; (800a934 <rt_test_003_002_execute+0x184>)
 800a8c4:	481c      	ldr	r0, [pc, #112]	; (800a938 <rt_test_003_002_execute+0x188>)
 800a8c6:	3901      	subs	r1, #1
 800a8c8:	f7fd fd8a 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a8cc:	69ab      	ldr	r3, [r5, #24]
 800a8ce:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800a8d0:	6899      	ldr	r1, [r3, #8]
 800a8d2:	4a10      	ldr	r2, [pc, #64]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a8d4:	4b15      	ldr	r3, [pc, #84]	; (800a92c <rt_test_003_002_execute+0x17c>)
 800a8d6:	4816      	ldr	r0, [pc, #88]	; (800a930 <rt_test_003_002_execute+0x180>)
 800a8d8:	3902      	subs	r1, #2
 800a8da:	f7fd fd81 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a8de:	69ab      	ldr	r3, [r5, #24]
 800a8e0:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800a8e2:	6899      	ldr	r1, [r3, #8]
 800a8e4:	4a0b      	ldr	r2, [pc, #44]	; (800a914 <rt_test_003_002_execute+0x164>)
 800a8e6:	4b0f      	ldr	r3, [pc, #60]	; (800a924 <rt_test_003_002_execute+0x174>)
 800a8e8:	480f      	ldr	r0, [pc, #60]	; (800a928 <rt_test_003_002_execute+0x178>)
 800a8ea:	3903      	subs	r1, #3
 800a8ec:	f7fd fd78 	bl	80083e0 <chThdCreateStatic.constprop.60>
 800a8f0:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 800a8f2:	f7fe fc85 	bl	8009200 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800a8f6:	4911      	ldr	r1, [pc, #68]	; (800a93c <rt_test_003_002_execute+0x18c>)
 800a8f8:	4811      	ldr	r0, [pc, #68]	; (800a940 <rt_test_003_002_execute+0x190>)
}
 800a8fa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 800a8fe:	f7f6 b8af 	b.w	8000a60 <_test_assert_sequence>
 800a902:	bf00      	nop
 800a904:	200011a0 	.word	0x200011a0
 800a908:	20001b3c 	.word	0x20001b3c
 800a90c:	0800d714 	.word	0x0800d714
 800a910:	20001428 	.word	0x20001428
 800a914:	08005051 	.word	0x08005051
 800a918:	20001b54 	.word	0x20001b54
 800a91c:	0800e62c 	.word	0x0800e62c
 800a920:	20001570 	.word	0x20001570
 800a924:	0800d8d4 	.word	0x0800d8d4
 800a928:	200016b8 	.word	0x200016b8
 800a92c:	0800d68c 	.word	0x0800d68c
 800a930:	20001800 	.word	0x20001800
 800a934:	0800d688 	.word	0x0800d688
 800a938:	20001948 	.word	0x20001948
 800a93c:	0800d774 	.word	0x0800d774
 800a940:	0800d710 	.word	0x0800d710
	...

0800a950 <cmd_test>:
}

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 800a950:	b530      	push	{r4, r5, lr}
  thread_t *tp;
  tfunc_t tfp;

  (void)argv;
  if (argc != 1) {
 800a952:	2901      	cmp	r1, #1
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 800a954:	b083      	sub	sp, #12
 800a956:	4604      	mov	r4, r0
  if (argc != 1) {
 800a958:	d11c      	bne.n	800a994 <cmd_test+0x44>
    shellUsage(chp, "test rt|oslib");
    return;
  }
  if (!strcmp(argv[0], "rt")) {
 800a95a:	6815      	ldr	r5, [r2, #0]
 800a95c:	4916      	ldr	r1, [pc, #88]	; (800a9b8 <cmd_test+0x68>)
 800a95e:	4628      	mov	r0, r5
 800a960:	f7f5 fd52 	bl	8000408 <strcmp>
 800a964:	b1f0      	cbz	r0, 800a9a4 <cmd_test+0x54>
    tfp = test_rt;
  }
  else if (!strcmp(argv[0], "oslib")) {
 800a966:	4628      	mov	r0, r5
 800a968:	4914      	ldr	r1, [pc, #80]	; (800a9bc <cmd_test+0x6c>)
 800a96a:	f7f5 fd4d 	bl	8000408 <strcmp>
 800a96e:	b988      	cbnz	r0, 800a994 <cmd_test+0x44>
    tfp = test_oslib;
 800a970:	4913      	ldr	r1, [pc, #76]	; (800a9c0 <cmd_test+0x70>)
  return ch.rlist.current;
 800a972:	4b14      	ldr	r3, [pc, #80]	; (800a9c4 <cmd_test+0x74>)
  }
  else {
    shellUsage(chp, "test rt|oslib");
    return;
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
 800a974:	4a14      	ldr	r2, [pc, #80]	; (800a9c8 <cmd_test+0x78>)
  return chThdGetSelfX()->prio;
 800a976:	699b      	ldr	r3, [r3, #24]
 800a978:	2000      	movs	r0, #0
 800a97a:	689b      	ldr	r3, [r3, #8]
 800a97c:	e9cd 1400 	strd	r1, r4, [sp]
 800a980:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 800a984:	f7fb fb4c 	bl	8006020 <chThdCreateFromHeap>
                           "test", chThdGetPriorityX(),
                           tfp, chp);
  if (tp == NULL) {
 800a988:	b170      	cbz	r0, 800a9a8 <cmd_test+0x58>
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
    return;
  }
  chThdWait(tp);
}
 800a98a:	b003      	add	sp, #12
 800a98c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  chThdWait(tp);
 800a990:	f7fe b8be 	b.w	8008b10 <chThdWait>
    shellUsage(chp, "test rt|oslib");
 800a994:	4a0d      	ldr	r2, [pc, #52]	; (800a9cc <cmd_test+0x7c>)
 800a996:	490e      	ldr	r1, [pc, #56]	; (800a9d0 <cmd_test+0x80>)
 800a998:	4620      	mov	r0, r4
}
 800a99a:	b003      	add	sp, #12
 800a99c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    shellUsage(chp, "test rt|oslib");
 800a9a0:	f7f7 bff6 	b.w	8002990 <chprintf>
    tfp = test_rt;
 800a9a4:	490b      	ldr	r1, [pc, #44]	; (800a9d4 <cmd_test+0x84>)
 800a9a6:	e7e4      	b.n	800a972 <cmd_test+0x22>
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
 800a9a8:	490b      	ldr	r1, [pc, #44]	; (800a9d8 <cmd_test+0x88>)
 800a9aa:	4620      	mov	r0, r4
}
 800a9ac:	b003      	add	sp, #12
 800a9ae:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
 800a9b2:	f7f7 bfed 	b.w	8002990 <chprintf>
 800a9b6:	bf00      	nop
 800a9b8:	0800c3f0 	.word	0x0800c3f0
 800a9bc:	0800c3e8 	.word	0x0800c3e8
 800a9c0:	08007f51 	.word	0x08007f51
 800a9c4:	200011a0 	.word	0x200011a0
 800a9c8:	0800e22c 	.word	0x0800e22c
 800a9cc:	0800c3e0 	.word	0x0800c3e0
 800a9d0:	0800c234 	.word	0x0800c234
 800a9d4:	08007f41 	.word	0x08007f41
 800a9d8:	0800c3f4 	.word	0x0800c3f4
 800a9dc:	00000000 	.word	0x00000000

0800a9e0 <chSysGetStatusAndLockX.part.1>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800a9e0:	f3ef 8305 	mrs	r3, IPSR
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 800a9e4:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (port_is_isr_context()) {
 800a9e8:	b923      	cbnz	r3, 800a9f4 <chSysGetStatusAndLockX.part.1+0x14>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a9ea:	2320      	movs	r3, #32
 800a9ec:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a9f0:	f7f8 bee6 	b.w	80037c0 <_dbg_check_lock>
 800a9f4:	2320      	movs	r3, #32
 800a9f6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800a9fa:	f7f6 bb61 	b.w	80010c0 <_dbg_check_lock_from_isr>
 800a9fe:	bf00      	nop

0800aa00 <rt_test_002_002_execute>:
static void rt_test_002_002_execute(void) {
 800aa00:	b530      	push	{r4, r5, lr}
  test_set_step(1);
 800aa02:	4d67      	ldr	r5, [pc, #412]	; (800aba0 <rt_test_002_002_execute+0x1a0>)
 800aa04:	2301      	movs	r3, #1
static void rt_test_002_002_execute(void) {
 800aa06:	b087      	sub	sp, #28
  test_set_step(1);
 800aa08:	602b      	str	r3, [r5, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aa0a:	f3ef 8311 	mrs	r3, BASEPRI
  if (port_irq_enabled(sts)) {
 800aa0e:	b91b      	cbnz	r3, 800aa18 <rt_test_002_002_execute+0x18>
 800aa10:	f7ff ffe6 	bl	800a9e0 <chSysGetStatusAndLockX.part.1>
 800aa14:	f7f8 feac 	bl	8003770 <chSysRestoreStatusX.part.2>
  test_set_step(2);
 800aa18:	2302      	movs	r3, #2
 800aa1a:	602b      	str	r3, [r5, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800aa1c:	2320      	movs	r3, #32
 800aa1e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800aa22:	f7f8 fecd 	bl	80037c0 <_dbg_check_lock>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aa26:	f3ef 8311 	mrs	r3, BASEPRI
 800aa2a:	b91b      	cbnz	r3, 800aa34 <rt_test_002_002_execute+0x34>
 800aa2c:	f7ff ffd8 	bl	800a9e0 <chSysGetStatusAndLockX.part.1>
 800aa30:	f7f8 fe9e 	bl	8003770 <chSysRestoreStatusX.part.2>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800aa34:	4c5b      	ldr	r4, [pc, #364]	; (800aba4 <rt_test_002_002_execute+0x1a4>)
  _dbg_check_unlock();
 800aa36:	f7f8 fe5b 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800aa3a:	6823      	ldr	r3, [r4, #0]
 800aa3c:	42a3      	cmp	r3, r4
 800aa3e:	d005      	beq.n	800aa4c <rt_test_002_002_execute+0x4c>
 800aa40:	69a2      	ldr	r2, [r4, #24]
 800aa42:	689b      	ldr	r3, [r3, #8]
 800aa44:	6892      	ldr	r2, [r2, #8]
 800aa46:	429a      	cmp	r2, r3
 800aa48:	f0c0 8099 	bcc.w	800ab7e <rt_test_002_002_execute+0x17e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800aa4c:	2300      	movs	r3, #0
 800aa4e:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 800aa52:	2303      	movs	r3, #3
 800aa54:	602b      	str	r3, [r5, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aa56:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 800aa5a:	b923      	cbnz	r3, 800aa66 <rt_test_002_002_execute+0x66>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800aa5c:	2320      	movs	r3, #32
 800aa5e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800aa62:	f7f8 fead 	bl	80037c0 <_dbg_check_lock>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aa66:	f3ef 8311 	mrs	r3, BASEPRI
  if (port_irq_enabled(port_get_irq_status())) {
 800aa6a:	b923      	cbnz	r3, 800aa76 <rt_test_002_002_execute+0x76>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800aa6c:	2320      	movs	r3, #32
 800aa6e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800aa72:	f7f8 fea5 	bl	80037c0 <_dbg_check_lock>
  _dbg_check_unlock();
 800aa76:	f7f8 fe3b 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800aa7a:	6823      	ldr	r3, [r4, #0]
 800aa7c:	42a3      	cmp	r3, r4
 800aa7e:	d004      	beq.n	800aa8a <rt_test_002_002_execute+0x8a>
 800aa80:	69a2      	ldr	r2, [r4, #24]
 800aa82:	689b      	ldr	r3, [r3, #8]
 800aa84:	6892      	ldr	r2, [r2, #8]
 800aa86:	429a      	cmp	r2, r3
 800aa88:	d375      	bcc.n	800ab76 <rt_test_002_002_execute+0x176>
 800aa8a:	2300      	movs	r3, #0
 800aa8c:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
 800aa90:	2304      	movs	r3, #4
 800aa92:	602b      	str	r3, [r5, #0]
 800aa94:	2320      	movs	r3, #32
 800aa96:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800aa9a:	f7f8 fe91 	bl	80037c0 <_dbg_check_lock>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800aa9e:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 800aaa2:	2b00      	cmp	r3, #0
 800aaa4:	d159      	bne.n	800ab5a <rt_test_002_002_execute+0x15a>
 800aaa6:	f3ef 8311 	mrs	r3, BASEPRI
 800aaaa:	2b00      	cmp	r3, #0
 800aaac:	d147      	bne.n	800ab3e <rt_test_002_002_execute+0x13e>
  test_set_step(5);
 800aaae:	2205      	movs	r2, #5
  vtp->func = NULL;
 800aab0:	2300      	movs	r3, #0
 800aab2:	9304      	str	r3, [sp, #16]
 800aab4:	602a      	str	r2, [r5, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800aab6:	2320      	movs	r3, #32
 800aab8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800aabc:	f7f8 fe80 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 800aac0:	f7f6 f88e 	bl	8000be0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800aac4:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 800aac6:	ad01      	add	r5, sp, #4
  if (chVTIsArmedI(vtp)) {
 800aac8:	b113      	cbz	r3, 800aad0 <rt_test_002_002_execute+0xd0>
    chVTDoResetI(vtp);
 800aaca:	4628      	mov	r0, r5
 800aacc:	f7f7 f898 	bl	8001c00 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800aad0:	2300      	movs	r3, #0
 800aad2:	4628      	mov	r0, r5
 800aad4:	4a34      	ldr	r2, [pc, #208]	; (800aba8 <rt_test_002_002_execute+0x1a8>)
 800aad6:	2101      	movs	r1, #1
 800aad8:	f7f7 f8da 	bl	8001c90 <chVTDoSetI>
  _dbg_check_unlock();
 800aadc:	f7f8 fe08 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800aae0:	6823      	ldr	r3, [r4, #0]
 800aae2:	42a3      	cmp	r3, r4
 800aae4:	d008      	beq.n	800aaf8 <rt_test_002_002_execute+0xf8>
 800aae6:	69a2      	ldr	r2, [r4, #24]
 800aae8:	689b      	ldr	r3, [r3, #8]
 800aaea:	6892      	ldr	r2, [r2, #8]
 800aaec:	429a      	cmp	r2, r3
 800aaee:	d203      	bcs.n	800aaf8 <rt_test_002_002_execute+0xf8>
  __ASM volatile ("cpsid i" : : : "memory");
 800aaf0:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 800aaf2:	4b2e      	ldr	r3, [pc, #184]	; (800abac <rt_test_002_002_execute+0x1ac>)
 800aaf4:	62e3      	str	r3, [r4, #44]	; 0x2c
 800aaf6:	e7fe      	b.n	800aaf6 <rt_test_002_002_execute+0xf6>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800aaf8:	2300      	movs	r3, #0
 800aafa:	f383 8811 	msr	BASEPRI, r3
    chThdSleep(10);
 800aafe:	200a      	movs	r0, #10
 800ab00:	f7fc fd96 	bl	8007630 <chThdSleep>
 800ab04:	2320      	movs	r3, #32
 800ab06:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800ab0a:	f7f8 fe59 	bl	80037c0 <_dbg_check_lock>
  chDbgCheckClassI();
 800ab0e:	f7f6 f867 	bl	8000be0 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
 800ab12:	9804      	ldr	r0, [sp, #16]
  _dbg_check_unlock();
 800ab14:	f7f8 fdec 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ab18:	6823      	ldr	r3, [r4, #0]
 800ab1a:	42a3      	cmp	r3, r4
 800ab1c:	d004      	beq.n	800ab28 <rt_test_002_002_execute+0x128>
 800ab1e:	69a2      	ldr	r2, [r4, #24]
 800ab20:	689b      	ldr	r3, [r3, #8]
 800ab22:	6892      	ldr	r2, [r2, #8]
 800ab24:	429a      	cmp	r2, r3
 800ab26:	d336      	bcc.n	800ab96 <rt_test_002_002_execute+0x196>
 800ab28:	2300      	movs	r3, #0
 800ab2a:	f383 8811 	msr	BASEPRI, r3
    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 800ab2e:	fab0 f080 	clz	r0, r0
 800ab32:	491f      	ldr	r1, [pc, #124]	; (800abb0 <rt_test_002_002_execute+0x1b0>)
 800ab34:	0940      	lsrs	r0, r0, #5
 800ab36:	f7f5 fef3 	bl	8000920 <_test_assert>
}
 800ab3a:	b007      	add	sp, #28
 800ab3c:	bd30      	pop	{r4, r5, pc}
  _dbg_check_unlock();
 800ab3e:	f7f8 fdd7 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ab42:	6823      	ldr	r3, [r4, #0]
 800ab44:	42a3      	cmp	r3, r4
 800ab46:	d004      	beq.n	800ab52 <rt_test_002_002_execute+0x152>
 800ab48:	69a2      	ldr	r2, [r4, #24]
 800ab4a:	689b      	ldr	r3, [r3, #8]
 800ab4c:	6892      	ldr	r2, [r2, #8]
 800ab4e:	429a      	cmp	r2, r3
 800ab50:	d31d      	bcc.n	800ab8e <rt_test_002_002_execute+0x18e>
 800ab52:	2300      	movs	r3, #0
 800ab54:	f383 8811 	msr	BASEPRI, r3
 800ab58:	e7a9      	b.n	800aaae <rt_test_002_002_execute+0xae>
  _dbg_check_unlock();
 800ab5a:	f7f8 fdc9 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ab5e:	6823      	ldr	r3, [r4, #0]
 800ab60:	42a3      	cmp	r3, r4
 800ab62:	d004      	beq.n	800ab6e <rt_test_002_002_execute+0x16e>
 800ab64:	69a2      	ldr	r2, [r4, #24]
 800ab66:	689b      	ldr	r3, [r3, #8]
 800ab68:	6892      	ldr	r2, [r2, #8]
 800ab6a:	429a      	cmp	r2, r3
 800ab6c:	d30b      	bcc.n	800ab86 <rt_test_002_002_execute+0x186>
 800ab6e:	2300      	movs	r3, #0
 800ab70:	f383 8811 	msr	BASEPRI, r3
 800ab74:	e797      	b.n	800aaa6 <rt_test_002_002_execute+0xa6>
  __ASM volatile ("cpsid i" : : : "memory");
 800ab76:	b672      	cpsid	i
 800ab78:	4b0c      	ldr	r3, [pc, #48]	; (800abac <rt_test_002_002_execute+0x1ac>)
 800ab7a:	62e3      	str	r3, [r4, #44]	; 0x2c
 800ab7c:	e7fe      	b.n	800ab7c <rt_test_002_002_execute+0x17c>
 800ab7e:	b672      	cpsid	i
 800ab80:	4b0a      	ldr	r3, [pc, #40]	; (800abac <rt_test_002_002_execute+0x1ac>)
 800ab82:	62e3      	str	r3, [r4, #44]	; 0x2c
 800ab84:	e7fe      	b.n	800ab84 <rt_test_002_002_execute+0x184>
 800ab86:	b672      	cpsid	i
 800ab88:	4b08      	ldr	r3, [pc, #32]	; (800abac <rt_test_002_002_execute+0x1ac>)
 800ab8a:	62e3      	str	r3, [r4, #44]	; 0x2c
 800ab8c:	e7fe      	b.n	800ab8c <rt_test_002_002_execute+0x18c>
 800ab8e:	b672      	cpsid	i
 800ab90:	4b06      	ldr	r3, [pc, #24]	; (800abac <rt_test_002_002_execute+0x1ac>)
 800ab92:	62e3      	str	r3, [r4, #44]	; 0x2c
 800ab94:	e7fe      	b.n	800ab94 <rt_test_002_002_execute+0x194>
 800ab96:	b672      	cpsid	i
 800ab98:	4b04      	ldr	r3, [pc, #16]	; (800abac <rt_test_002_002_execute+0x1ac>)
 800ab9a:	62e3      	str	r3, [r4, #44]	; 0x2c
 800ab9c:	e7fe      	b.n	800ab9c <rt_test_002_002_execute+0x19c>
 800ab9e:	bf00      	nop
 800aba0:	20001b3c 	.word	0x20001b3c
 800aba4:	200011a0 	.word	0x200011a0
 800aba8:	0800abc1 	.word	0x0800abc1
 800abac:	0800bc74 	.word	0x0800bc74
 800abb0:	0800d458 	.word	0x0800d458
	...

0800abc0 <vtcb>:
static void vtcb(void *p) {
 800abc0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800abc2:	2120      	movs	r1, #32
 800abc4:	f381 8811 	msr	BASEPRI, r1
  _dbg_check_lock_from_isr();
 800abc8:	f7f6 fa7a 	bl	80010c0 <_dbg_check_lock_from_isr>
  _dbg_check_unlock_from_isr();
 800abcc:	f7f6 fa60 	bl	8001090 <_dbg_check_unlock_from_isr>
 800abd0:	2300      	movs	r3, #0
 800abd2:	f383 8811 	msr	BASEPRI, r3
 800abd6:	f381 8811 	msr	BASEPRI, r1
  _dbg_check_lock_from_isr();
 800abda:	f7f6 fa71 	bl	80010c0 <_dbg_check_lock_from_isr>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800abde:	f3ef 8311 	mrs	r3, BASEPRI
  if (port_irq_enabled(sts)) {
 800abe2:	b91b      	cbnz	r3, 800abec <vtcb+0x2c>
 800abe4:	f7ff fefc 	bl	800a9e0 <chSysGetStatusAndLockX.part.1>
 800abe8:	f7f8 fdc2 	bl	8003770 <chSysRestoreStatusX.part.2>
  _dbg_check_unlock_from_isr();
 800abec:	f7f6 fa50 	bl	8001090 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800abf0:	2300      	movs	r3, #0
 800abf2:	f383 8811 	msr	BASEPRI, r3
}
 800abf6:	bd08      	pop	{r3, pc}
	...

0800ac00 <obqWriteTimeout>:
  osalDbgCheck(n > 0U);
 800ac00:	2a00      	cmp	r2, #0
 800ac02:	d07d      	beq.n	800ad00 <obqWriteTimeout+0x100>
                       size_t n, sysinterval_t timeout) {
 800ac04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ac08:	4698      	mov	r8, r3
 800ac0a:	b083      	sub	sp, #12
 800ac0c:	4606      	mov	r6, r0
 800ac0e:	460c      	mov	r4, r1
 800ac10:	4693      	mov	fp, r2
 800ac12:	2320      	movs	r3, #32
 800ac14:	f383 8811 	msr	BASEPRI, r3
 800ac18:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
  _dbg_check_lock();
 800ac1c:	f7f8 fdd0 	bl	80037c0 <_dbg_check_lock>
 800ac20:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
    if (obqp->ptr == NULL) {
 800ac24:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 800ac26:	f8df a144 	ldr.w	sl, [pc, #324]	; 800ad6c <obqWriteTimeout+0x16c>
 800ac2a:	eb08 0302 	add.w	r3, r8, r2
 800ac2e:	9300      	str	r3, [sp, #0]
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800ac30:	f108 33ff 	add.w	r3, r8, #4294967295
  size_t w = 0;
 800ac34:	2700      	movs	r7, #0
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800ac36:	9301      	str	r3, [sp, #4]
    if (obqp->ptr == NULL) {
 800ac38:	2800      	cmp	r0, #0
 800ac3a:	d03b      	beq.n	800acb4 <obqWriteTimeout+0xb4>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800ac3c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    if (size > (n - w)) {
 800ac3e:	ebab 0507 	sub.w	r5, fp, r7
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800ac42:	1a1b      	subs	r3, r3, r0
 800ac44:	429d      	cmp	r5, r3
 800ac46:	bf28      	it	cs
 800ac48:	461d      	movcs	r5, r3
    if (size > 64U) {
 800ac4a:	2d40      	cmp	r5, #64	; 0x40
 800ac4c:	d941      	bls.n	800acd2 <obqWriteTimeout+0xd2>
      memcpy(obqp->ptr, bp, 64U);
 800ac4e:	4603      	mov	r3, r0
 800ac50:	f104 0240 	add.w	r2, r4, #64	; 0x40
 800ac54:	6825      	ldr	r5, [r4, #0]
 800ac56:	6860      	ldr	r0, [r4, #4]
 800ac58:	68a1      	ldr	r1, [r4, #8]
 800ac5a:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 800ac5e:	f8c3 c00c 	str.w	ip, [r3, #12]
 800ac62:	3410      	adds	r4, #16
 800ac64:	4294      	cmp	r4, r2
 800ac66:	601d      	str	r5, [r3, #0]
 800ac68:	6058      	str	r0, [r3, #4]
 800ac6a:	6099      	str	r1, [r3, #8]
 800ac6c:	f103 0310 	add.w	r3, r3, #16
 800ac70:	d1f0      	bne.n	800ac54 <obqWriteTimeout+0x54>
      obqp->ptr += 64U;
 800ac72:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 800ac74:	6af2      	ldr	r2, [r6, #44]	; 0x2c
      obqp->ptr += 64U;
 800ac76:	3340      	adds	r3, #64	; 0x40
    if (obqp->ptr >= obqp->top) {
 800ac78:	429a      	cmp	r2, r3
      w         += 64U;
 800ac7a:	f107 0740 	add.w	r7, r7, #64	; 0x40
      obqp->ptr += 64U;
 800ac7e:	62b3      	str	r3, [r6, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 800ac80:	d933      	bls.n	800acea <obqWriteTimeout+0xea>
  _dbg_check_unlock();
 800ac82:	f7f8 fd35 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ac86:	f8da 3000 	ldr.w	r3, [sl]
 800ac8a:	4553      	cmp	r3, sl
 800ac8c:	d005      	beq.n	800ac9a <obqWriteTimeout+0x9a>
 800ac8e:	f8da 2018 	ldr.w	r2, [sl, #24]
 800ac92:	689b      	ldr	r3, [r3, #8]
 800ac94:	6892      	ldr	r2, [r2, #8]
 800ac96:	429a      	cmp	r2, r3
 800ac98:	d32d      	bcc.n	800acf6 <obqWriteTimeout+0xf6>
 800ac9a:	2300      	movs	r3, #0
 800ac9c:	f383 8811 	msr	BASEPRI, r3
    if (w >= n) {
 800aca0:	455f      	cmp	r7, fp
 800aca2:	d241      	bcs.n	800ad28 <obqWriteTimeout+0x128>
 800aca4:	2320      	movs	r3, #32
 800aca6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800acaa:	f7f8 fd89 	bl	80037c0 <_dbg_check_lock>
    if (obqp->ptr == NULL) {
 800acae:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 800acb0:	2800      	cmp	r0, #0
 800acb2:	d1c3      	bne.n	800ac3c <obqWriteTimeout+0x3c>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800acb4:	9b01      	ldr	r3, [sp, #4]
 800acb6:	3303      	adds	r3, #3
 800acb8:	d850      	bhi.n	800ad5c <obqWriteTimeout+0x15c>
 800acba:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 800acbe:	9b00      	ldr	r3, [sp, #0]
 800acc0:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 800acc2:	4588      	cmp	r8, r1
 800acc4:	d339      	bcc.n	800ad3a <obqWriteTimeout+0x13a>
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 800acc6:	4630      	mov	r0, r6
 800acc8:	f7f8 fa72 	bl	80031b0 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 800accc:	b9e8      	cbnz	r0, 800ad0a <obqWriteTimeout+0x10a>
 800acce:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 800acd0:	e7b4      	b.n	800ac3c <obqWriteTimeout+0x3c>
      memcpy(obqp->ptr, bp, size);
 800acd2:	462a      	mov	r2, r5
 800acd4:	4621      	mov	r1, r4
 800acd6:	f7f5 faed 	bl	80002b4 <memcpy>
      obqp->ptr += size;
 800acda:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 800acdc:	6af2      	ldr	r2, [r6, #44]	; 0x2c
      obqp->ptr += size;
 800acde:	442b      	add	r3, r5
    if (obqp->ptr >= obqp->top) {
 800ace0:	429a      	cmp	r2, r3
      w         += size;
 800ace2:	442f      	add	r7, r5
      bp        += size;
 800ace4:	442c      	add	r4, r5
      obqp->ptr += size;
 800ace6:	62b3      	str	r3, [r6, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 800ace8:	d8cb      	bhi.n	800ac82 <obqWriteTimeout+0x82>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800acea:	69f1      	ldr	r1, [r6, #28]
 800acec:	4630      	mov	r0, r6
 800acee:	3904      	subs	r1, #4
 800acf0:	f7f6 fe1e 	bl	8001930 <obqPostFullBufferS>
 800acf4:	e7c5      	b.n	800ac82 <obqWriteTimeout+0x82>
  __ASM volatile ("cpsid i" : : : "memory");
 800acf6:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 800acf8:	4a1b      	ldr	r2, [pc, #108]	; (800ad68 <obqWriteTimeout+0x168>)
 800acfa:	f8ca 202c 	str.w	r2, [sl, #44]	; 0x2c
 800acfe:	e7fe      	b.n	800acfe <obqWriteTimeout+0xfe>
 800ad00:	b672      	cpsid	i
 800ad02:	4b1a      	ldr	r3, [pc, #104]	; (800ad6c <obqWriteTimeout+0x16c>)
 800ad04:	4a1a      	ldr	r2, [pc, #104]	; (800ad70 <obqWriteTimeout+0x170>)
 800ad06:	62da      	str	r2, [r3, #44]	; 0x2c
 800ad08:	e7fe      	b.n	800ad08 <obqWriteTimeout+0x108>
  _dbg_check_unlock();
 800ad0a:	f7f8 fcf1 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ad0e:	f8da 2000 	ldr.w	r2, [sl]
 800ad12:	4552      	cmp	r2, sl
 800ad14:	d005      	beq.n	800ad22 <obqWriteTimeout+0x122>
 800ad16:	f8da 1018 	ldr.w	r1, [sl, #24]
 800ad1a:	6892      	ldr	r2, [r2, #8]
 800ad1c:	6889      	ldr	r1, [r1, #8]
 800ad1e:	4291      	cmp	r1, r2
 800ad20:	d306      	bcc.n	800ad30 <obqWriteTimeout+0x130>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ad22:	2300      	movs	r3, #0
 800ad24:	f383 8811 	msr	BASEPRI, r3
}
 800ad28:	4638      	mov	r0, r7
 800ad2a:	b003      	add	sp, #12
 800ad2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800ad30:	b672      	cpsid	i
 800ad32:	4a0d      	ldr	r2, [pc, #52]	; (800ad68 <obqWriteTimeout+0x168>)
 800ad34:	f8ca 202c 	str.w	r2, [sl, #44]	; 0x2c
 800ad38:	e7fe      	b.n	800ad38 <obqWriteTimeout+0x138>
  _dbg_check_unlock();
 800ad3a:	f7f8 fcd9 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ad3e:	f8da 2000 	ldr.w	r2, [sl]
 800ad42:	4552      	cmp	r2, sl
 800ad44:	d0ed      	beq.n	800ad22 <obqWriteTimeout+0x122>
 800ad46:	f8da 1018 	ldr.w	r1, [sl, #24]
 800ad4a:	6892      	ldr	r2, [r2, #8]
 800ad4c:	6889      	ldr	r1, [r1, #8]
 800ad4e:	4291      	cmp	r1, r2
 800ad50:	d2e7      	bcs.n	800ad22 <obqWriteTimeout+0x122>
 800ad52:	b672      	cpsid	i
 800ad54:	4a04      	ldr	r2, [pc, #16]	; (800ad68 <obqWriteTimeout+0x168>)
 800ad56:	f8ca 202c 	str.w	r2, [sl, #44]	; 0x2c
 800ad5a:	e7fe      	b.n	800ad5a <obqWriteTimeout+0x15a>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800ad5c:	4641      	mov	r1, r8
 800ad5e:	4630      	mov	r0, r6
 800ad60:	f7f8 fa26 	bl	80031b0 <obqGetEmptyBufferTimeoutS>
 800ad64:	e7b2      	b.n	800accc <obqWriteTimeout+0xcc>
 800ad66:	bf00      	nop
 800ad68:	0800bcf4 	.word	0x0800bcf4
 800ad6c:	200011a0 	.word	0x200011a0
 800ad70:	0800c144 	.word	0x0800c144
	...

0800ad80 <_writet>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 800ad80:	3044      	adds	r0, #68	; 0x44
 800ad82:	f7ff bf3d 	b.w	800ac00 <obqWriteTimeout>
 800ad86:	bf00      	nop
	...

0800ad90 <_write>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 800ad90:	3044      	adds	r0, #68	; 0x44
 800ad92:	f04f 33ff 	mov.w	r3, #4294967295
 800ad96:	f7ff bf33 	b.w	800ac00 <obqWriteTimeout>
 800ad9a:	bf00      	nop
 800ad9c:	0000      	movs	r0, r0
	...

0800ada0 <obqPutTimeout>:
                    sysinterval_t timeout) {
 800ada0:	b538      	push	{r3, r4, r5, lr}
 800ada2:	460d      	mov	r5, r1
 800ada4:	4604      	mov	r4, r0
 800ada6:	4611      	mov	r1, r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ada8:	2320      	movs	r3, #32
 800adaa:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800adae:	f7f8 fd07 	bl	80037c0 <_dbg_check_lock>
  if (obqp->ptr == NULL) {
 800adb2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800adb4:	b1ab      	cbz	r3, 800ade2 <obqPutTimeout+0x42>
  *obqp->ptr = b;
 800adb6:	701d      	strb	r5, [r3, #0]
  if (obqp->ptr >= obqp->top) {
 800adb8:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
  obqp->ptr++;
 800adbc:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 800adbe:	4293      	cmp	r3, r2
  obqp->ptr++;
 800adc0:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 800adc2:	d217      	bcs.n	800adf4 <obqPutTimeout+0x54>
  _dbg_check_unlock();
 800adc4:	f7f8 fc94 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800adc8:	4b17      	ldr	r3, [pc, #92]	; (800ae28 <obqPutTimeout+0x88>)
 800adca:	681a      	ldr	r2, [r3, #0]
 800adcc:	429a      	cmp	r2, r3
 800adce:	d004      	beq.n	800adda <obqPutTimeout+0x3a>
 800add0:	6999      	ldr	r1, [r3, #24]
 800add2:	6892      	ldr	r2, [r2, #8]
 800add4:	6889      	ldr	r1, [r1, #8]
 800add6:	4291      	cmp	r1, r2
 800add8:	d308      	bcc.n	800adec <obqPutTimeout+0x4c>
 800adda:	2000      	movs	r0, #0
 800addc:	f380 8811 	msr	BASEPRI, r0
}
 800ade0:	bd38      	pop	{r3, r4, r5, pc}
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800ade2:	f7f8 f9e5 	bl	80031b0 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 800ade6:	b958      	cbnz	r0, 800ae00 <obqPutTimeout+0x60>
 800ade8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800adea:	e7e4      	b.n	800adb6 <obqPutTimeout+0x16>
  __ASM volatile ("cpsid i" : : : "memory");
 800adec:	b672      	cpsid	i
 800adee:	4a0f      	ldr	r2, [pc, #60]	; (800ae2c <obqPutTimeout+0x8c>)
 800adf0:	62da      	str	r2, [r3, #44]	; 0x2c
 800adf2:	e7fe      	b.n	800adf2 <obqPutTimeout+0x52>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800adf4:	69e1      	ldr	r1, [r4, #28]
 800adf6:	4620      	mov	r0, r4
 800adf8:	3904      	subs	r1, #4
 800adfa:	f7f6 fd99 	bl	8001930 <obqPostFullBufferS>
 800adfe:	e7e1      	b.n	800adc4 <obqPutTimeout+0x24>
  _dbg_check_unlock();
 800ae00:	f7f8 fc76 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ae04:	4b08      	ldr	r3, [pc, #32]	; (800ae28 <obqPutTimeout+0x88>)
 800ae06:	681a      	ldr	r2, [r3, #0]
 800ae08:	429a      	cmp	r2, r3
 800ae0a:	d004      	beq.n	800ae16 <obqPutTimeout+0x76>
 800ae0c:	6999      	ldr	r1, [r3, #24]
 800ae0e:	6892      	ldr	r2, [r2, #8]
 800ae10:	6889      	ldr	r1, [r1, #8]
 800ae12:	4291      	cmp	r1, r2
 800ae14:	d303      	bcc.n	800ae1e <obqPutTimeout+0x7e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ae16:	2300      	movs	r3, #0
 800ae18:	f383 8811 	msr	BASEPRI, r3
}
 800ae1c:	bd38      	pop	{r3, r4, r5, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800ae1e:	b672      	cpsid	i
 800ae20:	4a02      	ldr	r2, [pc, #8]	; (800ae2c <obqPutTimeout+0x8c>)
 800ae22:	62da      	str	r2, [r3, #44]	; 0x2c
 800ae24:	e7fe      	b.n	800ae24 <obqPutTimeout+0x84>
 800ae26:	bf00      	nop
 800ae28:	200011a0 	.word	0x200011a0
 800ae2c:	0800bcf4 	.word	0x0800bcf4

0800ae30 <_putt>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 800ae30:	3044      	adds	r0, #68	; 0x44
 800ae32:	f7ff bfb5 	b.w	800ada0 <obqPutTimeout>
 800ae36:	bf00      	nop
	...

0800ae40 <_put>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 800ae40:	3044      	adds	r0, #68	; 0x44
 800ae42:	f04f 32ff 	mov.w	r2, #4294967295
 800ae46:	f7ff bfab 	b.w	800ada0 <obqPutTimeout>
 800ae4a:	bf00      	nop
 800ae4c:	0000      	movs	r0, r0
	...

0800ae50 <ibqReadTimeout>:
  osalDbgCheck(n > 0U);
 800ae50:	2a00      	cmp	r2, #0
 800ae52:	d07d      	beq.n	800af50 <ibqReadTimeout+0x100>
                      size_t n, sysinterval_t timeout) {
 800ae54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ae58:	4698      	mov	r8, r3
 800ae5a:	b083      	sub	sp, #12
 800ae5c:	4605      	mov	r5, r0
 800ae5e:	460f      	mov	r7, r1
 800ae60:	4692      	mov	sl, r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ae62:	2320      	movs	r3, #32
 800ae64:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800ae68:	f7f8 fcaa 	bl	80037c0 <_dbg_check_lock>
 800ae6c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    if (ibqp->ptr == NULL) {
 800ae70:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800ae72:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ae74:	9301      	str	r3, [sp, #4]
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800ae76:	f108 33ff 	add.w	r3, r8, #4294967295
  size_t r = 0;
 800ae7a:	2600      	movs	r6, #0
 800ae7c:	4c4b      	ldr	r4, [pc, #300]	; (800afac <ibqReadTimeout+0x15c>)
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800ae7e:	9300      	str	r3, [sp, #0]
  return systime + (systime_t)interval;
 800ae80:	eb08 0902 	add.w	r9, r8, r2
    if (ibqp->ptr == NULL) {
 800ae84:	2900      	cmp	r1, #0
 800ae86:	d040      	beq.n	800af0a <ibqReadTimeout+0xba>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 800ae88:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if (size > (n - r)) {
 800ae8a:	ebaa 0b06 	sub.w	fp, sl, r6
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 800ae8e:	1a5b      	subs	r3, r3, r1
 800ae90:	459b      	cmp	fp, r3
 800ae92:	bf28      	it	cs
 800ae94:	469b      	movcs	fp, r3
    if (size > 64U) {
 800ae96:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
 800ae9a:	d945      	bls.n	800af28 <ibqReadTimeout+0xd8>
      memcpy(bp, ibqp->ptr, 64U);
 800ae9c:	460b      	mov	r3, r1
 800ae9e:	463a      	mov	r2, r7
 800aea0:	3140      	adds	r1, #64	; 0x40
 800aea2:	f8d3 e000 	ldr.w	lr, [r3]
 800aea6:	f8d3 c004 	ldr.w	ip, [r3, #4]
 800aeaa:	6898      	ldr	r0, [r3, #8]
 800aeac:	f8d3 b00c 	ldr.w	fp, [r3, #12]
 800aeb0:	f8c2 b00c 	str.w	fp, [r2, #12]
 800aeb4:	3310      	adds	r3, #16
 800aeb6:	428b      	cmp	r3, r1
 800aeb8:	f8c2 e000 	str.w	lr, [r2]
 800aebc:	f8c2 c004 	str.w	ip, [r2, #4]
 800aec0:	6090      	str	r0, [r2, #8]
 800aec2:	f102 0210 	add.w	r2, r2, #16
 800aec6:	d1ec      	bne.n	800aea2 <ibqReadTimeout+0x52>
      ibqp->ptr += 64U;
 800aec8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 800aeca:	6aea      	ldr	r2, [r5, #44]	; 0x2c
      ibqp->ptr += 64U;
 800aecc:	3340      	adds	r3, #64	; 0x40
    if (ibqp->ptr >= ibqp->top) {
 800aece:	429a      	cmp	r2, r3
      bp        += 64U;
 800aed0:	f107 0740 	add.w	r7, r7, #64	; 0x40
      r         += 64U;
 800aed4:	f106 0640 	add.w	r6, r6, #64	; 0x40
      ibqp->ptr += 64U;
 800aed8:	62ab      	str	r3, [r5, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 800aeda:	d931      	bls.n	800af40 <ibqReadTimeout+0xf0>
  _dbg_check_unlock();
 800aedc:	f7f8 fc08 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800aee0:	6823      	ldr	r3, [r4, #0]
 800aee2:	42a3      	cmp	r3, r4
 800aee4:	d004      	beq.n	800aef0 <ibqReadTimeout+0xa0>
 800aee6:	69a2      	ldr	r2, [r4, #24]
 800aee8:	689b      	ldr	r3, [r3, #8]
 800aeea:	6892      	ldr	r2, [r2, #8]
 800aeec:	429a      	cmp	r2, r3
 800aeee:	d32b      	bcc.n	800af48 <ibqReadTimeout+0xf8>
 800aef0:	2300      	movs	r3, #0
 800aef2:	f383 8811 	msr	BASEPRI, r3
    if (r >= n) {
 800aef6:	4556      	cmp	r6, sl
 800aef8:	d23c      	bcs.n	800af74 <ibqReadTimeout+0x124>
 800aefa:	2320      	movs	r3, #32
 800aefc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800af00:	f7f8 fc5e 	bl	80037c0 <_dbg_check_lock>
    if (ibqp->ptr == NULL) {
 800af04:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800af06:	2900      	cmp	r1, #0
 800af08:	d1be      	bne.n	800ae88 <ibqReadTimeout+0x38>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800af0a:	9b00      	ldr	r3, [sp, #0]
 800af0c:	3303      	adds	r3, #3
 800af0e:	d847      	bhi.n	800afa0 <ibqReadTimeout+0x150>
 800af10:	9b01      	ldr	r3, [sp, #4]
 800af12:	6a59      	ldr	r1, [r3, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 800af14:	eba9 0101 	sub.w	r1, r9, r1
        if (next_timeout > timeout) {
 800af18:	4588      	cmp	r8, r1
 800af1a:	d333      	bcc.n	800af84 <ibqReadTimeout+0x134>
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 800af1c:	4628      	mov	r0, r5
 800af1e:	f7f8 f96f 	bl	8003200 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 800af22:	b9d0      	cbnz	r0, 800af5a <ibqReadTimeout+0x10a>
 800af24:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800af26:	e7af      	b.n	800ae88 <ibqReadTimeout+0x38>
      memcpy(bp, ibqp->ptr, size);
 800af28:	465a      	mov	r2, fp
 800af2a:	4638      	mov	r0, r7
 800af2c:	f7f5 f9c2 	bl	80002b4 <memcpy>
      ibqp->ptr += size;
 800af30:	6aab      	ldr	r3, [r5, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 800af32:	6aea      	ldr	r2, [r5, #44]	; 0x2c
      ibqp->ptr += size;
 800af34:	445b      	add	r3, fp
    if (ibqp->ptr >= ibqp->top) {
 800af36:	429a      	cmp	r2, r3
      r         += size;
 800af38:	445e      	add	r6, fp
      bp        += size;
 800af3a:	445f      	add	r7, fp
      ibqp->ptr += size;
 800af3c:	62ab      	str	r3, [r5, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 800af3e:	d8cd      	bhi.n	800aedc <ibqReadTimeout+0x8c>
      ibqReleaseEmptyBufferS(ibqp);
 800af40:	4628      	mov	r0, r5
 800af42:	f7f6 fe25 	bl	8001b90 <ibqReleaseEmptyBufferS>
 800af46:	e7c9      	b.n	800aedc <ibqReadTimeout+0x8c>
  __ASM volatile ("cpsid i" : : : "memory");
 800af48:	b672      	cpsid	i
 800af4a:	4b19      	ldr	r3, [pc, #100]	; (800afb0 <ibqReadTimeout+0x160>)
 800af4c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800af4e:	e7fe      	b.n	800af4e <ibqReadTimeout+0xfe>
 800af50:	b672      	cpsid	i
 800af52:	4b16      	ldr	r3, [pc, #88]	; (800afac <ibqReadTimeout+0x15c>)
 800af54:	4a17      	ldr	r2, [pc, #92]	; (800afb4 <ibqReadTimeout+0x164>)
 800af56:	62da      	str	r2, [r3, #44]	; 0x2c
 800af58:	e7fe      	b.n	800af58 <ibqReadTimeout+0x108>
  _dbg_check_unlock();
 800af5a:	f7f8 fbc9 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800af5e:	6823      	ldr	r3, [r4, #0]
 800af60:	42a3      	cmp	r3, r4
 800af62:	d004      	beq.n	800af6e <ibqReadTimeout+0x11e>
 800af64:	69a2      	ldr	r2, [r4, #24]
 800af66:	689b      	ldr	r3, [r3, #8]
 800af68:	6892      	ldr	r2, [r2, #8]
 800af6a:	429a      	cmp	r2, r3
 800af6c:	d306      	bcc.n	800af7c <ibqReadTimeout+0x12c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800af6e:	2300      	movs	r3, #0
 800af70:	f383 8811 	msr	BASEPRI, r3
}
 800af74:	4630      	mov	r0, r6
 800af76:	b003      	add	sp, #12
 800af78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800af7c:	b672      	cpsid	i
 800af7e:	4b0c      	ldr	r3, [pc, #48]	; (800afb0 <ibqReadTimeout+0x160>)
 800af80:	62e3      	str	r3, [r4, #44]	; 0x2c
 800af82:	e7fe      	b.n	800af82 <ibqReadTimeout+0x132>
  _dbg_check_unlock();
 800af84:	f7f8 fbb4 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800af88:	6823      	ldr	r3, [r4, #0]
 800af8a:	42a3      	cmp	r3, r4
 800af8c:	d0ef      	beq.n	800af6e <ibqReadTimeout+0x11e>
 800af8e:	69a2      	ldr	r2, [r4, #24]
 800af90:	689b      	ldr	r3, [r3, #8]
 800af92:	6892      	ldr	r2, [r2, #8]
 800af94:	429a      	cmp	r2, r3
 800af96:	d2ea      	bcs.n	800af6e <ibqReadTimeout+0x11e>
 800af98:	b672      	cpsid	i
 800af9a:	4b05      	ldr	r3, [pc, #20]	; (800afb0 <ibqReadTimeout+0x160>)
 800af9c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800af9e:	e7fe      	b.n	800af9e <ibqReadTimeout+0x14e>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800afa0:	4641      	mov	r1, r8
 800afa2:	4628      	mov	r0, r5
 800afa4:	f7f8 f92c 	bl	8003200 <ibqGetFullBufferTimeoutS>
 800afa8:	e7bb      	b.n	800af22 <ibqReadTimeout+0xd2>
 800afaa:	bf00      	nop
 800afac:	200011a0 	.word	0x200011a0
 800afb0:	0800bcf4 	.word	0x0800bcf4
 800afb4:	0800c070 	.word	0x0800c070
	...

0800afc0 <_readt>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 800afc0:	300c      	adds	r0, #12
 800afc2:	f7ff bf45 	b.w	800ae50 <ibqReadTimeout>
 800afc6:	bf00      	nop
	...

0800afd0 <_read>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 800afd0:	300c      	adds	r0, #12
 800afd2:	f04f 33ff 	mov.w	r3, #4294967295
 800afd6:	f7ff bf3b 	b.w	800ae50 <ibqReadTimeout>
 800afda:	bf00      	nop
 800afdc:	0000      	movs	r0, r0
	...

0800afe0 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
 800afe0:	b538      	push	{r3, r4, r5, lr}
 800afe2:	4604      	mov	r4, r0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800afe4:	2320      	movs	r3, #32
 800afe6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800afea:	f7f8 fbe9 	bl	80037c0 <_dbg_check_lock>
  if (ibqp->ptr == NULL) {
 800afee:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800aff0:	b1ab      	cbz	r3, 800b01e <ibqGetTimeout+0x3e>
  msg = (msg_t)*ibqp->ptr;
 800aff2:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
 800aff6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  ibqp->ptr++;
 800aff8:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 800affa:	4293      	cmp	r3, r2
 800affc:	d21a      	bcs.n	800b034 <ibqGetTimeout+0x54>
  _dbg_check_unlock();
 800affe:	f7f8 fb77 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b002:	4b18      	ldr	r3, [pc, #96]	; (800b064 <ibqGetTimeout+0x84>)
 800b004:	681a      	ldr	r2, [r3, #0]
 800b006:	429a      	cmp	r2, r3
 800b008:	d004      	beq.n	800b014 <ibqGetTimeout+0x34>
 800b00a:	6999      	ldr	r1, [r3, #24]
 800b00c:	6892      	ldr	r2, [r2, #8]
 800b00e:	6889      	ldr	r1, [r1, #8]
 800b010:	4291      	cmp	r1, r2
 800b012:	d313      	bcc.n	800b03c <ibqGetTimeout+0x5c>
 800b014:	2300      	movs	r3, #0
 800b016:	f383 8811 	msr	BASEPRI, r3
}
 800b01a:	4628      	mov	r0, r5
 800b01c:	bd38      	pop	{r3, r4, r5, pc}
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800b01e:	f7f8 f8ef 	bl	8003200 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 800b022:	4605      	mov	r5, r0
 800b024:	b970      	cbnz	r0, 800b044 <ibqGetTimeout+0x64>
 800b026:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 800b028:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  msg = (msg_t)*ibqp->ptr;
 800b02a:	f813 5b01 	ldrb.w	r5, [r3], #1
  ibqp->ptr++;
 800b02e:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 800b030:	4293      	cmp	r3, r2
 800b032:	d3e4      	bcc.n	800affe <ibqGetTimeout+0x1e>
    ibqReleaseEmptyBufferS(ibqp);
 800b034:	4620      	mov	r0, r4
 800b036:	f7f6 fdab 	bl	8001b90 <ibqReleaseEmptyBufferS>
 800b03a:	e7e0      	b.n	800affe <ibqGetTimeout+0x1e>
  __ASM volatile ("cpsid i" : : : "memory");
 800b03c:	b672      	cpsid	i
 800b03e:	4a0a      	ldr	r2, [pc, #40]	; (800b068 <ibqGetTimeout+0x88>)
 800b040:	62da      	str	r2, [r3, #44]	; 0x2c
 800b042:	e7fe      	b.n	800b042 <ibqGetTimeout+0x62>
  _dbg_check_unlock();
 800b044:	f7f8 fb54 	bl	80036f0 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b048:	4b06      	ldr	r3, [pc, #24]	; (800b064 <ibqGetTimeout+0x84>)
 800b04a:	681a      	ldr	r2, [r3, #0]
 800b04c:	429a      	cmp	r2, r3
 800b04e:	d0e1      	beq.n	800b014 <ibqGetTimeout+0x34>
 800b050:	6999      	ldr	r1, [r3, #24]
 800b052:	6892      	ldr	r2, [r2, #8]
 800b054:	6889      	ldr	r1, [r1, #8]
 800b056:	4291      	cmp	r1, r2
 800b058:	d2dc      	bcs.n	800b014 <ibqGetTimeout+0x34>
 800b05a:	b672      	cpsid	i
 800b05c:	4a02      	ldr	r2, [pc, #8]	; (800b068 <ibqGetTimeout+0x88>)
 800b05e:	62da      	str	r2, [r3, #44]	; 0x2c
 800b060:	e7fe      	b.n	800b060 <ibqGetTimeout+0x80>
 800b062:	bf00      	nop
 800b064:	200011a0 	.word	0x200011a0
 800b068:	0800bcf4 	.word	0x0800bcf4
 800b06c:	00000000 	.word	0x00000000

0800b070 <_gett>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 800b070:	300c      	adds	r0, #12
 800b072:	f7ff bfb5 	b.w	800afe0 <ibqGetTimeout>
 800b076:	bf00      	nop
	...

0800b080 <_get>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 800b080:	300c      	adds	r0, #12
 800b082:	f04f 31ff 	mov.w	r1, #4294967295
 800b086:	f7ff bfab 	b.w	800afe0 <ibqGetTimeout>
 800b08a:	bf00      	nop
 800b08c:	0000      	movs	r0, r0
	...

0800b090 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB2(STM32_GPIO_EN_MASK);
 800b090:	4a99      	ldr	r2, [pc, #612]	; (800b2f8 <__early_init+0x268>)
  gpiop->OTYPER  = config->otyper;
 800b092:	499a      	ldr	r1, [pc, #616]	; (800b2fc <__early_init+0x26c>)
  rccResetAHB2(STM32_GPIO_EN_MASK);
 800b094:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 800b096:	2300      	movs	r3, #0
 800b098:	f040 00ff 	orr.w	r0, r0, #255	; 0xff
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 800b09c:	b4f0      	push	{r4, r5, r6, r7}
  rccResetAHB2(STM32_GPIO_EN_MASK);
 800b09e:	62d0      	str	r0, [r2, #44]	; 0x2c
 800b0a0:	62d3      	str	r3, [r2, #44]	; 0x2c
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 800b0a2:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
  gpiop->PUPDR   = config->pupdr;
 800b0a4:	4f96      	ldr	r7, [pc, #600]	; (800b300 <__early_init+0x270>)
  gpiop->OTYPER  = config->otyper;
 800b0a6:	4c97      	ldr	r4, [pc, #604]	; (800b304 <__early_init+0x274>)
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 800b0a8:	f040 00ff 	orr.w	r0, r0, #255	; 0xff
 800b0ac:	64d0      	str	r0, [r2, #76]	; 0x4c
 800b0ae:	6ed6      	ldr	r6, [r2, #108]	; 0x6c
  gpiop->OTYPER  = config->otyper;
 800b0b0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  gpiop->OSPEEDR = config->ospeedr;
 800b0b4:	f04f 35ff 	mov.w	r5, #4294967295
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 800b0b8:	f046 06ff 	orr.w	r6, r6, #255	; 0xff
 800b0bc:	66d6      	str	r6, [r2, #108]	; 0x6c
  gpiop->OTYPER  = config->otyper;
 800b0be:	6043      	str	r3, [r0, #4]
  gpiop->ODR     = config->odr;
 800b0c0:	f64f 76ff 	movw	r6, #65535	; 0xffff
  gpiop->ASCR    = config->ascr;
 800b0c4:	62c3      	str	r3, [r0, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 800b0c6:	6085      	str	r5, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 800b0c8:	60c7      	str	r7, [r0, #12]
  gpiop->AFRL    = config->afrl;
 800b0ca:	f04f 473b 	mov.w	r7, #3137339392	; 0xbb000000
  gpiop->ODR     = config->odr;
 800b0ce:	6146      	str	r6, [r0, #20]
  gpiop->AFRL    = config->afrl;
 800b0d0:	6207      	str	r7, [r0, #32]
  gpiop->AFRH    = config->afrh;
 800b0d2:	4f8d      	ldr	r7, [pc, #564]	; (800b308 <__early_init+0x278>)
 800b0d4:	6247      	str	r7, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800b0d6:	f1a7 57ab 	sub.w	r7, r7, #358612992	; 0x15600000
 800b0da:	f6a7 27bb 	subw	r7, r7, #2747	; 0xabb
 800b0de:	6007      	str	r7, [r0, #0]
  gpiop->ASCR    = config->ascr;
 800b0e0:	2708      	movs	r7, #8
  gpiop->LOCKR   = config->lockr;
 800b0e2:	61c3      	str	r3, [r0, #28]
  gpiop->OTYPER  = config->otyper;
 800b0e4:	604b      	str	r3, [r1, #4]
  gpiop->ASCR    = config->ascr;
 800b0e6:	62cf      	str	r7, [r1, #44]	; 0x2c
  gpiop->PUPDR   = config->pupdr;
 800b0e8:	f44f 3700 	mov.w	r7, #131072	; 0x20000
  gpiop->OSPEEDR = config->ospeedr;
 800b0ec:	608d      	str	r5, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 800b0ee:	60cf      	str	r7, [r1, #12]
  gpiop->ODR     = config->odr;
 800b0f0:	f64f 77fb 	movw	r7, #65531	; 0xfffb
 800b0f4:	614f      	str	r7, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800b0f6:	4f85      	ldr	r7, [pc, #532]	; (800b30c <__early_init+0x27c>)
 800b0f8:	620f      	str	r7, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800b0fa:	f107 47ee 	add.w	r7, r7, #1996488704	; 0x77000000
 800b0fe:	f507 4787 	add.w	r7, r7, #17280	; 0x4380
 800b102:	3775      	adds	r7, #117	; 0x75
 800b104:	624f      	str	r7, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800b106:	4f82      	ldr	r7, [pc, #520]	; (800b310 <__early_init+0x280>)
 800b108:	600f      	str	r7, [r1, #0]
  gpiop->OSPEEDR = config->ospeedr;
 800b10a:	f06f 4770 	mvn.w	r7, #4026531840	; 0xf0000000
  gpiop->LOCKR   = config->lockr;
 800b10e:	61cb      	str	r3, [r1, #28]
  gpiop->OTYPER  = config->otyper;
 800b110:	6063      	str	r3, [r4, #4]
  gpiop->ASCR    = config->ascr;
 800b112:	62e3      	str	r3, [r4, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 800b114:	60a7      	str	r7, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 800b116:	4f7f      	ldr	r7, [pc, #508]	; (800b314 <__early_init+0x284>)
 800b118:	60e7      	str	r7, [r4, #12]
  gpiop->AFRL    = config->afrl;
 800b11a:	4f7f      	ldr	r7, [pc, #508]	; (800b318 <__early_init+0x288>)
  gpiop->ODR     = config->odr;
 800b11c:	6166      	str	r6, [r4, #20]
  gpiop->AFRL    = config->afrl;
 800b11e:	6227      	str	r7, [r4, #32]
  gpiop->AFRH    = config->afrh;
 800b120:	4f7e      	ldr	r7, [pc, #504]	; (800b31c <__early_init+0x28c>)
 800b122:	6267      	str	r7, [r4, #36]	; 0x24
  gpiop->OTYPER  = config->otyper;
 800b124:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
  gpiop->MODER   = config->moder;
 800b128:	4f7d      	ldr	r7, [pc, #500]	; (800b320 <__early_init+0x290>)
 800b12a:	6027      	str	r7, [r4, #0]
  gpiop->PUPDR   = config->pupdr;
 800b12c:	f244 1766 	movw	r7, #16742	; 0x4166
  gpiop->LOCKR   = config->lockr;
 800b130:	61e3      	str	r3, [r4, #28]
  gpiop->OTYPER  = config->otyper;
 800b132:	6043      	str	r3, [r0, #4]
  gpiop->ASCR    = config->ascr;
 800b134:	62c3      	str	r3, [r0, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 800b136:	6085      	str	r5, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 800b138:	60c7      	str	r7, [r0, #12]
  gpiop->ODR     = config->odr;
 800b13a:	f64f 77fe 	movw	r7, #65534	; 0xfffe
 800b13e:	6147      	str	r7, [r0, #20]
  gpiop->AFRL    = config->afrl;
 800b140:	4f78      	ldr	r7, [pc, #480]	; (800b324 <__early_init+0x294>)
 800b142:	6207      	str	r7, [r0, #32]
  gpiop->AFRH    = config->afrh;
 800b144:	f04f 37bb 	mov.w	r7, #3149642683	; 0xbbbbbbbb
 800b148:	6247      	str	r7, [r0, #36]	; 0x24
  gpiop->OTYPER  = config->otyper;
 800b14a:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
  gpiop->MODER   = config->moder;
 800b14e:	4f76      	ldr	r7, [pc, #472]	; (800b328 <__early_init+0x298>)
 800b150:	6007      	str	r7, [r0, #0]
  gpiop->PUPDR   = config->pupdr;
 800b152:	4f76      	ldr	r7, [pc, #472]	; (800b32c <__early_init+0x29c>)
  gpiop->LOCKR   = config->lockr;
 800b154:	61c3      	str	r3, [r0, #28]
  gpiop->OTYPER  = config->otyper;
 800b156:	604b      	str	r3, [r1, #4]
  gpiop->ASCR    = config->ascr;
 800b158:	62cb      	str	r3, [r1, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 800b15a:	608d      	str	r5, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 800b15c:	60cf      	str	r7, [r1, #12]
  gpiop->ODR     = config->odr;
 800b15e:	f64f 67ff 	movw	r7, #65279	; 0xfeff
 800b162:	614f      	str	r7, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800b164:	4f72      	ldr	r7, [pc, #456]	; (800b330 <__early_init+0x2a0>)
 800b166:	620f      	str	r7, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800b168:	4f72      	ldr	r7, [pc, #456]	; (800b334 <__early_init+0x2a4>)
 800b16a:	624f      	str	r7, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800b16c:	f5a7 477f 	sub.w	r7, r7, #65280	; 0xff00
 800b170:	3fff      	subs	r7, #255	; 0xff
 800b172:	600f      	str	r7, [r1, #0]
  gpiop->LOCKR   = config->lockr;
 800b174:	61cb      	str	r3, [r1, #28]
  gpiop->OTYPER  = config->otyper;
 800b176:	f8c4 3c04 	str.w	r3, [r4, #3076]	; 0xc04
  gpiop->ASCR    = config->ascr;
 800b17a:	f8c4 3c2c 	str.w	r3, [r4, #3116]	; 0xc2c
  gpiop->OSPEEDR = config->ospeedr;
 800b17e:	f8c4 5c08 	str.w	r5, [r4, #3080]	; 0xc08
  gpiop->PUPDR   = config->pupdr;
 800b182:	f8c4 3c0c 	str.w	r3, [r4, #3084]	; 0xc0c
  gpiop->ODR     = config->odr;
 800b186:	f8c4 6c14 	str.w	r6, [r4, #3092]	; 0xc14
  gpiop->AFRL    = config->afrl;
 800b18a:	f8c4 3c20 	str.w	r3, [r4, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
 800b18e:	f8c4 3c24 	str.w	r3, [r4, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
 800b192:	f8c4 5c00 	str.w	r5, [r4, #3072]	; 0xc00
  gpiop->LOCKR   = config->lockr;
 800b196:	f8c4 3c1c 	str.w	r3, [r4, #3100]	; 0xc1c
  gpiop->OSPEEDR = config->ospeedr;
 800b19a:	240f      	movs	r4, #15
  gpiop->OTYPER  = config->otyper;
 800b19c:	f8c0 3c04 	str.w	r3, [r0, #3076]	; 0xc04
  gpiop->MODER   = config->moder;
 800b1a0:	f06f 070f 	mvn.w	r7, #15
  gpiop->ASCR    = config->ascr;
 800b1a4:	f8c0 3c2c 	str.w	r3, [r0, #3116]	; 0xc2c
  gpiop->OSPEEDR = config->ospeedr;
 800b1a8:	f8c0 3c08 	str.w	r3, [r0, #3080]	; 0xc08
  gpiop->PUPDR   = config->pupdr;
 800b1ac:	f8c0 3c0c 	str.w	r3, [r0, #3084]	; 0xc0c
  gpiop->ODR     = config->odr;
 800b1b0:	f8c0 6c14 	str.w	r6, [r0, #3092]	; 0xc14
  gpiop->AFRL    = config->afrl;
 800b1b4:	f8c0 3c20 	str.w	r3, [r0, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
 800b1b8:	f8c0 3c24 	str.w	r3, [r0, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
 800b1bc:	f8c0 5c00 	str.w	r5, [r0, #3072]	; 0xc00
  gpiop->LOCKR   = config->lockr;
 800b1c0:	f8c0 3c1c 	str.w	r3, [r0, #3100]	; 0xc1c
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR1_RTCAPBEN)
  RCC->APB1ENR1 = RCC_APB1ENR1_PWREN | RCC_APB1ENR1_RTCAPBEN;
#else
  RCC->APB1ENR1 = RCC_APB1ENR1_PWREN;
 800b1c4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  gpiop->OTYPER  = config->otyper;
 800b1c8:	f8c1 3c04 	str.w	r3, [r1, #3076]	; 0xc04
  gpiop->ASCR    = config->ascr;
 800b1cc:	f8c1 3c2c 	str.w	r3, [r1, #3116]	; 0xc2c
  gpiop->OSPEEDR = config->ospeedr;
 800b1d0:	f8c1 4c08 	str.w	r4, [r1, #3080]	; 0xc08
  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fall back clock when PLL the fails.
     Trim fields are not altered from reset values.*/

  /* MSIRANGE can be set only when MSI is OFF or READY.*/
  RCC->CR = RCC_CR_MSION;
 800b1d4:	2401      	movs	r4, #1
  gpiop->PUPDR   = config->pupdr;
 800b1d6:	f8c1 3c0c 	str.w	r3, [r1, #3084]	; 0xc0c
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800b1da:	4610      	mov	r0, r2
  gpiop->ODR     = config->odr;
 800b1dc:	f8c1 6c14 	str.w	r6, [r1, #3092]	; 0xc14
  gpiop->AFRL    = config->afrl;
 800b1e0:	f8c1 3c20 	str.w	r3, [r1, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
 800b1e4:	f8c1 3c24 	str.w	r3, [r1, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
 800b1e8:	f8c1 7c00 	str.w	r7, [r1, #3072]	; 0xc00
  gpiop->LOCKR   = config->lockr;
 800b1ec:	f8c1 3c1c 	str.w	r3, [r1, #3100]	; 0xc1c
  RCC->APB1ENR1 = RCC_APB1ENR1_PWREN;
 800b1f0:	6595      	str	r5, [r2, #88]	; 0x58
  RCC->CR = RCC_CR_MSION;
 800b1f2:	6014      	str	r4, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800b1f4:	6803      	ldr	r3, [r0, #0]
 800b1f6:	079e      	lsls	r6, r3, #30
 800b1f8:	d5fc      	bpl.n	800b1f4 <__early_init+0x164>
    ;                                       /* Wait until MSI is stable.    */

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0;
 800b1fa:	2300      	movs	r3, #0
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 800b1fc:	4a3e      	ldr	r2, [pc, #248]	; (800b2f8 <__early_init+0x268>)
  RCC->CFGR = 0;
 800b1fe:	6083      	str	r3, [r0, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 800b200:	6893      	ldr	r3, [r2, #8]
 800b202:	f013 0f0c 	tst.w	r3, #12
 800b206:	d1fb      	bne.n	800b200 <__early_init+0x170>
    ;                                       /* Wait until MSI is selected.  */

  /* Core voltage setup.*/
  PWR->CR1 = STM32_VOS;
 800b208:	4a4b      	ldr	r2, [pc, #300]	; (800b338 <__early_init+0x2a8>)
 800b20a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b20e:	6013      	str	r3, [r2, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 800b210:	6953      	ldr	r3, [r2, #20]
 800b212:	055d      	lsls	r5, r3, #21
 800b214:	d4fc      	bmi.n	800b210 <__early_init+0x180>
    ;                                       /* stable.                      */

#if STM32_HSI16_ENABLED
  /* HSI activation.*/
  RCC->CR |= RCC_CR_HSION;
 800b216:	4b38      	ldr	r3, [pc, #224]	; (800b2f8 <__early_init+0x268>)
 800b218:	681a      	ldr	r2, [r3, #0]
 800b21a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800b21e:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0)
 800b220:	681a      	ldr	r2, [r3, #0]
 800b222:	0554      	lsls	r4, r2, #21
 800b224:	d5fc      	bpl.n	800b220 <__early_init+0x190>
    ;                                       /* Wait until HSE is stable.    */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800b226:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800b22a:	4933      	ldr	r1, [pc, #204]	; (800b2f8 <__early_init+0x268>)
  RCC->CSR |= RCC_CSR_LSION;
 800b22c:	f042 0201 	orr.w	r2, r2, #1
 800b230:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800b234:	f8d1 3094 	ldr.w	r3, [r1, #148]	; 0x94
 800b238:	0798      	lsls	r0, r3, #30
 800b23a:	d5fb      	bpl.n	800b234 <__early_init+0x1a4>
    ;                                       /* Wait until LSI is stable.    */
#endif

  /* Backup domain access enabled and left open.*/
  PWR->CR1 |= PWR_CR1_DBP;
 800b23c:	483e      	ldr	r0, [pc, #248]	; (800b338 <__early_init+0x2a8>)
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 800b23e:	4a2e      	ldr	r2, [pc, #184]	; (800b2f8 <__early_init+0x268>)
  PWR->CR1 |= PWR_CR1_DBP;
 800b240:	6803      	ldr	r3, [r0, #0]
 800b242:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b246:	6003      	str	r3, [r0, #0]
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 800b248:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 800b24c:	f043 0319 	orr.w	r3, r3, #25
 800b250:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 800b254:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800b258:	0799      	lsls	r1, r3, #30
 800b25a:	d5fb      	bpl.n	800b254 <__early_init+0x1c4>
    ;                                       /* Wait until LSE is stable.    */
#endif

  /* Flash setup for selected MSI speed setting.*/
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 800b25c:	4b37      	ldr	r3, [pc, #220]	; (800b33c <__early_init+0x2ac>)
  /* Changing MSIRANGE to configured value.*/
  RCC->CR |= STM32_MSIRANGE;

  /* Switching from MSISRANGE to MSIRANGE.*/
  RCC->CR |= RCC_CR_MSIRGSEL;
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800b25e:	4926      	ldr	r1, [pc, #152]	; (800b2f8 <__early_init+0x268>)
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 800b260:	f240 7002 	movw	r0, #1794	; 0x702
 800b264:	6018      	str	r0, [r3, #0]
  RCC->CR |= STM32_MSIRANGE;
 800b266:	6813      	ldr	r3, [r2, #0]
 800b268:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
 800b26c:	6013      	str	r3, [r2, #0]
  RCC->CR |= RCC_CR_MSIRGSEL;
 800b26e:	6813      	ldr	r3, [r2, #0]
 800b270:	f043 0308 	orr.w	r3, r3, #8
 800b274:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800b276:	680b      	ldr	r3, [r1, #0]
 800b278:	079a      	lsls	r2, r3, #30
 800b27a:	d5fc      	bpl.n	800b276 <__early_init+0x1e6>
    ;

  /* MSI is configured SYSCLK source so wait for it to be stable as well.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 800b27c:	4b1e      	ldr	r3, [pc, #120]	; (800b2f8 <__early_init+0x268>)
 800b27e:	689a      	ldr	r2, [r3, #8]
 800b280:	f012 0f0c 	tst.w	r2, #12
 800b284:	d1fb      	bne.n	800b27e <__early_init+0x1ee>
    ;

#if STM32_MSIPLL_ENABLED
  /* MSI PLL (to LSE) activation */
  RCC->CR |= RCC_CR_MSIPLLEN;
 800b286:	681a      	ldr	r2, [r3, #0]
                 STM32_PLLREN  | STM32_PLLQ  |
                 STM32_PLLQEN  | STM32_PLLP  |
                 STM32_PLLPEN  | STM32_PLLN  |
                 STM32_PLLM    | STM32_PLLSRC;
#else
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 800b288:	482d      	ldr	r0, [pc, #180]	; (800b340 <__early_init+0x2b0>)
#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR |= RCC_CR_PLLON;

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLRDY) == 0)
 800b28a:	491b      	ldr	r1, [pc, #108]	; (800b2f8 <__early_init+0x268>)
  RCC->CR |= RCC_CR_MSIPLLEN;
 800b28c:	f042 0204 	orr.w	r2, r2, #4
 800b290:	601a      	str	r2, [r3, #0]
  RCC->CSR |= STM32_MSISRANGE;
 800b292:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800b296:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
 800b29a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 800b29e:	60d8      	str	r0, [r3, #12]
  RCC->CR |= RCC_CR_PLLON;
 800b2a0:	681a      	ldr	r2, [r3, #0]
 800b2a2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800b2a6:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_PLLRDY) == 0)
 800b2a8:	680b      	ldr	r3, [r1, #0]
 800b2aa:	019b      	lsls	r3, r3, #6
 800b2ac:	d5fc      	bpl.n	800b2a8 <__early_init+0x218>
  while ((RCC->CR & RCC_CR_PLLSAI2RDY) == 0)
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 800b2ae:	2200      	movs	r2, #0
    ccipr |= STM32_SAI2SEL;
#endif
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
    ccipr |= STM32_SAI1SEL;
#endif
    RCC->CCIPR = ccipr;
 800b2b0:	4b24      	ldr	r3, [pc, #144]	; (800b344 <__early_init+0x2b4>)
  }

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS)
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 800b2b2:	4822      	ldr	r0, [pc, #136]	; (800b33c <__early_init+0x2ac>)
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 800b2b4:	608a      	str	r2, [r1, #8]
    RCC->CCIPR = ccipr;
 800b2b6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 800b2ba:	6803      	ldr	r3, [r0, #0]
 800b2bc:	f023 0307 	bic.w	r3, r3, #7
 800b2c0:	f043 0304 	orr.w	r3, r3, #4
 800b2c4:	6003      	str	r3, [r0, #0]

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800b2c6:	688b      	ldr	r3, [r1, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800b2c8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800b2cc:	f043 0303 	orr.w	r3, r3, #3
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800b2d0:	f502 3204 	add.w	r2, r2, #135168	; 0x21000
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800b2d4:	608b      	str	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800b2d6:	6893      	ldr	r3, [r2, #8]
 800b2d8:	f003 030c 	and.w	r3, r3, #12
 800b2dc:	2b0c      	cmp	r3, #12
 800b2de:	d1fa      	bne.n	800b2d6 <__early_init+0x246>

#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 800b2e0:	6e13      	ldr	r3, [r2, #96]	; 0x60
 800b2e2:	f043 0301 	orr.w	r3, r3, #1
 800b2e6:	6613      	str	r3, [r2, #96]	; 0x60
 800b2e8:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 800b2ec:	f043 0301 	orr.w	r3, r3, #1
 800b2f0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

  stm32_gpio_init();
  stm32_clock_init();
}
 800b2f4:	bcf0      	pop	{r4, r5, r6, r7}
 800b2f6:	4770      	bx	lr
 800b2f8:	40021000 	.word	0x40021000
 800b2fc:	48000400 	.word	0x48000400
 800b300:	240008aa 	.word	0x240008aa
 800b304:	48000800 	.word	0x48000800
 800b308:	000aabbb 	.word	0x000aabbb
 800b30c:	44bb00bb 	.word	0x44bb00bb
 800b310:	aaa8aada 	.word	0xaaa8aada
 800b314:	08000029 	.word	0x08000029
 800b318:	bbbbb000 	.word	0xbbbbb000
 800b31c:	000a000b 	.word	0x000a000b
 800b320:	0206aa81 	.word	0x0206aa81
 800b324:	07755050 	.word	0x07755050
 800b328:	aaaa6a89 	.word	0xaaaa6a89
 800b32c:	55500009 	.word	0x55500009
 800b330:	6ddd0d00 	.word	0x6ddd0d00
 800b334:	aaaaaa60 	.word	0xaaaaaa60
 800b338:	40007000 	.word	0x40007000
 800b33c:	40022000 	.word	0x40022000
 800b340:	03405032 	.word	0x03405032
 800b344:	3c015555 	.word	0x3c015555
	...

0800b350 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 800b350:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800b354:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
  OSAL_IRQ_PROLOGUE();
 800b358:	f7f5 fe82 	bl	8001060 <_dbg_check_enter_isr>
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800b35c:	693b      	ldr	r3, [r7, #16]
 800b35e:	079b      	lsls	r3, r3, #30
 800b360:	d405      	bmi.n	800b36e <VectorB0+0x1e>
  OSAL_IRQ_EPILOGUE();
 800b362:	f7f5 fe65 	bl	8001030 <_dbg_check_leave_isr>
}
 800b366:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 800b36a:	f7f5 bbd1 	b.w	8000b10 <_port_irq_epilogue>
    STM32_ST_TIM->SR = 0U;
 800b36e:	2500      	movs	r5, #0
 800b370:	613d      	str	r5, [r7, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800b372:	2320      	movs	r3, #32
 800b374:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 800b378:	4c2a      	ldr	r4, [pc, #168]	; (800b424 <VectorB0+0xd4>)
 800b37a:	46a1      	mov	r9, r4
  _dbg_check_lock_from_isr();
 800b37c:	f7f5 fea0 	bl	80010c0 <_dbg_check_lock_from_isr>
  chDbgCheckClassI();
 800b380:	f7f5 fc2e 	bl	8000be0 <chDbgCheckClassI>
  chDbgCheckClassI();
 800b384:	f7f5 fc2c 	bl	8000be0 <chDbgCheckClassI>
  vtp = ch.vtlist.next;
 800b388:	f859 1f1c 	ldr.w	r1, [r9, #28]!
 800b38c:	688b      	ldr	r3, [r1, #8]
 800b38e:	6a78      	ldr	r0, [r7, #36]	; 0x24
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 800b390:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800b392:	eba0 0802 	sub.w	r8, r0, r2

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 800b396:	4598      	cmp	r8, r3
 800b398:	d31e      	bcc.n	800b3d8 <VectorB0+0x88>
 800b39a:	2620      	movs	r6, #32

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800b39c:	6808      	ldr	r0, [r1, #0]
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
 800b39e:	f8d1 a00c 	ldr.w	sl, [r1, #12]
      ch.vtlist.lasttime += vtp->delta;
 800b3a2:	441a      	add	r2, r3
      vtp->func = NULL;

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800b3a4:	4548      	cmp	r0, r9
      ch.vtlist.lasttime += vtp->delta;
 800b3a6:	62a2      	str	r2, [r4, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800b3a8:	f8c0 9004 	str.w	r9, [r0, #4]
      ch.vtlist.next = vtp->next;
 800b3ac:	61e0      	str	r0, [r4, #28]
      vtp->func = NULL;
 800b3ae:	60cd      	str	r5, [r1, #12]
  STM32_ST_TIM->DIER = 0;
 800b3b0:	bf08      	it	eq
 800b3b2:	60fd      	streq	r5, [r7, #12]
      nowdelta -= vtp->delta;
 800b3b4:	eba8 0803 	sub.w	r8, r8, r3
  _dbg_check_unlock_from_isr();
 800b3b8:	f7f5 fe6a 	bl	8001090 <_dbg_check_unlock_from_isr>
 800b3bc:	f385 8811 	msr	BASEPRI, r5
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 800b3c0:	6908      	ldr	r0, [r1, #16]
 800b3c2:	47d0      	blx	sl
 800b3c4:	f386 8811 	msr	BASEPRI, r6
  _dbg_check_lock_from_isr();
 800b3c8:	f7f5 fe7a 	bl	80010c0 <_dbg_check_lock_from_isr>
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 800b3cc:	69e1      	ldr	r1, [r4, #28]
    }
    while (vtp->delta <= nowdelta);
 800b3ce:	688b      	ldr	r3, [r1, #8]
 800b3d0:	4598      	cmp	r8, r3
 800b3d2:	d3dc      	bcc.n	800b38e <VectorB0+0x3e>
 800b3d4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800b3d6:	e7e1      	b.n	800b39c <VectorB0+0x4c>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800b3d8:	69e3      	ldr	r3, [r4, #28]
 800b3da:	454b      	cmp	r3, r9
 800b3dc:	d016      	beq.n	800b40c <VectorB0+0xbc>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 800b3de:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.lasttime += nowdelta;
 800b3e0:	62a0      	str	r0, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 800b3e2:	eba2 0208 	sub.w	r2, r2, r8
 800b3e6:	609a      	str	r2, [r3, #8]
  return systime + (systime_t)interval;
 800b3e8:	6889      	ldr	r1, [r1, #8]
 800b3ea:	2902      	cmp	r1, #2
 800b3ec:	bf2c      	ite	cs
 800b3ee:	1841      	addcs	r1, r0, r1
 800b3f0:	1c81      	addcc	r1, r0, #2
 800b3f2:	4608      	mov	r0, r1
 800b3f4:	f7f6 fbf4 	bl	8001be0 <stSetAlarm>
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 800b3f8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  return (systime_t)STM32_ST_TIM->CNT;
 800b3fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 800b3fc:	1a89      	subs	r1, r1, r2
 800b3fe:	1a9b      	subs	r3, r3, r2
 800b400:	428b      	cmp	r3, r1
 800b402:	d903      	bls.n	800b40c <VectorB0+0xbc>
  __ASM volatile ("cpsid i" : : : "memory");
 800b404:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 800b406:	4b08      	ldr	r3, [pc, #32]	; (800b428 <VectorB0+0xd8>)
 800b408:	62e3      	str	r3, [r4, #44]	; 0x2c
 800b40a:	e7fe      	b.n	800b40a <VectorB0+0xba>
  _dbg_check_unlock_from_isr();
 800b40c:	f7f5 fe40 	bl	8001090 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800b410:	2300      	movs	r3, #0
 800b412:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 800b416:	f7f5 fe0b 	bl	8001030 <_dbg_check_leave_isr>
}
 800b41a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 800b41e:	f7f5 bb77 	b.w	8000b10 <_port_irq_epilogue>
 800b422:	bf00      	nop
 800b424:	200011a0 	.word	0x200011a0
 800b428:	0800bcd4 	.word	0x0800bcd4
 800b42c:	00000000 	.word	0x00000000

0800b430 <Vector14C>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 800b430:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
 800b434:	4cb6      	ldr	r4, [pc, #728]	; (800b710 <Vector14C+0x2e0>)
  OSAL_IRQ_PROLOGUE();
 800b436:	f7f5 fe13 	bl	8001060 <_dbg_check_enter_isr>
  stm32_otg_t *otgp = usbp->otg;
 800b43a:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
  sts  = otgp->GINTSTS;
 800b43c:	696e      	ldr	r6, [r5, #20]
  sts &= otgp->GINTMSK;
 800b43e:	69ab      	ldr	r3, [r5, #24]
 800b440:	401e      	ands	r6, r3
  if (sts & GINTSTS_USBRST) {
 800b442:	f416 5880 	ands.w	r8, r6, #4096	; 0x1000
  otgp->GINTSTS = sts;
 800b446:	616e      	str	r6, [r5, #20]
  if (sts & GINTSTS_USBRST) {
 800b448:	f040 8083 	bne.w	800b552 <Vector14C+0x122>
  if (sts & GINTSTS_WKUPINT) {
 800b44c:	2e00      	cmp	r6, #0
 800b44e:	f2c0 81a2 	blt.w	800b796 <Vector14C+0x366>
  if (sts & GINTSTS_USBSUSP) {
 800b452:	0532      	lsls	r2, r6, #20
 800b454:	f100 8119 	bmi.w	800b68a <Vector14C+0x25a>
  if (sts & GINTSTS_ENUMDNE) {
 800b458:	04b3      	lsls	r3, r6, #18
 800b45a:	d50c      	bpl.n	800b476 <Vector14C+0x46>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 800b45c:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
 800b460:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 800b464:	68eb      	ldr	r3, [r5, #12]
 800b466:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800b46a:	bf0c      	ite	eq
 800b46c:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 800b470:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 800b474:	60eb      	str	r3, [r5, #12]
  if (sts & GINTSTS_SOF) {
 800b476:	0737      	lsls	r7, r6, #28
 800b478:	d504      	bpl.n	800b484 <Vector14C+0x54>
    _usb_isr_invoke_sof_cb(usbp);
 800b47a:	6863      	ldr	r3, [r4, #4]
 800b47c:	68db      	ldr	r3, [r3, #12]
 800b47e:	b10b      	cbz	r3, 800b484 <Vector14C+0x54>
 800b480:	48a3      	ldr	r0, [pc, #652]	; (800b710 <Vector14C+0x2e0>)
 800b482:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 800b484:	02f0      	lsls	r0, r6, #11
 800b486:	f100 813a 	bmi.w	800b6fe <Vector14C+0x2ce>
  if (sts & GINTSTS_IISOOXFR) {
 800b48a:	02b3      	lsls	r3, r6, #10
 800b48c:	f100 810b 	bmi.w	800b6a6 <Vector14C+0x276>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 800b490:	06f7      	lsls	r7, r6, #27
 800b492:	f100 80d4 	bmi.w	800b63e <Vector14C+0x20e>
  if (sts & GINTSTS_OEPINT) {
 800b496:	0333      	lsls	r3, r6, #12
  src = otgp->DAINT;
 800b498:	f8d5 4818 	ldr.w	r4, [r5, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 800b49c:	d51a      	bpl.n	800b4d4 <Vector14C+0xa4>
    if (src & (1 << 16))
 800b49e:	03e7      	lsls	r7, r4, #15
 800b4a0:	d453      	bmi.n	800b54a <Vector14C+0x11a>
    if (src & (1 << 17))
 800b4a2:	03a5      	lsls	r5, r4, #14
 800b4a4:	d502      	bpl.n	800b4ac <Vector14C+0x7c>
      otg_epout_handler(usbp, 1);
 800b4a6:	2001      	movs	r0, #1
 800b4a8:	f7f5 fff2 	bl	8001490 <otg_epout_handler.constprop.67>
    if (src & (1 << 18))
 800b4ac:	0360      	lsls	r0, r4, #13
 800b4ae:	d502      	bpl.n	800b4b6 <Vector14C+0x86>
      otg_epout_handler(usbp, 2);
 800b4b0:	2002      	movs	r0, #2
 800b4b2:	f7f5 ffed 	bl	8001490 <otg_epout_handler.constprop.67>
    if (src & (1 << 19))
 800b4b6:	0321      	lsls	r1, r4, #12
 800b4b8:	d502      	bpl.n	800b4c0 <Vector14C+0x90>
      otg_epout_handler(usbp, 3);
 800b4ba:	2003      	movs	r0, #3
 800b4bc:	f7f5 ffe8 	bl	8001490 <otg_epout_handler.constprop.67>
    if (src & (1 << 20))
 800b4c0:	02e2      	lsls	r2, r4, #11
 800b4c2:	d502      	bpl.n	800b4ca <Vector14C+0x9a>
      otg_epout_handler(usbp, 4);
 800b4c4:	2004      	movs	r0, #4
 800b4c6:	f7f5 ffe3 	bl	8001490 <otg_epout_handler.constprop.67>
    if (src & (1 << 21))
 800b4ca:	02a3      	lsls	r3, r4, #10
 800b4cc:	d502      	bpl.n	800b4d4 <Vector14C+0xa4>
      otg_epout_handler(usbp, 5);
 800b4ce:	2005      	movs	r0, #5
 800b4d0:	f7f5 ffde 	bl	8001490 <otg_epout_handler.constprop.67>
  if (sts & GINTSTS_IEPINT) {
 800b4d4:	0377      	lsls	r7, r6, #13
 800b4d6:	d50b      	bpl.n	800b4f0 <Vector14C+0xc0>
    if (src & (1 << 0))
 800b4d8:	07e6      	lsls	r6, r4, #31
 800b4da:	d40f      	bmi.n	800b4fc <Vector14C+0xcc>
    if (src & (1 << 1))
 800b4dc:	07a5      	lsls	r5, r4, #30
 800b4de:	d42e      	bmi.n	800b53e <Vector14C+0x10e>
    if (src & (1 << 2))
 800b4e0:	0760      	lsls	r0, r4, #29
 800b4e2:	d426      	bmi.n	800b532 <Vector14C+0x102>
    if (src & (1 << 3))
 800b4e4:	0721      	lsls	r1, r4, #28
 800b4e6:	d41e      	bmi.n	800b526 <Vector14C+0xf6>
    if (src & (1 << 4))
 800b4e8:	06e2      	lsls	r2, r4, #27
 800b4ea:	d416      	bmi.n	800b51a <Vector14C+0xea>
    if (src & (1 << 5))
 800b4ec:	06a3      	lsls	r3, r4, #26
 800b4ee:	d40b      	bmi.n	800b508 <Vector14C+0xd8>
  OSAL_IRQ_EPILOGUE();
 800b4f0:	f7f5 fd9e 	bl	8001030 <_dbg_check_leave_isr>
}
 800b4f4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 800b4f8:	f7f5 bb0a 	b.w	8000b10 <_port_irq_epilogue>
      otg_epin_handler(usbp, 0);
 800b4fc:	2000      	movs	r0, #0
 800b4fe:	f7f5 ff37 	bl	8001370 <otg_epin_handler.constprop.66>
    if (src & (1 << 1))
 800b502:	07a5      	lsls	r5, r4, #30
 800b504:	d5ec      	bpl.n	800b4e0 <Vector14C+0xb0>
 800b506:	e01a      	b.n	800b53e <Vector14C+0x10e>
      otg_epin_handler(usbp, 5);
 800b508:	2005      	movs	r0, #5
 800b50a:	f7f5 ff31 	bl	8001370 <otg_epin_handler.constprop.66>
  OSAL_IRQ_EPILOGUE();
 800b50e:	f7f5 fd8f 	bl	8001030 <_dbg_check_leave_isr>
}
 800b512:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 800b516:	f7f5 bafb 	b.w	8000b10 <_port_irq_epilogue>
      otg_epin_handler(usbp, 4);
 800b51a:	2004      	movs	r0, #4
 800b51c:	f7f5 ff28 	bl	8001370 <otg_epin_handler.constprop.66>
    if (src & (1 << 5))
 800b520:	06a3      	lsls	r3, r4, #26
 800b522:	d5e5      	bpl.n	800b4f0 <Vector14C+0xc0>
 800b524:	e7f0      	b.n	800b508 <Vector14C+0xd8>
      otg_epin_handler(usbp, 3);
 800b526:	2003      	movs	r0, #3
 800b528:	f7f5 ff22 	bl	8001370 <otg_epin_handler.constprop.66>
    if (src & (1 << 4))
 800b52c:	06e2      	lsls	r2, r4, #27
 800b52e:	d5dd      	bpl.n	800b4ec <Vector14C+0xbc>
 800b530:	e7f3      	b.n	800b51a <Vector14C+0xea>
      otg_epin_handler(usbp, 2);
 800b532:	2002      	movs	r0, #2
 800b534:	f7f5 ff1c 	bl	8001370 <otg_epin_handler.constprop.66>
    if (src & (1 << 3))
 800b538:	0721      	lsls	r1, r4, #28
 800b53a:	d5d5      	bpl.n	800b4e8 <Vector14C+0xb8>
 800b53c:	e7f3      	b.n	800b526 <Vector14C+0xf6>
      otg_epin_handler(usbp, 1);
 800b53e:	2001      	movs	r0, #1
 800b540:	f7f5 ff16 	bl	8001370 <otg_epin_handler.constprop.66>
    if (src & (1 << 2))
 800b544:	0760      	lsls	r0, r4, #29
 800b546:	d5cd      	bpl.n	800b4e4 <Vector14C+0xb4>
 800b548:	e7f3      	b.n	800b532 <Vector14C+0x102>
      otg_epout_handler(usbp, 0);
 800b54a:	2000      	movs	r0, #0
 800b54c:	f7f5 ffa0 	bl	8001490 <otg_epout_handler.constprop.67>
 800b550:	e7a7      	b.n	800b4a2 <Vector14C+0x72>
  usbp->status        = 0;
 800b552:	2300      	movs	r3, #0
  usbp->receiving     = 0;
 800b554:	e9c4 3302 	strd	r3, r3, [r4, #8]
  usbp->state         = USB_READY;
 800b558:	2102      	movs	r1, #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800b55a:	2220      	movs	r2, #32
  usbp->status        = 0;
 800b55c:	6663      	str	r3, [r4, #100]	; 0x64
    usbp->epc[i] = NULL;
 800b55e:	e9c4 3304 	strd	r3, r3, [r4, #16]
 800b562:	e9c4 3306 	strd	r3, r3, [r4, #24]
 800b566:	6223      	str	r3, [r4, #32]
  usbp->ep0state = USB_EP0_STP_WAITING;
 800b568:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  usbp->state         = USB_READY;
 800b56c:	7021      	strb	r1, [r4, #0]
 800b56e:	612a      	str	r2, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800b570:	692e      	ldr	r6, [r5, #16]
 800b572:	f016 0620 	ands.w	r6, r6, #32
 800b576:	d1fb      	bne.n	800b570 <Vector14C+0x140>
 800b578:	2012      	movs	r0, #18
 800b57a:	f7f5 fe31 	bl	80011e0 <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800b57e:	6f22      	ldr	r2, [r4, #112]	; 0x70
  otgp->DIEPEMPMSK = 0;
 800b580:	f8c5 6834 	str.w	r6, [r5, #2100]	; 0x834
 800b584:	6893      	ldr	r3, [r2, #8]
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800b586:	f04f 1001 	mov.w	r0, #65537	; 0x10001
 800b58a:	f8c5 081c 	str.w	r0, [r5, #2076]	; 0x81c
 800b58e:	1c59      	adds	r1, r3, #1
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800b590:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800b594:	f04f 30ff 	mov.w	r0, #4294967295
 800b598:	eb05 1346 	add.w	r3, r5, r6, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800b59c:	3601      	adds	r6, #1
 800b59e:	428e      	cmp	r6, r1
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800b5a0:	f8c3 7900 	str.w	r7, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800b5a4:	f8c3 7b00 	str.w	r7, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800b5a8:	f8c3 0908 	str.w	r0, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800b5ac:	f8c3 0b08 	str.w	r0, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800b5b0:	d1f2      	bne.n	800b598 <Vector14C+0x168>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800b5b2:	6813      	ldr	r3, [r2, #0]
 800b5b4:	6763      	str	r3, [r4, #116]	; 0x74
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 800b5b6:	6812      	ldr	r2, [r2, #0]
 800b5b8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800b5ba:	626a      	str	r2, [r5, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 800b5bc:	2210      	movs	r2, #16
 800b5be:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 800b5c0:	691e      	ldr	r6, [r3, #16]
 800b5c2:	f016 0610 	ands.w	r6, r6, #16
 800b5c6:	d1fb      	bne.n	800b5c0 <Vector14C+0x190>
 800b5c8:	2012      	movs	r0, #18
 800b5ca:	f7f5 fe09 	bl	80011e0 <chSysPolledDelayX>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 800b5ce:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
  usbp->epc[0] = &ep0config;
 800b5d2:	4850      	ldr	r0, [pc, #320]	; (800b714 <Vector14C+0x2e4>)
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800b5d4:	4950      	ldr	r1, [pc, #320]	; (800b718 <Vector14C+0x2e8>)
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 800b5d6:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800b5da:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 800b5de:	69ab      	ldr	r3, [r5, #24]
 800b5e0:	e9d4 721c 	ldrd	r7, r2, [r4, #112]	; 0x70
 800b5e4:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 800b5e8:	f043 0310 	orr.w	r3, r3, #16
 800b5ec:	61ab      	str	r3, [r5, #24]
  usbp->pmnext += size;
 800b5ee:	f102 0310 	add.w	r3, r2, #16
 800b5f2:	6763      	str	r3, [r4, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800b5f4:	687f      	ldr	r7, [r7, #4]
  usbp->epc[0] = &ep0config;
 800b5f6:	60e0      	str	r0, [r4, #12]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 800b5f8:	2009      	movs	r0, #9
 800b5fa:	f8c5 0810 	str.w	r0, [r5, #2064]	; 0x810
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800b5fe:	42bb      	cmp	r3, r7
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 800b600:	f8c5 0814 	str.w	r0, [r5, #2068]	; 0x814
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 800b604:	f04f 40c0 	mov.w	r0, #1610612736	; 0x60000000
 800b608:	f8c5 0b10 	str.w	r0, [r5, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800b60c:	f8c5 1b00 	str.w	r1, [r5, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 800b610:	f8c5 6910 	str.w	r6, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800b614:	f8c5 1900 	str.w	r1, [r5, #2304]	; 0x900
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800b618:	f200 80d9 	bhi.w	800b7ce <Vector14C+0x39e>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800b61c:	6863      	ldr	r3, [r4, #4]
 800b61e:	681b      	ldr	r3, [r3, #0]
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800b620:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800b624:	62aa      	str	r2, [r5, #40]	; 0x28
 800b626:	2b00      	cmp	r3, #0
 800b628:	f43f af62 	beq.w	800b4f0 <Vector14C+0xc0>
 800b62c:	4631      	mov	r1, r6
 800b62e:	4838      	ldr	r0, [pc, #224]	; (800b710 <Vector14C+0x2e0>)
 800b630:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 800b632:	f7f5 fcfd 	bl	8001030 <_dbg_check_leave_isr>
}
 800b636:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 800b63a:	f7f5 ba69 	b.w	8000b10 <_port_irq_epilogue>
  sts = usbp->otg->GRXSTSP;
 800b63e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800b640:	6a13      	ldr	r3, [r2, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800b642:	f403 11f0 	and.w	r1, r3, #1966080	; 0x1e0000
 800b646:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 800b64a:	f3c3 170a 	ubfx	r7, r3, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800b64e:	f003 030f 	and.w	r3, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800b652:	f000 80c1 	beq.w	800b7d8 <Vector14C+0x3a8>
 800b656:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 800b65a:	f47f af1c 	bne.w	800b496 <Vector14C+0x66>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800b65e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800b662:	68db      	ldr	r3, [r3, #12]
 800b664:	6a18      	ldr	r0, [r3, #32]
  while (i < n) {
 800b666:	2f00      	cmp	r7, #0
 800b668:	f43f af15 	beq.w	800b496 <Vector14C+0x66>
  uint32_t w = 0;
 800b66c:	2100      	movs	r1, #0
      w = *fifop;
 800b66e:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  size_t i = 0;
 800b672:	460b      	mov	r3, r1
    if ((i & 3) == 0){
 800b674:	079c      	lsls	r4, r3, #30
      w = *fifop;
 800b676:	bf08      	it	eq
 800b678:	6811      	ldreq	r1, [r2, #0]
    if (i < max) {
 800b67a:	2b07      	cmp	r3, #7
    i++;
 800b67c:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 800b680:	f240 80d4 	bls.w	800b82c <Vector14C+0x3fc>
  while (i < n) {
 800b684:	429f      	cmp	r7, r3
 800b686:	d1f5      	bne.n	800b674 <Vector14C+0x244>
 800b688:	e705      	b.n	800b496 <Vector14C+0x66>
  usbp->saved_state = usbp->state;
 800b68a:	7822      	ldrb	r2, [r4, #0]
 800b68c:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800b690:	6863      	ldr	r3, [r4, #4]
  usbp->state       = USB_SUSPENDED;
 800b692:	2205      	movs	r2, #5
 800b694:	7022      	strb	r2, [r4, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800b696:	681b      	ldr	r3, [r3, #0]
 800b698:	2b00      	cmp	r3, #0
 800b69a:	f43f aedd 	beq.w	800b458 <Vector14C+0x28>
 800b69e:	2104      	movs	r1, #4
 800b6a0:	481b      	ldr	r0, [pc, #108]	; (800b710 <Vector14C+0x2e0>)
 800b6a2:	4798      	blx	r3
 800b6a4:	e6d8      	b.n	800b458 <Vector14C+0x28>
  stm32_otg_t *otgp = usbp->otg;
 800b6a6:	f8d4 a06c 	ldr.w	sl, [r4, #108]	; 0x6c
      _usb_isr_invoke_out_cb(usbp, ep);
 800b6aa:	f8df 9064 	ldr.w	r9, [pc, #100]	; 800b710 <Vector14C+0x2e0>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800b6ae:	2700      	movs	r7, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 800b6b0:	f04f 0801 	mov.w	r8, #1
 800b6b4:	e006      	b.n	800b6c4 <Vector14C+0x294>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800b6b6:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800b6b8:	3701      	adds	r7, #1
 800b6ba:	689b      	ldr	r3, [r3, #8]
 800b6bc:	b2ff      	uxtb	r7, r7
 800b6be:	429f      	cmp	r7, r3
 800b6c0:	f63f aee6 	bhi.w	800b490 <Vector14C+0x60>
 800b6c4:	eb0a 1247 	add.w	r2, sl, r7, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800b6c8:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 800b6cc:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 800b6d0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800b6d4:	d1ef      	bne.n	800b6b6 <Vector14C+0x286>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 800b6d6:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800b6da:	2b00      	cmp	r3, #0
 800b6dc:	daeb      	bge.n	800b6b6 <Vector14C+0x286>
      _usb_isr_invoke_out_cb(usbp, ep);
 800b6de:	eb04 0287 	add.w	r2, r4, r7, lsl #2
 800b6e2:	8963      	ldrh	r3, [r4, #10]
 800b6e4:	68d2      	ldr	r2, [r2, #12]
 800b6e6:	fa08 f107 	lsl.w	r1, r8, r7
 800b6ea:	68d2      	ldr	r2, [r2, #12]
 800b6ec:	ea23 0301 	bic.w	r3, r3, r1
 800b6f0:	4648      	mov	r0, r9
 800b6f2:	4639      	mov	r1, r7
 800b6f4:	8163      	strh	r3, [r4, #10]
 800b6f6:	2a00      	cmp	r2, #0
 800b6f8:	d0dd      	beq.n	800b6b6 <Vector14C+0x286>
 800b6fa:	4790      	blx	r2
 800b6fc:	e7db      	b.n	800b6b6 <Vector14C+0x286>
  stm32_otg_t *otgp = usbp->otg;
 800b6fe:	f8d4 b06c 	ldr.w	fp, [r4, #108]	; 0x6c
      _usb_isr_invoke_in_cb(usbp, ep);
 800b702:	f8df a00c 	ldr.w	sl, [pc, #12]	; 800b710 <Vector14C+0x2e0>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800b706:	2700      	movs	r7, #0
      _usb_isr_invoke_in_cb(usbp, ep);
 800b708:	f04f 0901 	mov.w	r9, #1
 800b70c:	e00e      	b.n	800b72c <Vector14C+0x2fc>
 800b70e:	bf00      	nop
 800b710:	20001128 	.word	0x20001128
 800b714:	0800c49c 	.word	0x0800c49c
 800b718:	10008040 	.word	0x10008040
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800b71c:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800b71e:	3701      	adds	r7, #1
 800b720:	689b      	ldr	r3, [r3, #8]
 800b722:	b2ff      	uxtb	r7, r7
 800b724:	429f      	cmp	r7, r3
 800b726:	46b8      	mov	r8, r7
 800b728:	f63f aeaf 	bhi.w	800b48a <Vector14C+0x5a>
 800b72c:	eb0b 1347 	add.w	r3, fp, r7, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 800b730:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800b734:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 800b738:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800b73c:	d1ee      	bne.n	800b71c <Vector14C+0x2ec>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 800b73e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 800b742:	2a00      	cmp	r2, #0
 800b744:	daea      	bge.n	800b71c <Vector14C+0x2ec>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 800b746:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800b74a:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 800b74e:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 800b752:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800b756:	2a00      	cmp	r2, #0
 800b758:	dbfb      	blt.n	800b752 <Vector14C+0x322>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800b75a:	ea4f 1388 	mov.w	r3, r8, lsl #6
 800b75e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800b760:	f043 0320 	orr.w	r3, r3, #32
 800b764:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800b766:	6913      	ldr	r3, [r2, #16]
 800b768:	0699      	lsls	r1, r3, #26
 800b76a:	d4fc      	bmi.n	800b766 <Vector14C+0x336>
 800b76c:	2012      	movs	r0, #18
 800b76e:	f7f5 fd37 	bl	80011e0 <chSysPolledDelayX>
      _usb_isr_invoke_in_cb(usbp, ep);
 800b772:	eb04 0287 	add.w	r2, r4, r7, lsl #2
 800b776:	8923      	ldrh	r3, [r4, #8]
 800b778:	68d2      	ldr	r2, [r2, #12]
 800b77a:	fa09 f107 	lsl.w	r1, r9, r7
 800b77e:	6892      	ldr	r2, [r2, #8]
 800b780:	ea23 0301 	bic.w	r3, r3, r1
 800b784:	8123      	strh	r3, [r4, #8]
 800b786:	b112      	cbz	r2, 800b78e <Vector14C+0x35e>
 800b788:	4639      	mov	r1, r7
 800b78a:	4650      	mov	r0, sl
 800b78c:	4790      	blx	r2
    otg_txfifo_handler(usbp, ep);
 800b78e:	4638      	mov	r0, r7
 800b790:	f7f4 ffa6 	bl	80006e0 <otg_txfifo_handler.constprop.69>
 800b794:	e7c2      	b.n	800b71c <Vector14C+0x2ec>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 800b796:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
 800b79a:	0799      	lsls	r1, r3, #30
 800b79c:	d005      	beq.n	800b7aa <Vector14C+0x37a>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 800b79e:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
 800b7a2:	f023 0303 	bic.w	r3, r3, #3
 800b7a6:	f8c5 3e00 	str.w	r3, [r5, #3584]	; 0xe00
  usbp->state = usbp->saved_state;
 800b7aa:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800b7ae:	6862      	ldr	r2, [r4, #4]
  usbp->state = usbp->saved_state;
 800b7b0:	7023      	strb	r3, [r4, #0]
    otgp->DCTL &= ~DCTL_RWUSIG;
 800b7b2:	f8d5 3804 	ldr.w	r3, [r5, #2052]	; 0x804
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800b7b6:	6812      	ldr	r2, [r2, #0]
 800b7b8:	f023 0301 	bic.w	r3, r3, #1
 800b7bc:	f8c5 3804 	str.w	r3, [r5, #2052]	; 0x804
 800b7c0:	2a00      	cmp	r2, #0
 800b7c2:	f43f ae46 	beq.w	800b452 <Vector14C+0x22>
 800b7c6:	2105      	movs	r1, #5
 800b7c8:	481a      	ldr	r0, [pc, #104]	; (800b834 <Vector14C+0x404>)
 800b7ca:	4790      	blx	r2
 800b7cc:	e641      	b.n	800b452 <Vector14C+0x22>
  __ASM volatile ("cpsid i" : : : "memory");
 800b7ce:	b672      	cpsid	i
 800b7d0:	4b19      	ldr	r3, [pc, #100]	; (800b838 <Vector14C+0x408>)
 800b7d2:	4a1a      	ldr	r2, [pc, #104]	; (800b83c <Vector14C+0x40c>)
 800b7d4:	62da      	str	r2, [r3, #44]	; 0x2c
 800b7d6:	e7fe      	b.n	800b7d6 <Vector14C+0x3a6>
                            usbp->epc[ep]->out_state->rxbuf,
 800b7d8:	3302      	adds	r3, #2
 800b7da:	eb04 0183 	add.w	r1, r4, r3, lsl #2
 800b7de:	6849      	ldr	r1, [r1, #4]
 800b7e0:	6988      	ldr	r0, [r1, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800b7e2:	e9d0 1c00 	ldrd	r1, ip, [r0]
 800b7e6:	f8d0 e008 	ldr.w	lr, [r0, #8]
 800b7ea:	eba1 0c0c 	sub.w	ip, r1, ip
  while (i < n) {
 800b7ee:	b197      	cbz	r7, 800b816 <Vector14C+0x3e6>
  uint32_t w = 0;
 800b7f0:	2000      	movs	r0, #0
      w = *fifop;
 800b7f2:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  size_t i = 0;
 800b7f6:	4601      	mov	r1, r0
    if ((i & 3) == 0){
 800b7f8:	f011 0f03 	tst.w	r1, #3
      w = *fifop;
 800b7fc:	bf08      	it	eq
 800b7fe:	6810      	ldreq	r0, [r2, #0]
    if (i < max) {
 800b800:	458c      	cmp	ip, r1
    i++;
 800b802:	f101 0101 	add.w	r1, r1, #1
    if (i < max) {
 800b806:	d904      	bls.n	800b812 <Vector14C+0x3e2>
      *buf++ = (uint8_t)w;
 800b808:	f88e 0000 	strb.w	r0, [lr]
      w >>= 8;
 800b80c:	0a00      	lsrs	r0, r0, #8
      *buf++ = (uint8_t)w;
 800b80e:	f10e 0e01 	add.w	lr, lr, #1
  while (i < n) {
 800b812:	428f      	cmp	r7, r1
 800b814:	d1f0      	bne.n	800b7f8 <Vector14C+0x3c8>
    usbp->epc[ep]->out_state->rxbuf += cnt;
 800b816:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 800b81a:	6863      	ldr	r3, [r4, #4]
 800b81c:	699b      	ldr	r3, [r3, #24]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 800b81e:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
    usbp->epc[ep]->out_state->rxbuf += cnt;
 800b822:	4439      	add	r1, r7
    usbp->epc[ep]->out_state->rxcnt += cnt;
 800b824:	443a      	add	r2, r7
 800b826:	e9c3 2101 	strd	r2, r1, [r3, #4]
 800b82a:	e634      	b.n	800b496 <Vector14C+0x66>
      *buf++ = (uint8_t)w;
 800b82c:	7001      	strb	r1, [r0, #0]
      w >>= 8;
 800b82e:	0a09      	lsrs	r1, r1, #8
      *buf++ = (uint8_t)w;
 800b830:	3001      	adds	r0, #1
 800b832:	e727      	b.n	800b684 <Vector14C+0x254>
 800b834:	20001128 	.word	0x20001128
 800b838:	200011a0 	.word	0x200011a0
 800b83c:	0800c060 	.word	0x0800c060

0800b840 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800b840:	b4f0      	push	{r4, r5, r6, r7}
 800b842:	4e14      	ldr	r6, [pc, #80]	; (800b894 <__init_ram_areas+0x54>)
 800b844:	4d14      	ldr	r5, [pc, #80]	; (800b898 <__init_ram_areas+0x58>)
 800b846:	4c15      	ldr	r4, [pc, #84]	; (800b89c <__init_ram_areas+0x5c>)
 800b848:	4b15      	ldr	r3, [pc, #84]	; (800b8a0 <__init_ram_areas+0x60>)
 800b84a:	4916      	ldr	r1, [pc, #88]	; (800b8a4 <__init_ram_areas+0x64>)
 800b84c:	f106 0c70 	add.w	ip, r6, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800b850:	2700      	movs	r7, #0
    while (p < rap->clear_area) {
 800b852:	429c      	cmp	r4, r3
 800b854:	d911      	bls.n	800b87a <__init_ram_areas+0x3a>
 800b856:	3904      	subs	r1, #4
 800b858:	461a      	mov	r2, r3
      *p = *tp;
 800b85a:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800b85e:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
 800b862:	4294      	cmp	r4, r2
 800b864:	d8f9      	bhi.n	800b85a <__init_ram_areas+0x1a>
 800b866:	43da      	mvns	r2, r3
 800b868:	4414      	add	r4, r2
 800b86a:	f024 0403 	bic.w	r4, r4, #3
 800b86e:	3404      	adds	r4, #4
 800b870:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
 800b872:	429d      	cmp	r5, r3
 800b874:	d903      	bls.n	800b87e <__init_ram_areas+0x3e>
      *p = 0;
 800b876:	f843 7b04 	str.w	r7, [r3], #4
    while (p < rap->no_init_area) {
 800b87a:	429d      	cmp	r5, r3
 800b87c:	d8fb      	bhi.n	800b876 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800b87e:	4566      	cmp	r6, ip
 800b880:	d005      	beq.n	800b88e <__init_ram_areas+0x4e>
 800b882:	e9d6 1304 	ldrd	r1, r3, [r6, #16]
 800b886:	e9d6 4506 	ldrd	r4, r5, [r6, #24]
 800b88a:	3610      	adds	r6, #16
 800b88c:	e7e1      	b.n	800b852 <__init_ram_areas+0x12>
#endif
}
 800b88e:	bcf0      	pop	{r4, r5, r6, r7}
 800b890:	4770      	bx	lr
 800b892:	bf00      	nop
 800b894:	0800c8c4 	.word	0x0800c8c4
 800b898:	20001ce0 	.word	0x20001ce0
 800b89c:	20001ce0 	.word	0x20001ce0
 800b8a0:	20001ce0 	.word	0x20001ce0
 800b8a4:	0800ed8c 	.word	0x0800ed8c
	...

0800b8b0 <__default_exit>:
void __default_exit(void) {
 800b8b0:	e7fe      	b.n	800b8b0 <__default_exit>
 800b8b2:	bf00      	nop
	...

0800b8c0 <__late_init>:
 800b8c0:	4770      	bx	lr
 800b8c2:	bf00      	nop
	...

0800b8d0 <__core_init>:
}
 800b8d0:	4770      	bx	lr
 800b8d2:	bf00      	nop

0800b8d4 <memset>:
 800b8d4:	b4f0      	push	{r4, r5, r6, r7}
 800b8d6:	0786      	lsls	r6, r0, #30
 800b8d8:	d043      	beq.n	800b962 <memset+0x8e>
 800b8da:	1e54      	subs	r4, r2, #1
 800b8dc:	2a00      	cmp	r2, #0
 800b8de:	d03e      	beq.n	800b95e <memset+0x8a>
 800b8e0:	b2ca      	uxtb	r2, r1
 800b8e2:	4603      	mov	r3, r0
 800b8e4:	e002      	b.n	800b8ec <memset+0x18>
 800b8e6:	f114 34ff 	adds.w	r4, r4, #4294967295
 800b8ea:	d338      	bcc.n	800b95e <memset+0x8a>
 800b8ec:	f803 2b01 	strb.w	r2, [r3], #1
 800b8f0:	079d      	lsls	r5, r3, #30
 800b8f2:	d1f8      	bne.n	800b8e6 <memset+0x12>
 800b8f4:	2c03      	cmp	r4, #3
 800b8f6:	d92b      	bls.n	800b950 <memset+0x7c>
 800b8f8:	b2cd      	uxtb	r5, r1
 800b8fa:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800b8fe:	2c0f      	cmp	r4, #15
 800b900:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800b904:	d916      	bls.n	800b934 <memset+0x60>
 800b906:	f1a4 0710 	sub.w	r7, r4, #16
 800b90a:	093f      	lsrs	r7, r7, #4
 800b90c:	f103 0620 	add.w	r6, r3, #32
 800b910:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 800b914:	f103 0210 	add.w	r2, r3, #16
 800b918:	e942 5504 	strd	r5, r5, [r2, #-16]
 800b91c:	e942 5502 	strd	r5, r5, [r2, #-8]
 800b920:	3210      	adds	r2, #16
 800b922:	42b2      	cmp	r2, r6
 800b924:	d1f8      	bne.n	800b918 <memset+0x44>
 800b926:	f004 040f 	and.w	r4, r4, #15
 800b92a:	3701      	adds	r7, #1
 800b92c:	2c03      	cmp	r4, #3
 800b92e:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 800b932:	d90d      	bls.n	800b950 <memset+0x7c>
 800b934:	461e      	mov	r6, r3
 800b936:	4622      	mov	r2, r4
 800b938:	3a04      	subs	r2, #4
 800b93a:	2a03      	cmp	r2, #3
 800b93c:	f846 5b04 	str.w	r5, [r6], #4
 800b940:	d8fa      	bhi.n	800b938 <memset+0x64>
 800b942:	1f22      	subs	r2, r4, #4
 800b944:	f022 0203 	bic.w	r2, r2, #3
 800b948:	3204      	adds	r2, #4
 800b94a:	4413      	add	r3, r2
 800b94c:	f004 0403 	and.w	r4, r4, #3
 800b950:	b12c      	cbz	r4, 800b95e <memset+0x8a>
 800b952:	b2c9      	uxtb	r1, r1
 800b954:	441c      	add	r4, r3
 800b956:	f803 1b01 	strb.w	r1, [r3], #1
 800b95a:	429c      	cmp	r4, r3
 800b95c:	d1fb      	bne.n	800b956 <memset+0x82>
 800b95e:	bcf0      	pop	{r4, r5, r6, r7}
 800b960:	4770      	bx	lr
 800b962:	4614      	mov	r4, r2
 800b964:	4603      	mov	r3, r0
 800b966:	e7c5      	b.n	800b8f4 <memset+0x20>

0800b968 <strchr>:
 800b968:	b2c9      	uxtb	r1, r1
 800b96a:	f000 0303 	and.w	r3, r0, #3
 800b96e:	2900      	cmp	r1, #0
 800b970:	d043      	beq.n	800b9fa <strchr+0x92>
 800b972:	b17b      	cbz	r3, 800b994 <strchr+0x2c>
 800b974:	7803      	ldrb	r3, [r0, #0]
 800b976:	2b00      	cmp	r3, #0
 800b978:	d067      	beq.n	800ba4a <strchr+0xe2>
 800b97a:	4299      	cmp	r1, r3
 800b97c:	d03c      	beq.n	800b9f8 <strchr+0x90>
 800b97e:	1c43      	adds	r3, r0, #1
 800b980:	e005      	b.n	800b98e <strchr+0x26>
 800b982:	f813 2b01 	ldrb.w	r2, [r3], #1
 800b986:	2a00      	cmp	r2, #0
 800b988:	d05d      	beq.n	800ba46 <strchr+0xde>
 800b98a:	428a      	cmp	r2, r1
 800b98c:	d034      	beq.n	800b9f8 <strchr+0x90>
 800b98e:	079a      	lsls	r2, r3, #30
 800b990:	4618      	mov	r0, r3
 800b992:	d1f6      	bne.n	800b982 <strchr+0x1a>
 800b994:	b470      	push	{r4, r5, r6}
 800b996:	6804      	ldr	r4, [r0, #0]
 800b998:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 800b99c:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 800b9a0:	ea86 0504 	eor.w	r5, r6, r4
 800b9a4:	f1a5 3301 	sub.w	r3, r5, #16843009	; 0x1010101
 800b9a8:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 800b9ac:	ea23 0305 	bic.w	r3, r3, r5
 800b9b0:	ea22 0204 	bic.w	r2, r2, r4
 800b9b4:	4313      	orrs	r3, r2
 800b9b6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b9ba:	d10f      	bne.n	800b9dc <strchr+0x74>
 800b9bc:	f850 4f04 	ldr.w	r4, [r0, #4]!
 800b9c0:	ea84 0506 	eor.w	r5, r4, r6
 800b9c4:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
 800b9c8:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 800b9cc:	ea22 0205 	bic.w	r2, r2, r5
 800b9d0:	ea23 0304 	bic.w	r3, r3, r4
 800b9d4:	4313      	orrs	r3, r2
 800b9d6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b9da:	d0ef      	beq.n	800b9bc <strchr+0x54>
 800b9dc:	7803      	ldrb	r3, [r0, #0]
 800b9de:	b143      	cbz	r3, 800b9f2 <strchr+0x8a>
 800b9e0:	4299      	cmp	r1, r3
 800b9e2:	d102      	bne.n	800b9ea <strchr+0x82>
 800b9e4:	e006      	b.n	800b9f4 <strchr+0x8c>
 800b9e6:	428b      	cmp	r3, r1
 800b9e8:	d004      	beq.n	800b9f4 <strchr+0x8c>
 800b9ea:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800b9ee:	2b00      	cmp	r3, #0
 800b9f0:	d1f9      	bne.n	800b9e6 <strchr+0x7e>
 800b9f2:	4618      	mov	r0, r3
 800b9f4:	bc70      	pop	{r4, r5, r6}
 800b9f6:	4770      	bx	lr
 800b9f8:	4770      	bx	lr
 800b9fa:	b15b      	cbz	r3, 800ba14 <strchr+0xac>
 800b9fc:	7803      	ldrb	r3, [r0, #0]
 800b9fe:	2b00      	cmp	r3, #0
 800ba00:	d0fa      	beq.n	800b9f8 <strchr+0x90>
 800ba02:	1c43      	adds	r3, r0, #1
 800ba04:	e003      	b.n	800ba0e <strchr+0xa6>
 800ba06:	7802      	ldrb	r2, [r0, #0]
 800ba08:	3301      	adds	r3, #1
 800ba0a:	2a00      	cmp	r2, #0
 800ba0c:	d0f4      	beq.n	800b9f8 <strchr+0x90>
 800ba0e:	0799      	lsls	r1, r3, #30
 800ba10:	4618      	mov	r0, r3
 800ba12:	d1f8      	bne.n	800ba06 <strchr+0x9e>
 800ba14:	6802      	ldr	r2, [r0, #0]
 800ba16:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800ba1a:	ea23 0302 	bic.w	r3, r3, r2
 800ba1e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800ba22:	d108      	bne.n	800ba36 <strchr+0xce>
 800ba24:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800ba28:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800ba2c:	ea23 0302 	bic.w	r3, r3, r2
 800ba30:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800ba34:	d0f6      	beq.n	800ba24 <strchr+0xbc>
 800ba36:	7803      	ldrb	r3, [r0, #0]
 800ba38:	2b00      	cmp	r3, #0
 800ba3a:	d0dd      	beq.n	800b9f8 <strchr+0x90>
 800ba3c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800ba40:	2b00      	cmp	r3, #0
 800ba42:	d1fb      	bne.n	800ba3c <strchr+0xd4>
 800ba44:	4770      	bx	lr
 800ba46:	4610      	mov	r0, r2
 800ba48:	4770      	bx	lr
 800ba4a:	4618      	mov	r0, r3
 800ba4c:	4770      	bx	lr
 800ba4e:	bf00      	nop

0800ba50 <strncmp>:
 800ba50:	2a00      	cmp	r2, #0
 800ba52:	d041      	beq.n	800bad8 <strncmp+0x88>
 800ba54:	ea40 0301 	orr.w	r3, r0, r1
 800ba58:	f013 0303 	ands.w	r3, r3, #3
 800ba5c:	b4f0      	push	{r4, r5, r6, r7}
 800ba5e:	d125      	bne.n	800baac <strncmp+0x5c>
 800ba60:	2a03      	cmp	r2, #3
 800ba62:	d923      	bls.n	800baac <strncmp+0x5c>
 800ba64:	6804      	ldr	r4, [r0, #0]
 800ba66:	680d      	ldr	r5, [r1, #0]
 800ba68:	42ac      	cmp	r4, r5
 800ba6a:	d11f      	bne.n	800baac <strncmp+0x5c>
 800ba6c:	3a04      	subs	r2, #4
 800ba6e:	d035      	beq.n	800badc <strncmp+0x8c>
 800ba70:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 800ba74:	ea25 0404 	bic.w	r4, r5, r4
 800ba78:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 800ba7c:	d131      	bne.n	800bae2 <strncmp+0x92>
 800ba7e:	1d07      	adds	r7, r0, #4
 800ba80:	1d0d      	adds	r5, r1, #4
 800ba82:	e00d      	b.n	800baa0 <strncmp+0x50>
 800ba84:	f857 3b04 	ldr.w	r3, [r7], #4
 800ba88:	680e      	ldr	r6, [r1, #0]
 800ba8a:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 800ba8e:	42b3      	cmp	r3, r6
 800ba90:	ea24 0403 	bic.w	r4, r4, r3
 800ba94:	d10a      	bne.n	800baac <strncmp+0x5c>
 800ba96:	3a04      	subs	r2, #4
 800ba98:	d020      	beq.n	800badc <strncmp+0x8c>
 800ba9a:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 800ba9e:	d11d      	bne.n	800badc <strncmp+0x8c>
 800baa0:	2a03      	cmp	r2, #3
 800baa2:	4629      	mov	r1, r5
 800baa4:	4638      	mov	r0, r7
 800baa6:	f105 0504 	add.w	r5, r5, #4
 800baaa:	d8eb      	bhi.n	800ba84 <strncmp+0x34>
 800baac:	7803      	ldrb	r3, [r0, #0]
 800baae:	780c      	ldrb	r4, [r1, #0]
 800bab0:	429c      	cmp	r4, r3
 800bab2:	f102 32ff 	add.w	r2, r2, #4294967295
 800bab6:	d10c      	bne.n	800bad2 <strncmp+0x82>
 800bab8:	b182      	cbz	r2, 800badc <strncmp+0x8c>
 800baba:	b914      	cbnz	r4, 800bac2 <strncmp+0x72>
 800babc:	e00e      	b.n	800badc <strncmp+0x8c>
 800babe:	b16a      	cbz	r2, 800badc <strncmp+0x8c>
 800bac0:	b17b      	cbz	r3, 800bae2 <strncmp+0x92>
 800bac2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800bac6:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800baca:	42a3      	cmp	r3, r4
 800bacc:	f102 32ff 	add.w	r2, r2, #4294967295
 800bad0:	d0f5      	beq.n	800babe <strncmp+0x6e>
 800bad2:	1b18      	subs	r0, r3, r4
 800bad4:	bcf0      	pop	{r4, r5, r6, r7}
 800bad6:	4770      	bx	lr
 800bad8:	4610      	mov	r0, r2
 800bada:	4770      	bx	lr
 800badc:	2000      	movs	r0, #0
 800bade:	bcf0      	pop	{r4, r5, r6, r7}
 800bae0:	4770      	bx	lr
 800bae2:	4618      	mov	r0, r3
 800bae4:	e7f6      	b.n	800bad4 <strncmp+0x84>
 800bae6:	bf00      	nop

0800bae8 <strncpy>:
 800bae8:	ea40 0301 	orr.w	r3, r0, r1
 800baec:	079b      	lsls	r3, r3, #30
 800baee:	b470      	push	{r4, r5, r6}
 800baf0:	d12a      	bne.n	800bb48 <strncpy+0x60>
 800baf2:	2a03      	cmp	r2, #3
 800baf4:	d928      	bls.n	800bb48 <strncpy+0x60>
 800baf6:	460c      	mov	r4, r1
 800baf8:	4603      	mov	r3, r0
 800bafa:	4621      	mov	r1, r4
 800bafc:	f854 6b04 	ldr.w	r6, [r4], #4
 800bb00:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
 800bb04:	ea25 0506 	bic.w	r5, r5, r6
 800bb08:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 800bb0c:	d106      	bne.n	800bb1c <strncpy+0x34>
 800bb0e:	3a04      	subs	r2, #4
 800bb10:	2a03      	cmp	r2, #3
 800bb12:	f843 6b04 	str.w	r6, [r3], #4
 800bb16:	4621      	mov	r1, r4
 800bb18:	d8ef      	bhi.n	800bafa <strncpy+0x12>
 800bb1a:	b19a      	cbz	r2, 800bb44 <strncpy+0x5c>
 800bb1c:	780c      	ldrb	r4, [r1, #0]
 800bb1e:	701c      	strb	r4, [r3, #0]
 800bb20:	3a01      	subs	r2, #1
 800bb22:	3301      	adds	r3, #1
 800bb24:	b13c      	cbz	r4, 800bb36 <strncpy+0x4e>
 800bb26:	b16a      	cbz	r2, 800bb44 <strncpy+0x5c>
 800bb28:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800bb2c:	f803 4b01 	strb.w	r4, [r3], #1
 800bb30:	3a01      	subs	r2, #1
 800bb32:	2c00      	cmp	r4, #0
 800bb34:	d1f7      	bne.n	800bb26 <strncpy+0x3e>
 800bb36:	b12a      	cbz	r2, 800bb44 <strncpy+0x5c>
 800bb38:	441a      	add	r2, r3
 800bb3a:	2100      	movs	r1, #0
 800bb3c:	f803 1b01 	strb.w	r1, [r3], #1
 800bb40:	4293      	cmp	r3, r2
 800bb42:	d1fb      	bne.n	800bb3c <strncpy+0x54>
 800bb44:	bc70      	pop	{r4, r5, r6}
 800bb46:	4770      	bx	lr
 800bb48:	4603      	mov	r3, r0
 800bb4a:	e7e6      	b.n	800bb1a <strncpy+0x32>

0800bb4c <strpbrk>:
 800bb4c:	b430      	push	{r4, r5}
 800bb4e:	7804      	ldrb	r4, [r0, #0]
 800bb50:	b1dc      	cbz	r4, 800bb8a <strpbrk+0x3e>
 800bb52:	780d      	ldrb	r5, [r1, #0]
 800bb54:	b19d      	cbz	r5, 800bb7e <strpbrk+0x32>
 800bb56:	42ac      	cmp	r4, r5
 800bb58:	d00f      	beq.n	800bb7a <strpbrk+0x2e>
 800bb5a:	460a      	mov	r2, r1
 800bb5c:	e001      	b.n	800bb62 <strpbrk+0x16>
 800bb5e:	429c      	cmp	r4, r3
 800bb60:	d00b      	beq.n	800bb7a <strpbrk+0x2e>
 800bb62:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800bb66:	2b00      	cmp	r3, #0
 800bb68:	d1f9      	bne.n	800bb5e <strpbrk+0x12>
 800bb6a:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800bb6e:	2c00      	cmp	r4, #0
 800bb70:	d1f0      	bne.n	800bb54 <strpbrk+0x8>
 800bb72:	7813      	ldrb	r3, [r2, #0]
 800bb74:	2b00      	cmp	r3, #0
 800bb76:	bf08      	it	eq
 800bb78:	2000      	moveq	r0, #0
 800bb7a:	bc30      	pop	{r4, r5}
 800bb7c:	4770      	bx	lr
 800bb7e:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800bb82:	460a      	mov	r2, r1
 800bb84:	2c00      	cmp	r4, #0
 800bb86:	d1e5      	bne.n	800bb54 <strpbrk+0x8>
 800bb88:	e7f3      	b.n	800bb72 <strpbrk+0x26>
 800bb8a:	4620      	mov	r0, r4
 800bb8c:	e7f5      	b.n	800bb7a <strpbrk+0x2e>
 800bb8e:	bf00      	nop

0800bb90 <strspn>:
 800bb90:	b470      	push	{r4, r5, r6}
 800bb92:	7804      	ldrb	r4, [r0, #0]
 800bb94:	b1a4      	cbz	r4, 800bbc0 <strspn+0x30>
 800bb96:	780d      	ldrb	r5, [r1, #0]
 800bb98:	4606      	mov	r6, r0
 800bb9a:	b14d      	cbz	r5, 800bbb0 <strspn+0x20>
 800bb9c:	42a5      	cmp	r5, r4
 800bb9e:	d00a      	beq.n	800bbb6 <strspn+0x26>
 800bba0:	460a      	mov	r2, r1
 800bba2:	e001      	b.n	800bba8 <strspn+0x18>
 800bba4:	42a3      	cmp	r3, r4
 800bba6:	d006      	beq.n	800bbb6 <strspn+0x26>
 800bba8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800bbac:	2b00      	cmp	r3, #0
 800bbae:	d1f9      	bne.n	800bba4 <strspn+0x14>
 800bbb0:	1b80      	subs	r0, r0, r6
 800bbb2:	bc70      	pop	{r4, r5, r6}
 800bbb4:	4770      	bx	lr
 800bbb6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800bbba:	2c00      	cmp	r4, #0
 800bbbc:	d1ed      	bne.n	800bb9a <strspn+0xa>
 800bbbe:	e7f7      	b.n	800bbb0 <strspn+0x20>
 800bbc0:	4620      	mov	r0, r4
 800bbc2:	e7f6      	b.n	800bbb2 <strspn+0x22>
